<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络规划与设计</title>
      <link href="/2024/07/01/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/07/01/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>学习自成都中医药大学严小英老师主讲的《网络规划与设计》</p><p>​    此门课实际并未把网络相关的技术讲的那么深，估计考试不会涉及太多内容，但是要知道，计算机四大件实际上是计算机专业大学最有必要上的课，无论是考研还是工作面试，都是重要考点，所以如想更深一步学习网络相关知识的话，推荐   <a href="https://xiaolincoding.com/">小林coding</a>，当然这个网站有的点也不是很详细，所以能静下心来读几本书或者看几个从零开始讲的基础课程是最好的。这里推荐<a href="https://www.bilibili.com/video/BV1c4411d7jb?p=1&vd_source=fdad3c0b6eddc3b28481a034d8b5e14a">湖科大教书匠</a>的计算机网络，我的计算机网络专栏就是跟着这个老师学习总结的，我也上传到文件夹里了。</p><p>这几篇老文章都是我之前用飞书云文档写的，因转换格式问题，之前已写完的文档图片太多了，不想一一转化了，大家可以访问我的飞书云文档来查看这些图片–<a href="https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e">https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e</a></p><h1 id="更新，此文图片较少，已同步"><a href="#更新，此文图片较少，已同步" class="headerlink" title="更新，此文图片较少，已同步"></a>更新，此文图片较少，已同步</h1><p>主要总结可能考到的知识点:</p><h1 id="网络生命周期-PDIOO"><a href="#网络生命周期-PDIOO" class="headerlink" title="网络生命周期(PDIOO)"></a>网络生命周期(PDIOO)</h1><ul><li>Planning（规划） </li><li>Design（设计）</li><li>Implementation（实现）</li><li>Operation（运行）</li><li>Optimization（优化）</li><li>Retire（退役）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022033534.png" alt="image-20240702203336688"></p><ol><li><h1 id="网络设计过程"><a href="#网络设计过程" class="headerlink" title="网络设计过程"></a>网络设计过程</h1></li></ol><ul><li>需求分析</li><li>逻辑网络设计</li></ul><ol><li>拓扑设计</li><li>ip地址规划和子网划分</li><li>交换策略和路由协议的选择</li><li>网络安全机制和网络管理策略的设计</li></ol><ul><li>物理网络设计</li><li>部署网络</li><li>调试和验收</li></ul><p><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022034613.png" alt="image-20240702203403435"></p><h1 id="技术指标"><a href="#技术指标" class="headerlink" title="技术指标"></a>技术指标</h1><ul><li>网络带宽</li></ul><p>​     指给定时间内，通过某个网络的信息量。</p><p> 主要记住单位:bp&#x2F;s，每秒通过网络的比特数。</p><p><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022038521.png" alt="image-20240702203852144"></p><p>决定带宽的因素：介质和广域网接入方式</p><ul><li>吞吐量</li></ul><p>是指一组特定的数据在特定的时间段经过特定的路径所传输的信息量的实际测量值。单位与带宽一样</p><p>影响应用层吞吐量的因素：</p><p>计算机性能（客户端的计算机性能和服务器性能）、LAN上其他用户的情况、网络拓扑设计、传输的数据类型、时间段</p><p>吞吐量与带宽的关系：  吞吐量 ≤ 网络的带宽</p><ul><li>差错率</li></ul><p>数据链路层和网络层都存在差错控制</p><ul><li>网络时延</li></ul><p>时延由四部分组成</p><p>处理时延（检查报文到决定转发报文刑事）</p><p>排队时延（报文等待）</p><p>传播时延（信号在物理链路的传播时间）</p><p>传输时延（发送报文第一个b到发送完最后一个b)</p><ul><li>网络路由</li><li>效率</li></ul><h1 id="网络设计方法"><a href="#网络设计方法" class="headerlink" title="网络设计方法"></a>网络设计方法</h1><p>网络设计有两种常用方法：自上而下和自下而上。</p><p>PDIOO 模型采用自上而下的设计方法。</p><p><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022035045.png" alt="image-20240702203539750"></p><ul><li>层次化网络设计</li></ul><p><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022036172.png" alt="image-20240702203626122"></p><p>核心层：高速的网络骨干</p><p>分布层：提供用户到核心层之间的连接，也叫汇聚层</p><p>接入层：为用户提供接入网络的服务，也叫访问层</p><p>层次化设计的优点:</p><ul><li>降低了网络设计的复杂性；</li><li>更容易处理广播风暴、信号循环等问题；</li><li>升级任意层次的网络不会对其他层次造成影响；</li><li>降低了设备配置的复杂性；</li><li>网络故障易于定位；</li><li>网络更容易管理。</li></ul><p>缺点:</p><ul><li>不适用于结构简单的小型局域网。</li><li>核心层设备或链路失效时，会导致整个网络遭到严重破坏。</li><li>分层设计中往往采用设备冗余、路由冗余等设计方法，这会导致网络复杂性的增加。</li></ul><h1 id="常见的局域网技术"><a href="#常见的局域网技术" class="headerlink" title="常见的局域网技术"></a>常见的局域网技术</h1><p>以太网(Ethernet)</p><p>令牌环(Token Ring)</p><p>令牌总线(Token Bus)</p><p>光纤分布式数据接口(FDDI, Fiber Distributed Data Interface)</p><h1 id="局域网参考模型（重点）"><a href="#局域网参考模型（重点）" class="headerlink" title="局域网参考模型（重点）"></a>局域网参考模型（重点）</h1><p>局域网参考模型IEEE 802模型 包含和OSI参考模型的物理层和数据链路层</p><p>其中物理层和OSI的物理层类似，但是局域网的数据链路层分为逻辑链路控制子层（LLC）和介质访问控制子层(MAC)</p><p>LLC子层的功能是保证站点之间数据传输的正确性</p><p>MAC子层的功能是解决多个站点对共享信道的访问问题</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IEEE802.1(A)： LAN和WAN体系结构</span><br><span class="line">IEEE802.1(B)： LAN寻址、网间互联</span><br><span class="line">IEEE802.2： 逻辑链路控制(LLC)协议</span><br><span class="line">IEEE802.3： CSMA/CD访问方法及物理技术规范</span><br><span class="line">IEEE802.4： 令牌总线访问方法及物理层技术规范</span><br><span class="line">IEEE802.5： 令牌环访问方法及物理层技术规范</span><br><span class="line">IEEE802.6： 城域网访问方法及物理层技术规范</span><br><span class="line">IEEE802.7： 宽带网络访问方法及物理层技术规范</span><br><span class="line">IEEE802.8： 光纤网络技术标准(FDDI)</span><br><span class="line">IEEE802.9： 综合数据/语音局域网(IVD LAN)</span><br><span class="line">IEEE802.10： 可互操作局域网安全标准(SILS)</span><br><span class="line">IEEE802.11： 无线局域网</span><br><span class="line">IEEE802.12： 100BaseVG高速网络访问方法</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022037549.png" alt="image-20240702203659599"></p><h1 id="局域网的拓扑结构"><a href="#局域网的拓扑结构" class="headerlink" title="局域网的拓扑结构"></a>局域网的拓扑结构</h1><p>星型，环型，总线型</p><h1 id="以太网技术"><a href="#以太网技术" class="headerlink" title="以太网技术"></a>以太网技术</h1><p>世界上第一个局域网就是以太网</p><p>以太网利用CSMA&#x2F;CD算法解决共享信道内的信道争用和冲突问题</p><p>原理:所有工作站在发送数据前都要侦听信道，如果信道空闲才开始发送数据，而且在发送数据过程中要不断地进行冲突检测秒如果发生冲突则停止，等待后重发</p><p>先听后发、边听边发、冲突停止、延时重发 </p><p><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022037132.png" alt="image-20240702203717639"></p><p> 以太网技术的命名由三个部分组成：传输速度（Speed）、信号传输方法（Signal Method）及传输介质（Medium）</p><p>传输速度（Speed）：10M  100M  1G   10G</p><p>信号传输方法（Signal Method）:基带（BASE）宽带（BROAD） 以太网采用基带信号传输。</p><p>传输介质（Medium）:光纤 同轴电缆  双绞线  无线</p><p>常见的以太网技术标准</p><p><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022037372.png" alt="image-20240702203738814"></p><p>重点记住</p><p>10、100、1000代表传输速率</p><p>Base代表基带传输</p><p>最后一位代表线缆类型：5代表同轴、2代表细同轴、T代表双绞线、FX代表光纤</p><h1 id="以太网-MAC-子层主要有两项职责"><a href="#以太网-MAC-子层主要有两项职责" class="headerlink" title="以太网 MAC 子层主要有两项职责"></a>以太网 MAC 子层主要有两项职责</h1><ul><li>数据封装</li><li>介质访问控制</li></ul><p>MAC地址（重点）</p><p>由48位二进制数组成</p><p>分类:</p><p>单播：第1个字节的最低位为0，可作为目的地址和源地址</p><p>组播：第1个字节的最低位为1，仅能作为目的地址</p><p>广播：48位全部为1</p><h1 id="常见的网络电缆"><a href="#常见的网络电缆" class="headerlink" title="常见的网络电缆"></a>常见的网络电缆</h1><p>双绞线（非屏蔽双绞线、屏蔽双绞线和外屏蔽双绞线）、同轴电缆、光纤</p><p>重要的是非屏蔽双绞线有两种布线方式：T568A 和 T568B。</p><p><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022037525.png" alt="image-20240702203754624"></p><p>结合图记忆</p><h1 id="集线器（第1层设备）"><a href="#集线器（第1层设备）" class="headerlink" title="集线器（第1层设备）"></a>集线器（第1层设备）</h1><p>传统以太网使用集线器来连接 LAN 网段中的节点。</p><p>集线器不执行任何类型的通信过滤，而是将所有比特转发到其连接的每台设备。</p><p>不隔离冲突域</p><p>使用Hub可以将网络拓扑从直线型总线结构转变为星型结构。</p><p>所有连接到Hub上的设备都能接受全部的通信，所有连接到同一个网段上的设备一起构成了一个冲突域</p><h1 id="交换机（2层的设备）"><a href="#交换机（2层的设备）" class="headerlink" title="交换机（2层的设备）"></a>交换机（2层的设备）</h1><p>交换机可以将 LAN 细分为多个单独的冲突域，缩小了冲突域的规模。其每个端口都代表一个单独的冲突域</p><p>交换机的三项主要功能：</p><ul><li>基于源MAC进行地址表学习</li><li>基于目的MAC地址转发&#x2F;过滤数据帧</li><li>隔离冲突域</li></ul><h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><p>IP 地址是用于标识特定主机和网络设备的逻辑网址</p><p>IPV4地址是32位的二进制数字</p><p>IP地址层次式的，由网络号（Network-ID）和主机号（Host-ID）两部分组成，用于标识特定网络中的特定主机。</p><p>ip计算相关的可以多找几道题练习（书上的练习题），这里只总结需要记忆的点</p><h1 id="子网划分-重点"><a href="#子网划分-重点" class="headerlink" title="子网划分(重点)"></a>子网划分(重点)</h1><p>原因:</p><p>为网络管理员提供灵活的地址空间</p><p>使用子网可以将一个局域网变成多个局域网</p><p>缩小广播域</p><p>好处:</p><p>1.缩减网络流量</p><p>2.优化网络性能</p><p>3.简化管理</p><p>4.更为灵活地形成大覆盖范围的网络</p><p>例子(这里大概介绍一下我经常用的方法，和老师讲的两个稍微不太一样):</p><p>网络地址192.168.1.0;子网掩码255.255.255.192(&#x2F;26)</p><p>子网掩码为26说明向主机位借了2位，可以划分2^2&#x3D;4个子网(这个子网要看题意，因为一般出题就是给条件需要几个子网)</p><p>这时候后面就还剩6位，所以六位最大就为六个1 63，所以后面划分四个子网就从192.168.1.0往后依次63即可</p><p>即</p><p>192.168.1.0-192.168.1.63</p><p>192.168.1.64-192.168.1.127</p><p>192.168.1.128-192.168.1.191</p><p>192.168.1.192-192.168.1.256</p><p>注意第一个和最后一个地址不能用于主机位</p><h1 id="可变长子网掩码VLSM（重点）"><a href="#可变长子网掩码VLSM（重点）" class="headerlink" title="可变长子网掩码VLSM（重点）"></a>可变长子网掩码VLSM（重点）</h1><p>一个主网络中定义多个子网，多个子网可能使用不同长度的掩码 </p><p>作用</p><p>节约地址，缩小广播范围，提高安全性</p><p>原理</p><p>在子网划分的基础上，向主机位借位</p><p>产生更小的子网，子网掩码继续变长</p><p>这里我找了一个例子，感觉很清晰</p><p>主要还是要在题中总结</p><p><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022038683.png" alt="image-20240702203812410"></p><h1 id="三层设备转发数据流比较"><a href="#三层设备转发数据流比较" class="headerlink" title="三层设备转发数据流比较"></a>三层设备转发数据流比较</h1><p>第1层设备不对数据进行过滤，只将收到的所有东西都转发到下一网络分段；由第1层设备构建的网络处于同一个冲突域或广播域中；</p><p>第2层设备基于目标MAC地址对数据帧进行过滤；桥接设备形成多个冲突域，但同属于一个广播域；</p><p>第3层设备根据目标IP地址对数据分组进行过滤，路由器只转发目标IP地址位于广播域之外，且路由器能辨别出转发分组的目标位置；第3层设备形成多个冲突域和广播域；</p><h1 id="二层交换机"><a href="#二层交换机" class="headerlink" title="二层交换机"></a>二层交换机</h1><p>交换机的所有端口（包含其默认配置）属于同一广播域</p><p>分割了冲突域，但是不能划分广播域</p><h1 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h1><p>广播域过大带来的问题:</p><ul><li>连续的二层交换机组成一个大的广播域</li><li>交换机从所有接口洪泛广播包</li><li>广播数据在广播域中洪泛，导致带宽浪费</li><li>广播面大导致安全性降低</li><li>节点需要处理过多的广播,降低设备性能</li></ul><p>解决广播域过大的方法是分割广播域，将一个大范围的广播域变成多个小范围的广播域</p><p>分割广播域的方法</p><ol><li>使用路由器分割成多个子网</li><li>使用虚拟局域网(VLAN)分割成多个子网</li></ol><p>特点</p><ul><li>基于逻辑的分组，将一个物理LAN逻辑地划分成不同的广播域</li><li>在同一VLAN内和真实局域网相同，一个VLAN内部的广播流量不会转发到其它VLAN中</li><li>不受物理位置限制，同一个VLAN内的主机不一定属于同一个LAN网段</li><li>减少节点在网络中移动带来的管理代价</li><li>不同VLAN内用户要通信需要借助三层设备</li><li>因为VLAN 使用逻辑连接代替物理连接，所以使用非常灵活。</li></ul><p>定义方法</p><ol><li>基于端口的VLAN–最常用</li><li>基于MAC地址的VLAN</li><li>基于网络层的VLAN</li><li>基于IP组播的VLAN</li></ol><p>端口模式</p><p>Access（接入端口）：</p><p>一般用于连接用户终端，承载标准的以太网帧，不带有VLAN标签，只能关联一个VLAN</p><p>Trunk（干线端口）：</p><p>一般用于交换机互联，可以允许多个VLAN通过，承载带有VLAN标签的802.1Q帧 ，缺省关联交换机上配置的所有VLAN</p><p>这个我推荐看一下湖科大教书匠的讲解-<a href="https://www.bilibili.com/video/BV1xJ411D74c/?spm_id_from=333.337.search-card.all.click&vd_source=fdad3c0b6eddc3b28481a034d8b5e14a">链接</a></p><h1 id="接下来记录一些我做错的题目"><a href="#接下来记录一些我做错的题目" class="headerlink" title="接下来记录一些我做错的题目:"></a>接下来记录一些我做错的题目:</h1><p>把重点放在老师的课堂练习上面，这里是我额外学习的错题</p><h3 id="一般来说，用户上网要通过因特网服务提供商，其英文缩写为-D"><a href="#一般来说，用户上网要通过因特网服务提供商，其英文缩写为-D" class="headerlink" title="一般来说，用户上网要通过因特网服务提供商，其英文缩写为     D"></a>一般来说，用户上网要通过因特网服务提供商，其英文缩写为     D</h3><p>A.ICP</p><p>B.IDC</p><p>C.ASP</p><p>D.ISP</p><h3 id="下面关于路由器的描述中，正确的是-A"><a href="#下面关于路由器的描述中，正确的是-A" class="headerlink" title="下面关于路由器的描述中，正确的是           A"></a>下面关于路由器的描述中，正确的是           A</h3><p>A.路由器的串口之间通常是点对点连接</p><p>B.路由器的以太口之间必须是点对点连接</p><p>C.路由器中串口与以太口的 IP 地址必须在同一网段</p><p>D.路由器中串口与以太口必须是成对的</p>]]></content>
      
      
      <categories>
          
          <category> 期末 </category>
          
          <category> 课内知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 期末 </tag>
            
            <tag> 网络规划与设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>医学数据分析与挖掘</title>
      <link href="/2024/07/01/%E5%8C%BB%E5%AD%A6%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/"/>
      <url>/2024/07/01/%E5%8C%BB%E5%AD%A6%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/</url>
      
        <content type="html"><![CDATA[<p>学习自成都中医药大学林薇老师主讲的《医学数据分析与挖掘》</p><p>这几篇老文章都是我之前用飞书云文档写的，因转换格式问题，本文之前已写完的文档图片太多了，不想一一转化了，大家可以访问我的飞书云文档来查看这些图片–<a href="https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e,%E4%B8%8D%E8%BF%87%E5%90%8E%E7%BB%AD%E8%A1%A5%E5%85%85%E7%9A%84%E9%83%BD%E4%BC%9A%E6%9C%89%E5%9B%BE%E7%89%87">https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e,不过后续补充的都会有图片</a></p><h1 id="第一章-概论"><a href="#第一章-概论" class="headerlink" title="第一章: 概论"></a>第一章: 概论</h1><ol><li><h2 id="从案例出发："><a href="#从案例出发：" class="headerlink" title="从案例出发："></a>从案例出发：</h2></li><li><p>探索生存质量 《—-》中医症型</p></li></ol><p>关联规则：</p><p>   大量的数据中发现特征之间或数据之间的相互依赖关系</p><ol><li>人脸数据爬取与识别</li></ol><p>分类与回归：</p><p>  分类是指利用已有样本，也就是训练集，来建立数学模型并进行分类</p><p>  回归则是过论因变量和自变量之间的关系，也就是目标变量与预测器的关系</p><ol><li>中医体质的划分</li></ol><p>聚类：</p><p>   指在预先不知道类别标签的情况下，恨据信息的相似度原则进行信息聚集的方法</p><ol><li>App推送</li></ol><p>智能推荐：</p><p>   联系用户和信息，并利用信息分类用户的兴趣偏好，为用户推荐感兴趣的内容</p><ol><li>癌症预测</li></ol><p>时间序列：</p><p>   强调的是进行一定时间段内的连续遥感观测，提取图像有关特征，并分析其变化过程</p><p>与发展规模</p><ol><li><h2 id="医学数据分析与挖掘的通用流程-知识发现的核心部分"><a href="#医学数据分析与挖掘的通用流程-知识发现的核心部分" class="headerlink" title="医学数据分析与挖掘的通用流程 (知识发现的核心部分)"></a>医学数据分析与挖掘的通用流程 (知识发现的核心部分)</h2></li></ol><ul><li>目标分析</li></ul><p>医学数据背景应用的需求分析</p><ul><li>数据抽取</li></ul><p>网络爬虫、历史数据、实验数据</p><p>抽取标准： 相关性 可靠性 有效性</p><p>衡量数据质量的标准： 资料完整无缺 数据准确无误</p><p>常见抽样类型：随机抽样、等距抽样、分层抽样、按起始顺序抽样、分类抽样</p><ul><li>数据探索</li></ul><p>集中趋势、离散趋势、异常值分析、缺失值分析、相关分析、周期性分析</p><ul><li>数据预处理</li></ul><p>数据清洗、数据转换、数据集成、数据约减</p><ul><li>数据建模与评价</li></ul><p>关联规则、分类和回归、聚类分折、智能推荐、时间序列</p><ul><li>模型反馈</li></ul><p>知识及确立的模型部署在应用中不断反馈和迭代</p><ol><li><h2 id="常用数据分析与挖掘的工具"><a href="#常用数据分析与挖掘的工具" class="headerlink" title="常用数据分析与挖掘的工具"></a>常用数据分析与挖掘的工具</h2></li></ol><ul><li>Python</li></ul><p>Python是一种面向对象、解释性的计算机程序设计语言，它拥有高效的数据结构</p><ul><li>R</li></ul><p>R是一种由统计计算基金会支持的用于统计计算和图形的编程语言和自由软件环境</p><ul><li>MATLAB</li></ul><p>MATLAB意为矩阵工厂（矩阵实验室），软件主要面对科学计算、可视化以及交互式程序设计的高科技计算环境</p><ul><li>SPSS</li></ul><p>SPSS采用类似EXCEL表格的方式输入与管理数据数据接口较为通用，能方便的从其他数据库中读入数据，输出结果十分美观。</p><ol><li><h2 id="第一章相关试题"><a href="#第一章相关试题" class="headerlink" title="第一章相关试题"></a>第一章相关试题</h2></li><li><p>建立一个模型，通过这个模型根据已知的变量值来预测其他某个变量值属于数据挖掘的哪一类任务？()</p></li></ol><p>A根据内容检索</p><p>B建模描述</p><p>C预测建模</p><p>D寻找模式和规则</p><ol><li>在抽样方法中,当合适的样本容量很难确定时,可以使用的抽样方法是:()</li></ol><p>A有放回的简单随机抽样</p><p>B无放回的简单随机抽样</p><p>C分层抽样</p><p>D渐进抽样</p><ol><li>舆情研判,信息科学侧重( ),社会和管理科学侧重突发群体事件管理中的群体心理行为及舆论控制研究,新闻传播学侧重对舆论的本体进行规律性的探索和研究.</li></ol><p>A舆论的本体进行规律性的探索和研究</p><p>B舆论控制研究</p><p>C互联网文本挖掘和分析技术</p><p>D用户行为分析</p><ol><li>协同过滤分析用户兴趣,在用户群中找到指定用户的相似(兴趣)用户,综合这些用户对某一信息的评价,形成系统对该指定用户对此信息的喜好程度( ),并将这些用户喜欢的项推荐给有相似兴趣的用户。</li></ol><p>A相似</p><p>B相同</p><p>C推荐</p><p>D预测</p><ol><li>大数据科学关注大数据网络发展和运营过程中( )大数据的规律及其与自然和社会活动之间的关系。</li></ol><p>A大数据网络发展和运营过程</p><p>B规划建设运营管理</p><p>C规律和验证</p><p>D发现和验证</p><ol><li>什么是KDD?()</li></ol><p>A数据挖掘与知识发现</p><p>B领域知识发现</p><p>C文档知识发现</p><p>D动态知识发现</p><ol><li>使用交互式的和可视化的技术,对数据进行探索属于数据挖掘的哪一类任务?()</li></ol><p>A探索性数据分析</p><p>B建模描述</p><p>C预测建模</p><p>D寻找模式和规则</p><ol><li>在受试人群中，根据人群的某些体征比如面色红润，口苦，疲乏，舌苔黄腻，畏寒怕冷等特征将这些人的体质分为平和体质，湿热体质，阳虚体质等等。属于数据挖掘的哪一类任务（）</li></ol><p>A分类</p><p>B回归</p><p>C关联规则</p><p>D聚类</p><ol><li>数据挖掘的挖掘方法包括:( )</li></ol><p>A聚类分析</p><p>B回归分析</p><p>C神经网络</p><p>D决策树算法</p><p>E关联规则分析</p><ol><li>抽取数据的标准有( )</li></ol><p>A相关性</p><p>B可靠性</p><p>C有效性</p><p>D实效性</p><p>E准确性</p><ol><li>数据挖掘的主要任务是从数据中发现潜在的规则,从而能更好的完成描述数据、预测数据等任务√</li><li>数据取样时,除了要求抽样时严把质量关外,还要求抽样数据必须在足够范围内有代表性。√</li><li>模型的具体化就是预测公式,公式可以产生与观察值有相似结构的输出,这就是预测值。√</li><li>Web数据挖掘是通过数据库的一些属性来预测另一个属性,它在验证用户提出的假设过程中提取信息。×</li><li>数据质量的标准有两个方面,一是资料完整无缺,各类指标项齐全;二是数据准确无误,且反应的都是在正常状态下的水平。√</li><li>在随机抽样这种操作中,首先将样本总体&#x2F;分成若干层次(或者说分成若干个子集)。每个层次中的观测值都具有相同的被选用的概率,但对不同的层次可以设定不同的概率。×</li><li>Python解释器易于扩展,可以使用C语言或C++,来扩展新的功能和数据类型,也可用于可定制化软件中的扩展程序语言。√</li><li>在选定主成分之后,还需要结合应用,对主成分进行解释,给出主成分的实际意义。√</li><li>医学数据分析与挖掘作为知识发现的核心部分,主要有以下几个步骤目标分析,数据抽取,数据探索,数据预处理,数据建模与评价以及模型反馈。√</li><li>进行降维处理、缺失值处理等,都是数据预处理要解决的问题。√</li></ol><h1 id="第二章：数据特征分析"><a href="#第二章：数据特征分析" class="headerlink" title="第二章：数据特征分析"></a>第二章：数据特征分析</h1><ol><li><h2 id="数据类型（各层要熟悉）"><a href="#数据类型（各层要熟悉）" class="headerlink" title="数据类型（各层要熟悉）"></a>数据类型（各层要熟悉）</h2></li></ol><p><img src="blob:https://miu7shl031o.feishu.cn/19add1df-27cc-4c56-b116-405a0217e8bf" alt="img"></p><p>区间：对于区间属性，值之间的差是有意义的，即存在测量单位。如日历日期、摄氏或华氏温度</p><p>比率：对于比率属性，差和比率都是有意义的。如绝对温度、货币量、计数、年龄、电流等</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YWJlMzczODY5NWUzMWJlZTI1Y2Q0MjMxNjk1MDNkNzJfODBBRDZlWmZaVFlkcm1xUU5aQUZ6VWYySWpGZm1oM1JfVG9rZW46WU1IY2JHUXd3b0JkMzl4Q0d6eWN4Tkxtbm5oXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>首选比率标度属性，可正向转换，一般不做相反方向的转化</p><ol><li><h2 id="数据的描述性特征"><a href="#数据的描述性特征" class="headerlink" title="数据的描述性特征"></a>数据的描述性特征</h2></li></ol><h3 id="数据集中趋势"><a href="#数据集中趋势" class="headerlink" title="数据集中趋势"></a>数据集中趋势</h3><p>指这组数据向某一中心值靠拢的程度，它反映了一组数据中心点的位置所在</p><h3 id="常用的表示数据集中趋势的度量"><a href="#常用的表示数据集中趋势的度量" class="headerlink" title="常用的表示数据集中趋势的度量"></a>常用的表示数据集中趋势的度量</h3><ul><li>算数平均值</li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NzI2ZDViYzMzZGYxZjk3NjEzMjAwMzU1OWI4MjFmZTVfU0JxNzhuUmNqRDZONXpZWDRkNFFwTDJXbUtNRGM3MTFfVG9rZW46VXVUaGJFcVU3b083dWR4NkxEaWNjR1BsbmpjXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>优点: ⑴反应灵敏  ⑵计算严密  ⑶计算简单  ⑷简明易解  ⑸适合运算  ⑹受抽样影响少</p><p>缺点: ⑴ 易受极端值影响，可以采用修剪平均数； ⑵ 若数据模糊不清，则无法计算平均数</p><ul><li>中位数</li></ul><p>优点: ⑴中位数计算不依靠数据本身，反应不够灵敏，极端值变化对中 位数无影响；⑵快速估计数据值</p><p>缺点:中位数没有均数稳定，计算要先排列数据，不能够进一步计算</p><ul><li>众数</li></ul><p>一组数据中出现最多的数</p><p>优点: 简单而不受极端值影响</p><p>缺点: 受分组与数据影响而不稳定,可靠性较差，一组数据可能没有众数或有几个众数</p><ul><li>k百分位数</li></ul><p>将一组数据从小到大排序，并计算相应的累计百分比，处于k%位置的值 称为第k百分位数，用xk%表示</p><p>xk%将数据分成两部分，大约有k%的数据小于或等于xk% ， 有(100－k)%的数据大于或等于xk% </p><ul><li>四分位数</li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NjZkN2YyMmJiMjU0YjEyZTAwZTlhMGE4MzFkMTMyZmRfNVVUeTRIbmI0Mkw5VHFoWDRTRFdBRm5kaUtoMFkzT2NfVG9rZW46UmZ4VGIwUXRBb2FiZUZ4alAxbWNPblRvbkJTXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>Q1又称“较小四分位数”，即25百分位数</p><p>Q2 即50百分位数，就是中位</p><p>Q3 又称“较大四分位数”，即75百分位数 </p><h3 id="数据离散趋势"><a href="#数据离散趋势" class="headerlink" title="数据离散趋势"></a>数据离散趋势</h3><p>是各变量值远离其中心值的程度(离中程度、变异程度)</p><h3 id="描述数据离散趋势的度量"><a href="#描述数据离散趋势的度量" class="headerlink" title="描述数据离散趋势的度量"></a>描述数据离散趋势的度量</h3><p>反映各变量值远离其中心值的程度、反映各变量值的稳定性和均匀性、反映集中趋势指标的代表性</p><ul><li>极差</li></ul><p>是一组数据中最大值与最小值之差，又称范围误差或全距，用R表示</p><p>优点：计算方便，容易理解</p><p>缺点：</p><p>易受极端值左右，</p><p>受数据量大小的影响，不够稳定，</p><p>不能反映组内其他观察值的变异情况。</p><ul><li>四分位数极差</li></ul><p>又称内距，是总体中数据居中的50%个体散布的范围，可看作中间1&#x2F;2数据的极差</p><p>公式   IQR&#x3D;Q3-Q1</p><p>优缺点  受极端值的影响相对小，比极差稳定，但没有利用所有数据的信息。</p><ul><li>平均绝对离差</li></ul><p>是数据集合中各个数值与平均值的距离总和，然后取其平均数</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OTAyN2NlOWQ5MjVmODU3YTkzNDFkNzcyNTMzMmQ1ZmFfUEx5c1pralVsOUF2Vmp3SXpZUW5qTVVjOVpxM0tpdkVfVG9rZW46QXl4bWJscXc0b0Fjajd4bXhweGNRNDhDbkhkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>缺点: 带有绝对值符号</p><ul><li>方差和标准差</li></ul><p>计算每个样本值与全体样本平均数之差的平方和的平均数，称为方差</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MDY4Nzc1ZmQ1MTRkZGQ0YWU3NTEzNWIyYTI5NDE5M2ZfVmJkM1pKRmFrR3UySVg1MFdDeHhoazV1cGhGYmNWM3NfVG9rZW46QnpONmJPZlc4b2RqSEl4N1VNRWNraTZ6bkFjXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>标准差反映观察值对均数的变异程度、说明均数的代表性、常与均数配套来使用</p><ul><li>离散系数</li></ul><p>又称变异系数，是标准差与平均数之比。 </p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTJkNjA0NWQ4OWI4YjE5M2Y5ZGM5N2Y0OTdjMzM0N2RfbXlYbndJVWFCN0plbDliREEwcjFJU21LNFpKUjV4V2tfVG9rZW46SGtraWJkc3hZb2d5c1B4eDFFYmNlMU5KbkFiXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li><h2 id="数据的相关分析"><a href="#数据的相关分析" class="headerlink" title="数据的相关分析"></a>数据的相关分析</h2></li></ol><h3 id="数值型属性间关系"><a href="#数值型属性间关系" class="headerlink" title="数值型属性间关系"></a>数值型属性间关系</h3><p>确定性关系：函数关系，两变量是一一对应的确定关系  如：圆面积与圆半径</p><p>非确定性关系：两类现象在发展变化方向与大小方面存在一定联系。一个变量的取值不能由另一个变量唯一确定。 如：体重与体表面积</p><h3 id="相关分析-（分析两个数值型属性之间的相关性）"><a href="#相关分析-（分析两个数值型属性之间的相关性）" class="headerlink" title="相关分析 （分析两个数值型属性之间的相关性）"></a>相关分析 （分析两个数值型属性之间的相关性）</h3><ol><li>散点图：将两个属性的成对数据，绘制在直角坐标系中得到的一系列点</li></ol><p>目的：观察两个数值型属性之间是否相关、相关的变现形式以及密切程度</p><p>正线性相关、负线性相关、零相关</p><ol><li>相关系数：是描述两个数值型属性间相关关系的密切程度与相关方向的指标。（高中的线性回归方程）</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NmNjYzU3MGQ3N2UxMmRiNjc2MGIyYTQwYTJhMmY4NTVfcE1GSHRRWGVoeFN2SGlFbzBlUmJmZzc2SDFoeFc3NjNfVG9rZW46V0JhMGJ4Mk9qb3RycmV4djBCYWNEUTN1bnRnXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>没有单位，-1≤r≤1</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=Yzg2OTZmYjM4NzgyYmQ5ZjYxZjJiMDM4ZjkzMTdkMWVfTEhNM01sZktGMUZKYWE1M1p2U1ptVm5pSHBoenpnd3dfVG9rZW46QTNNT2I0Mmtvb0ZOazF4Wm1Oa2M0bmdXbjZjXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>两变量间存在直线相关关系，并不表示一定是因果 关系，可能是伴随关系。</p><h3 id="卡方（χ2）检验（推断两个标称属性之间的独立性）"><a href="#卡方（χ2）检验（推断两个标称属性之间的独立性）" class="headerlink" title="卡方（χ2）检验（推断两个标称属性之间的独立性）"></a>卡方（χ2）检验（推断两个标称属性之间的独立性）</h3><p>建立检验假设，确定显著性水平</p><p>计算检验统计量χ2值</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ODRiMjFhYWRiZmVlYTI2M2EzYzVlYWYzZWI4YWNiN2ZfV0ZNQkFkNkF0YkhRZFdDV3YzaHB5REw2aVd2OFJ5S2tfVG9rZW46THpjUmI0NGZmb0EzbU94UFhvY2N1WDZYbnhjXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=M2ExMmI3MDBlNTE5YTNiMGE3ZjQ2YTdmYTE1MzFkZDVfOGxnNGNpclBNUE9wcEdJbWNTN2FPcUNhOVdjVkhqRUtfVG9rZW46SDQ1ZWJSbGRnb2pFUDl4U2syTmN5ME9XbjdkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li><h2 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h2></li></ol><p>由于维度较多，数据呈现出越来越稀疏的分布特点，再加上不</p><p>同维度之间有一定的相关性，增加了数据挖掘算法的复杂度(维灾难)</p><p>用较少数量的、彼此不相关的新维度（主成分)代替原来的维度，并能够解释数据所包含的大部分信息</p><h3 id="形式化描述"><a href="#形式化描述" class="headerlink" title="形式化描述"></a>形式化描述</h3><p>n 个p维样本组成的数据集合可以表示为一个n×p的矩阵X</p><h3 id="主成分分析的主要步骤"><a href="#主成分分析的主要步骤" class="headerlink" title="主成分分析的主要步骤"></a>主成分分析的主要步骤</h3><ol><li>给定10个二维数据 （x1 , x2 ） ，表示成10×2的矩阵形式</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OTQ1YjFkMWQ5NzkyNDk0ZWU2ODc4NjJiYmFkOGUzMjJfbnIxaks5Uk1XdFpEUzRTOENmWW8wZVV6MWJLUkhWQXVfVG9rZW46VjdwVGJTenp1b3dTNjZ4UXpkY2N0cVhqbmtkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li>将X的每一行（维）进行零均值化</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YjllYTg2NzVkNWE0ZTBhNzNjYzU3YTY4YjE2ZjA1ZTdfVjRjZmJjRmhSWk5KYWEyeG43ZWRMdG5WYm1ET3lxYnRfVG9rZW46SE9GaWJrandYb05mYkd4WUxkSGNwc3JNbmZjXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li>求样本协方差阵C</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MGM0ZjUyMjY2MDQ3YTZiMTJlMzA4YzI1MDJjMTNmODNfNndiT2lEUlhENzVkRUtQaWFXZVp5VUx5N0RvVHZkbEFfVG9rZW46U0ZzUmJ6ZTJ3bzgzNkh4ZXdpWWNEcDBCbnZkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li>计算协方差阵C的特征值及对应的标准正交特征向量</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YmQ5MDQ0YjkwN2JiMDc2YmQ3MmM2Y2Y0ZjExNTE0YzFfa3ZJWEFoZzdiVGdyV2JQTVRmZ0RiY3A5cE9BR3k3aGVfVG9rZW46SGdSY2J6MWJJb1cwd1F4RkhUNWNZYmdybnliXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li>将特征向量根据对应特征值大小从上到下按行排列成矩阵</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YTUwYWVlNTZjMzNiMTY3ZmE3MzM0OGRhYzAzYjU0ZDZfOXNtNmtDNGVwazNweFVCUzNQZ3NhR0RZUVd5NURpc0JfVG9rZW46TTJVV2JHSDJnb0FzVXV4bHh3MWM4YTl4bmljXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li>将样本投影到新的坐标系上</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NzlmMmZjMTI3MjUyODYyZGU3MGZjZDBjZmI0NGUwZWRfcEpiWEw4dDh3OFNlZHRBSlpYUVp6djNWM044NDRsRjBfVG9rZW46UE5zZGJab3kzb3Y3c214S0pqQ2NvUWxIbjZYXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li>确定提取主成分的数目</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OGQ5MDI3YjlmM2MxMzNhOWIxYjM4YjA3NzA1ZmQ3ODVfTkp6YzV3RVRuUTJlU1B6WHZPRkxEazQ5UXpNMmo5NFZfVG9rZW46VVNOUWI0enpYb3JwNFN4MVNER2MzNGdyblVnXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li><h2 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h2></li></ol><p>假 设 检 验 的 步 骤</p><ul><li>提出原假设（Null hypothesis） 与备择假设（Alternative hypothesis）</li><li>确定适当的检验统计量， 并计算检验统计量的值</li><li>规定显著性水平α</li><li>作出统计决策</li></ul><ol><li><h2 id="独立样本t检验"><a href="#独立样本t检验" class="headerlink" title="独立样本t检验"></a>独立样本t检验</h2></li></ol><p>应用条件</p><p>独立性(Independence)</p><p>组内变量值 间彼此独立一基础性条件</p><p>正态性(Normality)</p><p>不同组样本均来自正态总体一第一条件</p><p>方差齐性(Homogeneity&#x2F;.Equality of variance)</p><p>独立样本均数比较时，两样本对应的总体方差相同一第二条件</p><ol><li><h2 id="第二章相关试题"><a href="#第二章相关试题" class="headerlink" title="第二章相关试题"></a>第二章相关试题</h2></li><li><p>下列有关个人信息的指标,属于序数属性的是()</p></li></ol><p>A学历</p><p>B民族</p><p>C职业</p><p>D考试成绩</p><ol><li>下列说法错误的是()。</li></ol><p>A有时为了数据分析的方便,可将高级属性转化为比他低级的属性,一般不能做相反方向的转化。</p><p>B数据属性转化顺序:标称属性→序数属性→区间标度属性→比率属性</p><p>C数据属性的类型大的来说分为定性和定量两种。</p><p>D实际工作中,首选比率属性,其次是区间标度属性,再次是序数属性,最后是标称属性。</p><ol><li>下列属于二元属性的是()</li></ol><p>A血压值</p><p>B流感病毒检测结果</p><p>C身高</p><p>D血型</p><ol><li>肝炎病人的住院天数是()</li></ol><p>A区间标度属性</p><p>B比率标度属性</p><p>C标称属性</p><p>D序数属性</p><ol><li>一组数据中出现次数最多的变量值称为()。</li></ol><p>A算术平均值</p><p>B众数</p><p>C中位数</p><p>D标准差</p><ol><li>离散趋势是指 () 。</li></ol><p>A变量值的远离其中心值的程度</p><p>B变量值的平均水平</p><p>C变量值的分配</p><p>D变量值的大小</p><ol><li>主成分分析后每一个新的变量可以表示为()</li></ol><p>A某个原变量</p><p>B新变量的线性组合</p><p>C原来部分变量的线性组合</p><p>D原来所有变量的线性组合</p><ol><li>标准差数值越小,则()。</li></ol><p>A反映变量值越集中,算术平均值代表性越好。</p><p>B反映变量值越分散,算术平均值代表性越差。</p><p>C反映变量值越集中,算术平均值代表性越差。</p><p>D反映变量值越分散,算术平均值代表性越好。</p><ol><li>当两组或多组资料的变异度进行比较时,应采用离散系数的情况是()</li></ol><p>A均数相差悬殊</p><p>B标准差相差悬殊</p><p>C度量单位不同</p><p>D资料来自不同地区</p><p>E资料来自不同时期</p><ul><li>离散系数（Coefficient of Variation，CV）是衡量数据离散程度的统计量，它是标准差与均数的比值，用来比较不同数据集的变异程度。当均数相差悬殊时，直接比较标准差的大小可能不具有可比性，因为标准差会随着均数的增大而增大。此时，使用离散系数可以消除均数差异的影响，更公平地比较不同数据集的变异度。</li></ul><ol><li>下列指标中属于集中趋势指标的有()</li></ol><p>A算术平均值</p><p>B众数</p><p>C中位数</p><p>D百分位数</p><p>E极差</p><ol><li>比率标度属性能提供关于顺序、差异以及比率关系的信息,关键之处在于“真正零值”能够被定义。√</li><li>当资料分布的末端无确切数据时不能计算算术平均值。√</li><li>样本量增大时,极差可能会增大√</li><li>方差的单位与原始数据的单位相同×</li><li>卡方检验中,卡方统计量用来衡量所有单元格的观测值与理论值的差异大小。√</li><li>卡方检验中,卡方统计量越大,越有理由拒绝H0。√</li><li>相关系数∣r∣越接近于0,说明相关的密切程度越强。×</li><li>在选定主成分之后,还需要结合应用,对主成分进行解释,给出主成分的实际意义。√</li><li>主成分分析是一种统计方法,通过正交变换将一组可能存在相关性的变量转换为一组线性无关的变量,转换后的这组向量称为主成分。√</li><li>主成分分析方法是一种数据降维的方法。√</li></ol><h1 id="第三章：数据处理"><a href="#第三章：数据处理" class="headerlink" title="第三章：数据处理"></a>第三章：数据处理</h1><ol><li><h2 id="数据的清洗"><a href="#数据的清洗" class="headerlink" title="数据的清洗"></a>数据的清洗</h2></li></ol><h3 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h3><p>数据缺失机制分为以下三种：</p><ul><li>完全随机缺失</li><li>随机缺失</li><li>非随机缺失</li></ul><p>处理缺失值的方法可分为3类：删除记录、数据插补和不处理</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YTcxOTFkYjI4MjgxZWU4ZTE0YzI1ZDFkODZiODFjZjlfNVNQTVc0dXpTWHVJVkJ3dlQ5NFhiaHlkNGdDd0twcGRfVG9rZW46UEVVY2JsdEUyb2pkaXh4MWZLQmNXZm44blFkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>主要讲的两个插值方法</p><p>拉格朗日插值法</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTgwYzNlNmUzZTE3MGRmNzUzYzhiNGVmMzJlYjk2NzVfZVRnN2JLZVIyc0ZVVXZCek5iZmFWSklncEtBOVRuNGZfVG9rZW46QWY3bmJBVDlBb3ZTUDJ4SEtHc2M3ODkwbnpoXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>牛顿插值法</p><p>具有承袭性和易于变动节点的 特点。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NmY3YzUzMTg5ZWNlMGI4ODc4ZGVkYjFiMWQ4ZDhkYzlfT0dtVmZ3MnUzRHEzeFI4dHIwQXQ3cnlDb1V1ZUZKMm5fVG9rZW46QTRlS2I1Qlo5b2RwN0p4cHVqYWM4eW9sbjdkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><h3 id="重复值处理"><a href="#重复值处理" class="headerlink" title="重复值处理"></a>重复值处理</h3><p>记录重复</p><p>在某企业的药品发货记录表中，利用列表（list）对用品名称去重，查看所有的品牌名称： </p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">delRep</span>(<span class="params">list1</span>):</span><br><span class="line">     list2 = []</span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> list1</span><br><span class="line">         <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> list2:</span><br><span class="line">             list2.append(i)     //老师说这个append会考个两分的</span><br><span class="line">     <span class="keyword">return</span> list2</span><br><span class="line"> names = <span class="built_in">list</span>(data[<span class="string">&#x27;品牌名称&#x27;</span>]) <span class="comment"># 提取品牌名称</span></span><br><span class="line"> name = delRep(names) <span class="comment"># 使用自定义的去重函数去重</span></span><br></pre></td></tr></table></figure><p>还可以利用集合（set）元素为唯一的特性去重:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;去重前品牌总数为：&#x27;</span>, <span class="built_in">len</span>(names)) </span><br><span class="line">name_set = <span class="built_in">set</span>(names) <span class="comment"># 利用set的特性去重 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;去重后品牌总数为：&#x27;</span>, <span class="built_in">len</span>(name_set）</span><br></pre></td></tr></table></figure><p>pandas提供了一个名为drop_duplicates的去重方法。该方法只对 DataFrame或Series类型有效。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.DataFrame.drop_duplicates(subset=<span class="literal">None</span>,keep=<span class="string">&#x27;first&#x27;</span>,inplace=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MjI2ZTk0YTNiZTUyNDcyYjA0MjZkNTY1MjAyYzFmNWVfVXZHQ2kzYTI3YlprVkd4VUNuTVh1ZnNiR0VvcVlYd1JfVG9rZW46QXRFcGJFeFdWb081ek54S1RXMWNuNzRlbjZkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>属性内容重复</p><p>属性内容重复是指数据中存在一个或多个属性名称不同，但数据完全相同。当需要去除 连续型属性重复时，可以利用属性间的相似度，去除两个相似度为1的属性的其中一个</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">corr_ = data[[<span class="string">&#x27;品牌标签&#x27;</span>, <span class="string">&#x27;仓库标签&#x27;</span>]].corr(method=<span class="string">&#x27;kendall&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;kendall相似度为：\n&#x27;</span>, corr_）</span><br></pre></td></tr></table></figure><p>除了使用相似度矩阵进行属性去重之外，可以通过pandas库的DataFrame.equals()方法进行属性去重。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.DataFrame.equals(other)</span><br></pre></td></tr></table></figure><h3 id="异常值处理"><a href="#异常值处理" class="headerlink" title="异常值处理"></a>异常值处理</h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjJmM2MwMzA4ZGM0ZGViYWFjYWM3YzNiNTUwZmEyOWVfWk5vSHNOS1paZEhseWtGYnBrVDZnUm1PYzFuS0wxVnZfVG9rZW46VDc0ZWJJU0lCb0dST2V4cnIxVGNlNk92bkpmXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li><h2 id="数据的变换"><a href="#数据的变换" class="headerlink" title="数据的变换"></a>数据的变换</h2></li></ol><h3 id="简单函数变换"><a href="#简单函数变换" class="headerlink" title="简单函数变换"></a>简单函数变换</h3><p>简单函数变换是对原始数据进行某些数学函数变换，常用的包括平方、开方、取对数、差分运算等。</p><h3 id="最小-最大标准化"><a href="#最小-最大标准化" class="headerlink" title="最小-最大标准化"></a>最小-最大标准化</h3><p>最小-最大标准化也称为离差标准化，是对原始数据的线性变换，将数值映射到[0,1]之间。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NTI5N2IxOTJkZWE1MWVmY2QwM2U5ZWQ3ZjcxN2RmODVfS1Ayaks4S3ExRzJlZXlZU2pTbThBanlYVkpXNHZubGtfVG9rZW46TG5NQWI1VGRwb3RyVnV4RHVYRGNJTm44bnlwXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>其中， max为样本数据的最大值， min为样本数据的最小值。max-min 为极差。</p><h3 id="零-均值标准化"><a href="#零-均值标准化" class="headerlink" title="零-均值标准化"></a>零-均值标准化</h3><p>零-均值标准化也叫标准差标准化，经过处理的数据的均值为0，标准差为1。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NjI1MWNhOWNjNWZlZjZmM2Y3ZDY1YTA4YjI5MDQ0ZjFfU0YzZHFFZ0NhazV2TDNPYnBwSFl1SjBWRUtvNjZwOVlfVG9rZW46QjJ4VGJMOENQb2JQcVp4RzBxd2NCRnd1bkhoXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>其中x为原始数据的均值，S为原始数据的标准差，零-均值标准化是当前用得最多的数据标准化方法。</p><h3 id="小数定标标准化"><a href="#小数定标标准化" class="headerlink" title="小数定标标准化"></a>小数定标标准化</h3><p>通过移动属性值的小数位数，将属性值映射到[-1,1]之间，移动的小数位数 取决于属性值绝对值的最大值</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=M2I2YjY0ZGIyNTM2Zjc4NmFhOGRjNmYxNjBhZjFhOGRfeG41QnlKODV5b1pTOHI5SjFFbldaemhtZHdHYmpXSDBfVG9rZW46Wld4OWIzcnExb0Q3Smh4blYzUmNmRkhxblRnXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>其中k为属性值中绝对值最大的数值的位数。</p><h3 id="数据离散化"><a href="#数据离散化" class="headerlink" title="数据离散化"></a>数据离散化</h3><p>將连续的数据进行分段，使其变为一段段离散化的区间</p><p>离散化的方法：</p><p>无监督学习的方式</p><p>有监督学习的方式</p><p>分段的原则有星于等距离、等频率、聚类或优化的方法</p><p>离散化的过程:</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YmJiZjUwNzY3MTA5MjNiN2FjNzkzZGNiNDNmMmM3ODZfVWFxVWRyUEVGbGV4R3FaSWpKRXJMUXQyTTdjdk1GTVJfVG9rZW46Unp6MmJTWVRpb1hIT2F4T3p3bmNSS1NWblFnXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>常用的离散化方法：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MmNjN2U1YmFkNGVhYWJmYjc5NmFhNjYzOWJmZTM3ZjJfblZIWDQ1S3VpWHJZcXI2bWhCb2E4Tlpva0FuQkhSeG9fVG9rZW46SzduNWJkMklob3NDTzJ4NEUwM2MwTUlwblllXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><h3 id="独热编码（重点，可能考到代码）"><a href="#独热编码（重点，可能考到代码）" class="headerlink" title="独热编码（重点，可能考到代码）"></a>独热编码（重点，可能考到代码）</h3><p>独热编码即One-Hot编码，又称一位有效编码，是处理类型数据较好的方法，主要是使用N位状态寄存器来对N个状态进行编码，每个状态都有它独立的寄存器位，并且在任意时候都只有一个编码位有效。</p><p>独热编码有以下优点：</p><ul><li>将离散型属性的取值扩展到欧氏空间，离散型属性的某个取值就对应欧氏空间的某个点。</li><li>对离散型属性使用独热编码，可以让属性之间的距离计算更为合理。</li></ul><p>在Python中使用scikit-learn库中preprocessing模块的OneHotEncoder函数进行独热编码</p><p>以书上的 示例2-16为参考记忆代码:–亲测可以跑通</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">enc=preprocessing.OneHotEncoder() <span class="comment">#这行代码创建了一个OneHotEncoder类的实例，并将这个实例赋值给变量enc。OneHotEncoder是preprocessing模块中用于进行独热编码的类。</span></span><br><span class="line">productData=np.array([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]]) <span class="comment">#这行代码使用numpy库创建了一个二维数组productData。这个数组包含了5行3列的数据，每行代表一个产品的数据，每列代表一个特征。</span></span><br><span class="line">enc.fit(productData)  <span class="comment">#这行代码使用fit方法来拟合OneHotEncoder实例enc。fit方法会根据输入的数据来学习如何进行独热编码，即确定哪些特征是分类特征，以及每个分类特征中有多少个不同的类别。</span></span><br><span class="line">Ohe=enc.transform(productData)  <span class="comment">#这行代码使用transform方法来转换productData数组。transform方法将原始数据转换为独热编码形式。转换后的数据存储在变量Ohe中。</span></span><br><span class="line"><span class="built_in">print</span> (Ohe.toarray())</span><br></pre></td></tr></table></figure><ol><li><h2 id="数据的合并"><a href="#数据的合并" class="headerlink" title="数据的合并"></a>数据的合并</h2></li></ol><h3 id="多表合并"><a href="#多表合并" class="headerlink" title="多表合并"></a>多表合并</h3><ul><li>堆叠合并数据</li></ul><p> 使用pandas库的concat函数可以实现横向堆叠和纵向堆叠，concat函数的基本使用格式 和常用参数说明如下：</p><p>分为横向堆叠和纵向堆叠</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MWIwOTI5ZDY3Yzk0MDNlYjFhZGVjZWIxMTc2N2E2MjBfZENlcktVbUtqaWsyTHppM09GOXZqSEpnNU9YUmZVWWpfVG9rZW46QnVNZ2JLMGNyb1E2bE94M2J6NWNNWDdGblhkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>使用pandas库的concat函数可以实现横向堆叠和纵向堆叠</p><p>除了concat函数之外，pandas库的append()方法也可以用于纵向合并两张表</p><ul><li>主键合并数据</li></ul><p>主键合并，即通过一个或多个键将两个数据集的行连接起来。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=Mjc5ZTI2MDFiZDU0ZTgxY2YwZGI4ZmVjYzg4YjcyZGRfWkJkbVRXUnpXQkhDMWZuUmFOSWtkZkxENDQ0OWQ0RE5fVG9rZW46VFlUNGIwVlVLb29hMDh4OGlua2MzdFAwblRjXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>pandas库中的merge函数（pandas.merge（））和join()方法（pandas.DataFrame.join（））都可以实现主键合并，但两者的实现方式并不相同</p><p>使用join()方 法时，两个主键的名字必须相同</p><ul><li>重叠合并数据</li></ul><p>数据分析和处理过程中偶尔会出现两份数据的内容几乎一致的情况，但是某些属性在其中 一张表上是完整的，而在另外一张表上的数据则是缺失的。这时除了使用将数据一对一比较， 然后进行填充的方法外，还有一种方法就是重叠合并</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=M2IyZGJhMWZlZWI4ZjRjMjY2OTY3OGM4NWRkMzMyNmFfNGFpYUdYaDBOWm5lb1dmRzVENkFENXJaMVA1MDRwMmhfVG9rZW46SzdaTGJyYThGb21VbG94WmhhZGNYdWpabjJlXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><h3 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h3><p>分组是使用特定的条件将元数据进行划分为多个组。聚合是对每个分组中的数据执行某些</p><p>操作，最后将计算结果进行整合。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmFjZjkzMTU4YTI5NjQ1Y2E3YzI4YTExMjQ1ZTk0OGZfS2pSMmg0d2V0RXF3bVRzTHYwSG1oQUhtVVJNenNtamNfVG9rZW46UTRLS2J4Sm9MbzBlc3J4Wk1MaGNIa1Vnbk12XzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li>使用groupby0方法拆分数据</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.DataFrame.groupby（）</span><br></pre></td></tr></table></figure><ol><li>使用agg()方法聚合数据</li></ol><p>agg()方法和aggregate()方法都支持对每个分组应用某函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.DataFrame.agg（）</span><br><span class="line">pandas.DataFrame.aggregate（）</span><br></pre></td></tr></table></figure><ol><li>使用apply()方法聚合数据</li></ol><p>apply()方法类似于agg()方法，能够将函数应用于每一列。不同之处在于，与agg()方法相比， apply()方法传入的函数只能够作用于整个DataFrame或Series，而无法像agg()方法一样能够对不 同字段应用不同函数来获取不同结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.DataFrame.apply（）</span><br></pre></td></tr></table></figure><ol><li>使用transform()方法聚合数据</li></ol><p> transform()方法能够对整个DataFrame的所有元素进行操作。</p><p>以药品详情表为例，对销量和售价使用pandas库的transform()方法进行翻倍：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">detail[[<span class="string">&#x27;counts&#x27;</span>, <span class="string">&#x27;amounts&#x27;</span>]].transform(<span class="keyword">lambda</span> x: x * <span class="number">2</span>).head(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><ol><li><h2 id="第三章相关试题"><a href="#第三章相关试题" class="headerlink" title="第三章相关试题"></a>第三章相关试题</h2></li><li><p>( )的目的缩小数据的取值范围,使其更适合于数据挖掘算法的需要,并且能够得到和原始数据相同的分析结果</p></li></ol><p>A数据清洗</p><p>B数据集成</p><p>C数据变换</p><p>D数据归约</p><ol><li>将原始数据进行集成、变换、维度规约、数值规约是在以下哪个步骤的任务?()</li></ol><p>A频繁模式挖掘</p><p>B分类和预测</p><p>C数据预处理</p><p>D数据流挖掘</p><ol><li>下面哪种不属于数据预处理的方法? ()</li></ol><p>A变量代换</p><p>B离散化</p><p>C聚集</p><p>D估计遗漏值</p><ol><li>假设12个销售价格记录组已经排序如下:5, 10,11,13, 15,35, 50, 55,72,92,204, 215 使用如下每种方法将它们划分成四个箱。等频(等深)划分时,15在第几个箱子内?()</li></ol><p>A第一个</p><p>B第二个</p><p>C第三个</p><p>D第四个</p><ol><li>以下哪种方法不属于特征选择的标准方法:()</li></ol><p>A嵌入</p><p>B过滤</p><p>C包装</p><p>D抽样</p><ol><li>下面哪个属于映射数据到新的空间的方法?()</li></ol><p>A傅立叶变换</p><p>B特征加权</p><p>C渐进抽样</p><p>D维归约</p><ol><li>数据仓库是随着时间变化的,下面的描述不正确的是()</li></ol><p>A数据仓库随时间的变化不断增加新的数据内容</p><p>B捕捉到的新数据会覆盖原来的快照</p><p>C数据仓库随事件变化不断删去旧的数据内容</p><p>D数据仓库中包含大量的综合数据,这些综合数据会随着时间的变化不断地进行重新综合</p><ol><li>MapReduce的Map函数产生很多的( )</li></ol><p>Akey</p><p>Bvalue</p><p>C&lt;key,value&gt;</p><p>DHash</p><ol><li>噪声数据的产生原因主要有:()</li></ol><p>A数据采集设备有问题</p><p>B在数据录入过程中发生了人为或计算机错误</p><p>C数据传输过程中发生错误</p><p>D由于命名规则或数据代码不同而引起的不一致</p><p>E数据资料自然产生</p><ol><li>进行多表合并时,使用pandas库的可以实现横向堆叠和纵向堆叠()</li></ol><p>Aconcat函数</p><p>Bappend()方法</p><p>Cmerge函数</p><p>Djoin()方法</p><p>Egroupby()</p><ol><li>对遗漏数据的处理方法主要有:忽略该条记录;手工填补遗漏值;利用默认值填补遗漏值;利用均值填补遗漏值;利用同类别均值填补遗漏值;利用最可能的值填充遗漏值。√</li><li>数据规范化指将数据按比例缩放(如更换大单位),使之落入一个特定的区域(如0—1)以提高数据挖掘效率的方法。规范化的常用方法有:最大—最小规范化、零-均值规范化、小数定标规范化。√</li><li>原始业务数据来自多个数据库或数据仓库,它们的结构和规则可能是不同的,这将导致原始数据非常的杂乱、不可用,即使在同一个数据库中,也可能存在重复的和不完整的数据信息,为了使这些数据能够符合数据挖掘的要求,提高效率和得到清晰的结果,必须进行数据的预处理。√</li><li>孤立点在数据挖掘时总是被视为异常、无用数据而丢弃。×</li><li>维归约可以去掉不重要的属性,减少数据立方体的维数,从而减少数据挖掘处理的数据量,提高挖掘效率。√</li><li>分组是使用特定的条件将元数据进行划分为多个组。√</li><li>agg()方法和aggregate()方法都支持对每个分组应用某函数,但是不包括Python内置函数或自定义函数×</li><li>特征离散化以后,起到了简化了模型的作用,降低了模型过拟合的风险。√</li><li>最小-最大标准化也称为离差标准化,是对原始数据的线性变换,将数值映射到[0,1]之间。√</li><li>处理缺失值的方法可分为3类:删除记录、数据插补和不处理。√</li></ol><h1 id="第四章-关联规则挖掘"><a href="#第四章-关联规则挖掘" class="headerlink" title="第四章: 关联规则挖掘"></a>第四章: 关联规则挖掘</h1><ol><li><h2 id="基于候选项集产生-测试策略的频繁模式挖掘算法"><a href="#基于候选项集产生-测试策略的频繁模式挖掘算法" class="headerlink" title="基于候选项集产生-测试策略的频繁模式挖掘算法"></a>基于候选项集产生-测试策略的频繁模式挖掘算法</h2></li></ol><p>关联规则分析</p><p>关联规则分析也称为购物篮分析，目的是从大量数据中找出各项之间的关联关系，如关联规则“面包&#x3D;&gt;牛奶”，其中面包称为规则的前项，而牛奶称为后项。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmRkNDA3NTE5ODNjNjExMDVjMzIyOWVhZDkwNDgxYWZfZDI2NEJnbUtYVmVUeW5oNkY2YWNuRnlUS2F5UmZKVWNfVG9rZW46QmdhNGJISjNnbzA3OEl4Q3RRU2M3VmdxbnlkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>重点记忆Apriori</p><h3 id="Apriori算法"><a href="#Apriori算法" class="headerlink" title="Apriori算法"></a>Apriori算法</h3><p>关联规则和频繁项集</p><p>支持度（Support）：项集A、B同时发生的概率称为关联规则的支持度。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MDZlMjQ0NzdkMDEzMTY3MWIwMDY1YzI1ZDgxMWMzZDVfQ3FYcGxBQjZCajRsNWpCa0RTa2liQnVEdlFZRDhsZkJfVG9rZW46SWpQUGJkWEppb3c5eTN4azF0V2NuQWNubmltXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>置信度（可信度Confidence）：项集A发生，则项集B发生的概率为关联规则的置信度</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YWYwM2JkODg0OTY2MjliZDExMThlYTQ3MGQ1ODkxMTFfZ2kyREk0NER5bFhVZ2ZkUkVmemU2OXZiQzVmT01RMVNfVG9rZW46SnB0U2J5Y09ub0piYm94VmlaTGNBc2Q3bktlXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>提升度：含有A的条件下，同时含有B的概率，与B总体发生的概率之比。也 就是A对B的置信度与B总体发生的概率之比</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NmU4YWY2NzNkZWQ5NTczZjBlNTQ4MzE2NjRlOWRiNzhfcjg1SXB4UjhoV1J4SU9sOUk5d2dBZ0d2eFFrUHhVelRfVG9rZW46T3oyWGI5Skd0bzJ6T1Z4ZmtKRGNiOHh3bkVkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>强关联规则：</p><ol><li>先寻找满足最小支持度的频繁项集 </li><li>然后在频繁项集中寻找满足最小置信度的关联规则</li></ol><p>最小支持度和最小置信度:</p><p>最小支持度是用户或专家定义的衡量支持度的一个阈值，表示项目集在统计意义上 的最低重要性；最小置信度是用户或专家定义的衡量置信度的一个阈值，表示关联规则 的最低可靠性。同时满足最小支持度阈值和最小置信度阈值的规则称作强规则</p><p>项集与频繁项集:</p><p>项集是项的集合。包含k个项的项集称为k项集，如集合{人参、附子、甘草}是一个3 项集。 项集的出现频数是所有包含项集的事务计数，又称作绝对支持度或支持度计数。如 果项集I的相对支持度满足预定义的最小支持度阈值，则I是频繁项集。</p><p>Apriori算法的主要思想是找出存在于事务数据集中的最大的频繁项集，再利 用得到的最大频繁项集与预先设定的最小置信度阈值生成强关联规则。</p><p>Apriori的性质</p><p>频繁项集的所有非空子集也必须是频繁项集。根据该性质可以得出：向不是频 繁项集的项集 中添加事务 ，新的项集 一定也不是频繁项</p><p>步骤:</p><ul><li>设定最小支持度和最小置信度 </li><li>根据最小支持度找出所有的频繁项集 </li><li>根据最小的置信度发现强关联规则</li></ul><p>按ppt上的案例应该可以快速入门这一算法</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NTcxYWI1OGE5YmU3ODQxNTIxNzAxNzQ0YTllMTQyZDRfVW9XcDRKVll4ZjZRRkxIcFdqRUFHVXV2VVBkYVdvczJfVG9rZW46WWt5M2JuOG5SbzFyMzZ4NXFGaWNJZEtibmpoXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MzA5NTVjYThiM2ZiYzAzNzI4YTEzMDA5NTRjNTE3YzNfZ20wMG1ncm1FbHFHZmgwM09YSmxDVUxEQXlvQ1pyRk5fVG9rZW46SlZGTmI0R0RGb003ZFF4aEg1bGNrWWFwbnVGXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YjE1MTMxZTE5NzEyNmVlZmI2NWFiN2VhMzlmZjAxY2VfZWdBVVYzR09odXBDeWJBN3E4c2ZxNlBoTjdmMW5HRHVfVG9rZW46QzVRcGJQVnlsb3RpeXJ4Wm1ZSGM4U052bk9lXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTA5MDBkNjg3NjkzMjg5OGQzOGQzNzliODQ1ZjQwZjZfcm1iQU5Xc1VzcVNNeFZlOWhJWTFxZ2l6OGRpc3lrcmlfVG9rZW46SlJmTWJKeEw5b2NnSDB4Vjl5cWN5OU1abmdkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li><h2 id="基于Apriori算法的中医证型关联规则挖掘"><a href="#基于Apriori算法的中医证型关联规则挖掘" class="headerlink" title="基于Apriori算法的中医证型关联规则挖掘"></a>基于Apriori算法的中医证型关联规则挖掘</h2></li></ol><p>不必理会，看不懂</p><ol><li><h2 id="不需要产生候选项集的-频繁模式挖掘算法"><a href="#不需要产生候选项集的-频繁模式挖掘算法" class="headerlink" title="不需要产生候选项集的 频繁模式挖掘算法"></a>不需要产生候选项集的 频繁模式挖掘算法</h2></li></ol><h3 id="FP-growth算法"><a href="#FP-growth算法" class="headerlink" title="FP-growth算法"></a>FP-growth算法</h3><p>流程:</p><p>首先构造FP树，然后利用它来挖掘频繁 项集。在构造FP树时，需要对数据集扫 描两边，第一遍扫描用来统计频率， 第二遍扫描至考虑频繁项集</p><h3 id="多层关联规则挖掘算法"><a href="#多层关联规则挖掘算法" class="headerlink" title="多层关联规则挖掘算法"></a>多层关联规则挖掘算法</h3><p>多层关联规则（Multilevel Rules）是一种基于概念分层的关联规则挖掘方法，概念 层次结构通常用概念树来表示，按照一般到特殊的顺序以偏序的形式排列</p><ol><li><h2 id="第四章相关试题"><a href="#第四章相关试题" class="headerlink" title="第四章相关试题"></a>第四章相关试题</h2></li><li><p>某超市研究销售纪录数据后发现,买啤酒的人很大概率也会购买尿布,这种属于数据挖掘的哪类问题?()</p></li></ol><p>A关联规则发现</p><p>B聚类</p><p>C分类</p><p>D自然语言处理</p><ol><li>设X&#x3D;{1,2,3}是频繁项集,则可由X产生( )个关联规则.</li></ol><p>A4</p><p>B5</p><p>C6</p><p>D7</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">由于 𝑋X 包含<span class="number">3</span>个项，我们可以生成以下子集 𝑌：</span><br><span class="line">&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;（单个项集）</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">1</span>,<span class="number">3</span>&#125;, &#123;<span class="number">2</span>,<span class="number">3</span>&#125; （两个项的组合）</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;（整个项集本身）</span><br><span class="line">对于每个子集 𝑌Y，我们都可以生成一个关联规则 𝑌⇒𝑍Y⇒Z，其中 𝑍Z 是 𝑋X 中不在 𝑌Y 中的项集。</span><br><span class="line">具体来说：</span><br><span class="line">对于 𝑌=&#123;<span class="number">1</span>&#125;Y=&#123;<span class="number">1</span>&#125;，可以生成 &#123;<span class="number">1</span>&#125;⇒&#123;<span class="number">2</span>,<span class="number">3</span>&#125;。</span><br><span class="line">对于 𝑌=&#123;<span class="number">2</span>&#125;Y=&#123;<span class="number">2</span>&#125;，可以生成 &#123;<span class="number">2</span>&#125;⇒&#123;<span class="number">1</span>,<span class="number">3</span>&#125;。</span><br><span class="line">对于 𝑌=&#123;<span class="number">3</span>&#125;Y=&#123;<span class="number">3</span>&#125;，可以生成 &#123;<span class="number">3</span>&#125;⇒&#123;<span class="number">1</span>,<span class="number">2</span>&#125;。</span><br><span class="line">对于 𝑌=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;Y=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;，可以生成 &#123;<span class="number">1</span>,<span class="number">2</span>&#125;⇒&#123;<span class="number">3</span>&#125;。</span><br><span class="line">对于 𝑌=&#123;<span class="number">1</span>,<span class="number">3</span>&#125;Y=&#123;<span class="number">1</span>,<span class="number">3</span>&#125;，可以生成 &#123;<span class="number">1</span>,<span class="number">3</span>&#125;⇒&#123;<span class="number">2</span>&#125;。</span><br><span class="line">对于 𝑌=&#123;<span class="number">2</span>,<span class="number">3</span>&#125;Y=&#123;<span class="number">2</span>,<span class="number">3</span>&#125;，可以生成 &#123;<span class="number">2</span>,<span class="number">3</span>&#125;⇒&#123;<span class="number">1</span>&#125;。</span><br><span class="line">对于 𝑌=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;，通常不生成规则，因为没有剩余的项集可以作为规则的后件。</span><br></pre></td></tr></table></figure><ol><li>考虑下面的频繁3—项集的集合:{1,2,3},{1,2,4},{1,2,5},{1,3,4},{1,3,5},{2,3,4},{2,3,5},{3,4,5}假定数据集中只有5个项,采用合并策略,由候选产生过程得到4-项集不包含( )</li></ol><p>A1,2,3,4</p><p>B1,2,3,5</p><p>C1,2,4,5</p><p>D1,3,4,5</p><ul><li>合并两个频繁k-项集，以生成一个新的k+1-项集，前提是这两个k-项集有(k-1)个共同的项。</li></ul><ol><li>在图集合中发现一组公共子结构,这样的任务称为( )</li></ol><p>A频繁子集挖掘</p><p>B频繁子图挖掘</p><p>C频繁数据项挖掘</p><p>D频繁模式挖掘</p><ol><li>下面购物篮能够提取的3—项集的最大数量是多少()</li></ol><table><thead><tr><th>TID</th><th>项集</th></tr></thead><tbody><tr><td>1</td><td>牛奶，啤酒,尿布</td></tr><tr><td>2</td><td>面包,黄油，牛奶</td></tr><tr><td>3</td><td>牛奶，尿布，饼干</td></tr><tr><td>4</td><td>面包，黄油,饼干</td></tr><tr><td>5</td><td>啤酒,饼干,尿布</td></tr><tr><td>6</td><td>牛奶,尿布,面包,黄油</td></tr><tr><td>7</td><td>面包，黄油，尿布</td></tr><tr><td>8</td><td>啤酒，尿布</td></tr><tr><td>9</td><td>牛奶，尿布，面包，黄油</td></tr><tr><td>10</td><td>啤酒，饼干</td></tr></tbody></table><p>A1</p><p>B2</p><p>C3</p><p>D4</p><ol><li>可用作数据挖掘分析中的关联规则算法有().</li></ol><p>A决策树、对数回归、关联模式</p><p>BK均值法、SOM神经网络</p><p>CApriori算法、FP-Tree算法</p><p>DRBF神经网络、K均值法、决策</p><ol><li>关联规则的评价指标是:().</li></ol><p>A均方误差、均方根误差</p><p>BKappa统计、显著性检验</p><p>C支持度、置信度</p><p>D平均绝对误差、相对误差</p><ol><li>分析顾客就医行为,以便有针对性的向其推荐感兴趣的就医服务,属于()问题。</li></ol><p>A关联规则挖掘</p><p>B分类与回归</p><p>C聚类分析</p><p>D时序预测</p><ol><li>利用Apriori算法计算频繁项集可以有效降低计算频繁集的时间复杂度。在以下的购物篮中产生支持度不小于3的候选3—项集,在候选2-项集中需要剪枝的是( ) 。</li></ol><table><thead><tr><th>TID</th><th>项集</th></tr></thead><tbody><tr><td>1</td><td>面包、牛奶</td></tr><tr><td>2</td><td>面包、尿布、啤酒、鸡蛋</td></tr><tr><td>3</td><td>牛奶、尿布、啤酒、可乐</td></tr><tr><td>4</td><td>面包、牛奶、尿布、啤酒</td></tr><tr><td>5</td><td>面包、牛奶、尿布、可乐</td></tr></tbody></table><p>A啤酒、尿布</p><p>B啤酒、面包</p><p>C面包、尿布</p><p>D啤酒、牛奶</p><p>E面包、牛奶</p><ol><li>Apriori算法的计算复杂度受( )影响。</li></ol><p>A支持度阀值</p><p>B项数(维度)</p><p>C事务数</p><p>D事务平均宽度</p><p>E极差</p><ol><li>比率标度属性能提供关于顺序、差异以及比率关系的信息,关键之处在于“真正零值”能够被定义。√</li><li>当资料分布的末端无确切数据时不能计算算术平均值√</li><li>在图集合中发现一组公共子结构,这样的任务称为频繁子图挖掘。√</li><li>决策树方法通常用于关联规则挖掘。×</li><li>Apriori算法是一种典型的关联规则挖掘算法。√</li><li>关联规则挖掘过程是发现满足最小支持度的所有项集代表的规则。×</li><li>可信度是对关联规则的准确度的衡量×</li><li>利用先验原理可以帮助减少频繁项集产生时需要探查的候选项个数。√</li><li>先验原理可以表述为:如果一个项集是频繁的,那包含它的所有项集（应该是非空子集）也是频繁的×</li><li>回归分析通常用于挖掘关联规则。×</li></ol><h1 id="第五章-分类与回归算法"><a href="#第五章-分类与回归算法" class="headerlink" title="第五章: 分类与回归算法"></a>第五章: 分类与回归算法</h1><ol><li><h2 id="分类与回归概述"><a href="#分类与回归概述" class="headerlink" title="分类与回归概述"></a>分类与回归概述</h2></li></ol><p>分类：分类算法构造一个分类模型，模型的输入为样本的属性值，输出为对应的类别，将每个样本映射到预先定义好的类别。</p><p>回归: 回归算法则是建立两种或两种以上变量间相互依赖的函数模型，然后使用函数模型预测目标的值。</p><h3 id="常用的分类与回归算法"><a href="#常用的分类与回归算法" class="headerlink" title="常用的分类与回归算法"></a>常用的分类与回归算法</h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTVlOTc3MDI0NGIwOGE0MTIyNzZhODhjMWMyZGJkNmNfVFpWdTQ3cFZSZlBRc0FPcWMxN0NvZU5MSDJpM1daVjlfVG9rZW46WEJDRmI3blBMb0Nkemx4RkowQmNPNExZblhmXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><h3 id="最近邻分类"><a href="#最近邻分类" class="headerlink" title="最近邻分类"></a>最近邻分类</h3><p>K近邻（K-Nearest Neighbor，KNN）算法是一种常用的监督学习方法 。其原理非常简单：对于给定测试样本，基于指定的距离度量找出 训练集中与其最近的k个样本，然后基于这k个“邻居”的信息来进行预测</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MTljNTc4YzA4NmE1MDMyMzZiMDUwM2JmZjk4YWNiMTdfZXJoWk1yQWY5bTI4RGhOdnJZSGlDUVpxVkVCZTFOejdfVG9rZW46SHFoaWJsbTJXb09WSXB4cTNuRGNqZjg4bmxlXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>确定预测样本类别： 1. 投票法  2. 平均法</p><p>使用scikit-learn库中neighbors模块的KNeighborsClassifier类可以实现K近 邻算法对数据进行分类</p><p>具体使用实例(亲测可跑通)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入所需的库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report, accuracy_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据集</span></span><br><span class="line">iris = load_iris()</span><br><span class="line">X = iris.data  <span class="comment"># 特征数据</span></span><br><span class="line">y = iris.target  <span class="comment"># 标签数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化KNeighborsClassifier对象</span></span><br><span class="line"><span class="comment"># n_neighbors=3 表示选择最近的3个邻居</span></span><br><span class="line"><span class="comment"># weights=&#x27;uniform&#x27; 表示所有邻居的权重相同</span></span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">3</span>, weights=<span class="string">&#x27;uniform&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">knn.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测测试集</span></span><br><span class="line">y_pred = knn.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评估模型</span></span><br><span class="line">accuracy = accuracy_score(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Accuracy: <span class="subst">&#123;accuracy:<span class="number">.2</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印分类报告</span></span><br><span class="line"><span class="built_in">print</span>(classification_report(y_test, y_pred))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化KNN决策边界（可选）</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了可视化，我们只取两个特征</span></span><br><span class="line">X = iris.data[:, :<span class="number">2</span>]  <span class="comment"># 只取前两个特征</span></span><br><span class="line">y = iris.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">knn.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建网格以绘制决策边界</span></span><br><span class="line">x_min, x_max = X[:, <span class="number">0</span>].<span class="built_in">min</span>() - <span class="number">1</span>, X[:, <span class="number">0</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">y_min, y_max = X[:, <span class="number">1</span>].<span class="built_in">min</span>() - <span class="number">1</span>, X[:, <span class="number">1</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class="number">0.1</span>),</span><br><span class="line">                     np.arange(y_min, y_max, <span class="number">0.1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测网格点的类别</span></span><br><span class="line">Z = knn.predict(np.c_[xx.ravel(), yy.ravel()])</span><br><span class="line">Z = Z.reshape(xx.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制决策边界和训练样本</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.contourf(xx, yy, Z, alpha=<span class="number">0.4</span>)</span><br><span class="line">plt.scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], c=y_train, edgecolors=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Feature 1&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Feature 2&#x27;</span>)</span><br><span class="line">plt.xlim(xx.<span class="built_in">min</span>(), xx.<span class="built_in">max</span>())</span><br><span class="line">plt.ylim(yy.<span class="built_in">min</span>(), yy.<span class="built_in">max</span>())</span><br><span class="line">plt.xticks(())</span><br><span class="line">plt.yticks(())</span><br><span class="line">plt.title(<span class="string">&#x27;3-Class classification (K = 3)&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="线性回归模型"><a href="#线性回归模型" class="headerlink" title="线性回归模型"></a>线性回归模型</h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=M2ExNjdjZmY3ODk3MWNkZjM4YTc0YjczODA5NzViYzlfWDBFUzJDNm0xblQzTFRxZEVOVXZsSWdwamltYno3QUhfVG9rZW46UnozRWJodGs3b0Zoa1N4YVdlVmNxcmI2bmtiXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>使用scikit-learn库中linear_model模块的LinearRegression类可以建立 线性回归模型</p><p>下面是一个实例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入所需的库</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error, r2_score</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一些示例数据</span></span><br><span class="line"><span class="comment"># 假设我们有一组数据点，x是特征，y是目标变量</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">X = <span class="number">2</span> * np.random.rand(<span class="number">100</span>, <span class="number">1</span>)  <span class="comment"># 100个样本，1个特征</span></span><br><span class="line">y = <span class="number">4</span> + <span class="number">3</span> * X + np.random.randn(<span class="number">100</span>, <span class="number">1</span>)  <span class="comment"># y = 4 + 3x + 噪声</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化LinearRegression对象</span></span><br><span class="line">lr = LinearRegression()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">lr.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测测试集</span></span><br><span class="line">y_pred = lr.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评估模型</span></span><br><span class="line">mse = mean_squared_error(y_test, y_pred)</span><br><span class="line">r2 = r2_score(y_test, y_pred)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Mean squared error: <span class="subst">&#123;mse:<span class="number">.2</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Coefficient of determination (R^2): <span class="subst">&#123;r2:<span class="number">.2</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印模型参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Slope (weight): <span class="subst">&#123;lr.coef_&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Intercept: <span class="subst">&#123;lr.intercept_&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="逻辑回归模型"><a href="#逻辑回归模型" class="headerlink" title="逻辑回归模型"></a>逻辑回归模型</h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OGQ0YWJjNGU4ZTdlODg2NDk1ZWYzZmE2NTM4YWJhY2JfZHJwMGlLanRwaFFsVFFhcG1wRWdhYTE4UTlHaU9uRUxfVG9rZW46Q2l3SWIxQXltb3RBaDF4TWVyMmNpWFpDbmVoXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>使用scikit-learn库中linear_model模块的LogisticRegression类可以建立逻 辑回归模型</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入所需的库</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_classification</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score, confusion_matrix, classification_report</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一些示例二分类数据</span></span><br><span class="line">X, y = make_classification(n_samples=<span class="number">1000</span>, n_features=<span class="number">20</span>,</span><br><span class="line">                           n_informative=<span class="number">2</span>, n_redundant=<span class="number">10</span>,</span><br><span class="line">                           random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化LogisticRegression对象</span></span><br><span class="line"><span class="comment"># 默认情况下，solver=&#x27;lbfgs&#x27;，penalty=&#x27;l2&#x27;（正则化项）</span></span><br><span class="line">log_reg = LogisticRegression(max_iter=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">log_reg.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测测试集</span></span><br><span class="line">y_pred = log_reg.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评估模型</span></span><br><span class="line">accuracy = accuracy_score(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Accuracy: <span class="subst">&#123;accuracy:<span class="number">.2</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印混淆矩阵</span></span><br><span class="line">conf_matrix = confusion_matrix(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Confusion Matrix:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(conf_matrix)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印分类报告</span></span><br><span class="line">class_report = classification_report(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Classification Report:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(class_report)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印模型的权重和截距</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Model Coefficients:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(log_reg.coef_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Intercept: <span class="subst">&#123;log_reg.intercept_&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li><h2 id="模型评价"><a href="#模型评价" class="headerlink" title="模型评价"></a>模型评价</h2></li></ol><h3 id="分类模型评价"><a href="#分类模型评价" class="headerlink" title="分类模型评价"></a>分类模型评价</h3><p>对于分类模型的评价，常用的模型评价指标包括了准确率、精确率、反馈率、混淆矩阵和ROC曲线等</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MTJhYmNmNzdiMGJlZWFjOTAxYzI5YjBjNzI3MWQ4ODdfaUx6VDg3VW82N0hoMlk3d2VkYmR1ckF3R2l6MUJpSjVfVG9rZW46VVBucWJTZUlJb2VwRDl4N3hwNmNMTE1tbkRmXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MjY5NzkxMzRiNzAyNzk5ZDU4NDU2NTMzOWMyZjlkNThfT1RCcXlZZmFYa1JPNzhiN2w1bGd2c3JuWHFLSm9vS3lfVG9rZW46TGU5a2JkY0V5b3NJS2N4WnRaU2NlR01sblZnXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjI2NDE5NzhkMDljNTFjM2I5ZGEzYTljNTc4NjE5ZmJfOXU2ZjVNdVg2TGs0NWhiOE9MbjdzVVl3ancycFN3SGJfVG9rZW46Q3lzMWJSM3V2b29reHV4c0VpMWMyR1k2bjlnXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGJhMTU0NDY1ZGYxODJiZGM0NDFiM2JiMWMyMjk5MjdfSlJ1a3BBYWlDeld0dXhmWnlXYXlWQ29DWFp0NzA3ZThfVG9rZW46RzVkN2J3dGxyb2dtYU54ZWpaWGNjQmhybkJoXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>接收者操作特征曲线（Receiver Operating Characteristic curve，ROC曲 线）是一种非常有效的模型评价方法，可为选定临界值给出定量提示。</p><h3 id="回归模型评价"><a href="#回归模型评价" class="headerlink" title="回归模型评价"></a>回归模型评价</h3><p>对于回归模型，常用的模型评价指标包括了绝对误差 与相对误差、误差分析中的综合指标（平均绝对误差、 均方误差、均方根误差）、平均绝对百分误差和 Kappa统计量等</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NWY5MDRjMDM1OTkzNzI0MGViYzFlNDYwODgzNTk2YzdfYmNITFZBMG1jRXF0Q2ZEaVlla281Y3NyeTNCdmlGNXVfVG9rZW46SmFuaGJlWVl3b1p4bmZ4Tkg0OGNHYVJPbkxnXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MDQ3ODM0ZTUzY2JjYjRhMGQ1YzFhMDNiMjI4NDZmNTFfbnVPbHJpVnZ5TnRDeHJTTDN5WGhyd2ZMZmRQQXg0RW5fVG9rZW46RlZIc2JzSElXb3pwVGZ4d3RrV2NKMnZsbndxXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>Kappa统计是比较两个或多个观测者对同一事物，或观测者对同一事物的两次 或多次观测结果是否一致，将由随机造成的一致性和实际观测的一致性之间的 差别大小作为评价基础的统计指标。</p><ol><li><h2 id="决策树算法"><a href="#决策树算法" class="headerlink" title="决策树算法"></a>决策树算法</h2></li></ol><p>决策树是一树状结构，它的每一个叶节点对应着一个分类，非叶节点 对应着在某个属性上的划分，根据样本在该属性上的不同取值将其划 分成若干个子集。</p><h3 id="纯度的度量"><a href="#纯度的度量" class="headerlink" title="纯度的度量"></a>纯度的度量</h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NTU1OWUyOGQ1ZDFlOWM1YWE5OWNmYmQwZTNjYTEyNmJfVHpjTHRFc0ZCRGxWcjNKZ1lOMVJSQkNJejJrQ0pETjFfVG9rZW46RjZKemIyNkZxb1h6Z254SXVMRmNJbzR4bkdiXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>常用的决策树算法:</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmY3MjUwZWE3YWRhODRlNjI3NzNmYjYyZmZiNGE2MmRfbk94UGZ1Wm9UQUJUQWtmWVVIQjc1SGFOR0ZHd0xjVDRfVG9rZW46Uk41bWIySGpCb0ZVUGZ4SUZabGNmOGg0blFiXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NmYzMWJiYjhkN2E1NThmYzJlYWY0ODE5MmY2YjVkNGJfZW9Kb1RYREFxMGpDTGtnUldQYno1d2NGNXFOYzM3R2NfVG9rZW46THhWbWJmM0xDb1lISHB4cE5GSWNqbDZtbkdoXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>使用scikit-learn库中tree模块的DecisionTreeClassifier类可以建立决策树模 型</p><ol><li><h2 id="支持向量机算法"><a href="#支持向量机算法" class="headerlink" title="支持向量机算法"></a>支持向量机算法</h2></li></ol><p>支持向量机（Support Vector Machines，SVM）的思想是 在样本空间中找到一个划分超平面，将不同类别的样本分开。</p><p>在样本空间中，划分超平面可通过线性方程来描述</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YTQxMzkxMmE0MGFjMWRiMDg4N2Q2Y2Q2M2E3OWZiNWNfb0NMTTl1cDFSUHlLYWY4dEF6ZTBNM2tMNGpXNXc1ZzhfVG9rZW46VkFTcGI2Y1M2b3hOSlV4V2d6S2MyMkVvbm9oXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MWJmNDgyZjk2Y2ZhZjM2ZDMyNmJlM2RiNGVhMGQ1MWZfMVZGaG5QT3VVRDMzOURqWEZiWm5jc2FWQm9KYzB5Y3FfVG9rZW46RFJqWGJkdFNSb01SenB4VEFyR2N4S1FPbmhkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><h3 id="线性支持向量机"><a href="#线性支持向量机" class="headerlink" title="线性支持向量机"></a>线性支持向量机</h3><p>基本步骤</p><ul><li>将原问题转化为凸优化问题</li><li>通过构建拉格朗日函数，将原问题对偶化。</li><li>对对偶化后的问题进行求解。</li></ul><h3 id="非线性支持向量机"><a href="#非线性支持向量机" class="headerlink" title="非线性支持向量机"></a>非线性支持向量机</h3><p>将样本从原始空间映射到一个更高维的特征空间，使得样本在这个特征空间内线性可分</p><p>然而由于映射后的特征空间维数可能很高，直接计算通常是很困难的， 为了避开这个障碍，会利用已知的核函数直接进行计算：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZThjYTYzZjMwNGJkYzAyYjdjOTIzMGNhMmE5NjI3OWRfZUNEcFNCdjJCMk5VTlN3ZXh3Skx5NlZZVGIyajNOd0hfVG9rZW46SFkxeWI1UkZRbzFGZUh4R0VSMGNrUkVoblNjXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>使用scikit-learn库中svm模块的SVC类可以实现支持向量机算法对 数据进行分类</p><ol><li><h2 id="集成学习算法"><a href="#集成学习算法" class="headerlink" title="集成学习算法"></a>集成学习算法</h2></li></ol><p>集成学习算法通过组合多种学习算法来获得比任何单独的学习算法具 有更好的预测性能的估计器。对于训练集数据，我们通过训练若干个 个体学习器（individual learner），通过一定的结合策略，就可以最终 形成一个强学习器，以达到博采众长的目的</p><p>Bagging的个体弱学习器的训练集是通过随机采样得到的。通过T次的 随机采样，我们就可以得到T个采样集，对于这T个采样集，我们可以 分别独立的训练出T个弱学习器，再对这T个弱学习器通过集合策略来 得到最终的强学习器</p><h3 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h3><p>Bagging的个体弱学习器的训练集是通过随机采样得到的。通过T次的 随机采样，我们就可以得到T个采样集，对于这T个采样集，我们可以 分别独立的训练出T个弱学习器，再对这T个弱学习器通过集合策略来 得到最终的强学习器</p><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><p>随机森林（Random Forest，RF）是Bagging的一个拓展，RF在以决策树 为基分类器构建Bagging学习器的基础上，进一步在决策树的训练过程 中引入了随机属性选择</p><h3 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h3><p>Boosting（提升）是一个可将弱学习器提升为强学习器的算法。这个 算法的工作机制为：赋予一个相等的初始权重给每个训练样本；迭代 地学习k个分类器，学习得到弱学习器1之后，更新权重，使得后面的 分类器更关注误分类的训练样本；最后的分类器组合每个个体分类器 的表决结果</p><p>使用scikit-learn库中ensemble模块的GradientBoostingClassifier类可以建 立梯度提升决策树模型</p><h3 id="梯度提升机"><a href="#梯度提升机" class="headerlink" title="梯度提升机"></a>梯度提升机</h3><p>梯度提升机（Gradient Boosting Machine，GBM）是一种Boosting的方法，其提高 模型精度的方法与传统Boosting对正确、错误样本进行加权不同，该模型通过在残差减 少的梯度（Gradient）方向上建立一个新的模型，从而降低新模型的残差（Residual）。 即每个新模型的建立是为了使得之前模型的残差往梯度方向减少</p><h3 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h3><p>Stacking集成学习方法是指训练一个模型用于组合其他各个模型。首先 我们先训练多个不同的模型（初级学习器），然后把之前训练的各个 模型的输出为输入来训练一个模型（次级学习器），以得到一个最终 的输出</p><p>使用scikit-learn库中ensemble模块的StackingClassifier类可以建立 Stacking分类模型</p><ol><li><h2 id="丹参生长影响指标筛选"><a href="#丹参生长影响指标筛选" class="headerlink" title="丹参生长影响指标筛选"></a>丹参生长影响指标筛选</h2></li></ol><p>看不懂</p><ol><li><h2 id="肺癌转移影响因素及生存分析"><a href="#肺癌转移影响因素及生存分析" class="headerlink" title="肺癌转移影响因素及生存分析"></a>肺癌转移影响因素及生存分析</h2></li></ol><p>看不懂</p><ol><li><h2 id="第五章相关试题"><a href="#第五章相关试题" class="headerlink" title="第五章相关试题"></a>第五章相关试题</h2></li><li><p>下列问题,属于回归的是()</p></li></ol><p>A通过症状判别证型</p><p>B胃癌术后五年期生存率分析</p><p>C根据影像对病程分期</p><p>D根据患者证症推荐医生</p><p>我觉得这个答案应该是B，但是老师给的答案是C</p><ol><li>下列说法错误的是()。</li></ol><p>A支撑向量机可以用来进行拟合函数。</p><p>B支撑向量机可以用于多分类问题。</p><p>C支撑向量机需要大量训练样本。</p><p>D支撑向量机通过核函数将数据映射到高维空间,从而能够解决非线性问题。</p><ol><li>患者试纸检测结果是阳性,实际真实值是阴性,则试纸结果是()</li></ol><p>A TP</p><p>B TN</p><p>C FP</p><p>D FN</p><ul><li>TP (True Positive)：真正例，即检测结果为阳性且实际也是阳性。</li><li>TN (True Negative)：真负例，即检测结果为阴性且实际也是阴性。</li><li>FP (False Positive)：假正例，即检测结果为阳性但实际是阴性。</li><li>FN (False Negative)：假负例，即检测结果为阴性但实际是阳性。</li></ul><ol><li>在医学疾病筛查中,希望尽量小的是()</li></ol><p>A Recall</p><p>B Precision</p><p>C Accuracy</p><p>D 漏检率</p><ol><li>当Kappa(),说明已经取得相当满意的一致程度。</li></ol><p>A在区间[-1,1]内</p><p>B大于等于0.75时</p><p>CKappa&#x3D;1</p><p>DKappa&lt;0.4</p><ol><li>下面是SVM算法中需要指定的超参数 () 。</li></ol><p>A C</p><p>B alpha</p><p>C bias</p><p>D omiga</p><ol><li>ROC曲线下方的面积就是()</li></ol><p>A LOT</p><p>B TPR</p><p>C FPR</p><p>D AUC</p><ol><li>（）算法只适用于离散的描述属性。</li></ol><p>A ID3</p><p>B C4.5</p><p>C CART决策树</p><p>D SLIQ</p><ol><li>常见的非线性映射核有()</li></ol><p>ARBF核</p><p>B多项式核</p><p>Csigmoid核</p><p>D拉普拉斯核</p><p>ESobel核</p><ol><li>集成学习有如下几种方式()</li></ol><p>ABagging</p><p>BBoosting</p><p>CAdaboost</p><p>DStacking</p><p>EID3</p><ol><li>K近邻(K-Nearest Neighbor,KNN)算法是一种常用的监督学习方法。√</li><li>最近邻算法是K近邻算法的一个特例。√</li><li>决策树算法通常按照纯度的增加来选择拆分属性√</li><li>C4.5决策树生成算法相对于ID3算法的重要改进是使用信息增益率来选择节点属性。√</li><li>为了评价回归模型,一般让模型预测单个点的值进行评价以免受到噪声影响而不准×</li><li>当Kappa&gt;0时,说明有意义,Kappa愈大,说明一致性愈好。√</li><li>Bagging算法中个体学习器间存在强依赖关系。×</li><li>Bagging的个体弱学习器的训练集是通过随机采样得到的。√</li><li>随机森林RF算法是Stacking的一个拓展×</li><li>均方误差开根号后就变成均方根误差√</li></ol><h1 id="第六章-聚类算法"><a href="#第六章-聚类算法" class="headerlink" title="第六章: 聚类算法"></a>第六章: 聚类算法</h1><ol><li><h2 id="聚类算法概述"><a href="#聚类算法概述" class="headerlink" title="聚类算法概述"></a>聚类算法概述</h2></li></ol><p>与分类不同，聚类分析是在没有给定划分类别的情况下，根据数据相似度进行样本分组 的一种方法。聚类的输入是一组未被标记的样本，聚类根据数据自身的距离或相似度将他们 划分为若干组，划分的原则是组内样本最小化而组间（外部）距离最大化。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NDRkYzJjMTYzMGIxNDhlMDY2NjZiMzI2MDg4N2RjMmFfTjVBbnF3Nzk1c3Y5MjVWNzAzejU5WDF6MjdoRUNTMFBfVG9rZW46UVN4WWJTVFZqb0I0cWd4M1VidWNBNDdkbnNlXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><h3 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h3><p>常见距离度量有：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NjI5YTlhOGQ0MDExZjAwNmJjNDIzZTU1NjA0MDhhMGVfUVQ3bkQySlVMTkxiZ2s1Rkx5RDZoaXhibk9uaVp6YktfVG9rZW46VFZ0NWJlUXNib2xKTUd4RGVrSGNuOHRYbjk0XzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><h3 id="聚类算法评价指标"><a href="#聚类算法评价指标" class="headerlink" title="聚类算法评价指标"></a>聚类算法评价指标</h3><p>聚类分析仅根据样本数据本身将样本分组，组内的对象相互之间是相似的（相关的），而 不同组中的对象是不同的（不相关的）。组内的相似性越大，组间差别越大，聚类效果就越好。</p><p>常见评价法有：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2U2ZjFjZThjNmFjNjNhOWYxODg3OGVmMGVjNjhjMmZfcVJrNGhLaVN3RTQxQ0l6ZExoMUlxcm9mcXJYelRHVFpfVG9rZW46U0NKRGI2OHhBb0lrTEJ4eXpHRmNUcUk1bnFkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li><h2 id="基于划分的聚类算法"><a href="#基于划分的聚类算法" class="headerlink" title="基于划分的聚类算法"></a>基于划分的聚类算法</h2></li></ol><h3 id="K-Means聚类"><a href="#K-Means聚类" class="headerlink" title="K-Means聚类"></a>K-Means聚类</h3><p>K-Means算法是典型的基于距离的非层次聚类算法，在最小化误差函数的基础上将数据划分 为预定的类数K，采用距离作为相似性的衡量指标，即认为两个对象的距离越近，相似度就越大。</p><p>1.相似度度量</p><p>2.算法过程</p><p>K均值算法的具体步骤如下： </p><p>（1）从N个样本数据中随机选取K个对象作为初始的聚类中心。</p><p>（2）分别计算每个样本到各个聚类中心的距离，将对象分配到距离最近的聚类中。 </p><p>（3）所有对象分配完成后，重新计算K个聚类的中心。 </p><p>（4）与前一次计算得到的K个聚类中心比较，如果聚类中心发生变化，转步骤（2），否则转步骤 （5）</p><p>（5）当质心不发生变化时停止并输出聚类结果</p><p>3.目标函数</p><p>使用误差平方和准则（Sum Squared Error，SSE）作为度量聚类质量的目标函数， 对于两种不同的聚类结果，选择误差平方和较小的分类结果</p><p>4.具体实现</p><p>使用scikit-learn库中cluster模块的KMeans类可以实现K-Means聚类算法对数据进行聚类</p><h3 id="二分K均值聚类"><a href="#二分K均值聚类" class="headerlink" title="二分K均值聚类"></a>二分K均值聚类</h3><ul><li>使用小批量的样本而不是整个数据集对群集质心进行更新</li><li>通过 MiniBatchKMeans 类实现的 </li><li>优化的主配置是“ n _ clusters ”超参数，设置为数据中估计的群集数量</li></ul><h3 id="K中心点算法"><a href="#K中心点算法" class="headerlink" title="K中心点算法"></a>K中心点算法</h3><ul><li>为每个簇随意选择一个代表对象</li><li>剩余对象根据其与代表对象的距离分配给最近的一个簇 </li><li>反复用非代表对象来代替代表对象，改进聚类质量</li></ul><ol><li><h2 id="信用卡风险识别模型"><a href="#信用卡风险识别模型" class="headerlink" title="信用卡风险识别模型"></a>信用卡风险识别模型</h2></li></ol><p>看不懂</p><ol><li><h2 id="基于层次的聚类算法"><a href="#基于层次的聚类算法" class="headerlink" title="基于层次的聚类算法"></a>基于层次的聚类算法</h2></li></ol><h3 id="层次聚类"><a href="#层次聚类" class="headerlink" title="层次聚类"></a>层次聚类</h3><p>试图在不同层次上对样本集进行划分 进而达到形成树形的聚类结构</p><p>在运用层次聚类法时，需要对类与类之间的距离做出规定，按照规定的不同，形成了基于 最短距离、最长距离和平均距离的层次聚类法</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MTVkNWE0YmUxN2Y5YjEyZTU3MWMyMDk4YjEzNTUzMmFfVHhMMXVhVkdSakU5NU1HaVJ5ajNDY3hCNU5qWWFWakJfVG9rZW46TXhFUmJVdDJSb2xubFB4MnU1S2NPNlIybmpiXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>聚集系统法具体步骤</p><p>（1） 输入样本集合、对聚类簇函数做出规定给出聚类的簇数。 </p><p>（2） 将每个样本点作为单独的一簇。 </p><p>（3） 计算任何两个簇之间的距离。</p><p>（4） 按照距离最近原则合并簇。 </p><p>（5） 若当前聚类簇数未到达规定的聚类簇数，则返回步骤（3） 否则聚类结束。 </p><p>（6） 输出聚类结果。</p><p>使用scikit-learn库中cluster模块的AgglomerativeClustering类可以实现层次聚类算法对数 据进行聚类</p><h3 id="BIRCH算法"><a href="#BIRCH算法" class="headerlink" title="BIRCH算法"></a>BIRCH算法</h3><p>阶段一：扫描数据库，构造一棵能够存放 于内存中的CF树。</p><p>阶段二：选用一个聚类算法对CF树的叶 节点聚类，把稀疏的簇当做离群点删除， 把稠密的簇合并为更大的簇</p><p>CF</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjJkMTg0MWI2MjQ5YTEzNmMwY2NjMDhkMjMzODBjYjJfMGJTZlVoZ3hxbjY3SEhVYzhMNUZGeTdLNDZkYjFrc0ZfVG9rZW46Q1k0a2I3aHY5b2FvQ0h4cnpNUGNxUldlblplXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ul><li>从根节点root 开始递归往下，计算当前条目与要插入数据点之间 的距离，寻找距 离最小的那个路径，直到找到与该数据点最接近 的叶节点中的条目。</li><li>比较计算出的距离是否小于阈值T，如果小于则当前条目吸收该数 据点；反之，则 继续第三步。 </li><li>判断当前条目所在叶节点的条目个数是否小于L，如果是，则直接 将数据点插入作 为该数据点的新条目，否则需要分裂该叶节点。</li></ul><ol><li><h2 id="道地药材文本数据挖掘"><a href="#道地药材文本数据挖掘" class="headerlink" title="道地药材文本数据挖掘"></a>道地药材文本数据挖掘</h2></li></ol><p>看不懂</p><ol><li><h2 id="基于密度的聚类算法"><a href="#基于密度的聚类算法" class="headerlink" title="基于密度的聚类算法"></a>基于密度的聚类算法</h2></li></ol><p>密度聚类</p><p>以样本点在空间分布上的稠密程度为依据进 行聚类 p若区域中的样本密度大于某个阈值，则将相 应的样本点划入与之相近的簇中</p><h3 id="DBSCAN算法"><a href="#DBSCAN算法" class="headerlink" title="DBSCAN算法"></a>DBSCAN算法</h3><p>（1） 输入样本集合、初始化距离参数 ，数目参数 。 </p><p>（2） 确定核心对象集合。 </p><p>（3） 在核心对象集合中，随机选择一个核心对象作为种子。 </p><p>（4） 依据簇划分原则生成一个簇，并更新核心对象集合。 </p><p>（5） 若核心对象集合为空，则算法结束，否则返回步骤（3）。</p><p>（6） 输出聚类结果</p><p>使用scikit-learn库中cluster模块的DBSCAN类可以实现密度聚类算法对数据进行聚类</p><h3 id="OPTICS算法"><a href="#OPTICS算法" class="headerlink" title="OPTICS算法"></a>OPTICS算法</h3><ul><li>为聚类分析生成一个增广的簇排序 </li><li>排序代表了各样本点基于密度的聚类结构</li></ul><p>对象p的核心距离是 指是p成为核心对象 的最小E’ 。如果p不 是核心对象，那么p 的核心距离没有任何 意义。</p><p>对象q到对象p的可达距离是 指p的核心距离和p与q之间 欧几里得距离之间的较大值。 如果p不是核心对象，p和q 之间的可达距离没有意义</p><p>基本过程:</p><p>（1） 创建两个队列，有序队列和结果队列。</p><p>（2） 如果所有样本集D中所有点都处理完毕，则算法结束。否则，选择一个未处理（即不在结果队列中）且为核心对象的样本点，找到其所 有直接密度可达样本点，如果该样本点不存在于结果队列中，则将其放 入有序队列中，并按可达距离排序； </p><p>（3）如果有序队列为空，则跳至步骤2，否则，从有序队列中取出第一 个样本点（即可达距离最小的样本点）进行拓展，并将取出的样本点保 存至结果队列中，如果它不存在结果队列当中的话。</p><p>（4）算法结束，输出结果队列中的有序样本点。</p><ol><li><h2 id="第六章相关试题"><a href="#第六章相关试题" class="headerlink" title="第六章相关试题"></a>第六章相关试题</h2></li><li><p>当不知道数据所带标签时,可以使用哪种技术促使带同类标签的数据与带其他标签的数据相分离?()</p></li></ol><p>A分类</p><p>B聚类</p><p>C关联分析</p><p>D回归</p><ol><li>通过聚集多个分类器的预测来提高分类准确率的技术称为 ()</li></ol><p>A组合(ensemble)</p><p>B聚集(aggregate)</p><p>C合并(combination)</p><p>D投票(voting)</p><ol><li>简单地将数据对象集划分成不重叠的子集,使得每个数据对象恰在一个子集中,这种聚类类型称作()</li></ol><p>A层次聚类</p><p>B划分聚类</p><p>C非互斥聚类</p><p>D模糊聚类</p><ol><li>在基本K均值算法里,当邻近度函数采用()的时候,合适的质心是簇中各点的中位数.</li></ol><p>A曼哈顿距离</p><p>B平方欧几里德距离</p><p>C余弦距离</p><p>D切比雪夫距离</p><ol><li>DBSCAN是一种()。</li></ol><p>A分类器</p><p>B聚类算法</p><p>C关联分析算法</p><p>D特征选择算法</p><ol><li>将两个簇的邻近度定义为不同簇的所有点对的平均逐对邻近度,它是一种凝聚层次聚类技术。</li></ol><p>AMIN(单链)</p><p>BMAX(全链)</p><p>C组平均</p><p>DWard方法</p><ol><li>将两个簇的邻近度定义为两个簇合并时导致的平方误差的增量,它是一种凝聚层次聚类技术。</li></ol><p>AMIN(单链)</p><p>BMAX(全链)</p><p>C组平均</p><p>DWard方法</p><ol><li>关于K均值和DBSCAN的比较,以下说法不正确的是()。</li></ol><p>AK均值丢弃被它识别为噪声的对象,而DBSCAN一般聚类所有对象</p><p>BK均值使用簇的基于原型的概念,而DBSCAN使用基于密度的概念。</p><p>CK均值很难处理非球形的簇和不同大小的簇,DBSCAN可以处理不同大小和不同形状的簇</p><p>DK均值可以发现不是明显分离的簇,即便簇有重叠也可以发现,但是DBSCAN会合并有重叠的簇。</p><ol><li>以下属于聚类算法的是()。</li></ol><p>AK—Means</p><p>BDBSCAN</p><p>CApriori</p><p>DKNN</p><p>EBayes</p><ol><li>都属于簇有效性的监督度量。</li></ol><p>A轮廓系数</p><p>B共性分类相关系数</p><p>C熵</p><p>DF度量</p><p>E余弦距离</p><ol><li>聚类是指将物理或抽象对象的集合分组成为由类似的对象组成的多个类的过程√</li><li>用于分类的离散化方法之间的根本区别在于是否使用类信息。√</li><li>简单地将数据对象集划分成不重叠的子集,使得每个数据对象恰在一个子集中,这种聚类类型称作划分聚类。√</li><li>在基本K均值算法里,当邻近度函数采用曼哈顿距离的时候,合适的质心是簇中各点的中位数。√</li><li>聚类是这样的过程:它找出描述并区分数据类或概念的模型(或函数),以便能够使用模型预测类标记未知的对象类。×</li><li>在聚类分析当中,簇内的相似性越大,簇间的差别越大,聚类的效果就越差。×</li><li>聚类分析可以看作是一种非监督的分类。√</li><li>K均值是一种产生划分聚类的基于密度的聚类算法,簇的个数由算法自动地确定×</li><li>基于邻近度的离群点检测方法不能处理具有不同密度区域的数据集。√</li><li>如果一个对象不强属于任何簇,那么该对象是基于聚类的离群点。√</li></ol><h1 id="第七章：算法应用，看一遍即可，重点记住题"><a href="#第七章：算法应用，看一遍即可，重点记住题" class="headerlink" title="第七章：算法应用，看一遍即可，重点记住题"></a>第七章：算法应用，看一遍即可，重点记住题</h1><h2 id="第七章相关试题"><a href="#第七章相关试题" class="headerlink" title="第七章相关试题"></a>第七章相关试题</h2><ol><li>关于随机抽样,下列说法正确的是()。</li></ol><p>A抽样时应使得总体中的每一个个体都有同等机会被抽取</p><p>B研究者在抽样时应精心挑选个体,以使样本更能代表总体</p><p>C随机抽样即随意抽取个体</p><p>D为确保样本具有更好的代表性,样本量越大越好</p><ol><li>报上登出了国内20家大医院的名单,名单按他们在近三年中病人死亡率的高低排序。专家指出不能把名单排列的顺序作为评价医院医疗水平的标准。以下各项,如果是真的,都能做论据支持专家的结论,除了哪一项()。</li></ol><p>A这20家医院中,有5家医院依靠国家资助从国外引进了多项先进、大型和配套的医疗设备,其余15家都没有。</p><p>B有些医院,留病人住院的时间长,病人死亡率因此较高;有些医院,往往较早地动员患绝症而救治无望的病人出院,病人死亡率因此较低。</p><p>C这20家医院中,有2家老人医院和3家儿童医院。</p><p>D20家医院中,有2家是肿瘤医院。</p><ol><li>下列哪项检验不适用χ2检验()。</li></ol><p>A两样本均值比较</p><p>B两样本率比较</p><p>C构成比比较</p><p>D拟合优度检验</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A. 两样本均值比较 - 这通常使用t检验或ANOVA（方差分析）来完成，而不是χ<span class="number">2</span>检验。</span><br><span class="line">B. 两样本率比较 - 可以使用χ<span class="number">2</span>检验来分析两个独立样本的分类变量频率是否相同。</span><br><span class="line">C. 构成比比较 - 这通常指的是比较不同类别的构成比例，χ<span class="number">2</span>检验可以用于此目的。</span><br><span class="line">D. 拟合优度检验 - 这是检验实际观测值与理论值是否一致的检验，χ<span class="number">2</span>检验是常用的方法之一。</span><br></pre></td></tr></table></figure><ol><li>为研究矽肺患者肺功能的变化情况,某医院对I、II期肺硅沉着病患者各35名测定其肺活量,得到I期患者的均值2700ml,标准差137ml;II期患者均值2800ml,标准差125ml,欲求I、II期肺硅沉着病患者的肺活量是否有显著性差异,宜采用什么统计方法()。</li></ol><p>Aχ2检验</p><p>Bt检验</p><p>Clogit回归</p><p>D秩和检验</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A. χ<span class="number">2</span>检验 - 适用于分类数据的关联性检验，不适用于比较两个独立样本的均值。</span><br><span class="line">B. t检验 - 适用于比较两个独立样本的均值，特别是当样本量较小（通常小于<span class="number">30</span>）且数据近似正态分布时。由于这里每组样本量为<span class="number">35</span>，且没有提到数据分布，如果数据近似正态分布，t检验是合适的。</span><br><span class="line">C. logit回归 - 用于二分类结果变量的回归分析，不适用于比较两个独立样本的均值。</span><br><span class="line">D. 秩和检验 - 又称为Mann-Whitney U检验，适用于两个独立样本的非参数比较，当数据不满足正态分布或方差不齐时使用。</span><br></pre></td></tr></table></figure><ol><li>下表为某项指标频数分布表，描述其集中趋势宜采用什么指标（）。</li></ol><table><thead><tr><th>组段</th><th>频数</th><th>频率</th><th>百分比（%）</th></tr></thead><tbody><tr><td>10~</td><td>35</td><td>0.35</td><td>35</td></tr><tr><td>20~</td><td>45</td><td>0.45</td><td>45</td></tr><tr><td>30~</td><td>15</td><td>0.15</td><td>15</td></tr><tr><td>40~</td><td>4</td><td>0.04</td><td>4</td></tr><tr><td>50~60</td><td>1</td><td>0.01</td><td>1</td></tr><tr><td>合计</td><td>100</td><td>1</td><td>100</td></tr></tbody></table><p>A算数均数</p><p>B几何均数</p><p>C中位数</p><p>D百分位数</p><ol><li>某医生研究复方哌唑嗪对高血压的治疗效果，以复方降压片为对照，结果如下表，问两种药物效果有无显著性差别，宜采用何种统计方法（）。</li></ol><table><thead><tr><th></th><th>治疗例数</th><th>有效例数</th><th>有效率（%）</th></tr></thead><tbody><tr><td>复方哌唑嗪</td><td>40</td><td>35</td><td>87.5</td></tr><tr><td>复方降压片</td><td>30</td><td>20</td><td>66.67</td></tr></tbody></table><p>Aχ2检验</p><p>Bt检验</p><p>C方差分析</p><p>D秩和检验</p><ol><li>某地区某病患病率20%,随机从该地抽出50人,则患病人数的数学期望和方差分别为多少()。</li></ol><p>A25和8</p><p>B10和2.8</p><p>C25和64</p><p>D10和8</p><ol><li>已知σ2时,区间（）的含义是()。</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YWFjMWFmYzgyMzk4YTRiMDM3MjMxN2I3OGVlMmZiZGFfa1d3SExCT3FiNktrOUttN3BFZXc2R2RsTGxINGlYYmlfVG9rZW46TkFYbmJiRldkb0pxZ0h4UE94UmNORWdubnhkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>A95%的总体均值在此范围内</p><p>B样本均值的95%置信区间</p><p>C95%的样本均值在此范围内</p><p>D总体均值的95%置信区间</p><ol><li>下列选项中,哪几项是实验设计的基本原则()。</li></ol><p>A盲法的原则</p><p>B对照的原则</p><p>C重复的原则</p><p>D随机化的原则</p><p>E多中心的原则</p><ol><li>下列有关直线回归的论述中,正确的是()。</li></ol><p>A满足所有点距离直线垂直距离平方和最小</p><p>B满足残差平方和最小</p><p>C拟合方法为最小二乘法</p><p>D满足所有点距离直线竖直距离平方和最小</p><p>E满足所有点距离直线的绝对值距离最小</p><ol><li>LSTM网络在分类上属于深度学习方法。√</li><li>OR值、RR值属于病因学指标。√</li><li>样条方法属于非线性方法。√</li><li>机器学习方法在分类上属于深度学习的一种。×</li><li>线性回归分析中,决定系数R2是衡量拟合效果优劣的一个指标。√</li><li>线性回归系数与pearson相关系数在假设检验上是等效的。√</li><li>同一个资料,计算相关系数与回归系数,两个系数的正负号是相反的。×</li><li>在做回归分析时,需要先做散点图查看分布和趋势。√</li><li>回归分析要求样本满足残差独立性√</li><li>深度学习方法可以用于回归也可以用于分类。√</li></ol><h1 id="期末考试题"><a href="#期末考试题" class="headerlink" title="期末考试题:"></a>期末考试题:</h1><ol><li>单选题(2分)</li></ol><p>（）作为知识发现的核心部分，指的是从数据集合中自动抽取隐藏在数据中的那些有价值的信息的过程</p><p>A数据挖掘</p><p>B人工智能</p><p>C机器学习</p><p>D模式识别</p><p><strong>正确答案： A</strong></p><ol><li>单选题(2分)</li></ol><p>（）是指在大量的数据中发现特征之间或数据之间的相互依赖关系。</p><p>A分类</p><p>B回归</p><p>C关联规则</p><p>D聚类</p><p><strong>正确答案： C</strong></p><ol><li>单选题 (2分)</li></ol><p>在受试人群中，根据人群的某些体征比如面色红润，口苦，疲乏，舌苔黄腻，畏寒怕冷等特征将这些人的体质分为平和体质，湿热体质，阳虚体质等等。属于数据挖掘的哪一类任务（）</p><p>A分类</p><p>B回归</p><p>C关联规则</p><p>D聚类</p><p><strong>正确答案： D</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这里的关键区别在于是否有预先定义的标签：</span><br><span class="line">如果我们已经有了体质类型的标签，并且我们的目标是训练一个模型，以便能够根据新的体征特征预测体质类型，那么这是一个分类问题。</span><br><span class="line">如果我们没有标签，而是希望算法根据体征特征自动将人群分组，那么这是一个聚类问题。</span><br></pre></td></tr></table></figure><ol><li>单选题 (2分)</li></ol><p>（ ）用于联系用户和信息，并利用信息分类用户的兴趣偏好，为用户推荐感兴趣的内容</p><p>A聚类</p><p>B智能推荐</p><p>C时间序列分析</p><p>D回归</p><p><strong>正确答案： B</strong></p><ol><li>单选题 (2分)</li></ol><p>下列数据属于序数属性的是（）。</p><p>A红细胞计数</p><p>B门诊就诊人数</p><p>C患者的病情分级</p><p>D住院患者费用支付方式</p><p><strong>正确答案： C</strong></p><ol><li>单选题 (2分)</li></ol><p>某年某地六岁女孩成长发育情况如下：身高均数为119cm，标准差为4.56cm，体重均数为20kg，标准差为1.16kg，欲比较两者的变异程度，应选用的指标是（）。</p><p>A算数平均数</p><p>B标准差</p><p>C离散系数</p><p>D极差</p><p>本题得分： 2分</p><p><strong>正确答案： C</strong></p><ol><li>单选题 (2分)</li></ol><p>算术平均值与中位数相比，其特点是（）。</p><p>A不易受极端值的影响</p><p>B能充分利用数据的信息</p><p>C更适用于开口数据（无确切端点值）资料</p><p>D更适用于分布不明确资料</p><p>本题得分： 2分</p><p><strong>正确答案： B</strong></p><ol><li>单选题 (2分)</li></ol><p>对3×2表资料做卡方检验，其自由度为（B）。</p><p>A1</p><p>B2</p><p>C3</p><p>D4</p><p><strong>正确答案： B</strong></p><ol><li>单选题 (2分)</li></ol><p>Mapreduce适用于 （）。</p><p>A任意应用程序</p><p>B任意可在windows servet2008上运行的程序</p><p>C可以串行处理的应用程序</p><p>D可以并行处理的应用程序</p><p><strong>正确答案： D</strong></p><ol><li>单选题 (2分)</li></ol><p>将原始数据进行集成、变换、维度规约、数值规约是在以下哪个步骤的任务？( )</p><p>A 频繁模式挖掘</p><p>B分类和预测</p><p>C数据预处理</p><p>D数据流挖掘</p><p><strong>正确答案： C</strong></p><ol><li>单选题 (2分)</li></ol><p>下面哪种不属于数据预处理的方法？ （）</p><p>A变量代换</p><p>B离散化</p><p>C聚集</p><p>D估计遗漏值</p><p><strong>正确答案： D</strong></p><ol><li>单选题 (2分)</li></ol><p>假设12个销售价格记录组已经排序如下:5, 10， 11， 13, 15， 35, 50, 55， 72， 92， 204, 215 使用如下每种方法将它们划分成四个箱。等频(等深)划分时,15在第几个箱子内？ ( ）</p><p>A第一个</p><p>B第二个</p><p>C第三个</p><p>D第四个</p><p><strong>正确答案： B</strong></p><ol><li>单选题 (2分)</li></ol><p>发现关联规则的算法通常要经过以下三个步骤：连接数据，作数据准备；给定最小支持度和（ ）,利用数据挖掘工具提供的算法发现关联规则；可视化显示、理解、评估关联规则。</p><p>A最小兴趣度</p><p>B最小置信度</p><p>C最大支持度</p><p>D最小可信度</p><p><strong>正确答案： B</strong></p><ol><li>单选题 (2分)</li></ol><p>规则I-〉j，“有可能”，等于所有包含I的购物篮中同时包含J的购物篮的比例,为（ ）。</p><p>A置信度</p><p>B可信度</p><p>C兴趣度</p><p>D支持度</p><p><strong>正确答案： A</strong></p><ol><li>单选题 (2分)</li></ol><p>考虑下面的频繁3—项集的集合：｛1，2,3｝,{1，2,4｝，{1，2，5｝，｛1,3，4｝,｛1，3,5},｛2,3,4},｛2,3,5｝，{3，4,5}假定数据集中只有5个项，采用合并策略,由候选产生过程得到4-项集不包含(）。</p><p>A1,2，3，4</p><p>B1,2，3，5</p><p>C1,2，4，5</p><p>D1,3，4，5</p><p><strong>正确答案： C</strong></p><ol><li>单选题 (2分)</li></ol><p>在图集合中发现一组公共子结构，这样的任务称为 ( )。</p><p>A频繁子集挖掘</p><p>B频繁子图挖掘</p><p>C频繁数据项挖掘</p><p>D频繁模式挖掘</p><p><strong>正确答案： B</strong></p><ol><li>单选题 (2分)</li></ol><p>关于聚类的目标，下面说法不正确的是（）。</p><p>A使聚类内部对象之间的距离尽可能小</p><p>B使它们之间具有很低的相似度</p><p>C常见的距离度量有：幂距离</p><p>D距离或相似性度量对于聚类算法是非常重要的</p><p><strong>正确答案： B</strong></p><ol><li>单选题 (2分)</li></ol><p>假设在城市中，要从一个十字路口到另一个十字路口，驾驶距离显然不是两点间的直线距离，实际驾驶距离就是 ( ）。</p><p>A幂距离</p><p>B切比雪夫距离</p><p>C欧式距离</p><p>D曼哈顿距离</p><p><strong>正确答案： D</strong></p><ol><li>单选题 (2分)</li></ol><p>余弦相似度更加关注两个向量在（）上的差异</p><p>A大小</p><p>B方向</p><p>C密度</p><p>D距离</p><p><strong>正确答案： B</strong></p><ol><li>单选题 (2分)</li></ol><p>刻画k均值聚类的特点，采用的是哪一类准则函数来作为聚类的准则函数。（ ）</p><p>A均值</p><p>B误差平方和准则（Sum Squared Error，SSE）</p><p>C方差</p><p>D标准差</p><p><strong>正确答案： B</strong></p><ol><li>单选题 (2分)</li></ol><p>当Kappa（ ），说明已经取得相当满意的一致程度。</p><p>A在区间[-1,1]内</p><p>B大于等于0.75时</p><p>CKappa&#x3D;1</p><p>DKappa&lt;0.4</p><p><strong>正确答案： B</strong></p><ol><li>单选题 (2分)</li></ol><p>下面是SVM算法中需要指定的超参数 （）。</p><p>AC</p><p>Balpha</p><p>Cbias</p><p>Domiga</p><p><strong>正确答案： A</strong></p><ol><li>单选题 (2分)</li></ol><p>ROC曲线下方的面积就是（ ）。</p><p>ALOT</p><p>BTPR</p><p>CFPR</p><p>DAUC</p><p><strong>正确答案： D</strong></p><ol><li>单选题 (2分)</li></ol><p>（）算法只适用于离散的描述属性。</p><p>AID3</p><p>BC4.5</p><p>CCART决策树</p><p>DSLIQ</p><p><strong>正确答案： A</strong></p><ol><li>多选题 (4分)</li></ol><p>集成学习有如下几种方式（）。</p><p>ABagging</p><p>BBoosting</p><p>CAdaboost</p><p>DStacking</p><p>EID3</p><p><strong>正确答案： A,B,D (少选不得分)</strong></p><ol><li>多选题 (4分)</li></ol><p>数据挖掘的主要功能包括概念描述、趋势分析、孤立点分析及（ ）等方面。</p><p>A挖掘频繁模式</p><p>B分类和预测</p><p>C聚类分析</p><p>D偏差分析</p><p>E抽样</p><p><strong>正确答案： A,B,C,D (少选不得分)</strong></p><ol><li>多选题 (4分)</li></ol><p>下列属于定量属性的是（）</p><p>A区间标度属性</p><p>B比率标度属性</p><p>C二元属性</p><p>D多元属性</p><p>E序数属性</p><p><strong>正确答案： A,B (少选不得分)</strong></p><ol><li>多选题 (4分)</li></ol><p>数据预处理方法主要有（ ）。</p><p>A数据清洗</p><p>B数据集成</p><p>C数据变换</p><p>D数据归约</p><p>E数据分析</p><p><strong>正确答案： A,B,C,D (少选不得分)</strong></p><ol><li>多选题 (4分)</li></ol><p>下表是一个购物篮，假定支持度阈值为40％，其中( )是频繁闭项集。</p><table><thead><tr><th>ID</th><th>项集</th></tr></thead><tbody><tr><td>1</td><td>面包、牛奶、尿布</td></tr><tr><td>2</td><td>面包、牛奶、尿布、啤酒</td></tr><tr><td>3</td><td>牛奶、尿布、鸡蛋</td></tr><tr><td>4</td><td>面包、尿布、啤酒、鸡蛋</td></tr><tr><td>5</td><td>啤酒、鸡蛋</td></tr></tbody></table><p>A面包、牛奶、尿布</p><p>B面包、啤酒</p><p>C尿布、啤酒</p><p>D啤酒、鸡蛋</p><p>E面包、尿布、啤酒、鸡蛋</p><p><strong>正确答案： A,D (少选不得分)</strong></p><ol><li>多选题 (4分)</li></ol><p>K-平均算法的聚类过程为()。</p><p>A任意选择k个对象作为初始的簇中心</p><p>B计算其它对象与这k个中心的距离，然后把每个对象归入离它“最近”的簇</p><p>C计算各簇中对象的平均值，然后重新选择簇中心(离平均值“最近”的对象值</p><p>D重复第2第3步直到簇中心不再变化为止</p><p><strong>正确答案： A,B,C,D (少选不得分)</strong></p><ol><li>判断题</li></ol><p>数据探索主要包括：集中趋势、离散趋势、异常值分析、缺失值分析、相关分析、周期性分析等。（）</p><p><strong>正确答案： 正确</strong></p><ol><li>判断题</li></ol><p>抽取数据的标准有，相关性，可靠性，有效性。（）</p><p><strong>正确答案： 正确</strong></p><ol><li>判断题</li></ol><p>在主成分分析中，每个主成分都是原始变量的线性组合，且各个主成分之间线性无关。（）</p><p><strong>正确答案： 正确</strong></p><ol><li>判断题</li></ol><p>确定保留哪些主成分，通常既考虑累计贡献率又考虑特征值大小。（）</p><p><strong>正确答案： 正确</strong></p><ol><li>判断题</li></ol><p>pandas库中的merge函数和join()方法都可以实现主键合并。（）</p><p><strong>正确答案： 正确</strong></p><ol><li>判断题</li></ol><p>数据清洗(Data cleaning)是 对数据进行重新审查和校验的过程，目的在于删除重复信息、纠正存在的错误，并提供数据一致性。（）</p><p><strong>正确答案： 正确</strong></p><ol><li>判断题</li></ol><p>transform()方法能够对整个DataFrame的所有元素进行操作。（）</p><p><strong>正确答案： 正确</strong></p><ol><li>判断题</li></ol><p>同时满足最小支持度阈值和最大置信度阈值的规则称作强规则。（）</p><p><strong>正确答案： 错误</strong></p><ol><li>判断题</li></ol><p>FP-growth算法在求每个潜在的频繁项集时都需要扫描一次数据集。（）</p><p><strong>正确答案： 错误</strong></p><ol><li>判断题</li></ol><p>基于划分的算法最明显的优点就是，只需要扫描两遍数据库T，I&#x2F;O开销比Apriori算法增加。（）</p><p><strong>正确答案： 错误</strong></p><ol><li>判断题</li></ol><p>多层关联规则（Multilevel Rules）是一种基于概念分层的关联规则挖掘方法，概念分层是一种映射，它将低层概念映射到高层概念。（）</p><p><strong>正确答案： 正确</strong></p><ol><li>判断题</li></ol><p>BIRCH是一种分类器。（）</p><p><strong>正确答案： 错误</strong></p><ol><li>判断题</li></ol><p>组平均将两个簇的邻近度定义为不同簇的所有点对的平均逐对邻近度，它是一种凝聚层次聚类技术。（）</p><p><strong>正确答案： 正确</strong></p><ol><li>判断题</li></ol><p>DBSCAN在最坏情况下的时间复杂度是O(m2)。（）</p><p><strong>正确答案： 正确</strong></p><ol><li>判断题</li></ol><p>K均值丢弃被它识别为噪声的对象，而DBSCAN一般聚类所有对象。（）</p><p><strong>正确答案： 错误</strong></p><h1 id="摘选于讨论区中的问题，可能是考试中会出现的内容"><a href="#摘选于讨论区中的问题，可能是考试中会出现的内容" class="headerlink" title="摘选于讨论区中的问题，可能是考试中会出现的内容"></a>摘选于讨论区中的问题，可能是考试中会出现的内容</h1><p>代码出题方式为填空，所以可以重点记忆标记的代码行</p><ol><li><h2 id="医学数据中，尤其是中医学数据中，如何来清洗数据。"><a href="#医学数据中，尤其是中医学数据中，如何来清洗数据。" class="headerlink" title="医学数据中，尤其是中医学数据中，如何来清洗数据。"></a>医学数据中，尤其是中医学数据中，如何来清洗数据。</h2></li></ol><p>选自林薇老师的回答：</p><p>在Python中，可以使用pandas库进行数据清洗，例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line"><span class="comment"># 删除重复行</span></span><br><span class="line">df = df.drop_duplicates()</span><br><span class="line"><span class="comment"># 填充缺失值</span></span><br><span class="line">df.fillna(<span class="number">0</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ol><li><h2 id="使用Python实现Apriori算法："><a href="#使用Python实现Apriori算法：" class="headerlink" title="使用Python实现Apriori算法："></a>使用Python实现Apriori算法：</h2></li></ol><p>选自林薇老师的示例：</p><p>使用Python实现Apriori算法的示例代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mlxtend.frequent_patterns <span class="keyword">import</span> apriori</span><br><span class="line"><span class="keyword">from</span> mlxtend.frequent_patterns <span class="keyword">import</span> association_rules</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设我们有以下事务数据集</span></span><br><span class="line">dataset = [[<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;橙子&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;橙子&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;橙子&#x27;</span>, <span class="string">&#x27;香蕉&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;橙子&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;橙子&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;橙子&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;香蕉&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Apriori算法找到频繁项集</span></span><br><span class="line">frequent_itemsets = apriori(dataset, min_support=<span class="number">0.5</span>, use_colnames=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成关联规则</span></span><br><span class="line">rules = association_rules(frequent_itemsets, metric=<span class="string">&quot;confidence&quot;</span>, min_threshold=<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;频繁项集：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(frequent_itemsets)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n关联规则：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(rules)</span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先使用<code>mlxtend.frequent_patterns.apriori</code>函数来找到频繁项集。<code>min_support</code>参数设置为0.5，表示项集在数据集中出现的最小支持度。<code>use_colnames</code>参数设置为True，表示使用列名作为项集的标识符。然后，我们使用<code>mlxtend.frequent_patterns.association_rules</code>函数来生成关联规则。在这个例子中，我们使用<code>confidence</code>作为度量标准，并设置最小阈值为0.7。最后，我们打印出频繁项集和关联规则的结果。</p><ol><li><h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2></li></ol><p>选自林薇老师的示例代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 从CSV文件中读取数据</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;input.csv&#x27;</span>)</span><br><span class="line"><span class="comment"># 数据转换</span></span><br><span class="line"><span class="comment"># 假设我们要将&#x27;column_name&#x27;列中的字符串转换为整数</span></span><br><span class="line">df[<span class="string">&#x27;column_name&#x27;</span>] = df[<span class="string">&#x27;column_name&#x27;</span>].astype(<span class="built_in">int</span>)</span><br><span class="line"><span class="comment"># 将转换后的数据保存到新的CSV文件中</span></span><br><span class="line">df.to_csv(<span class="string">&#x27;output.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><ol><li><h2 id="要实现文本分类、python常见代码是什么"><a href="#要实现文本分类、python常见代码是什么" class="headerlink" title="要实现文本分类、python常见代码是什么"></a>要实现文本分类、python常见代码是什么</h2></li></ol><p>选自林薇老师的示例代码</p><p>假设我们有一些文档，需要将它们分类为两个类别（类别1和类别2）。我们可以首先将文档转化为向量形式（即词袋模型），然后使用Scikit-learn的逻辑回归模型进行分类。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 假设我们有以下文档：</span></span><br><span class="line">documents = [</span><br><span class="line">    <span class="string">&#x27;This is a document about the first topic.&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;This document is about the second topic.&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;And this one is about the third topic.&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Is this document about the first or the second topic?&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;This is the second document.&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Is this document about the first or the second topic?&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;This document is about the first topic.&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;I wonder if this document is about the first or the second topic?&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;This is the third document.&#x27;</span></span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将文档转化为向量形式：</span></span><br><span class="line">vectorizer = CountVectorizer()</span><br><span class="line">vectorized_docs = vectorizer.fit_transform(documents)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 划分训练集和测试集：</span></span><br><span class="line">train_docs, test_docs = vectorized_docs[:-<span class="number">2</span>], vectorized_docs[-<span class="number">2</span>:]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用逻辑回归模型进行训练：</span></span><br><span class="line">classifier = LogisticRegression()</span><br><span class="line">classifier.fit(train_docs, [<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;third&#x27;</span>, <span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;third&#x27;</span>])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 对测试集进行预测：</span></span><br><span class="line">predicted = classifier.predict(test_docs)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出预测结果：</span></span><br><span class="line"><span class="built_in">print</span>(predicted)</span><br></pre></td></tr></table></figure><p>这个例子中，我们使用了逻辑回归模型，但实际上还有很多其他的模型可以选择，比如支持向量机（SVM）、朴素贝叶斯、决策树等。此外，还可以使用深度学习模型，如卷积神经网络（CNN）或递归神经网络（RNN）等。在选择模型时，需要根据具体的问题和数据来进行权衡。</p><ol><li><h2 id="简述拉格朗日插值法和牛顿差值法的异同"><a href="#简述拉格朗日插值法和牛顿差值法的异同" class="headerlink" title="简述拉格朗日插值法和牛顿差值法的异同"></a>简述拉格朗日插值法和牛顿差值法的异同</h2></li></ol><p>相同点：</p><ol><li>插值原理：拉格朗日插值法和牛顿插值法都是基于插值原理，即通过在已知数据点之间构建一个多项式函数来逼近这些点。</li><li>多项式性质：两种方法得到的结果都是多项式函数，这些多项式函数通过已知数据点，并且满足插值条件。</li></ol><p>不同点：</p><ol><li><p>插值多项式的构造方式：拉格朗日插值法通过构造一个基于拉格朗日基函数的插值多项式来进行插值。而牛顿插值法则是通过计算差商并构建牛顿插值多项式来进行插值。</p></li><li><p>运算量与复杂性：拉格朗日插值法在每次增加一个新的插值节点时，都需要重新计算所有的基函数因此其计算量相对较大，尤其是在插值节点较多的情况下。而牛顿插值法则通过差商表的逐步构建，可以在增加新的插值节点时只更新部分差商，因此其计算量相对较小。</p></li><li><p>数值稳定性：在某些情况下，拉格朗日插值法可能会出现龙格现象(Runge’s Phenomenon)，即插值多项式在插值区间的端点附近可能会出现较大的振荡。而牛颅插值法则在某些情况下表现出更好的数值稳定性。</p></li><li><h2 id="如何将异常值处理与缺失值处理的方法联系起来"><a href="#如何将异常值处理与缺失值处理的方法联系起来" class="headerlink" title="如何将异常值处理与缺失值处理的方法联系起来"></a>如何将异常值处理与缺失值处理的方法联系起来</h2></li><li><p>原因关联：异常值和缺失值有时可能源于相同的原因。例如，某些数据可能因为测量设备故障、数据录入错误或其他原因而同时出现异常或缺失。因此，在处理这些值时，可能需要同时考虑异常值和缺失值的处理方法。</p></li><li><p>处理方法的互补性：在某些情况下，可以使用异常值处理方法来处理缺失值，反之亦然。例如，如果数据集中的某个特征是数值型的，那么可以使用该特征的均值、中位数或众数来填充缺失值或替换异常值。同样，插值法既可以用于填充缺失值，也可以用于替换异常值。</p></li><li><p>处理顺序的灵活性：在某些情况下，可能需要先处理异常值，然后再处理缺失值。例如，如果异常值对后续的数据分析产生较大影响，那么可以先将其替换或删除，然后再对剩余的缺失值进行处理。反之，如果缺失值的数量较多，可能会对后续的数据分析产生较大影响，那么可以先填充缺失值，然后再对可能出现的异常值进行处理。</p></li><li><h2 id="独热编码（one-hot-encoding）和标签编码（label-encoding）的区别"><a href="#独热编码（one-hot-encoding）和标签编码（label-encoding）的区别" class="headerlink" title="独热编码（one-hot encoding）和标签编码（label encoding）的区别"></a>独热编码（one-hot encoding）和标签编码（label encoding）的区别</h2></li></ol><p>独热编码和标签编码是常用的分类数据编码方式。标签编码将每个类别映射为整数值，保留了顺序关系，但可能引入假设关系。独热编码将每个类别转换为二进制向量，适用于无序类别数据，不会引入假设关系。标签编码维持数据维度不变，而独热编码会增加维度。标签编码适用于有序类别数据，而独热编码适用于无序类别数据。</p><ol><li><h2 id="机器学习中常见编码方式：标签编码、序列编码、独热编码、频数编码、目标编码的区别与联系，如何在python中实现"><a href="#机器学习中常见编码方式：标签编码、序列编码、独热编码、频数编码、目标编码的区别与联系，如何在python中实现" class="headerlink" title="机器学习中常见编码方式：标签编码、序列编码、独热编码、频数编码、目标编码的区别与联系，如何在python中实现"></a>机器学习中常见编码方式：标签编码、序列编码、独热编码、频数编码、目标编码的区别与联系，如何在python中实现</h2></li><li><p>标签编码：</p></li></ol><p>①将类别型变量映射为整数标签，适用于有序类别数据。</p><p>②保留了类别之间的顺序关系。</p><p>③Python实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line">encoder = LabelEncoder()</span><br><span class="line">encoded_labels = encoder.fit_transform(labels)</span><br></pre></td></tr></table></figure><ol><li>序列编码：</li></ol><p>①将序列数据中的词汇或符号编码为整数序列。</p><p>②用于处理文本或时间序列数据。</p><p>③Python实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.preprocessing.text <span class="keyword">import</span> Tokenizer</span><br><span class="line">tokenizer = Tokenizer()</span><br><span class="line">tokenizer.fit_on_texts(texts)</span><br><span class="line">sequences = tokenizer.texts_to_sequences(texts)</span><br></pre></td></tr></table></figure><ol><li>独热编码：</li></ol><p>①将每个类别转换为二进制向量，适用于无序类别数据。</p><p>②不会引入类别之间的顺序关系。</p><p>③Python实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"> encoded_features = OneHotEncoder().fit_transform(features.reshape(-<span class="number">1</span>, <span class="number">1</span>)).toarray()</span><br></pre></td></tr></table></figure><ol><li>频数编码：</li></ol><p>①将每个类别映射为其出现的频率，用于有序或无序类别数据。</p><p>②可以帮助模型学习类别的频率信息。</p><p>③Python实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">freq_encoding = df[<span class="string">&#x27;category&#x27;</span>].value_counts(normalize=<span class="literal">True</span>)</span><br><span class="line"> df[<span class="string">&#x27;category_freq_encoded&#x27;</span>] = df[<span class="string">&#x27;category&#x27;</span>].<span class="built_in">map</span>(freq_encoding)</span><br></pre></td></tr></table></figure><ol><li>目标编码：</li></ol><p>①将类别型变量的每个类别的目标变量均值编码为数值。</p><p>②用于处理分类问题的特征编码。</p><p>③Python实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> category_encoders <span class="keyword">as</span> ce</span><br><span class="line"> encoder = ce.TargetEncoder()</span><br><span class="line"> encoded_features = encoder.fit_transform(features, target)</span><br></pre></td></tr></table></figure><ol><li><h2 id="python中，进行缺失值处理的时候，请简单描述牛顿插值法和拉格朗日插值法的示例代码"><a href="#python中，进行缺失值处理的时候，请简单描述牛顿插值法和拉格朗日插值法的示例代码" class="headerlink" title="python中，进行缺失值处理的时候，请简单描述牛顿插值法和拉格朗日插值法的示例代码"></a>python中，进行缺失值处理的时候，请简单描述牛顿插值法和拉格朗日插值法的示例代码</h2></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#牛顿插值法：</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">newton_interpolation</span>(<span class="params">x, y, x_new</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(x)</span><br><span class="line">    f = np.zeros((n, n))</span><br><span class="line">    <span class="comment"># 初始化f矩阵</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        f[i, <span class="number">0</span>] = y[i]</span><br><span class="line">    <span class="comment"># 计算差商</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-j):</span><br><span class="line">            f[i, j] = (f[i+<span class="number">1</span>, j-<span class="number">1</span>] - f[i, j-<span class="number">1</span>]) / (x[i+j] - x[i])</span><br><span class="line">    <span class="comment"># 计算插值结果</span></span><br><span class="line">    result = f[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        term = f[<span class="number">0</span>, i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            term *= (x_new - x[j])</span><br><span class="line">        result += term</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">x = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">y = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>])</span><br><span class="line">x_new = <span class="number">2.5</span></span><br><span class="line"><span class="comment"># 插值</span></span><br><span class="line">result = newton_interpolation(x, y, x_new)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;牛顿插值结果:&quot;</span>, result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#拉格朗日插值法：</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lagrange_interpolation</span>(<span class="params">x, y, x_new</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(x)</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        term = y[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i != j:</span><br><span class="line">                term *= (x_new - x[j]) / (x[i] - x[j])</span><br><span class="line">        result += term</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">x = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">y = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>])</span><br><span class="line">x_new = <span class="number">2.5</span></span><br><span class="line"><span class="comment"># 插值</span></span><br><span class="line">result = lagrange_interpolation(x, y, x_new)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;拉格朗日插值结果:&quot;</span>, result)</span><br></pre></td></tr></table></figure><ol><li><h2 id="Pandas提供了更强大的聚合功能，如groupby-和agg-函数，允许根据某些列对数据进行分组并应用聚合函数。试举例说明"><a href="#Pandas提供了更强大的聚合功能，如groupby-和agg-函数，允许根据某些列对数据进行分组并应用聚合函数。试举例说明" class="headerlink" title="Pandas提供了更强大的聚合功能，如groupby()和agg()函数，允许根据某些列对数据进行分组并应用聚合函数。试举例说明"></a>Pandas提供了更强大的聚合功能，如<code>groupby()</code>和<code>agg()</code>函数，允许根据某些列对数据进行分组并应用聚合函数。试举例说明</h2></li></ol><p>使用pandas中的groupby()函数和agg()函数可以对数据执行聚合操作。以”Product”和”Region”两列对销售额进行求和和平均值的计算。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># Create a sample data frame</span></span><br><span class="line">data = &#123;<span class="string">&#x27;Product&#x27;</span>: [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;C&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;Region&#x27;</span>: [<span class="string">&#x27;East&#x27;</span>, <span class="string">&#x27;East&#x27;</span>, <span class="string">&#x27;West&#x27;</span>, <span class="string">&#x27;West&#x27;</span>, <span class="string">&#x27;East&#x27;</span>, <span class="string">&#x27;West&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;Sales&#x27;</span>: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="comment"># Group by &#x27;Product&#x27; and &#x27;Region&#x27;, and compute sum and mean of &#x27;Sales&#x27;</span></span><br><span class="line">grouped = df.groupby([<span class="string">&#x27;Product&#x27;</span>, <span class="string">&#x27;Region&#x27;</span>])[<span class="string">&#x27;Sales&#x27;</span>].agg([<span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(grouped)</span><br></pre></td></tr></table></figure><p>从输出结果可以看出，groupby()函数根据”Product”和”Region”两列对数据进行分组，agg()函数计算了每组数据的”Sales”列的总和和平均值。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MDRjY2M2MjI5ZjIwMTg3MzA1YTgxMzRhYzE3NTY5NDhfODdGbEFGdzdmYVRFbFVGNDhoc0wxTU1USkN5MXQybTJfVG9rZW46TjhlVGJBald1bzIzRmh4ZlJFbmM2R0YxbmhnXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li><h2 id="关联规则算法实现"><a href="#关联规则算法实现" class="headerlink" title="关联规则算法实现"></a>关联规则算法实现</h2></li></ol><p>示例数据集</p><p>dataset &#x3D; [[‘牛奶’, ‘面包’, ‘黄油’],</p><p>​           [‘面包’, ‘黄油’, ‘尿布’],</p><p>​           [‘牛奶’, ‘尿布’, ‘鸡蛋’, ‘黄油’],</p><p>​           [‘面包’, ‘牛奶’, ‘尿布’, ‘鸡蛋’],</p><p>​           [‘面包’, ‘尿布’, ‘黄油’, ‘鸡蛋’]]</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mlxtend.frequent_patterns <span class="keyword">import</span> apriori</span><br><span class="line"><span class="keyword">from</span> mlxtend.frequent_patterns <span class="keyword">import</span> association_rules</span><br><span class="line"><span class="keyword">from</span> mlxtend.preprocessing <span class="keyword">import</span> TransactionEncoder</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据集</span></span><br><span class="line">data = [[<span class="string">&#x27;牛奶&#x27;</span>, <span class="string">&#x27;面包&#x27;</span>, <span class="string">&#x27;黄油&#x27;</span>],</span><br><span class="line">           [<span class="string">&#x27;面包&#x27;</span>, <span class="string">&#x27;黄油&#x27;</span>, <span class="string">&#x27;尿布&#x27;</span>],</span><br><span class="line">           [<span class="string">&#x27;牛奶&#x27;</span>, <span class="string">&#x27;尿布&#x27;</span>, <span class="string">&#x27;鸡蛋&#x27;</span>, <span class="string">&#x27;黄油&#x27;</span>],</span><br><span class="line">           [<span class="string">&#x27;面包&#x27;</span>, <span class="string">&#x27;牛奶&#x27;</span>, <span class="string">&#x27;尿布&#x27;</span>, <span class="string">&#x27;鸡蛋&#x27;</span>],</span><br><span class="line">           [<span class="string">&#x27;面包&#x27;</span>, <span class="string">&#x27;尿布&#x27;</span>, <span class="string">&#x27;黄油&#x27;</span>, <span class="string">&#x27;鸡蛋&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 TransactionEncoder 将数据集转换为适合Apriori算法的格式</span></span><br><span class="line">te = TransactionEncoder()</span><br><span class="line">te_ary= te.fit(data).transform(data)</span><br><span class="line">df = pd.DataFrame(te_ary, columns=te.columns_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 Apriori 算法计算频繁项集</span></span><br><span class="line">frequent_itemsets = apriori(df, min_support=<span class="number">0.4</span>, use_colnames=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用association_rules函数生成关联规则</span></span><br><span class="line">rules=association_rules(frequent_itemsets,metric=<span class="string">&quot;confidence&quot;</span>,min_threshold=<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;频繁项集：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(frequent_itemsets)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n关联规则：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(rules)</span><br></pre></td></tr></table></figure><ol><li><h2 id="利用Apriori算法对中药组方进行关联规则分析"><a href="#利用Apriori算法对中药组方进行关联规则分析" class="headerlink" title="利用Apriori算法对中药组方进行关联规则分析"></a>利用Apriori算法对中药组方进行关联规则分析</h2></li></ol><p>示例数据集</p><p>dataset &#x3D; [[‘当归’, ‘川芎’, ‘人参’],</p><p>​           [‘川芎’, ‘人参’, ‘茯苓’],</p><p>​           [‘当归’, ‘茯苓’, ‘甘草’, ‘人参’],</p><p>​           [‘川芎’, ‘当归’, ‘茯苓’, ‘甘草’],</p><p>​           [‘川芎’, ‘茯苓’, ‘人参’, ‘甘草’]]</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> apyori <span class="keyword">import</span> apriori</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据集</span></span><br><span class="line">dataset = [[<span class="string">&#x27;当归&#x27;</span>, <span class="string">&#x27;川芎&#x27;</span>, <span class="string">&#x27;人参&#x27;</span>],</span><br><span class="line">           [<span class="string">&#x27;川考&#x27;</span>, <span class="string">&#x27;人参&#x27;</span>, <span class="string">&#x27;茯苓&#x27;</span>],</span><br><span class="line">           [<span class="string">&#x27;当归&#x27;</span>, <span class="string">&#x27;茯苓&#x27;</span>, <span class="string">&#x27;甘草&#x27;</span>, <span class="string">&#x27;人参&#x27;</span>],</span><br><span class="line">           [<span class="string">&#x27;川芎&#x27;</span>, <span class="string">&#x27;当归&#x27;</span>, <span class="string">&#x27;茯苓&#x27;</span>, <span class="string">&#x27;甘草&#x27;</span>],</span><br><span class="line">           [<span class="string">&#x27;川芎&#x27;</span>, <span class="string">&#x27;茯苓&#x27;</span>, <span class="string">&#x27;人参&#x27;</span>, <span class="string">&#x27;甘草&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用Apriori算法</span></span><br><span class="line">min_support = <span class="number">0.3</span>  <span class="comment"># 设置最小支持度阈值</span></span><br><span class="line">min_confidence = <span class="number">0.7</span>  <span class="comment"># 设置最小置信度阈值</span></span><br><span class="line">min_lift = <span class="number">1.2</span>  <span class="comment"># 设置最小提升度阈值</span></span><br><span class="line">min_length = <span class="number">2</span>  <span class="comment"># 设置最小项集长度</span></span><br><span class="line"></span><br><span class="line">results = <span class="built_in">list</span>(apriori(dataset, min_support=min_support, min_confidence=min_confidence, min_lift=min_lift, min_length=min_length))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出频繁项集和关联规则</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;频繁项集：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> results:</span><br><span class="line">    <span class="built_in">print</span>(item.items, <span class="string">&quot;Support:&quot;</span>, <span class="built_in">round</span>(item.support, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n关联规则：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> rule <span class="keyword">in</span> results:</span><br><span class="line">    <span class="keyword">for</span> outcome <span class="keyword">in</span> rule.ordered_statistics:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;, &quot;</span>.join(item <span class="keyword">for</span> item <span class="keyword">in</span> outcome.items_base), <span class="string">&quot;=&gt;&quot;</span>, <span class="string">&quot;, &quot;</span>.join(item <span class="keyword">for</span> item <span class="keyword">in</span> outcome.items_add), <span class="string">&quot;Confidence:&quot;</span>, <span class="built_in">round</span>(outcome.confidence, <span class="number">4</span>), <span class="string">&quot;Lift:&quot;</span>, <span class="built_in">round</span>(outcome.lift, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><ol><li><h2 id="利用fp-growth算法进行中药组方关联规则挖掘"><a href="#利用fp-growth算法进行中药组方关联规则挖掘" class="headerlink" title="利用fp-growth算法进行中药组方关联规则挖掘"></a>利用fp-growth算法进行中药组方关联规则挖掘</h2></li></ol><p>模拟中医药方剂的数据集</p><p>data &#x3D; [</p><p>​    [‘黄连’, ‘黄芩’, ‘黄柏’, ‘栀子’],</p><p>​    [‘麻黄’, ‘桂枝’, ‘杏仁’, ‘甘草’],</p><p>​    [‘银花’, ‘连翘’, ‘桔梗’, ‘薄荷’],</p><p>[‘川芎’, ‘麻黄’, ‘桔梗’, ‘杏仁’],</p><p>… 添加更多方剂</p><p>]</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mlxtend.preprocessing <span class="keyword">import</span> TransactionEncoder</span><br><span class="line"><span class="keyword">from</span> mlxtend.frequent_patterns <span class="keyword">import</span> fpgrowth Graph</span><br><span class="line"><span class="keyword">from</span> mlxtend.frequent_patterns <span class="keyword">import</span> association_rules</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟数据集</span></span><br><span class="line">data = [</span><br><span class="line">    [<span class="string">&#x27;黄连&#x27;</span>, <span class="string">&#x27;黄芩&#x27;</span>, <span class="string">&#x27;黄柏&#x27;</span>, <span class="string">&#x27;栀子&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;麻黄&#x27;</span>, <span class="string">&#x27;桂枝&#x27;</span>, <span class="string">&#x27;杏仁&#x27;</span>, <span class="string">&#x27;甘草&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;银花&#x27;</span>, <span class="string">&#x27;连翘&#x27;</span>, <span class="string">&#x27;桔梗&#x27;</span>, <span class="string">&#x27;薄荷&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;川芎&#x27;</span>, <span class="string">&#x27;麻黄&#x27;</span>, <span class="string">&#x27;桔梗&#x27;</span>, <span class="string">&#x27;杏仁&#x27;</span>],</span><br><span class="line">    <span class="comment"># ...添加更多方剂</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据预处理</span></span><br><span class="line">te = TransactionEncoder()</span><br><span class="line">te_ary = te.fit(data).transform(data)</span><br><span class="line">df = pd.DataFrame(te_ary, columns=te.columns_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># FP-growth模型</span></span><br><span class="line">frequent_itemsets = fpgrowth(df, use_colnames=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成关联规则</span></span><br><span class="line">rules = association_rules(frequent_itemsets, metric=<span class="string">&quot;lift&quot;</span>, min_threshold=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印关联规则</span></span><br><span class="line"><span class="built_in">print</span>(rules)</span><br></pre></td></tr></table></figure><ol><li><h2 id="寻找针灸治疗功能性胃肠病的选穴规律关联规则"><a href="#寻找针灸治疗功能性胃肠病的选穴规律关联规则" class="headerlink" title="寻找针灸治疗功能性胃肠病的选穴规律关联规则"></a>寻找针灸治疗功能性胃肠病的选穴规律关联规则</h2></li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YTQ1YjQxOGZlN2YxM2I1OTZkNGQ0ZmE5NzE2Yzg3YzVfTUlCY2dXWkU3N2VLSms2WUFvMjNQZTRER1lacmdJd2xfVG9rZW46SldNOWJHdnJRb05lS2l4Q3pLemNZOGdmbnJnXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dataset = [</span><br><span class="line">    [<span class="string">&#x27;公孙&#x27;</span>, <span class="string">&#x27;解溪&#x27;</span>, <span class="string">&#x27;太仓&#x27;</span>, <span class="string">&#x27;足三里&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;公孙&#x27;</span>, <span class="string">&#x27;劳宫&#x27;</span>, <span class="string">&#x27;通里&#x27;</span>, <span class="string">&#x27;大陵&#x27;</span>, <span class="string">&#x27;膻中&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;公孙&#x27;</span>, <span class="string">&#x27;厉兑&#x27;</span>, <span class="string">&#x27;胃俞&#x27;</span>, <span class="string">&#x27;大都&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;公孙&#x27;</span>, <span class="string">&#x27;内关&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;公孙&#x27;</span>, <span class="string">&#x27;天枢&#x27;</span>, <span class="string">&#x27;水分&#x27;</span>, <span class="string">&#x27;内庭&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;公孙&#x27;</span>, <span class="string">&#x27;天枢&#x27;</span>, <span class="string">&#x27;水分&#x27;</span>, <span class="string">&#x27;内庭&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;公孙&#x27;</span>, <span class="string">&#x27;中脘&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;公孙&#x27;</span>, <span class="string">&#x27;巨阙&#x27;</span>, <span class="string">&#x27;中脘&#x27;</span>, <span class="string">&#x27;厉兑&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;公孙&#x27;</span>, <span class="string">&#x27;中脘&#x27;</span>, <span class="string">&#x27;太白&#x27;</span>, <span class="string">&#x27;中魁&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;公孙&#x27;</span>, <span class="string">&#x27;中脘&#x27;</span>, <span class="string">&#x27;足三里&#x27;</span>, <span class="string">&#x27;解溪&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;劳宫&#x27;</span>, <span class="string">&#x27;中魁&#x27;</span>, <span class="string">&#x27;中脘&#x27;</span>, <span class="string">&#x27;足三里&#x27;</span>, <span class="string">&#x27;大陵&#x27;</span>, <span class="string">&#x27;支沟&#x27;</span>, <span class="string">&#x27;上脘&#x27;</span>, <span class="string">&#x27;脾俞&#x27;</span>, <span class="string">&#x27;胃俞&#x27;</span>, <span class="string">&#x27;中脘&#x27;</span>, <span class="string">&#x27;太白&#x27;</span>, <span class="string">&#x27;下脘&#x27;</span>, <span class="string">&#x27;食关&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;中脘&#x27;</span>, <span class="string">&#x27;太白&#x27;</span>, <span class="string">&#x27;下脘&#x27;</span>, <span class="string">&#x27;食关&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;劳宫&#x27;</span>, <span class="string">&#x27;中渚&#x27;</span>, <span class="string">&#x27;支沟&#x27;</span>, <span class="string">&#x27;中脘&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;脾俞&#x27;</span>, <span class="string">&#x27;章门&#x27;</span>, <span class="string">&#x27;期门&#x27;</span>, <span class="string">&#x27;太白&#x27;</span>, <span class="string">&#x27;中脘&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;俞府&#x27;</span>, <span class="string">&#x27;灵墟&#x27;</span>, <span class="string">&#x27;巨阙&#x27;</span>, <span class="string">&#x27;率谷&#x27;</span>, <span class="string">&#x27;神藏&#x27;</span>]</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"><span class="comment"># 数据预处理：转换数据格式</span></span><br><span class="line">te = TransactionEncoder()</span><br><span class="line">transaction_te = te.fit(dataset).transform(dataset)</span><br><span class="line">df = pd.DataFrame(transaction_te, columns=te.columns_)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 设置最小支持度（例如：0.2，表示项集在所有事务中出现的频率至少为20%）</span></span><br><span class="line">min_support = <span class="number">0.2</span></span><br><span class="line"><span class="comment"># 设置最小置信度（例如：0.7，表示规则的置信度至少为70%）</span></span><br><span class="line">min_confidence = <span class="number">0.25</span></span><br><span class="line"><span class="comment"># 找出频繁项集</span></span><br><span class="line">frequent_items = fpgrowth(df, min_support, use_colnames=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 生成关联规则</span></span><br><span class="line">rules = association_rules(frequent_items, metric=<span class="string">&quot;confidence&quot;</span>, min_threshold=<span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># 打印频繁项集和关联规则</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;频繁项集:\n&quot;</span>, frequent_items)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;关联规则:\n&quot;</span>, rules[[<span class="string">&#x27;antecedents&#x27;</span>, <span class="string">&#x27;consequents&#x27;</span>, <span class="string">&#x27;support&#x27;</span>, <span class="string">&#x27;confidence&#x27;</span>, <span class="string">&#x27;lift&#x27;</span>]])</span><br></pre></td></tr></table></figure><ol><li><h2 id="针灸治疗头痛"><a href="#针灸治疗头痛" class="headerlink" title="针灸治疗头痛"></a>针灸治疗头痛</h2></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> mlxtend.preprocessing <span class="keyword">import</span> TransactionEncoder</span><br><span class="line"><span class="keyword">from</span> mlxtend.frequent_patterns <span class="keyword">import</span> apriori, association_rules</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]  <span class="comment"># 指定默认字体为黑体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  <span class="comment"># 解决保存图像时负号&#x27;-&#x27;显示为方块的问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 针灸处方数据</span></span><br><span class="line">data = [</span><br><span class="line">    [<span class="string">&#x27;眉冲&#x27;</span>, <span class="string">&#x27;颞颥&#x27;</span>, <span class="string">&#x27;涌泉&#x27;</span>, <span class="string">&#x27;风门&#x27;</span>, <span class="string">&#x27;小海&#x27;</span>, <span class="string">&#x27;水沟&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;期门&#x27;</span>, <span class="string">&#x27;水沟&#x27;</span>, <span class="string">&#x27;神道&#x27;</span>, <span class="string">&#x27;涌泉&#x27;</span>, <span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>,<span class="string">&#x27;人迎&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;腕骨&#x27;</span>,<span class="string">&#x27;小海&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;目窗&#x27;</span>,<span class="string">&#x27;天冲&#x27;</span>,<span class="string">&#x27;风池&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;神庭&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;人迎&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;曲差&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;神道&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;本神&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;通天&#x27;</span>,<span class="string">&#x27;神道&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;承灵&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;目窗&#x27;</span>,<span class="string">&#x27;天冲&#x27;</span>,<span class="string">&#x27;风池&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;神道&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>,<span class="string">&#x27;人迎&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;命门&#x27;</span>,<span class="string">&#x27;目窗&#x27;</span>,<span class="string">&#x27;天冲&#x27;</span>,<span class="string">&#x27;风池&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;大杼&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>,<span class="string">&#x27;风府&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;风门&#x27;</span>,<span class="string">&#x27;神道&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;目窗&#x27;</span>,<span class="string">&#x27;天冲&#x27;</span>,<span class="string">&#x27;风池&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;悬厘&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;风府&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;阳白&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;攒竹&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>,<span class="string">&#x27;人迎&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;温溜&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;清冷渊&#x27;</span>,<span class="string">&#x27;人迎&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;消泺&#x27;</span>,<span class="string">&#x27;目窗&#x27;</span>,<span class="string">&#x27;天冲&#x27;</span>,<span class="string">&#x27;风池&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;小海&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;丰隆&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;束骨&#x27;</span>,<span class="string">&#x27;人迎&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;人迎&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;目窗&#x27;</span>,<span class="string">&#x27;天冲&#x27;</span>,<span class="string">&#x27;风池&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;孔最&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;商丘&#x27;</span>,<span class="string">&#x27;目窗&#x27;</span>,<span class="string">&#x27;天冲&#x27;</span>,<span class="string">&#x27;风池&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;百会&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;后顶&#x27;</span>,<span class="string">&#x27;目窗&#x27;</span>,<span class="string">&#x27;天冲&#x27;</span>,<span class="string">&#x27;风池&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用TransactionEncoder转换数据</span></span><br><span class="line">te = TransactionEncoder()</span><br><span class="line">te_ary = te.fit(data).transform(data)</span><br><span class="line">df = pd.DataFrame(te_ary, columns=te.columns_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出频繁项集</span></span><br><span class="line">frequent_itemsets = apriori(df, min_support=<span class="number">0.02</span>, use_colnames=<span class="literal">True</span>)  <span class="comment"># 根据数据量调整min_support</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算关联规则</span></span><br><span class="line">rules = association_rules(frequent_itemsets, metric=<span class="string">&quot;confidence&quot;</span>, min_threshold=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印关联规则</span></span><br><span class="line"><span class="built_in">print</span>(rules[[<span class="string">&#x27;antecedents&#x27;</span>, <span class="string">&#x27;consequents&#x27;</span>, <span class="string">&#x27;support&#x27;</span>, <span class="string">&#x27;confidence&#x27;</span>, <span class="string">&#x27;lift&#x27;</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建网络图</span></span><br><span class="line">G = nx.DiGraph()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加节点和边</span></span><br><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> rules.iterrows():</span><br><span class="line">    antecedents = <span class="built_in">list</span>(row[<span class="string">&#x27;antecedents&#x27;</span>])  <span class="comment"># 将frozenset转换为list</span></span><br><span class="line">    consequents = <span class="built_in">list</span>(row[<span class="string">&#x27;consequents&#x27;</span>])  <span class="comment"># 将frozenset转换为list</span></span><br><span class="line">    <span class="comment"># 为每个关联规则添加一条边，同时检查antecedents和consequents是否已经存在于图中</span></span><br><span class="line">    <span class="keyword">for</span> ante <span class="keyword">in</span> antecedents:</span><br><span class="line">        <span class="keyword">if</span> ante <span class="keyword">not</span> <span class="keyword">in</span> G:</span><br><span class="line">            G.add_node(ante)</span><br><span class="line">        <span class="keyword">for</span> conseq <span class="keyword">in</span> consequents:</span><br><span class="line">            <span class="keyword">if</span> conseq <span class="keyword">not</span> <span class="keyword">in</span> G:</span><br><span class="line">                G.add_node(conseq)</span><br><span class="line">            <span class="keyword">if</span> ante != conseq:</span><br><span class="line">                G.add_edge(ante, conseq, weight=row[<span class="string">&#x27;confidence&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制网络图</span></span><br><span class="line">pos = nx.spring_layout(G)</span><br><span class="line">edge_colors = [G[u][v][<span class="string">&#x27;weight&#x27;</span>] <span class="keyword">for</span> u, v <span class="keyword">in</span> G.edges()]</span><br><span class="line">nx.draw(G, pos, with_labels=<span class="literal">True</span>, node_color=<span class="string">&#x27;skyblue&#x27;</span>, node_size=<span class="number">700</span>, edge_color=edge_colors, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><h2 id="成人自闭症进行聚类实现"><a href="#成人自闭症进行聚类实现" class="headerlink" title="成人自闭症进行聚类实现"></a>成人自闭症进行聚类实现</h2></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载文件</span></span><br><span class="line">file_path = <span class="string">&#x27;F:\\下载\\autism_screening成人自闭症.csv&#x27;</span></span><br><span class="line">autism_data = pd.read_csv(file_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计数据中各列中缺失值的数量</span></span><br><span class="line">missing_values = autism_data.isnull().<span class="built_in">sum</span>()</span><br><span class="line">missing_values</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用平均年龄填充“年龄”列中的缺失值</span></span><br><span class="line">autism_data[<span class="string">&#x27;age&#x27;</span>].fillna(autism_data[<span class="string">&#x27;age&#x27;</span>].mean(), inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次统计数据中各列中缺失值的数量，确定缺失值是否填充</span></span><br><span class="line">missing_values_after_filling = autism_data.isnull().<span class="built_in">sum</span>()</span><br><span class="line">missing_values_after_filling</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择聚类的特征</span></span><br><span class="line">features = [<span class="string">&#x27;A1_Score&#x27;</span>, <span class="string">&#x27;A2_Score&#x27;</span>, <span class="string">&#x27;A3_Score&#x27;</span>, <span class="string">&#x27;A4_Score&#x27;</span>, <span class="string">&#x27;A5_Score&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;A6_Score&#x27;</span>, <span class="string">&#x27;A7_Score&#x27;</span>, <span class="string">&#x27;A8_Score&#x27;</span>, <span class="string">&#x27;A9_Score&#x27;</span>, <span class="string">&#x27;A10_Score&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;result&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将每个特征的数据标准化为平均值为0，标准差为1的类</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">autism_data[features] = scaler.fit_transform(autism_data[features])</span><br><span class="line"></span><br><span class="line">autism_data[features].head()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = <span class="string">&#x27;SimHei&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确定要测试的 k 个值的范围</span></span><br><span class="line">k_values = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个列表来存储每个 k 值的聚类效果值</span></span><br><span class="line">inertia_list = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历 k 值并拟合模型</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> k_values:</span><br><span class="line">    kmeans = KMeans(n_clusters=k, random_state=<span class="number">42</span>)</span><br><span class="line">    kmeans.fit(autism_data[features])</span><br><span class="line">    inertia_list.append(kmeans.inertia_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制“肘部曲线”</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">plt.plot(k_values, inertia_list, marker=<span class="string">&#x27;o&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;肘部曲线图&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;value of K&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Distortion&#x27;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数来运行 KMean 并绘制给定 k 值的聚类</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_clusters</span>(<span class="params">data, feature1, feature2, k_values</span>):</span><br><span class="line">    plt.figure(figsize=(<span class="number">15</span>, <span class="number">8</span>))</span><br><span class="line">    <span class="keyword">for</span> i, k <span class="keyword">in</span> <span class="built_in">enumerate</span>(k_values, <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 进行 KMeans 聚类</span></span><br><span class="line">        kmeans = KMeans(n_clusters=k, random_state=<span class="number">42</span>)</span><br><span class="line">        data[<span class="string">&#x27;cluster&#x27;</span>] = kmeans.fit_predict(data[[feature1, feature2]])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 绘制聚类结果</span></span><br><span class="line">        plt.subplot(<span class="number">1</span>, <span class="built_in">len</span>(k_values), i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="comment"># 根据聚类结果绘制散点图</span></span><br><span class="line">            plt.scatter(data[data[<span class="string">&#x27;cluster&#x27;</span>] == j][feature1],</span><br><span class="line">                        data[data[<span class="string">&#x27;cluster&#x27;</span>] == j][feature2],</span><br><span class="line">                        label=<span class="string">f&#x27;Cluster <span class="subst">&#123;j&#125;</span>&#x27;</span>)</span><br><span class="line">        plt.xlabel(feature1)</span><br><span class="line">        plt.ylabel(feature2)</span><br><span class="line">        plt.title(<span class="string">f&#x27;KMeans Clustering with <span class="subst">&#123;k&#125;</span> Clusters&#x27;</span>)</span><br><span class="line">        plt.legend()</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择要进行聚类的特征</span></span><br><span class="line">feature1 = <span class="string">&#x27;result&#x27;</span>  <span class="comment"># x轴</span></span><br><span class="line">feature2 = <span class="string">&#x27;age&#x27;</span>  <span class="comment"># y轴</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义要绘制的 k 值</span></span><br><span class="line">k_values = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制不同 k 值的聚类</span></span><br><span class="line">plot_clusters(autism_data, feature1, feature2, k_values)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 k=3 运行k均值聚类</span></span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">3</span>, random_state=<span class="number">42</span>)</span><br><span class="line">autism_data[<span class="string">&#x27;cluster&#x27;</span>] = kmeans.fit_predict(autism_data[features])</span><br><span class="line"></span><br><span class="line">autism_data[[<span class="string">&#x27;cluster&#x27;</span>] + features].head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先获取每个聚类的中心点</span></span><br><span class="line">cluster_centers = kmeans.cluster_centers_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看每个聚类的中心点</span></span><br><span class="line">cluster_centers_df = pd.DataFrame(cluster_centers, columns=features)</span><br><span class="line">cluster_centers_df.index.name = <span class="string">&#x27;Cluster&#x27;</span></span><br><span class="line">cluster_centers_df.reset_index(inplace=<span class="literal">True</span>)</span><br><span class="line">cluster_centers_df</span><br><span class="line"><span class="comment"># 计算每个聚类中出现的自闭症次数（Class / ASD列）</span></span><br><span class="line">cluster_class_counts = autism_data.groupby([<span class="string">&#x27;cluster&#x27;</span>, <span class="string">&#x27;Class/ASD&#x27;</span>]).size().unstack().fillna(<span class="number">0</span>)</span><br><span class="line">cluster_class_counts</span><br></pre></td></tr></table></figure><ol><li><h2 id="贝叶斯分类"><a href="#贝叶斯分类" class="headerlink" title="贝叶斯分类"></a>贝叶斯分类</h2></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入高斯朴素贝叶斯分类器</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"><span class="comment"># 导入计算分类模型的准确率的库</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据集</span></span><br><span class="line">data = pd.read_excel(<span class="string">&quot;F:\Desktop\表1.xlsx&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data.head())</span><br><span class="line"><span class="comment"># 分离特征和标签</span></span><br><span class="line">X = data[[<span class="string">&#x27;身高（英尺）&#x27;</span>, <span class="string">&#x27;体重（磅）&#x27;</span>, <span class="string">&#x27;脚掌（英寸）&#x27;</span>]]</span><br><span class="line">y = data[<span class="string">&#x27;性别&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据集划分为训练集和测试集</span></span><br><span class="line"><span class="comment"># 训练集包含80%的数据，测试集包含20%的数据</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化高斯朴素贝叶斯分类器</span></span><br><span class="line">nb_classifier = GaussianNB()</span><br><span class="line"><span class="comment"># 拟合数据</span></span><br><span class="line">nb_classifier.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测测试集中的数据，以验证分类器准确率</span></span><br><span class="line">y_pred = nb_classifier.predict(X_test)</span><br><span class="line">accuracy = accuracy_score(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(accuracy)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入预测数据</span></span><br><span class="line">test_data = pd.read_excel(<span class="string">&quot;F:\Desktop\表2.xlsx&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测数据表2的性别属性</span></span><br><span class="line">test_data[<span class="string">&#x27;性别预测&#x27;</span>] = nb_classifier.predict(test_data[[<span class="string">&#x27;身高（英尺）&#x27;</span>, <span class="string">&#x27;体重（磅）&#x27;</span>, <span class="string">&#x27;脚掌（英寸）&#x27;</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示预测结果</span></span><br><span class="line">test_data[[<span class="string">&#x27;记录&#x27;</span>, <span class="string">&#x27;性别预测&#x27;</span>]]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 期末 </category>
          
          <category> 课内知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 期末 </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在面试中回顾知识</title>
      <link href="/2024/07/01/%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%9B%9E%E9%A1%BE%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/07/01/%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%9B%9E%E9%A1%BE%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>抛开实际谈理论永远是流氓，开设此专栏的目的很简单，就是聚焦于从面试题中回顾知识，里面概括了我在面试中遇到的真实面试题以及收录其他同路人的面经，希望能在面试题中再次回顾知识，能把会的东西表达出来。参考答案来源包括但不仅限于：个人总结、<a href="https://javaguide.cn/">JavaGuide</a>、<a href="https://xiaolincoding.com/">小林coding</a>,咕泡教育<br>持续更新，直至上岸</p><p>这几篇老文章都是我之前用飞书云文档写的，因转换格式问题，本文之前已写完的文档图片太多了，不想一一转化了，大家可以访问我的飞书云文档来查看这些图片–<a href="https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e,%E4%B8%8D%E8%BF%87%E5%90%8E%E7%BB%AD%E8%A1%A5%E5%85%85%E7%9A%84%E9%83%BD%E4%BC%9A%E6%9C%89%E5%9B%BE%E7%89%87">https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e,不过后续补充的都会有图片</a></p><h2 id="某厂后端java实习一面"><a href="#某厂后端java实习一面" class="headerlink" title="某厂后端java实习一面"></a>某厂后端java实习一面</h2><ol><li><h3 id="聊一下关于mp的使用"><a href="#聊一下关于mp的使用" class="headerlink" title="聊一下关于mp的使用"></a>聊一下关于mp的使用</h3></li></ol><p>MyBatis-Plus是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。如果添加了MybatisPlus的依赖 但是不想使用MybatisPlus的类和方法 这时候仍然可以按照之前使用Mybatis的步骤做开发 几乎和之前没有任何的改变</p><p>它的使用方法</p><p>① 导入依赖，如果有注释掉之前mybatis的依赖</p><p>②如果MyBatis Plus有自定义mapper文件，地址配置由mybatis-mapper-locations改为mybatis-plus.mapper-locations</p><p>③ 给实体类加注解</p><p>@TableName(“user”) 加载类上 将该类和数据库中对应的表建立联系 注解值为表名</p><p>@TableId(value &#x3D; “对应表列名”,type &#x3D; IdType.AUTO) 建立主键属性和主键字段之间的联系。 value 字段名， type 定义主键自增类型 IdType.AUTO MySQL自动递增</p><p>常规属性@TableField(“name”) 将常规属性和常规字段名建立联系</p><p>连表查询 封装数据的属性 没有对应的字段 需要定义忽略</p><p>@TableField(exist &#x3D; false) exist &#x3D; false代表当前属性在表中没有字段名</p><ol><li><h3 id="HashMap的底层讲一下"><a href="#HashMap的底层讲一下" class="headerlink" title="HashMap的底层讲一下"></a>HashMap的底层讲一下</h3></li></ol><p>我从三个方面讲一下它</p><p>1.HashMap 中的关键属性—看-HashMap 的源码片段，可以知道它的几个属性</p><p>第一个属性 loadFactor，它是负载因子，默认值是 0.75，表示扩容前。</p><p>第二个属性 threshold 它是记录 HashMap 所能容纳的键值对的临界值，它的计算规则是负载因子乘以数组长度。 </p><p>第三个属性 size，它用来记录 HashMap 实际存在的键值对的数量。 </p><p>第四个属性 modCount，它用来记录 HashMap 内部结构发生变化的次数。 </p><p>第五个是常量属性 DEFAULT_INITIAL_CAPACITY ，它规定 的默认容量是 16。</p><p>2、HashMap 的存储结构</p><p>HashMap 采用的是key-value 的存储结构。HashMap 的数组部分称为 Hash 桶，数组元素保存在一个叫做 table 的属性中。jdk1.8以后当链表长度大于等于 8 时，链表数据将会以红黑树的形式进行存储。</p><p>每个 Node 节点，保存了用来定位数组索引位置的 hash 值、Key、Value 和链表指向 的下一个 Node 节点。而 Node 类是 HashMap 的内部类，它实现了 Map.Entry 接口， 它的本质其实可以简单的理解成就是一个键值对。</p><ol><li>HashMap 的工作原理</li></ol><p>首先，通过hash算法计算出key的hashcode值，然后根据数组长度取模，得到在数组中的位置。</p><p>如果该位置上没有元素，则直接将key-value存储在该位置上。</p><p>如果该位置上已经存在元素，则需要进行链表或红黑树的操作。</p><p>如果链表长度小于8，则采用链表存储，将新元素插入到链表尾部。</p><p>如果链表长度大于等于8，则将链表转化为红黑树进行存储。</p><p>当数组长度达到阈值时（默认为0.75），需要进行扩容操作，将数组长度扩大为原来的两倍，并将原有元素重新分布到新数组中。</p><p>当数组中的元素数量小于阈值的0.25时，会进行缩容操作，将数组长度缩小为原来的一半。</p><ol><li><h3 id="mysql的锁了解吗"><a href="#mysql的锁了解吗" class="headerlink" title="mysql的锁了解吗"></a>mysql的锁了解吗</h3></li></ol><p>我通常会把Mysql中锁搞成六种分类，共14种锁</p><ol><li><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4></li></ol><p>死锁，简单来说就是两个或者两个以上的线程在执行的过程中，争夺同一个共 </p><p>享资源造成的相互等待的现象</p><p>互斥条件，共享资源 X 和 Y 只能被一个线程占用； </p><p>请求和保持条件，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不 </p><p>释放共享资源 X； </p><p>不可抢占条件，其他线程不能强行抢占线程 T1 占有的资源； </p><p>循环等待条件，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有 </p><p>的资源，就是循环等待</p><ol><li><h4 id="锁的区间划分"><a href="#锁的区间划分" class="headerlink" title="锁的区间划分"></a>锁的区间划分</h4></li></ol><p>1、间隙锁</p><p>间隙锁是开区间的，是一个在索引记录之间的间隙上的锁。</p><p>作用：保证某个间隙内的数据在锁定情况下不会发生任何变化。比如mysql默认隔离级别下的可重复读（RR）。 当使用唯一索引来搜索唯一行的语句时，不需要间隙锁定。如下面语句的id列有唯一索引，此时只会对id值为10的行使用记录锁。</p><p>2、临键锁（Next-key Locks）</p><p>临键锁是行锁+间隙锁，即临键锁是是一个左开右闭的区间，比如（- ∞， 1 ] |（1， 3 ] |（3， 4 ] | （4， + ∞）。</p><p>InnoDB的默认事务隔离级别是RR，在这种级别下，如果使用select … in share mode或者select … for update语句，那么InnoDB会使用临键锁，因而可以防止幻读；但即使你的隔离级别是RR，如果你这是使用普通的select语句，那么InnoDB将是快照读，不会使用任何锁，因而还是无法防止幻读。</p><h4 id="4-3-锁的粒度划分"><a href="#4-3-锁的粒度划分" class="headerlink" title="4.3 锁的粒度划分"></a>4.3 锁的粒度划分</h4><ol><li>表级锁（Table-level lock）</li></ol><p>InnoDB在使用过程中只要不通过索引检索数据时，全部是表锁。 开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低InnoDB在使用过程中只要不通过索引检索数据时，全部是表锁。 开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低</p><ol><li>行级锁（Record Locks）</li></ol><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点，MySQL于Oracle不同，后者是通过在数据块中对相应的数据行加锁来实现的，InnoDB只有通过索引条件检索数据，InnoDB才使用行级锁</p><p>行锁的劣势：开销大；加锁慢；会出现死锁</p><p>行锁的优势：锁的粒度小，发生锁冲突的概率低；处理并发的能力强</p><p>3、页级锁</p><p>页级锁是 MySQL 中比较独特的一种锁定级别，在其他数据库管理软件中并不常见。 页级锁的颗粒度介于行级锁与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力同样也是介于上面二者之间。另外，页级锁和行级锁一样，会发生死锁。 页级锁主要应用于 BDB 存储引擎。</p><h4 id="4-4-锁级别划分"><a href="#4-4-锁级别划分" class="headerlink" title="4.4 锁级别划分"></a>4.4 锁级别划分</h4><p>1、共享锁（share lock，即S锁）</p><p>共享锁（S）：又称读锁，允许一个事务去读取一行，阻止其他事务获得相同数据集的排它锁，若事务T对数据对象A加上S锁，则事务T可以读A，但不能修改A，其他事务只能对再对A加S锁，而不能加X锁，直到T释放A上的锁，这保证了其他事务可以读A，但在释放A上的S锁之前不能对A做任何修改。</p><p>2、排它锁 &#x2F; 独占锁（exclusive lock，即X锁）</p><p>排它锁（X）：又称写锁，允许获取排它锁的事物更新数据，阻止其他事务取得相同的数据集共享读锁和排它写锁，若事务T对数据对象A加上X锁，事物T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T 释放A上的锁</p><p>3、意向锁</p><p>事物B对一行数据使用行锁，当有另一个事物A对这个表使用了表锁，那么这个行锁就会升级为表锁，事务A在申请行锁（写锁）之前，数据库会自动先给事务A申请表的意向排他锁。当事务B去申请表的写锁时就会失败，因为表上有意向排他锁之后事务B申请表的写锁时会被阻塞。</p><p>当一个事务在需要获取资源的锁定时，如果该资源已经被排他锁占用，则数据库会自动给该事务申请一个该表的意向锁。如果自己需要一个共享锁定，就申请一个意向共享锁。如果需要的是某行（或者某些行）的排他锁定，则申请一个意向排他锁。</p><h4 id="4-5-加锁方式划分"><a href="#4-5-加锁方式划分" class="headerlink" title="4.5 加锁方式划分"></a>4.<strong>5 加锁方式划分</strong></h4><p>1、自动锁（ Automatic Locks）</p><p>当进行一项数据库操作时，缺省情况下，系统自动为此数据库操作获得所有有必要的锁。</p><p>自动锁分为三种：</p><p>DML 锁：</p><p>锁用于控制并发事务中的数据操纵，保证数据的一致性和完整性。</p><p>保护并发情况下的数据完整性。</p><p>语句能够自动地获得所需的表级锁（TM）与行级（事务）锁（TX）。</p><p>DDL 锁</p><p>锁用于保护数据库对象的结构，如表、索引等的结构定义。</p><p>排它 DDL 锁</p><p>创建、修改、删除一个数据库对象的 DDL 语句获得操作对象的 排它锁。</p><p>共享 DDL 锁</p><p>需在数据库对象之间建立相互依赖关系的 DDL 语句通常需共享获得 DDL锁。</p><p>如创建一个包，该包中的过程与函数引用了不同的数据库表，当编译此包时该事务就获得了引用表的共享 DDL 锁。如使用 alter table 语句时，为了维护数据的完成性、一致性、合法性，该事务获得一排它 DDL 锁</p><p>2.systemlocks 系统锁。</p><p>3.显示锁（LOCK TABLES ）</p><p>某些情况下，需要用户显示的锁定数据库操作要用到的数据，才能使数据库操作执行得更好，显示锁是用户为数据库对象设定的。</p><h4 id="4-6-锁的使用方式划分"><a href="#4-6-锁的使用方式划分" class="headerlink" title="4.6 锁的使用方式划分"></a>4.6 锁的使用方式划分</h4><p>1、乐观锁（Optimistic Lock）</p><p>乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。</p><p>2、悲观锁（Pessimistic Lock）</p><p>悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。</p><ol><li><h3 id="索引为什么用B-树，有什么特性"><a href="#索引为什么用B-树，有什么特性" class="headerlink" title="索引为什么用B+树，有什么特性"></a>索引为什么用B+树，有什么特性</h3></li></ol><p>首先，常规的数据库存储引擎，一般都是采用 B 树或者 B+树来实现索引的存储。 </p><p>因为 B 树是一种多路平衡树，用这种存储结构来存储大量数据，它的整个高度会相比二叉树来说矮很多。 而对于数据库来说，所有的数据必然都是存储在磁盘上的，而磁盘 IO 的效率实际上是 很低的，特别是在随机磁盘 IO 的情况下效率更低。 所以树的高度能够决定磁盘 IO 的次数，磁盘 IO 次数越少，对于性能的提升就越大，这 也是为什么采用 B 树作为索引存储结构的原因。</p><p>但是在 Mysql 的 InnoDB 存储引擎里面，它用了一种增强的 B 树结构，也就 </p><p>是 B+树来作为索引和数据的存储结构。 </p><p>相比较于 B 树结构，B+树做了几个方面的优化。 </p><p>\1.  B+树的所有数据都存储在叶子节点，非叶子节点只存储索引。 </p><p>\2. 叶子节点中的数据使用双向链表的方式进行关联</p><p>使用 B+树来实现索引的原因，我认为有几个方面。 </p><p>\3. B+树非叶子节点不存储数据，所以每一层能够存储的索引数量会增加，意味着 B+ 树在层高相同的情况下存储的数据量要比 B 树要多，使得磁盘 IO 次数更少。 </p><p>\4. 在 Mysql 里面，范围查询是一个比较常用的操作，而 B+树的所有存储在叶子节点的数据使用了双向链表来关联，所以在查询的时候只需查两个节点进行遍历就行，而 B 树需要获取所有节点，所以 B+树在范围查询上效率更高。 </p><p>\5. 在数据检索方面，由于所有的数据都存储在叶子节点，所以 B+树的 IO 次数会更加稳定一些。 </p><p>\6. 因为叶子节点存储所有数据，所以 B+树的全局扫描能力更强一些，因为它只需要扫描叶子节点。但是 B 树需要遍历整个树。 </p><p>另外，基于 B+树这样一种结构，如果采用自增的整型数据作为主键，还能更好的避免增加数据的时候，带来叶子节点分裂导致的大量运算的问题。 </p><p>总的来说，我认为技术方案的选型，更多的是去解决当前场景下的特定问题，并不一定是说 B+树就是最好的选择，就像MongoDB 里面采用B树结构，本质上来说，其实是关系型数据库和非关系型数据库的差异</p><ol><li><h3 id="创建索引需要考虑什么，索引优化有没有相关经验"><a href="#创建索引需要考虑什么，索引优化有没有相关经验" class="headerlink" title="创建索引需要考虑什么，索引优化有没有相关经验"></a>创建索引需要考虑什么，索引优化有没有相关经验</h3></li></ol><p>（1）MySQL 表主键设计</p><p>自增： 顺序存储，索引维护成本低，索引效率高；</p><p>UUID：非顺序增长，随机IO严重。</p><p>（2）索引并不是越多越好，要根据查询，有针对性的创建</p><p>（3）应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描；</p><p>（4）值分布很稀少的字段不适合建索引，例如“性别”这种只有两三个值的字段；</p><p>（5）不用外键，由程序保证约束；</p><p>（6）尽量不用UNIQUE，由程序保证约束；</p><p>（7）使用多列索引时注意顺序和查询条件保持一致，同时删除不必要的单列索引。</p><p>（8）排序时，排序字段需要注意index，尤其是关联查询排序时，尽可能使用小表的字段进行排序</p><p>SQL优化原则</p><p>（1）避免属性隐式转换 ， 如定义Moblie varchar where Moblie &#x3D;198989888会导致全表扫描；</p><p>（2）Where子句中条件字段本身避免使用函数；</p><p>（3）使用获取的必要字段代替SELECT *；</p><p>（4）批量插入，使用INSERT INTO table (col1,col2,…) VALUES (value1, value2,…),(value1, value2,…); 插入多条数据只有一次提交；</p><p>（5）避免使用长事务；</p><p>（6）禁止负向查询： NOT、！&#x3D;、&lt;&gt;、！&lt;、！&gt;、NOT IN、NOT LIKE，会导致全表扫描；</p><p>（7）大表之间的join，尽量缩小结果集之后再join，否则会消耗较多的内存和CPU；</p><p>（8）搜索严禁左模糊或者全模糊（like %XX, 或like %XX%），会导致全表扫描。</p><h3 id="7-用过linux吗？Linux的常用命令有哪些"><a href="#7-用过linux吗？Linux的常用命令有哪些" class="headerlink" title="7.用过linux吗？Linux的常用命令有哪些"></a>7.用过linux吗？Linux的常用命令有哪些</h3><p>切换用户（su）</p><p>切换目录（cd）</p><p>查看目录（ls）</p><p>创建目录（mkdir）</p><p>删除目录与文件（rm）</p><p>修改目录（mv）</p><p>拷贝目录（cp）</p><p>搜索目录（find）</p><p>查看当前目录（pwd）</p><p>新增文件（touch）</p><p>删除文件（rm）</p><p>编辑文件（vi、vim）</p><p>过滤文件(grep)</p><h2 id="滴滴-一面-二面"><a href="#滴滴-一面-二面" class="headerlink" title="滴滴 一面&amp;二面"></a>滴滴 一面&amp;二面</h2><ol><li><h3 id="说一下MySQL-优化有哪几方面"><a href="#说一下MySQL-优化有哪几方面" class="headerlink" title="说一下MySQL 优化有哪几方面"></a>说一下MySQL 优化有哪几方面</h3></li></ol><p>MySQL 的性能优化我认为可以分为 4 大部分 </p><p>硬件和操作系统层面的优化 </p><p>架构设计层面的优化 </p><p>MySQL 程序配置优化 </p><p>SQL 优化</p><p>从硬件层面来说，影响 Mysql 性能的因素有，CPU、可用内存大小、磁盘读写速度、 </p><p>网络带宽从操作系层面来说，应用文件句柄数、操作系统网络的配置都会影响到 Mysql 性能。 这部分的优化一般由 DBA 或者运维工程师去完成。</p><p>架构设计层面的优化 </p><p>MySQL 是一个磁盘 IO 访问量非常频繁的关系型数据库 </p><p>在高并发和高性能的场景中.MySQL 数据库必然会承受巨大的并发压力，而此时，我们 </p><p>的优化方式可以分为几个部分。 </p><p>\1. 搭建 Mysql 主从集群，单个 Mysql 服务容易单点故障，一旦服务器宕机，将会导 </p><p>致依赖 Mysql 数据库的应用全部无法响应。 主从集群或者主主集群可以保证服务 </p><p>的高可用性。 </p><p>\2. 读写分离设计，在读多写少的场景中，通过读写分离的方案，可以避免读写冲突导 </p><p>致的性能影响 </p><p>\3. 引入分库分表机制，通过分库可以降低单个服务器节点的 IO 压力，通过分表的方 </p><p>式可以降低单表数据量，从而提升 sql 查询的效率。 </p><p>\4. 针对热点数据，可以引入更为高效的分布式数据库，比如 Redis、MongoDB 等， </p><p>他们可以很好的缓解 Mysql 的访问压力，同时还能提升数据检索性能</p><p>MySQL 程序配置优化 </p><p>MySQL 是一个经过互联网大厂验证过的生产级别的成熟数据库，对于 Mysql 数据库本身的优化，一般是通过 Mysql 中的配置文件 my.cnf 来完成的，比如。 </p><p>Mysql5.7 版本默认的最大连接数是 151 个，这个值可以在 my.cnf 中修改。 </p><p>binlog 日志，默认是不开启 </p><p>缓存池 bufferpoll 的默认大小配置等。</p><p>由于这些配置一般都和用户安装的硬件环境以及使用场景有关系，因此这些配置官方只会提供一个默认值，具体情况还得由使用者来修改。 </p><p>关于配置项的修改，需要关注两个方面。 </p><p> 配置的作用域，分为会话级别和全局</p><p> 是否支持热加载 </p><p>因此，针对这两个点，我们需要注意的是： </p><p> 全局参数的设定对于已经存在的会话无法生效 </p><p> 会话参数的设定随着会话的销毁而失效 </p><p> 全局类的统一配置建议配置在默认配置文件中，否则重启服务会导致配置失效 </p><p>SQL 优化 </p><p>SQL 优化又能分为三步曲 </p><p> 第一、慢 SQL 的定位和排查 </p><p>我们可以通过慢查询日志和慢查询日志分析工具得到有问题的 SQL 列表。 </p><p> 第二、执行计划分析 </p><p>针对慢 SQL，我们可以使用关键字 explain 来查看当前 sql 的执行计划.可以重点关注type key rows filterd 等字段 ，从而定位该 SQL 执行慢的根本原因。再有的放矢的进 行优化 </p><p> 第三、使用 show profile 工具 </p><p>Show Profile 是 MySQL 提供的可以用来分析当前会话中，SQL 语句资源消耗情况的 工具，可用于 SQL 调优的测量。在当前会话中.默认情况下处于 show profile 是关闭状态，打开之后保存最近 15 次的运行结果 </p><p>针对运行慢的 SQL，通过 profile 工具进行详细分析.可以得到 SQL 执行过程中所有的 资源开销情况. 如 IO 开销,CPU 开销,内存开销等. </p><p>以上就是我对 MySQL 性能优化的理解。 </p><ol><li><h3 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h3></li></ol><p>\1. TCP 协议，是一种可靠的，基于字节流的，面向连接的传输层协议。 </p><p> 可靠性体现在 TCP 协议通信双方的数据传输是稳定的，即便是在网络不好的情 </p><p>况下，TCP 都能够保证数据传输到目标端，而这个可靠性是基于数据包确认机 </p><p>制来实现的。 </p><p> TCP 通信双方的数据传输是通过字节流来实现传输的 </p><p> 面向连接，是说数据传输之前，必须要建立一个连接，然后基于这个连接进行 </p><p>数据传输 </p><p>\2. 因为 TCP 是面向连接的协议，所以在进行数据通信之前，需要建立一个 </p><p>可靠的连接，TCP 采用了三次握手的方式来实现连接的建立</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ol><li><strong>第一次握手：</strong>建立连接时，客户端发送syn包（syn&#x3D;j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</li><li><strong>第二次握手：</strong>服务器收到syn包，必须确认客户的SYN（ack&#x3D;j+1），同时自己也发送一个SYN包（syn&#x3D;k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li><strong>第三次握手：</strong>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack&#x3D;k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MzcxNzU2OWZkZjgzNmZjNzNlOWIwYTQyMTg1NjBiMWZfR09DTHIwYkVJWHN6VlI3QjFvUDFxQkJISkZkVU0zdUxfVG9rZW46RWxhUGJpNUJFb3FTRm14Y0lVM2NHcVUybmVjXzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><h5 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h5><p>三次握手的意义在于确定双方都能够完成读写操作。</p><p>第一次握手，客户端发了个连接请求消息到服务端，服务端收到信息后知道自己与客户端是可以连接成功的，但此时客户端并不知道服务端是否已经接收到了它的请求，所以服务端接收到消息后的应答。客户端得到服务端的反馈后，才确定自己与服务端是可以连接上的，这就是第二次握手。而服务端发送出去的消息，要等客户端响应后，才能确定此次连接为有效连接。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>在完成数据交互之后，如果选择关闭连接，以回收资源，则完成四次挥手来进行“和平分手”。</p><ol><li><strong>第一次挥手：</strong>主动关闭方发送第一个包，其中FIN标志位为1，发送顺序号seq为X。</li><li><strong>第二次挥手：</strong>被动关闭方收到FIN包后发送第二个包，其中发送顺序号seq为Z，接收顺序号ack为X+1。</li><li><strong>第三次挥手：</strong>被动关闭方再发送第三个包，其中FIN标志位为1，发送顺序号seq为Y，接收顺序号ack为X。</li><li><strong>第四次挥手：</strong>主动关闭方发送第四个包，其中发送顺序号为X，接收顺序号为Y。至此，完成四次挥手。</li></ol><h5 id="为什么断开连接需要四次挥手？"><a href="#为什么断开连接需要四次挥手？" class="headerlink" title="为什么断开连接需要四次挥手？"></a>为什么断开连接需要四次挥手？</h5><p>三次握手是因为建立连接时，ACK和SYN可以放在一个报文里来发送。而关闭连接时，被动关闭方可能还需要发送一些数据后，再发送FIN报文表示同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。因此断开连接需要4次。</p><ol><li><h3 id="从输入URL到页面发生了什么"><a href="#从输入URL到页面发生了什么" class="headerlink" title="从输入URL到页面发生了什么"></a>从输入URL到页面发生了什么</h3></li></ol><p>总体来说分为以下几个步骤:</p><ol><li>在浏览器中输入指定网页的 URL。</li><li>浏览器通过 DNS 协议，获取域名对应的 IP 地址。</li><li>浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP 连接请求。</li><li>浏览器在 TCP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容。</li><li>服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器。</li><li>浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。</li><li>浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ODRmY2ZkYTAzNzFmOWU0NTA5ZjZkM2FmNTM2NzIxYjhfVkdpNmNNc1Q4QW4zVHFsYkFWMGE4M09KVnlxYVJCUjdfVG9rZW46UUlWbWJ2VFpHb2ZVdm54QmRiVmNtNlV2bkhiXzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><p>上图有一个错误需要注意：是 OSPF 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议, 是由 Internet 工程任务组开发的路由选择协议</p><ol><li><h3 id="用户态和内核态的区别"><a href="#用户态和内核态的区别" class="headerlink" title="用户态和内核态的区别"></a>用户态和内核态的区别</h3></li></ol><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p><ul><li>用户态(User Mode) : 用户态运行的进程可以直接读取用户程序的数据，拥有较低的权限。当应用程序需要执行某些需要特殊权限的操作，例如读写磁盘、网络通信等，就需要向操作系统发起系统调用请求，进入内核态。</li><li>内核态(Kernel Mode)：内核态运行的进程几乎可以访问计算机的任何资源包括系统的内存空间、设备、驱动程序等，不受限制，拥有非常高的权限。当操作系统接收到进程的系统调用请求时，就会从用户态切换到内核态，执行相应的系统调用，并将结果返回给进程，最后再从内核态切换回用户态。</li></ul><p>内核态相比用户态拥有更高的特权级别，因此能够执行更底层、更敏感的操作。不过，由于进入内核态需要付出较高的开销（需要进行一系列的上下文切换和权限检查），应该尽量减少进入内核态的次数，以提高系统的性能和稳定性。</p><h4 id="为什么要有用户态和内核态？只有一个内核态不行么？"><a href="#为什么要有用户态和内核态？只有一个内核态不行么？" class="headerlink" title="为什么要有用户态和内核态？只有一个内核态不行么？"></a>为什么要有用户态和内核态？只有一个内核态不行么？</h4><ul><li>在 CPU 的所有指令中，有一些指令是比较危险的比如内存分配、设置时钟、IO 处理等，如果所有的程序都能使用这些指令的话，会对系统的正常运行造成灾难性地影响。因此，我们需要限制这些危险指令只能内核态运行。这些只能由操作系统内核态执行的指令也被叫做 特权指令 。</li><li>如果计算机系统中只有一个内核态，那么所有程序或进程都必须共享系统资源，例如内存、CPU、硬盘等，这将导致系统资源的竞争和冲突，从而影响系统性能和效率。并且，这样也会让系统的安全性降低，毕竟所有程序或进程都具有相同的特权级别和访问权限。</li></ul><p>因此，同时具有用户态和内核态主要是为了保证计算机系统的安全性、稳定性和性能。</p><h4 id="用户态和内核态是如何切换的？"><a href="#用户态和内核态是如何切换的？" class="headerlink" title="用户态和内核态是如何切换的？"></a>用户态和内核态是如何切换的？</h4><p>用户态切换到内核态的 3 种方式：</p><ol><li>系统调用（Trap）：用户态进程 主动 要求切换到内核态的一种方式，主要是为了使用内核态才能做的事情比如读取磁盘资源。系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现。</li><li>中断（Interrupt）：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</li><li>异常（Exception）：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</li></ol><p>在系统的处理上，中断和异常类似，都是通过中断向量表来找到相应的处理程序进行处理。区别在于，中断来自处理器外部，不是由任何一条专门的指令造成，而异常是执行当前指令的结果。</p><ol><li><h3 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h3></li></ol><ul><li>进程（Process） 是指计算机中正在运行的一个程序实例。举例：你打开的微信就是一个进程。</li><li>线程（Thread） 也被称为轻量级进程，更加轻量。多个线程可以在同一个进程中同时执行，并且共享进程的资源比如内存空间、文件句柄、网络连接等。举例：你打开的微信里就有一个线程专门用来拉取别人发你的最新的消息</li><li>线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。</li><li>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</li><li>线程执行开销小，但不利于资源的管理和保护；而进程正相反。</li></ul><h4 id="有了进程为什么还需要线程"><a href="#有了进程为什么还需要线程" class="headerlink" title="有了进程为什么还需要线程?"></a>有了进程为什么还需要线程?</h4><ul><li>进程切换是一个开销很大的操作，线程切换的成本较低。</li><li>线程更轻量，一个进程可以创建多个线程。</li><li>多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题比如 IO 阻塞就会挂起直到结果返回。</li><li>同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核。</li></ul><ol><li><h3 id="HashSet和HashMap的区别和实现原理"><a href="#HashSet和HashMap的区别和实现原理" class="headerlink" title="HashSet和HashMap的区别和实现原理"></a>HashSet和HashMap的区别和实现原理</h3></li></ol><p>HashSet 底层就是基于 HashMap 实现的</p><p>以下是他们的区别</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=Yjc5YWI3MzhhNzVjNzAzN2QzZmU5YTllMTBiYjgyNDRfakZFTk5IUUJsdkJjRWJVTkhMVG03R3llS1ozRXZmZXlfVG9rZW46Q3pGcGJIM2w2b3V4blB4cEpsaGNIWWpubm1iXzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><h5 id="HashMap-和-TreeMap-区别"><a href="#HashMap-和-TreeMap-区别" class="headerlink" title="HashMap 和 TreeMap 区别"></a><strong>HashMap 和 TreeMap 区别</strong></h5><p>TreeMap 和HashMap 都继承自AbstractMap ，但是需要注意的是TreeMap它还实现了NavigableMap接口和SortedMap 接口。</p><p>相比于HashMap来说， TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</p><ol><li><h3 id="Sychoronized和Volatile的区别和解决了什么"><a href="#Sychoronized和Volatile的区别和解决了什么" class="headerlink" title="Sychoronized和Volatile的区别和解决了什么"></a>Sychoronized和Volatile的区别和解决了什么</h3></li></ol><p>synchronized 关键字和 volatile 关键字是两个互补的存在，而不是对立的存在！</p><ul><li>volatile 关键字是线程同步的轻量级实现，所以 volatile性能肯定比synchronized关键字要好 。但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块 。</li><li>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</li><li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性</li></ul><ol><li><h3 id="synchronized的锁升级过程"><a href="#synchronized的锁升级过程" class="headerlink" title="synchronized的锁升级过程"></a>synchronized的锁升级过程</h3></li></ol><p>在 jdk1.6 版本中，synchronized 增加了锁升级的机制，来平衡数据安全性和性能。 </p><p>简单来说，就是线程去访问 synchronized 同步代码块的时候，synchronized 根 </p><p>据线程竞争情况，会先尝试在不加重量级锁的情况下去保证线程安全性。所以引入了偏向锁和轻量级锁的机制。 偏向锁，就是直接把当前锁偏向于某个线程，简单来说就是通过 CAS 修改偏向锁标记， 这种锁适合同一个线程多次去申请同一个锁资源并且没有其他线程竞争的场景。 轻量级锁也可以称为自旋锁，基于自适应自旋的机制，通过多次自旋重试去竞争锁。自旋锁优点在于它避免避免了用户态到内核态的切换带来的性能开销。</p><p>Synchronized 引入了锁升级的机制之后，如果有线程去竞争锁： </p><p>首先，synchronized 会尝试使用偏向锁的方式去竞争锁资源，如果能够竞争到偏 </p><p>向锁，表示加锁成功直接返回。如果竞争锁失败，说明当前锁已经偏向了其他线程。 </p><p>需要将锁升级到轻量级锁，在轻量级锁状态下，竞争锁的线程根据自适应自旋次数 </p><p>去尝试抢占锁资源，如果在轻量级锁状态下还是没有竞争到锁， </p><p>就只能升级到重量级锁，在重量级锁状态下，没有竞争到锁的线程就会被阻塞，线 </p><p>程状态是 Blocked。 处于锁等待状态的线程需要等待获得锁的线程来触发唤醒</p><p>总的来说， Synchronized 的锁升级的设计思想，在我看来本质上是一种性能和安全性的平衡，也就是如何在不加锁的情况下能够保证线程安全性。</p><ol><li><h3 id="Synchronized是公平锁吗，ReetrantLock是怎么实现公平锁"><a href="#Synchronized是公平锁吗，ReetrantLock是怎么实现公平锁" class="headerlink" title="Synchronized是公平锁吗，ReetrantLock是怎么实现公平锁"></a>Synchronized是公平锁吗，ReetrantLock是怎么实现公平锁</h3></li></ol><p>不是</p><p>ReentrantLock 比 synchronized 增加了一些高级功能</p><p>相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：</p><p>等待可中断 : ReentrantLock提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</p><p>可实现公平锁 : ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)构造方法来指定是否是公平的。</p><p>可实现选择性通知（锁可以绑定多个条件）: synchronized关键字与wait()和notify()&#x2F;notifyAll()方法相结合可以实现等待&#x2F;通知机制。ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition()方法。</p><ol><li><h3 id="Java中对象的创建过程"><a href="#Java中对象的创建过程" class="headerlink" title="Java中对象的创建过程"></a>Java中对象的创建过程</h3></li></ol><h4 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程</p><h4 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h4><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><h4 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h4><p>初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="执行init方法"><a href="#执行init方法" class="headerlink" title="执行init方法"></a>执行init方法</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来</p><ol><li><h3 id="垃圾回收的过程"><a href="#垃圾回收的过程" class="headerlink" title="垃圾回收的过程"></a>垃圾回收的过程</h3></li><li><h3 id="CHAR和VARCHAR有什么区别"><a href="#CHAR和VARCHAR有什么区别" class="headerlink" title="CHAR和VARCHAR有什么区别"></a>CHAR和VARCHAR有什么区别</h3></li></ol><p>第一个，char 是一个固定长度的字符串，Varchar 是一个可变长度的字符串 </p><p>假设声明一个 char(10)的长度，如果存储字符串“abc”，虽然实际字符长度只有 3， </p><p>但是 char 还是会占 10 个字节长度。 </p><p>同样，如果用 varchar 存储，那它只会使用 3 个字符的实际长度来存储。 </p><p> 第二个，存储的效率不同，char 类型每次修改以后存储空间的长度不变，所以效率更高 varchar 每次修改数据都需要更新存储空间长度，效率较低 </p><p> 第三个，存储空间不同，char 不管实际数据大小，存储空间是固定的，而 varchar </p><p>存储空间等于实际数据长度， 所以 varchar 实际存储空间的使用要比 char 更小 </p><p>基于他们特性的分析，可以得出一个基本的结论： </p><p> char 适合存储比较短的且是固定长度的字符串 </p><p> varchar 适合存储可变长度的字符串 </p><ol><li><h3 id="介绍一下索引"><a href="#介绍一下索引" class="headerlink" title="介绍一下索引"></a>介绍一下索引</h3></li></ol><p>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</p><p>索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构</p><h4 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h4><p>优点：</p><ul><li>使用索引可以大大加快数据的检索速度（大大减少检索的数据量）, 减少 IO 次数，这也是创建索引的最主要的原因。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p>缺点：</p><ul><li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><p>但是，使用索引一定能提高查询性能吗?</p><p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p><h3 id="14介绍一下日志"><a href="#14介绍一下日志" class="headerlink" title="14介绍一下日志"></a>14介绍一下日志</h3><p>MySQL 日志 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志 binlog（归档日志）和事务日志 redo log（重做日志）和 undo log（回滚日志）</p><p>具体</p><p><a href="https://javaguide.cn/database/mysql/mysql-logs.html">MySQL三大日志(binlog、redo log和undo log)详解 | JavaGuide</a></p><ol><li>redolog如何保证持久性</li></ol><p>1.记录修改操作：当数据发生修改时，不是直接修改数据，而是在Redo log中先记录本次操作。这个操作是顺序写入的，速度非常快。</p><p>2.数据修改：在Redo log中记录操作后，再修改缓冲区中的数据。这一步是实际的数据修改</p><p>3.日志刷盘：在事务提交时或者提交前，通过调用fsync接口将Redo log写入磁盘。这一步是为了确保在数据库系统发生故障时，已经记录的修改操作不会丢失。</p><p>4.故障恢复：如果数据库系统发生故障并宕机，那么在重启时，系统会读取Redo log中的数据，根据这些日志对数据库进行恢复。由于Redo log是预写日志，它记录了所有已经提交的事务的修改操作，因此可以用来恢复数据库到一致的状态。通过这种方式，Redo log保证了即使在数据库系统发生故障并宕机的情况下，已经提交的事务的修改也不会丢失，从而满足了持久性的要求。同时，由于Redo log的顺序写入和快速恢复的特性，它也在一定程度上提高了数据库系统的性能。</p><ol><li><h3 id="能不能只用binLog不用redolog"><a href="#能不能只用binLog不用redolog" class="headerlink" title="能不能只用binLog不用redolog"></a>能不能只用binLog不用redolog</h3></li></ol><p>不能只用binlog而不用redo log。虽然binlog和redo log都是用于保证数据库持久性的重要机制，但它各自的作用和用途是不同的。</p><p>binlog(二进制日志)主要用于记录数据库的所有更改，包括数据修改和表结构变更等。它可以用于数据恢复和主从复制等场景。然而，binlog并不具备崩渍恢复的能力，也就是说，它不能单独用于在系统崩溃后恢复数据。</p><p>而redolog(重做日志)则主要用于保证事务的持久性。在数据库事务提交前，相关的修改操作会先写入redo log中，并在系统崩渍后利用这些日志来恢复数据。这样可以确保即使系统发生故障，已经提交的事务的修改也不会丢失。</p><p>因此，虽然binlog和redo log都是数据库持久性的重要保障，但它们各自的作用和用途是不同的。在实际应用中，通常会将它们结合使用，以确保数据库的特久性和可靠性。如果只使用binlog而不使用redo log,那么在系统崩渍后可能无法恢复已经提交的事务的修改，从而导致数据丢失。</p><ol><li><h3 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h3></li></ol><p>·  原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p><p>·  一致性（Consistency）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</p><p>·  隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</p><p>·  持久性（Durability）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p><ol><li><h3 id="四种事务隔离级别"><a href="#四种事务隔离级别" class="headerlink" title="四种事务隔离级别"></a>四种事务隔离级别</h3></li></ol><p>SQL 标准定义了四个隔离级别：</p><ul><li>READ-UNCOMMITTED(读取未提交) ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li>READ-COMMITTED(读取已提交) ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li>REPEATABLE-READ(可重复读) ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li>SERIALIZABLE(可串行化) ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YTMyMDA3OWFjNTQyMDUxZjdjNTEwZWVmMzY4NTdkZTRfTHM5ald4UlFxcVRSS05tVGRKbnJTMjhSb1RXWTZieWNfVG9rZW46RlpDOWJzcmVIbzFGVzZ4QnRRUmMzMjBnblZIXzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）</p><p>从上面对 SQL 标准定义了四个隔离级别的介绍可以看出，标准的 SQL 隔离级别定义里，REPEATABLE-READ(可重复读)是不可以防止幻读的。</p><p>但是！InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的，主要有下面两种情况：</p><ul><li>快照读：由 MVCC 机制来保证不出现幻读。</li><li>当前读：使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是行锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。</li></ul><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED ，但是你要知道的是 InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失。</p><p>InnoDB 存储引擎在分布式事务的情况下一般会用到 SERIALIZABLE 隔离级别。</p><ol><li><h3 id="update语句的具体执行流程"><a href="#update语句的具体执行流程" class="headerlink" title="update语句的具体执行流程"></a>update语句的具体执行流程</h3></li></ol><p>1.解析(Parsing):</p><p>客户端发送UPDATE语句到服务器。</p><p>服务器对SQL语句进行语法解析，生成解析树。</p><p>进行语义检查，例如检查表和列名是否存在，权限是否足够等。</p><p>2.预处理(Preprocessing):</p><p>生成执行计划(Execution Plan)。优化器会决定如何高效地执行这个UPDATE语句，例如选择哪个索引，如何进行数据查找等。确定影响的行数，这会影响到后续操作（如锁的数量）。</p><p>3.锁定(Locking):</p><p>根据优化器生成的执行计划，确定需要锁定哪些行或表。</p><p>如果是InnoDB存储擎，它会在事务开始时使用行锁或表锁来确保数据的一致性。</p><p>4.执行(Execution):</p><p>根据解析和预处理的结果，开始实际的数据更新操作。</p><p>遍历每一行（或者通过索引直接定位到某些行），应用UPDATE语句中的修改。</p><p>对于每一行，MySQL会先检查该行是否满足UPDATE语句的WHERE条件，如果满足则进行更新。</p><p>5.写入redo log(如果是InnoDB):</p><p>在数据实际更新到磁盘之前，InnoDB会先将这个更新操作记泉到redo log中。</p><p>redo log是循环写的，当达到一定大小时会从头开始写。</p><p>6.更新数据页（如果是InnoDB):</p><p>将数据实际更新到内存中的缓冲池中。</p><p>如果这个修改导致数据页变得不整洁（比如半满或者混合了新旧版本的数据），可能会触发页合并或者页分裂的操作。</p><p>7.写入binlog(如果是配置了的话)：</p><p>将这次UPDATE操作的信息写入到binlog中。</p><p>binlog是MySQL用于复制和恢复的数据日志。</p><p>8.提交事务(Commit):</p><p>如果[PDATE语句在事务中执行，那么在所有的更新操作都成功之后，事务会被提交。</p><p>在事务提交时，M小ySQL会将redo log和binlog都刷新到磁盘上，确保数据的持久性。</p><p>如果使用了两阶段提交协议，在提交阶段还会进行额砂外的检查和日志写入。</p><p>9.返回结果：</p><p>客户端接收更新操作的结果，包括更新的行数等信息。</p><p>10.清理(Cleanup):</p><p>释放相关的锁和资源。</p><ol><li><h3 id="如果有一个字段是status值为0或者1，适合建索引吗"><a href="#如果有一个字段是status值为0或者1，适合建索引吗" class="headerlink" title="如果有一个字段是status值为0或者1，适合建索引吗"></a>如果有一个字段是status值为0或者1，适合建索引吗</h3></li></ol><p>假设表中有一千万条记录，某个状态为0的记录总数大概有100条，那么你想查询状态为0的记录时，有没有索引影响非常大，而查询状态为1的记录，则索引基本无用。如果两种状态的记录数相差无几的话，索引也基本无用</p><p>假设表中有一千万条记录，某个状态为0的记录总数大概会有100条，就在这个状态列建立索引其他两种情况不需要建立索引，毕竟索引空间消耗不小的</p><ol><li><h3 id="redis的zset底层是怎么实现的"><a href="#redis的zset底层是怎么实现的" class="headerlink" title="redis的zset底层是怎么实现的"></a>redis的zset底层是怎么实现的</h3></li></ol><p>因为设计者考虑到 Redis 数据存放于内存，为了节约宝贵的内存空间在</p><ol><li>ZSet 保存的键值对数量少于 128 个；</li><li>每个元素的长度小于 64 字节。</li></ol><p>会使用 ziplist一旦有序集合中的某个元素超出这两个其中的一个阈值它就会转为 <strong>skiplist</strong>（实际是 dict+skiplist，还会借用字典来提高获取指定元素的效率）。</p><h2 id="某厂java后端实习一面"><a href="#某厂java后端实习一面" class="headerlink" title="某厂java后端实习一面"></a>某厂java后端实习一面</h2><ol><li><h3 id="两个对象的HashCode相同会怎么样"><a href="#两个对象的HashCode相同会怎么样" class="headerlink" title="两个对象的HashCode相同会怎么样"></a>两个对象的HashCode相同会怎么样</h3></li></ol><p>hashCode() 和 equals()都是用于比较两个对象是否相等。</p><p>那为什么 JDK 还要同时提供这两个方法呢？</p><p>这是因为在一些容器（比如 HashMap、HashSet）中，有了 hashCode() 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进HashSet的过程）！</p><p>我们在前面也提到了添加元素进HashSet的过程，如果 HashSet 在对比的时候，同样的 hashCode 有多个对象，它会继续使用 equals() 来判断是否真的相同。也就是说 hashCode 帮助我们大大缩小了查找成本。</p><p>那为什么不只提供 hashCode() 方法呢？</p><p>这是因为两个对象的hashCode 值相等并不代表两个对象就相等。</p><p>那为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？</p><p>因为 hashCode() 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 hashCode )。</p><p>总结下来就是：</p><ul><li>如果两个对象的hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的hashCode 值相等并且equals()方法也返回 true，我们才认为这两个对象相等。</li><li>如果两个对象的hashCode 值不相等，我们就可以直接认为这两个对象不相等。</li></ul><ol><li><h3 id="线程池的参数及工作原理"><a href="#线程池的参数及工作原理" class="headerlink" title="线程池的参数及工作原理"></a>线程池的参数及工作原理</h3></li></ol><p>ThreadPoolExecutor 3 个最重要的参数：</p><ul><li>corePoolSize : 核心线程数量，任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li>maximumPoolSize : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li>workQueue（工作队列）: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p>ThreadPoolExecutor其他常见参数 :</p><ul><li>keepAliveTime（空闲线程存活时间）:线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁。</li><li>unit : keepAliveTime 参数的时间单位。</li><li>threadFactory（线程工厂） :executor 创建新线程的时候会用到。</li><li>handler :拒绝策略</li></ul><ol><li><h3 id="AQS有了解吗，说一下加锁的过程"><a href="#AQS有了解吗，说一下加锁的过程" class="headerlink" title="AQS有了解吗，说一下加锁的过程"></a>AQS有了解吗，说一下加锁的过程</h3></li></ol><p>AQS 是多线程同步器，它是 J.U.C 包中多个组件的底层实现，如 Lock、 </p><p>CountDownLatch、Semaphore 等都用到了 AQS. </p><p>从本质上来说，AQS 提供了两种锁机制，分别是排它锁，和 共享锁。 </p><p>排它锁，就是存在多线程竞争同一共享资源时，同一时刻只允许一个线程访问该共享资 </p><p>源，也就是多个线程中只能有一个线程获得锁资源，比如 Lock 中的 ReentrantLock 重 </p><p>入锁实现就是用到了 AQS 中的排它锁功能。 </p><p>共享锁也称为读锁，就是在同一时刻允许多个线程同时获得锁资源，比如 </p><p>CountDownLatch 和 Semaphore 都是用到了 AQS 中的共享锁功能。</p><p><a href="https://javaguide.cn/java/concurrent/aqs.html">AQS 详解 | JavaGuide</a></p><ol><li><h3 id="聚簇索引和非聚簇索引的区别"><a href="#聚簇索引和非聚簇索引的区别" class="headerlink" title="聚簇索引和非聚簇索引的区别"></a>聚簇索引和非聚簇索引的区别</h3></li></ol><p>聚簇索引（Clustered Index）即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。</p><p>优点：</p><ul><li>查询速度非常快：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。</li><li>对排序查找和范围查找优化：聚簇索引对于主键的排序查找和范围查找速度非常快。</li></ul><p>缺点：</p><ul><li>依赖于有序的数据：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li>更新代价大：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的</li></ul><p>非聚簇索引(Non-Clustered Index)即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</p><p>非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</p><p>优点：</p><p>更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的。</p><p>缺点：</p><ul><li>依赖于有序的数据:跟聚簇索引一样，非聚簇索引也依赖于有序的数据</li><li>可能会二次查询(回表):这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li></ul><h2 id="携程后端一面"><a href="#携程后端一面" class="headerlink" title="携程后端一面"></a>携程后端一面</h2><h3 id="1-ArratList和LinkList的区别"><a href="#1-ArratList和LinkList的区别" class="headerlink" title="1.ArratList和LinkList的区别"></a>1.ArratList和LinkList的区别</h3><ul><li>是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li><li>底层数据结构： ArrayList 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li>插入和删除是否受元素位置的影响：</li><li>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位&#x2F;向前移一位的操作。</li><li>LinkedList 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst()、 removeLast()），时间复杂度为 O(1)，如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o),remove(int index)）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。</li><li>·  是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList（实现了 RandomAccess 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。</li><li>·  内存空间占用： ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul><ol><li><h3 id="JVM双亲委派机制"><a href="#JVM双亲委派机制" class="headerlink" title="JVM双亲委派机制"></a>JVM双亲委派机制</h3></li></ol><p>首先，我简单说一下类的加载机制，就是我们自己写的 java 源文件到最终运行，必须要经过编译和类加载两个阶段。 </p><p>编译的过程就是把.java 文件编译成.class 文件。</p><p>类加载的过程，就是把 class 文件装载到 JVM 内存中，装载完成以后就会得到一个 Class 对象，我们就可以使用 new 关键字来实例化这个对象。</p><p>而类的加载过程，需要涉及到类加载器。 </p><p>JVM 在运行的时候，会产生 3 个类加载器，这三个类加载器组成了一个层级关系 </p><p>每个类加载器分别去加载不同作用范围的 jar 包，比如 </p><ul><li>Bootstrap ClassLoader，主要是负责 Java 核心类库的加载，也就是 %{JDK_HOME}\lib 下的 rt.jar、resources.jar 等 </li><li>Extension ClassLoader，主要负责%{JDK_HOME}\lib\ext 目录下的 jar 包和 class 文件 </li><li>Application ClassLoader，主要负责当前应用里面的 classpath 下的所有 jar 包和类文件</li></ul><p>除了系统自己提供的类加载器以外，还可以通过 ClassLoader 类实现自定义加载器，去满足一些特殊场景的需求</p><p>所谓的父委托模型，就是按照类加载器的层级关系，逐层进行委派。 </p><p>比如当需要加载一个 class 文件的时候，首先会把这个 class 的查询和加载委派给父加 载器去执行，如果父加载器都无法加载，再尝试自己来加载这个 class。</p><p>这样设计的好处，我认为有几个。 </p><p>\1. 安全性，因为这种层级关系实际上代表的是一种优先级，也就是所有的类的加载， </p><p>优先给 Bootstrap ClassLoader。那对于核心类库中的类，就没办法去破坏，比如 </p><p>自己写一个 java.lang.String，最终还是会交给启动类加载器。再加上每个类加载 </p><p>器的作用范围，那么自己写的 java.lang.String 就没办法去覆盖类库中类。 </p><p>\2. 我认为这种层级关系的设计，可以避免重复加载导致程序混乱的问题，因为如果父加载器已经加载过了，那么子类就没必要去加载了。 </p><ol><li><h3 id="创建线程的方式有哪几种"><a href="#创建线程的方式有哪几种" class="headerlink" title="创建线程的方式有哪几种"></a>创建线程的方式有哪几种</h3></li></ol><p>一般来说，创建线程有很多种方式，例如继承Thread类、实现Runnable接口、实现Callable接口、使用线程池、使用CompletableFuture类等等。</p><p>不过，这些方式其实并没有真正创建出线程。准确点来说，这些都属于是在 Java 代码中使用多线程的方法。严格来说，Java 就只有一种方式可以创建线程，那就是通过new Thread().start()创建。不管是哪种方式，最终还是依赖于new Thread().start()。</p><p><a href="https://mp.weixin.qq.com/s/NspUsyhEmKnJ-4OprRFp9g">大家都说Java有三种创建线程的方式！并发编程中的惊天骗局！ (qq.com)</a></p><ol><li><h3 id="了解线程池吗"><a href="#了解线程池吗" class="headerlink" title="了解线程池吗"></a>了解线程池吗</h3></li></ol><p>什么是线程池?</p><p>顾名思义，线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p><p>为什么要用线程池？</p><p>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、HTTP 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p><p>线程池提供了一种限制和管理资源（包括执行一个任务）的方式。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p><p>这里借用《Java 并发编程的艺术》提到的来说一下使用线程池的好处：</p><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><p>如何创建线程池？</p><p>方式一：通过ThreadPoolExecutor构造函数来创建（推荐）。</p><p>方式二：通过 Executor 框架的工具类 Executors 来创建。</p><p>可以看出，通过Executors工具类可以创建多种类型的线程池，包括：</p><p>FixedThreadPool：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p><p>SingleThreadExecutor： 只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</p><p>CachedThreadPool： 可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</p><p>ScheduledThreadPool：给定的延迟后运行任务或者定期执行任务的线程池。</p><ol><li><h3 id="Session和cookie的区别"><a href="#Session和cookie的区别" class="headerlink" title="Session和cookie的区别"></a>Session和cookie的区别</h3></li></ol><p>Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><p>Cookie 一般用来保存用户信息 比如 ① 我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；② 一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③ 登录一次网站后访问网站其他页面不需要重新登录。Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果使用Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><ol><li><h3 id="解释一下SpringIOC和AOP的原理"><a href="#解释一下SpringIOC和AOP的原理" class="headerlink" title="解释一下SpringIOC和AOP的原理"></a>解释一下SpringIOC和AOP的原理</h3></li></ol><p><a href="https://javaguide.cn/system-design/framework/spring/ioc-and-aop.html">IOC &amp; AOP详解（快速搞懂） | JavaGuide</a></p><h2 id="淘天java暑期一面"><a href="#淘天java暑期一面" class="headerlink" title="淘天java暑期一面"></a>淘天java暑期一面</h2><ol><li><h3 id="封装，继承，多态"><a href="#封装，继承，多态" class="headerlink" title="封装，继承，多态"></a>封装，继承，多态</h3></li></ol><p>封装</p><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p><p>继承</p><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p><p>关于继承如下 3 点请记住：</p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ol><p>多态</p><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><p>多态的特点:</p><ul><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul><ol><li><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3></li></ol><p>接口和抽象类有什么共同点和区别？</p><p>共同点：</p><ul><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。</li></ul><p>区别：</p><ul><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li></ul><ol><li><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3></li></ol><p><a href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html">JVM垃圾回收详解（重点） | JavaGuide</a></p><ol><li><h3 id="java的引用计数"><a href="#java的引用计数" class="headerlink" title="java的引用计数"></a>java的引用计数</h3></li></ol><p>死亡对象判断方法</p><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p><p>引用计数法</p><p>给对象中添加一个引用计数器：</p><ul><li>每当有一个地方引用它，计数器就加 1；</li><li>当引用失效，计数器就减 1；</li><li>任何时候计数器为 0 的对象就是不可能再被使用的。</li></ul><p>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。</p><p>可达性分析算法</p><p>这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><p>哪些对象可以作为 GC Roots 呢？</p><ul><li>虚拟机栈(栈帧中的局部变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li><li>JNI（Java Native Interface）引用的对象</li></ul><p>对象可以被回收，就代表一定会被回收吗？</p><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p><p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><ol><li><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3></li></ol><p>ThreadLocal 内存泄露问题是怎么导致的？</p><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p><p>这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后最好手动调用remove()方法</p><ol><li><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3></li></ol><p><a href="https://javaguide.cn/cs-basics/algorithms/10-classical-sorting-algorithms.html">十大经典排序算法总结 | JavaGuide</a></p><ol><li><h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3></li></ol><p>4.1 为什么要有虚拟内存？ | 小林coding (xiaolincoding.com)</p><ol><li><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3></li></ol><p>什么是泛型？有什么作用？</p><p>Java 泛型（Generics） 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。</p><p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 ArrayList<Person> persons &#x3D; new ArrayList<Person>() 这行代码就指明了该 ArrayList 对象只能传入 Person 对象，如果传入其他类型的对象就会报错。</p><p>泛型的使用方式有哪几种？</p><p>泛型一般有三种使用方式：泛型类、泛型接口、泛型方法。</p><ol><li><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><ul><li>并发：两个及两个以上的作业在同一 时间段 内执行。</li><li>并行：两个及两个以上的作业在同一 时刻 执行。</li></ul></li></ol><p>同步和异步</p><ul><li>同步：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li><li>异步：调用在发出之后，不用等待返回结果，该调用直接返回。</li></ul><ol><li><h3 id="操作系统的底层逻辑"><a href="#操作系统的底层逻辑" class="headerlink" title="操作系统的底层逻辑"></a>操作系统的底层逻辑</h3></li></ol><p><a href="https://xiaolincoding.com/os/2_os_structure/linux_vs_windows.html">3.1 Linux 内核 vs Windows 内核 | 小林coding (xiaolincoding.com)</a></p><ol><li><h3 id="linux软链接和硬链接"><a href="#linux软链接和硬链接" class="headerlink" title="linux软链接和硬链接"></a>linux软链接和硬链接</h3></li></ol><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p><p>硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</p><p>软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p><p>7.1 文件系统全家桶 | 小林coding (xiaolincoding.com)</p><h3 id="12-git的指令"><a href="#12-git的指令" class="headerlink" title="12.git的指令"></a>12.git的指令</h3><p><a href="https://javaguide.cn/tools/git/git-intro.html">Git核心概念总结 | JavaGuide</a></p><h3 id="13-MVCC"><a href="#13-MVCC" class="headerlink" title="13.MVCC"></a>13.MVCC</h3><p><a href="https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html">InnoDB存储引擎对MVCC的实现 | JavaGuide</a></p><h2 id="飞书一面"><a href="#飞书一面" class="headerlink" title="飞书一面"></a>飞书一面</h2><ol><li><h3 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h3></li><li><h3 id="抽象类可以被实例化吗"><a href="#抽象类可以被实例化吗" class="headerlink" title="抽象类可以被实例化吗"></a>抽象类可以被实例化吗</h3></li><li><h3 id="聊一下双亲委派机制"><a href="#聊一下双亲委派机制" class="headerlink" title="聊一下双亲委派机制"></a>聊一下双亲委派机制</h3></li><li><h3 id="有几种类型的类加载器，都具体是干什么的"><a href="#有几种类型的类加载器，都具体是干什么的" class="headerlink" title="有几种类型的类加载器，都具体是干什么的"></a>有几种类型的类加载器，都具体是干什么的</h3></li></ol><p>JVM 中内置了三个重要的 ClassLoader：</p><ol><li>BootstrapClassLoader(启动类加载器)：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ %JAVA_HOME%&#x2F;lib目录下的 rt.jar、resources.jar、charsets.jar等 jar 包和类）以及被 -Xbootclasspath参数指定的路径下的所有类。</li><li>ExtensionClassLoader(扩展类加载器)：主要负责加载 %JRE_HOME%&#x2F;lib&#x2F;ext 目录下的 jar 包和类以及被 java.ext.dirs 系统变量所指定的路径下的所有类。</li><li>AppClassLoader(应用程序类加载器)：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li></ol><p>类加载器详解（重点） | JavaGuide</p><h3 id="5-java中有哪些类型的锁"><a href="#5-java中有哪些类型的锁" class="headerlink" title="5.java中有哪些类型的锁"></a>5.java中有哪些类型的锁</h3><p><a href="https://blog.csdn.net/xingchensuiyue/article/details/108716466">Java中常见的各种锁（非常全）_java滑块锁-CSDN博客</a>、</p><p><a href="https://blog.csdn.net/Pireley/article/details/136375023">Java进阶（锁）——锁分类总结，Java中常用的锁的介绍_java锁-CSDN博客</a></p><h3 id="6-synchronized的偏向锁和自旋锁是怎么实现的"><a href="#6-synchronized的偏向锁和自旋锁是怎么实现的" class="headerlink" title="6.synchronized的偏向锁和自旋锁是怎么实现的"></a>6.synchronized的偏向锁和自旋锁是怎么实现的</h3><p><a href="https://blog.csdn.net/Kirito_j/article/details/79201213">Synchronized的原理及自旋锁，偏向锁，轻量级锁，重量级锁的区别_synchronize原理, 旋锁等 系列锁-CSDN博客</a></p><p>Java并发常见面试题总结（中） | JavaGuide</p><ol><li><h3 id="偏向锁存线程的消息存在哪"><a href="#偏向锁存线程的消息存在哪" class="headerlink" title="偏向锁存线程的消息存在哪"></a>偏向锁存线程的消息存在哪</h3></li></ol><p><a href="https://blog.csdn.net/cckevincyh/article/details/117251020">Java锁synchronized关键字学习系列之偏向锁_偏向锁如何判断是否同一线程-CSDN博客</a></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YzNlNzM4Yjg4NWZiZDY3N2UzOTBkNzRkN2NhNWI3YjhfT2dmMFM0d29xdlZGTTVxeU92SlJ0NDNBMXNBMkpHUGdfVG9rZW46U1B4OWJkTUxrb2w5emJ4bG5uVGNxVmdvbklmXzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><ol><li><h3 id="java对象头里面有什么"><a href="#java对象头里面有什么" class="headerlink" title="java对象头里面有什么"></a>java对象头里面有什么</h3></li></ol><p><a href="https://blog.csdn.net/lkforce/article/details/81128115">Java的对象头和对象组成详解-CSDN博客</a></p><ol><li><h3 id="计算机网络的分层模型说一下，每个层有什么协议"><a href="#计算机网络的分层模型说一下，每个层有什么协议" class="headerlink" title="计算机网络的分层模型说一下，每个层有什么协议"></a>计算机网络的分层模型说一下，每个层有什么协议</h3></li></ol><p>计算机网络常见面试题总结(上) | JavaGuide</p><ol><li><h3 id="tcp如何实现可靠传输"><a href="#tcp如何实现可靠传输" class="headerlink" title="tcp如何实现可靠传输"></a>tcp如何实现可靠传输</h3></li><li><h3 id="流量控制则被么实现TCP-传输可靠性保障（传输层）-JavaGuide"><a href="#流量控制则被么实现TCP-传输可靠性保障（传输层）-JavaGuide" class="headerlink" title="流量控制则被么实现TCP 传输可靠性保障（传输层） | JavaGuide"></a>流量控制则被么实现TCP 传输可靠性保障（传输层） | JavaGuide</h3></li><li><h3 id="什么是SYN攻击"><a href="#什么是SYN攻击" class="headerlink" title="什么是SYN攻击"></a>什么是SYN攻击</h3></li></ol><p>网络攻击常见手段总结 | JavaGuide</p><ol><li><h3 id="http常见的头部，头部里面有哪些键，content-length作用"><a href="#http常见的头部，头部里面有哪些键，content-length作用" class="headerlink" title="http常见的头部，头部里面有哪些键，content-length作用"></a>http常见的头部，头部里面有哪些键，content-length作用</h3></li></ol><p>面试官：说说 HTTP 常见的请求头有哪些? 作用？ | web前端面试 - 面试官系列 (vue3js.cn)</p><ol><li><h3 id="utf-8和unicode什么区别"><a href="#utf-8和unicode什么区别" class="headerlink" title="utf-8和unicode什么区别"></a>utf-8和unicode什么区别</h3></li></ol><p>字符集详解 | JavaGuide</p><ol><li><h3 id="进程包含什么"><a href="#进程包含什么" class="headerlink" title="进程包含什么"></a>进程包含什么</h3></li></ol><p>操作系统常见面试题总结(上) | JavaGuide</p><ol><li><h3 id="redis中有哪些数据结构"><a href="#redis中有哪些数据结构" class="headerlink" title="redis中有哪些数据结构"></a>redis中有哪些数据结构</h3></li><li><h3 id="zset是如何实现有序的"><a href="#zset是如何实现有序的" class="headerlink" title="zset是如何实现有序的"></a>zset是如何实现有序的</h3></li><li><h3 id="跳表怎么维护平衡"><a href="#跳表怎么维护平衡" class="headerlink" title="跳表怎么维护平衡"></a>跳表怎么维护平衡</h3></li></ol><p>Redis 数据结构 | 小林coding (xiaolincoding.com)</p><ol><li><h3 id="redis新节点加入集群会发生什么"><a href="#redis新节点加入集群会发生什么" class="headerlink" title="redis新节点加入集群会发生什么"></a>redis新节点加入集群会发生什么</h3></li><li><h3 id="从节点怎么跟主节点同步数据"><a href="#从节点怎么跟主节点同步数据" class="headerlink" title="从节点怎么跟主节点同步数据"></a>从节点怎么跟主节点同步数据</h3></li></ol><p>为什么要有哨兵？ | 小林coding (xiaolincoding.com)</p><ol><li><h3 id="写操作日志记录什么"><a href="#写操作日志记录什么" class="headerlink" title="写操作日志记录什么"></a>写操作日志记录什么</h3></li></ol><p><a href="https://blog.csdn.net/qingyangcc123/article/details/106724306">如何使用Redis来记录日志？_redis log_recent-CSDN博客</a></p><h2 id="鹅厂CSIG"><a href="#鹅厂CSIG" class="headerlink" title="鹅厂CSIG"></a>鹅厂CSIG</h2><ol><li><h3 id="java的hashMap底层数据结构"><a href="#java的hashMap底层数据结构" class="headerlink" title="java的hashMap底层数据结构"></a>java的hashMap底层数据结构</h3></li></ol><p>我从三个方面讲一下它</p><p>1.HashMap 中的关键属性—看-HashMap 的源码片段，可以知道它的几个属性</p><p>第一个属性 loadFactor，它是负载因子，默认值是 0.75，表示扩容前。</p><p>第二个属性 threshold 它是记录 HashMap 所能容纳的键值对的临界值，它的计算规 则是负载因子乘以数组长度。 </p><p>第三个属性 size，它用来记录 HashMap 实际存在的键值对的数量。 </p><p>第四个属性 modCount，它用来记录 HashMap 内部结构发生变化的次数。 </p><p>第五个是常量属性 DEFAULT_INITIAL_CAPACITY ，它规定 的默认容量是 16。</p><p>2、HashMap 的存储结构</p><p>HashMap 采用的是K-V 的存储结构。HashMap 的数组部分称为 Hash 桶，数组元素保存 在一个叫做 table 的属性中。jdk1.8以后当链表长度大于等于 8 时，链表数据将会以红黑树的形式进行存储，当长度降到 6 时，又会转成链表形式存储。</p><p>每个 Node 节点，保存了用来定位数组索引位置的 hash 值、Key、Value 和链表指向 的下一个 Node 节点。而 Node 类是 HashMap 的内部类，它实现了 Map.Entry 接口， 它的本质其实可以简单的理解成就是一个键值对。</p><ol><li>HashMap 的工作原理</li></ol><p>首先，通过hash算法计算出key的hashcode值，然后根据数组长度取模，得到在数组中的位置。</p><p>如果该位置上没有元素，则直接将key-value存储在该位置上。</p><p>如果该位置上已经存在元素，则需要进行链表或红黑树的操作。</p><p>如果链表长度小于8，则采用链表存储，将新元素插入到链表尾部。</p><p>如果链表长度大于等于8，则将链表转化为红黑树进行存储。</p><p>当数组长度达到阈值时（默认为0.75），需要进行扩容操作，将数组长度扩大为原来的两倍，并将原有元素重新分布到新数组中。</p><p>当数组中的元素数量小于阈值的0.25时，会进行缩容操作，将数组长度缩小为原来的一半。</p><ol><li><h3 id="concurrentHashMap是怎么保证线程安全的"><a href="#concurrentHashMap是怎么保证线程安全的" class="headerlink" title="concurrentHashMap是怎么保证线程安全的"></a>concurrentHashMap是怎么保证线程安全的</h3></li></ol><p>我们知道 HashMap 不是线程安全的，在并发场景下如果要保证一种可行的方式是使用 Collections.synchronizedMap() 方法来包装我们的 HashMap。但这是通过使用一个全局的锁来同步不同线程间的并发访问，因此会带来不可忽视的性能问题。</p><p>所以就有了 HashMap 的线程安全版本—— ConcurrentHashMap 的诞生。</p><p>Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。</p><p>Java8 中的 ConcurrentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 Segment 数组 + HashEntry 数组 + 链表 进化成了 Node 数组 + 链表 &#x2F; 红黑树，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。<a href="https://javaguide.cn/java/collection/concurrent-hash-map-source-code.html">ConcurrentHashMap 源码分析 | JavaGuide</a></p><ol><li><h3 id="java锁框架介绍一下-AQS"><a href="#java锁框架介绍一下-AQS" class="headerlink" title="java锁框架介绍一下  AQS"></a>java锁框架介绍一下  AQS</h3></li></ol><p>AQS 是多线程同步器，它是 J.U.C 包中多个组件的底层实现，如 Lock、 </p><p>CountDownLatch、Semaphore 等都用到了 AQS. </p><p>从本质上来说，AQS 提供了两种锁机制，分别是排它锁，和 共享锁。 </p><p>排它锁，就是存在多线程竞争同一共享资源时，同一时刻只允许一个线程访问该共享资 </p><p>源，也就是多个线程中只能有一个线程获得锁资源，比如 Lock 中的 ReentrantLock 重 </p><p>入锁实现就是用到了 AQS 中的排它锁功能。 </p><p>共享锁也称为读锁，就是在同一时刻允许多个线程同时获得锁资源，比如 </p><p>CountDownLatch 和 Semaphore 都是用到了 AQS 中的共享锁功能。</p><p><a href="https://javaguide.cn/java/concurrent/aqs.html">AQS 详解 | JavaGuide</a></p><ol><li><h3 id="java垃圾回收是怎么做的"><a href="#java垃圾回收是怎么做的" class="headerlink" title="java垃圾回收是怎么做的"></a>java垃圾回收是怎么做的</h3></li></ol><p><a href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html">JVM垃圾回收详解（重点） | JavaGuide</a></p><ol><li><h3 id="Spring的核心思想IOC和AOP"><a href="#Spring的核心思想IOC和AOP" class="headerlink" title="Spring的核心思想IOC和AOP"></a>Spring的核心思想IOC和AOP</h3></li></ol><p>IoC （Inversion of Control ）即控制反转&#x2F;反转控制。它是一种思想不是一个技术实现。描述的是：Java 开发领域对象的创建以及管理的问题。</p><p>·  传统的开发方式 ：往往是在类 A 中手动通过 new 关键字来 new 一个 B 的对象出来</p><p>·  使用 IoC 思想的开发方式 ：不通过 new 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面去取即可。</p><p>IoC 的思想就是两方之间不互相依赖，由第三方容器来管理相关资源。这样有什么好处呢？</p><ol><li>对象之间的耦合度或者说依赖程度降低；</li><li>资源变的容易管理；比如你用 Spring 容器提供的话很容易就可以实现一个单例。</li></ol><p>什么是 AOP？</p><p>AOP（Aspect Oriented Programming）即面向切面编程，AOP 是 OOP（面向对象编程）的一种延续，二者互补，并不对立。</p><p>AOP 的目的是将横切关注点（如日志记录、事务管理、权限控制、接口限流、接口幂等等）从核心业务逻辑中分离出来，通过动态代理、字节码操作等技术，实现代码的复用和解耦，提高代码的可维护性和可扩展性。OOP 的目的是将业务逻辑按照对象的属性和行为进行封装，通过类、对象、继承、多态等概念，实现代码的模块化和层次化（也能实现代码的复用），提高代码的可读性和可维护性</p><p>详见</p><p><a href="https://javaguide.cn/system-design/framework/spring/ioc-and-aop.html">IoC &amp; AOP详解（快速搞懂） | JavaGuide</a></p><h2 id="讯飞消费者java日常实习"><a href="#讯飞消费者java日常实习" class="headerlink" title="讯飞消费者java日常实习"></a>讯飞消费者java日常实习</h2><ol><li><h3 id="jvm内存划分"><a href="#jvm内存划分" class="headerlink" title="jvm内存划分"></a>jvm内存划分</h3></li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2I0NmU2MThjMzljOWI0N2NiMGQ2YmU3YjQ5ZjJjNjJfUnBEeXRJTFlTMjRsNlIzblE5MTJ4eDkzSnNiVmtDYUtfVG9rZW46Q0dxdmJQUE1wb2djZXd4dElRSWNnZ3Q1bk9oXzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><p>Java堆</p><p>Java堆是java虚拟机所管理的内存中最大的一块，是被所有线程都共享的内存区域。存在的唯一目的就是存放对象实例，几乎所有的对象实例都在这里进行分配内存。不过目前随着技术的不断发展，也并不是所有的对象实例都在堆中分配内存，可能也存在栈上分配。由于所占空间大，又存放各种实例对象，因此java虚拟机的垃圾回收机制主要管理的就是此区域，详细的垃圾回收方法以后会提到。JVM规范中规定堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。并且可以通过-Xmx和-Xms来扩展堆的内存大小，如果在堆中没有足够的内存为实例分配，并且堆也无法在扩展时，就会报OutOfMemoryError异常。</p><p>方法区</p><p>跟Java堆一样，方法区是各个线程共享的内存区域，此区域是用来存储类的信息(类的名称、字段信息、方法信息)、静态变量、常量以及编译器编译后的代码。JVM规范中并不区分方法区和堆，只把方法区描述为堆的逻辑部分，但是它却有一个别名叫做非堆(Non-Heap)，目的就是与Java堆区分开。根据垃圾回收机制中分代回收的思想，如果在HotSpot虚拟机上开发，可以把方法区称为“永久代”(只是可以这么理解，但实质是不一样的)，垃圾回收机制在Java堆中划分一个部分称为永久代，用此区域来实现方法区，这样HotSpot的垃圾收集器就可以像管理Java堆一样管理这部分内存，而不必为方法区开发专门的内存管理器。</p><p>运行时常量池</p><p>运行时常量池是方法区的一个部分，class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期间生成的各种字面量和符号引用，这部分内容会在类加载后进入方法区的运行时常量池中。Java 虚拟机对 Class 文件的每一部分(自然也包括常量池)的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。</p><p>程序计数器</p><p>虽然在上图中程序计数器的面积很大，但实际上它是一块较小的内存空间，可以看做当前线程所执行字节码的行号指示器。字节码解释器在工作中时下一步该干啥、到哪了，就是通过它来确定的。大家都知道在多线程的情况下，CPU在执行线程时是通过轮流切换线程实现的，也就是说一个CPU处理器(假设是单核)都只会执行一条线程中的指令，因此为了线程切换后能恢复到正确的执行位置，每个线程都要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。很明显，程序计数器就是线程私有的。如果线程正在执行的是一个java方法，程序计数器记录的是正在执行的虚拟机字节码指令地址；如果执行的Native方法，程序计数器记录的值为空(Undefined)，此内存区域是java中唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><p>Java虚拟机栈</p><p>我们经常会把java内存粗糙的分为两个部分，堆和栈，Java虚拟机栈就是栈这一部分，或者说是虚拟机栈中局部变量表部分。跟程序计数器一样，虚拟机栈也是线程私有的，它的生命周期跟线程相同。每个方法在执行的同时都会创建一个栈帧(Stack Frame)，每个栈帧对应一个被调用的方法，栈帧中用于存储局部变量表、操作数栈、动态链表、方法出口等信息。每一个方法从开始执行到结束就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>局部变量表：顾名思义，他就是用来存储方法中的局部变量(包括在方法中生命的非静态变量以及函数形参)，对于基本数据类型，直接存值，对于引用类型的变量，存储指向该对象的引用。由于它只存放基本数据类型的变量、引用类型的地址和返回值的地址，这些类型所需空间大小已知且固定，所以当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全可以确定的，在方法运行期间也不会改变局部变量表的大小。</p><p>指向运行常量池的引用：在方法执行过程中难免会使用到类中定义的常量，因此栈帧中要存放一个指向运行时常量池的引用。</p><p>方法返回地址：当一个方法执行结束后，要返回到之前调用它的地方，因此在栈帧中需要保存一个方法返回地址。</p><p>本地方法栈</p><p>本地方法栈与虚拟机栈的功能非常的相似，区别不过是虚拟机栈为虚拟机执行java方法服务，而本地方法栈为虚拟机执行Native方法服务。有的虚拟机并不会区分本地方法栈和虚拟机栈，比如Sun HotSpot虚拟机直接将两个合二为一。</p><p><a href="https://javaguide.cn/java/jvm/memory-area.html">Java内存区域详解（重点） | JavaGuide</a></p><ol><li><h3 id="new创建的对象一定在堆吗，局部变量是基本类型创建在哪，如果基本类型是成员变量呢"><a href="#new创建的对象一定在堆吗，局部变量是基本类型创建在哪，如果基本类型是成员变量呢" class="headerlink" title="new创建的对象一定在堆吗，局部变量是基本类型创建在哪，如果基本类型是成员变量呢"></a>new创建的对象一定在堆吗，局部变量是基本类型创建在哪，如果基本类型是成员变量呢</h3></li></ol><p>Java中的对象不一定是在堆上分配的，因为JVM通过逃逸分析，能够分析出一个新对象的使用范围，并以此确定是否要将这个对象分配到堆上。</p><p>逃逸分析的概念</p><p>先以官方的形式来说下什么是逃逸分析。逃逸分析就是：一种确定指针动态范围的静态分析，它可以分析在程序的哪些地方可以访问到指针。</p><p>在JVM的即时编译语境下，逃逸分析将判断新建的对象是否逃逸。即时编译判断对象是否逃逸的依据：一种是对象是否被存入堆中（静态字段或者堆中对象的实例字段），另一种就是对象是否被传入未知代码。</p><p>直接说这些概念，确实有点晕啊，那我们就来两个示例。</p><p>一种典型的对象逃逸就是：对象被复制给成员变量或者静态变量，可能被外部使用，此时变量就发生了逃逸。</p><p>在ObjectEscape类中，存在一个成员变量user，我们在init()方法中，创建了一个User类的对象，并将其赋值给成员变量user。此时，对象被复制给了成员变量，可能被外部使用，此时的变量就发生了逃逸。</p><p>另一种典型的场景就是：对象通过return语句返回。如果对象通过return语句返回了，此时的程序并不能确定这个对象后续会不会被使用，外部的线程可以访问到这个变量，此时对象也发生了逃逸。</p><p>逃逸分析的优点</p><p>逃逸分析的优点总体上来说可以分为三个：对象可能分配在栈上、分离对象或标量替换、消除同步锁。。</p><p>1对象可能分配在栈上</p><p>JVM通过逃逸分析，分析出新对象的使用范围，就可能将对象在栈上进行分配。栈分配可以快速地在栈帧上创建和销毁对象，不用再将对象分配到堆空间，可以有效地减少 JVM 垃圾回收的压力。</p><p>2分离对象或标量替换</p><p>当JVM通过逃逸分析，确定要将对象分配到栈上时，即时编译可以将对象打散，将对象替换为一个个很小的局部变量，我们将这个打散的过程叫做标量替换。将对象替换为一个个局部变量后，就可以非常方便的在栈上进行分配了。</p><p>3同步锁消除</p><p>如果JVM通过逃逸分析，发现一个对象只能从一个线程被访问到，则访问这个对象时，可以不加同步锁。如果程序中使用了synchronized锁，则JVM会将synchronized锁消除。</p><p>这里，需要注意的是：这种情况针对的是synchronized锁，而对于Lock锁，则JVM并不能消除。</p><p>要开启同步消除，需要加上 -XX:+EliminateLocks 参数。因为这个参数依赖逃逸分析，所以同时要打开 -XX:+DoEscapeAnalysis 选项。</p><p>所以，并不是所有的对象和数组，都是在堆上进行分配的，由于即时编译的存在，如果JVM发现某些对象没有逃逸出方法，就很有可能被优化成在栈上分配。</p><p>局部变量是基本类型：</p><p>当我们在方法中声明一个基本类型的局部变量时，这个变量会存储在java虚拟机的栈内存中。具体来说，这个局部变量会存储在方法区的栈帧(Stack Frame)的局部变量表(Local VariableTble)中。每个方法被调用时，JVM都会为该方法创建一个新的栈帧，并在该栈帧的局部变量表中为方法的所有局部变量分配空间。当方法执行完毕时，这个栈帧就会被销毁，局部变量也随，之被销毁。</p><p>基本类型是成员变量：</p><p>成员变量（无论是静态的还是非静态的）都是类的属性，并且与类相关联。当成员变量是基本类型时，它们会作为对象实例的一部分存储在堆内存中。每个对象实例在堆上都有一个独立的存储空间，其中包含该刻对象所有成员变量的值。静态成员变量（也称为类变量）则存储在Java的方法区中。</p><ol><li><h3 id="jvm堆内存详细说一下，为什么要这么划分，用的什么垃圾回收算法"><a href="#jvm堆内存详细说一下，为什么要这么划分，用的什么垃圾回收算法" class="headerlink" title="jvm堆内存详细说一下，为什么要这么划分，用的什么垃圾回收算法"></a>jvm堆内存详细说一下，为什么要这么划分，用的什么垃圾回收算法</h3></li></ol><p>Java内存区域详解（重点） | JavaGuide</p><p><a href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html">JVM垃圾回收详解（重点） | JavaGuide</a></p><ol><li><h3 id="什么时候会发生full-gc"><a href="#什么时候会发生full-gc" class="headerlink" title="什么时候会发生full gc"></a>什么时候会发生full gc</h3></li></ol><p>\1. 调用 System.gc()</p><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p><p>\2. 未指定老年代和新生代大小，堆伸缩时会产生fullgc,所以一定要配置-Xmx、-Xms</p><p>\3. 老年代空间不足</p><p>老年代空间不足的常见场景比如大对象、大数组直接进入老年代、长期存活的对象进入老年代等。</p><p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。</p><p>除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。</p><p>还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p><p>在执行Full GC后空间仍然不足，则抛出错误：java.lang.OutOfMemoryError: Java heap space</p><p>\4. JDK 1.7 及以前的（永久代）空间满</p><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p><p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。</p><p>如果经过 Full GC 仍然回收不了，那么虚拟机会抛出java.lang.OutOfMemoryError PermGen space</p><p>为避免以上原因引起的 Full GC，可采用的方法为增大Perm Gen或转为使用 CMS GC。</p><p>\5. 空间分配担保失败</p><p>空间担保，下面两种情况是空间担保失败：</p><p>1、每次晋升的对象的平均大小 &gt; 老年代剩余空间</p><p>2、Minor GC后存活的对象超过了老年代剩余空间</p><p>注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当出现这两种状况的时候就有可能会触发Full GC。</p><p>promotion failed 是在进行 Minor GC时候，survivor space空间放不下只能晋升老年代，而此时老年代也空间不足时发生的。</p><p>concurrent mode failure 是在进行CMS GC过程，此时有对象要放入老年代而空间不足造成的，这种情况下会退化使用Serial Old收集器变成单线程的，此时是相当的慢的。</p><ol><li><h3 id="full-gc对程序的影响"><a href="#full-gc对程序的影响" class="headerlink" title="full gc对程序的影响"></a>full gc对程序的影响</h3></li></ol><p>1.应用程序停顿：在Full GC进行期间，JVM(Jva虚拟机)会暂停所有的应用程序线程，等待垃圾回收完成之后再恢复线程的执行。这意味着在Full GC期间，应用程序无法执行任何操作，会导致应用程序出现长时间的停顿和卡顿，影响用户体验。</p><p>2.系统性能损耗：由于Full GC需要遍历整个堆内存，所以它的耗时较长，会消耗大量的系统资源，导致系统性能下降。如果Full GC发生的频率过高或回收的对象数量过大，会导致系统性能损耗更加严重。</p><p>3.内存不足：如果Full GC无法回收足够的内存，会导致OutOfMemoryError(OOM)错误，从而导致系统崩渍。这种情况下，通常需要增加堆内存的大小或优化代码实现，以减少内存的使用。</p><ol><li><h3 id="怎么解决full-GC"><a href="#怎么解决full-GC" class="headerlink" title="怎么解决full GC"></a>怎么解决full GC</h3></li></ol><p>1.增大堆内存：通过增加Jva堆内存的大小，可以减少Full GC的频率，从而降低系统卡死的风险。可以使用-x和-s参数来调整VM的最大和初始堆内存大小。</p><p>2.检查内存泄漏：定期检查应用程序，确保没有潜在的内存泄漏问题。内存泄漏会导致堆内存不断增长，最终触发Full GC。可以使用工具如jconsole、.jvisualvm或MAT(Memory Analyzer Tool)来分析堆内存和查找内存泄世漏。</p><p>3.优化大对象的处理：对于频繁创建的大对象，可以考虑使用对象池或重用对象，以减少Full GC的负担。此外，也可以尝试调整JVM参数，如新生代大小、Edn区和Survivor区的比例等，以适应大对象的处理</p><p>4.优化Finalizer的使用：尽量避免过度使用Finalizer,确保Finalizer方法的执行时间尽量短暂。Finalizer的过度使用可能会导致对象无法及时被回收，从而增加Full GC的频率</p><p>5.调整并发线程数：根据应用程序的负载和硬件环境，调整垃圾回收器的并发线程数，以平衡垃圾回收和应用程序的执行。过多的并发线程可能会导致系统资源竞争，影响性能。</p><p>6.优化代码实现：通过优化代码实现，减少不必要的对象创建和销毁，降低内存的使用。例如，使用缓存技术来减少数据库查询次数，避免频繁创建和销毁对象等。</p><p>7.选择合适的垃圾回收器：根据应用程序的特点和性能需求，选择合适的垃圾回收器。例如，对于延迟敏感的应用，可以选择G1垃圾回收器；对于内存占用较多的应用，可以选择CMS垃圾回收器等。</p><p>综上所述，解决Full GC的问题需要综合考虑多个方面，包括调整JVM参数、优化代码实现、检查和修复内存泄漏等。通过综合运用这些解决方法，可以降低Fu川GC的频率和影响，提高系统的稳定性和性能。</p><ol><li><h3 id="线上系统发生了full-gc该如何快速解决"><a href="#线上系统发生了full-gc该如何快速解决" class="headerlink" title="线上系统发生了full gc该如何快速解决"></a>线上系统发生了full gc该如何快速解决</h3></li></ol><p>1.快速恢复系统：</p><p>首先，需要尽快恢复系统的正常使用。这可能包括使用机器扩容、服务重启、接口限流等手段来维持服务的正常运行，以减轻Full GC带来的压力，并给问题定位争取时间。</p><p>2.查看监控和日志：</p><p>使用监控工具查看系统性能指标，如CPU、内存、GC次数等，了解Full GC发生的频率和严重程度。</p><p>查看GC日志，分析Full GC的原因。GC日志可以提供关于每次GC的详细信息，如GC的类</p><p>型、GC的时间、回收的内存量等。</p><p>3.定位问题原因：</p><p>通过分析监控数据和GC日志，定位导致Full GC的具体原因。可能的原因包括内存泄漏、不合理的内存分配、过多的临时对象、不合理的对象引用等。</p><p>使用JVM调优工具，如jmap、jstack、jvisualvm等，进一步分析内存使用情况、线程堆栈信息等，帮助定位问题。</p><p>4.紧急措施：</p><p>如果FullGC导致系统无法正常运行，可以考虑采取紧急措施，如回滚到上一个稳定版本，暂时缓解问题。</p><p>如果问题是由新上线的代码导致的，需要尽快回滚到上一个版本，并修复问题后再重新上线。</p><h2 id="得帆-Java一面"><a href="#得帆-Java一面" class="headerlink" title="得帆 Java一面"></a>得帆 Java一面</h2><ol><li><h3 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h3></li></ol><p><a href="https://javaguide.cn/java/collection/java-collection-questions-01.html">Java集合常见面试题总结(上) | JavaGuide</a></p><ol><li><h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3></li></ol><p>一般来说，创建线程有很多种方式，例如继承Thread类、实现Runnable接口、实现Callable接口、使用线程池、使用CompletableFuture类等等。</p><p>不过，这些方式其实并没有真正创建出线程。准确点来说，这些都属于是在 Java 代码中使用多线程的方法。</p><p>严格来说，Java 就只有一种方式可以创建线程，那就是通过new Thread().start()创建。不管是哪种方式，最终还是依赖于new Thread().start()。</p><p><a href="https://mp.weixin.qq.com/s/NspUsyhEmKnJ-4OprRFp9g">大家都说Java有三种创建线程的方式！并发编程中的惊天骗局！ (qq.com)</a></p><ol><li><h3 id="对spring的理解"><a href="#对spring的理解" class="headerlink" title="对spring的理解"></a>对spring的理解</h3></li></ol><h3 id="4-springboot与spring的区别"><a href="#4-springboot与spring的区别" class="headerlink" title="4.springboot与spring的区别"></a>4.springboot与spring的区别</h3><p><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html">Spring常见面试题总结 | JavaGuide</a></p><h3 id="5如何解决循环依赖"><a href="#5如何解决循环依赖" class="headerlink" title="5如何解决循环依赖"></a>5如何解决循环依赖</h3><p><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html">Spring常见面试题总结 | JavaGuide</a></p><ol><li><h3 id="对mybais的理解"><a href="#对mybais的理解" class="headerlink" title="对mybais的理解"></a>对mybais的理解</h3></li></ol><p><a href="https://javaguide.cn/system-design/framework/mybatis/mybatis-interview.html">MyBatis常见面试题总结 | JavaGuide</a></p><ol><li><h3 id="实现一个抢红包的案例（后面统一总结学习）"><a href="#实现一个抢红包的案例（后面统一总结学习）" class="headerlink" title="实现一个抢红包的案例（后面统一总结学习）"></a>实现一个抢红包的案例（后面统一总结学习）</h3></li><li><h3 id="缓存三兄弟"><a href="#缓存三兄弟" class="headerlink" title="缓存三兄弟"></a>缓存三兄弟</h3></li></ol><p><a href="https://javaguide.cn/database/redis/redis-questions-02.html">Redis常见面试题总结(下) | JavaGuide</a></p><ol><li><h3 id="设计模式-看视频"><a href="#设计模式-看视频" class="headerlink" title="设计模式(看视频)"></a>设计模式(看视频)</h3></li></ol><h3 id="10-接口响应慢的处理思路"><a href="#10-接口响应慢的处理思路" class="headerlink" title="10.接口响应慢的处理思路"></a>10.接口响应慢的处理思路</h3><p>1.寻找性能瓶颈</p><p>首先，我们需要找出导致接口响应慢的原因。可能的原因包括：</p><ul><li>数据库查询慢：接口中涉及到数据库查询操作，可能是查询语句不够优化，或者数据库索引不够合理。</li><li>外部依赖调用慢：接口调用了其他服务或者外部资源，可能是调用的服务响应慢或者网络延迟高。</li><li>高并发压力：接口同时被多个请求调用，可能是由于并发请求过多，导致接口响应慢。</li></ul><p>为了找出性能瓶颈，可以使用一些性能分析工具，比如Java Mission Control、.VisualVM等。</p><p>2.优化数据库查询</p><p>如果接口中存在数据库查询操作，可以通过以下方式优化查询性能：</p><ul><li>优化查询语句：确保查询语句使用了正确的索引，避免全表扫描。可以使用数据库的查询优化器来自动生成或者调整查询计划。</li><li>缓存查询结果：对于一些数据量较大且不经常变动的查询结果，可以将其缓存在内存中，避免重复查询数据库。可以使用缓存库，比如Redis、Ehcache等。</li><li>分批查询：如果查询结果集很大，可以采用分批查询的方式，每次只查询一部分数据，减轻数据库的压力。</li></ul><p>3.优化外部依赖调用</p><p>如果接口中调用了其他服务或者外部资源，可以通过以下方式优化调用性能：</p><ul><li>异步调用：将耗时的调用改为异步方式，可以减少等待时间。可以使用Java的CompletableFuture或者基于消息队列的异步调用方式。</li><li>缓存调用结果：对于一些调用结果不经常变动的场景，可以将其缓存起来，避免重复调用。可以使用缓存库，比如Redis、Ehcache等</li><li>优化网络通信：如果网络延迟较高，可以考虑使用更快的网络通信协议，比如gRPC、Apache Thrift等。</li></ul><p>4.处理高并发压力</p><p>如果接口面临高并发压力，可能会导致接口响应慢。可以通过以下方式处理高并发：</p><ul><li>负载均衡：使用负载均衡器将请求分发到多个实例上，提高系统容量和吞吐量。可以使用Nginx、HAProxy等。</li><li>限流策略：对接口进行限流，控制同时处理的请求数量，避免系统资源被消耗殆尽。可以使用框架自带的限流功能，或者使用第三方库，比如Guava RateLimiter。.</li><li>水平扩展：增加系统实例数量，提高系统的处理能力。可以通过添加更多的服务器或者使用容器化技术，比如Docker、Kubernetes等。</li></ul><h3 id="11-http的状态码"><a href="#11-http的状态码" class="headerlink" title="11.http的状态码"></a>11.http的状态码</h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YzEwYjJhYjA2ZTU3NWVjODQ3ZDMxOGQ5NzVlYzkxMTVfV1BRb2RVVnZ2SWhCcmI4cllHbGZuZ2dBTmt5NkdPZ2hfVG9rZW46SGM3UWJjSDlZb0daSnZ4S1Vqb2NuOEQ2bm9mXzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><p><a href="https://javaguide.cn/cs-basics/network/other-network-questions.html#http-%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B">计算机网络常见面试题总结(上) | JavaGuide</a></p><ol><li><h3 id="Java8的新特性"><a href="#Java8的新特性" class="headerlink" title="Java8的新特性"></a>Java8的新特性</h3></li></ol><p><a href="https://javaguide.cn/java/new-features/java8-common-new-features.html">Java8 新特性实战 | JavaGuide</a></p><ol><li><h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3></li></ol><p><a href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">Java基础常见面试题总结(上) | JavaGuide</a></p><ol><li><h3 id="线程常用的方法"><a href="#线程常用的方法" class="headerlink" title="线程常用的方法"></a>线程常用的方法</h3></li></ol><p><a href="https://blog.csdn.net/shaomingmin/article/details/106180380">Java线程基本方法详解_java中线程相关的基本方法-CSDN博客</a></p><ol><li><h3 id="保证线程串行执行的方法"><a href="#保证线程串行执行的方法" class="headerlink" title="保证线程串行执行的方法"></a>保证线程串行执行的方法</h3></li></ol><p><a href="https://blog.csdn.net/lyf_zm/article/details/130082773">让线程顺序运行的11种方法_线程池如何保证线程执行顺序-CSDN博客</a></p><p>美团二面</p><ol><li><h3 id="讲讲java垃圾回收"><a href="#讲讲java垃圾回收" class="headerlink" title="讲讲java垃圾回收"></a>讲讲java垃圾回收</h3></li><li><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3></li></ol><p>1.标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</p><ul><li>该算法分为两个阶段，标记和清除。标记阶段标记所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。该算法最大的问题就是内存碎片严重化，后续可能发生对象不能找到利用空间的问题。</li></ul><p>2.复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</p><ul><li>按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。</li></ul><p>3.标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</p><ul><li>标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。</li></ul><p>4.分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</p><ul><li>当前商业虚拟机都采用分代收集的垃圾收集算法。分代收集算法，顾名思义是根据对象的存活周期将内存划分为几块。一般包括年轻代、老年代 和 永久代。</li></ul><p>​    <a href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html">垃圾回收算法详解</a></p><ol><li><h3 id="怎么进行分代回收"><a href="#怎么进行分代回收" class="headerlink" title="怎么进行分代回收"></a>怎么进行分代回收</h3></li></ol><p><a href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95">分代回收详解</a></p><ol><li><h3 id="讲讲JVM内存结构"><a href="#讲讲JVM内存结构" class="headerlink" title="讲讲JVM内存结构"></a>讲讲JVM内存结构</h3></li></ol><p><a href="https://javaguide.cn/java/jvm/memory-area.html">JVM内存结构详解</a></p><ol><li><h3 id="堆内部的结构是怎样的"><a href="#堆内部的结构是怎样的" class="headerlink" title="堆内部的结构是怎样的"></a>堆内部的结构是怎样的</h3></li></ol><p>Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p><strong>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存。</strong> </p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。不过，设置的值应该在 0-15，否则会爆出以下错误：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MaxTenuringThreshold of 20 is invalid; must be between 0 and 15</span><br></pre></td></tr></table></figure><p><a href="https://javaguide.cn/java/jvm/memory-area.html#%E5%A0%86">堆详解</a></p><ol><li><h3 id="讲讲常用的设计模式"><a href="#讲讲常用的设计模式" class="headerlink" title="讲讲常用的设计模式"></a>讲讲常用的设计模式</h3></li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MGM2YzAzOTJmODU0MTc0YmQ1YzFlZThjY2YyNTIzNDhfNDRLU044REVSVnd4eHFMWFpsU0c1VGpBT3dxSlo4bnZfVG9rZW46S1N4ZGJ6SkVCb0NBV3F4b1c2aGM5VXh5bmxnXzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><h3 id="7-写一段策略模式的代码"><a href="#7-写一段策略模式的代码" class="headerlink" title="7.写一段策略模式的代码"></a>7.写一段策略模式的代码</h3><p><a href="https://blog.csdn.net/sufu1065/article/details/127002701">六种常见的设计模式详解</a></p><h3 id="8-优先队列是基于什么数据结构实现的"><a href="#8-优先队列是基于什么数据结构实现的" class="headerlink" title="8.优先队列是基于什么数据结构实现的"></a>8.优先队列是基于什么数据结构实现的</h3><p><strong>优先队列 (Priority Queue)</strong> 从底层结构上来讲并非线性的数据结构，它一般是由堆来实现的。</p><ol><li>在每个元素入队时，优先队列会将新元素其插入堆中并调整堆。</li><li>在队头出队时，优先队列会返回堆顶元素并调整堆。</li></ol><p>总而言之，不论我们进行什么操作，优先队列都能按照<strong>某种排序方式</strong>进行一系列堆的相关操作，从而保证整个集合的<strong>有序性</strong>。</p><p>虽然优先队列的底层并非严格的线性结构，但是在我们使用的过程中，我们是感知不到<strong>堆</strong>的，从使用者的眼中优先队列可以被认为是一种线性的数据结构：一种会自动排序的线性队列。</p><h3 id="9-堆是怎么实现的，怎么增删改查"><a href="#9-堆是怎么实现的，怎么增删改查" class="headerlink" title="9.堆是怎么实现的，怎么增删改查"></a>9.堆是怎么实现的，怎么增删改查</h3><p>  <a href="https://javaguide.cn/cs-basics/data-structure/heap.html">堆详解</a></p><h3 id="10-MySQL中主键自增正数和随机整数在性能上有什么区别-如果自增和随机id都是程序给的，MySQL都需要进行查找，那么在写入时会有什么性能区别呢"><a href="#10-MySQL中主键自增正数和随机整数在性能上有什么区别-如果自增和随机id都是程序给的，MySQL都需要进行查找，那么在写入时会有什么性能区别呢" class="headerlink" title="10.MySQL中主键自增正数和随机整数在性能上有什么区别?如果自增和随机id都是程序给的，MySQL都需要进行查找，那么在写入时会有什么性能区别呢?"></a>10.MySQL中主键自增正数和随机整数在性能上有什么区别?如果自增和随机id都是程序给的，MySQL都需要进行查找，那么在写入时会有什么性能区别呢?</h3><ol><li>主键自增：</li></ol><ul><li>写入性能：自增主键每次插入时都是追加记录，不需要移动其他数据。这意味着在B+Tree索引结</li></ul><p>构中，自增主键的插入是高效的，不会触发页分裂(page split)。页分裂是当数据页已满，需要</p><p>申请新的数据页并将部分数据移动到新页的过程，这会导致性能下降和空间利用率降低。</p><ul><li>存储空间：使用自增主键时，索引的大小相对较小，因为主键是连续的，存储时更紧凑。这也有助</li></ul><p>于提高性能，因为连续的主键可以更快地检索。</p><ul><li>唯一性：自增主键保证了数据的唯一性，并且是自动生成的，这简化了应用层的逻辑</li></ul><ol><li>随机整数主键：</li></ol><ul><li>写入性能：如果使用随机整数作为主键，每次插入数据时都需要在索引中查找该值是否已经存在</li></ul><p>这增加了写入的复杂性，并可能导致性能下降。此外，由于随机整数不是有序的，因此更有可能触</p><p>发页分裂，从而降低写入性能。</p><ul><li>存储空间：使用随机整数作为主键可能会导致索引的大小增加，因为随机值可能不如自增主键那样</li></ul><p>紧凑。这可能会占用更多的存储空间，并可能影响查询性能。</p><p>​     在写入时，自增主键和随机整数主键的性能差异主要体现在页分裂和索引查找上。自增主键由于是有序的可以避免页分裂，并且插入时不需要进行额外的索引查找。而随机整数主键可能导致频繁的页分裂和索引查找，从而降低写入性能。</p><h3 id="11-MySQL为什么要采用b-树作为底层结构"><a href="#11-MySQL为什么要采用b-树作为底层结构" class="headerlink" title="11.MySQL为什么要采用b+树作为底层结构"></a>11.MySQL为什么要采用b+树作为底层结构</h3><p>可以看之前的</p><h3 id="12-Java中高并发的情况下，什么情况会出现线程不安全，怎么解决"><a href="#12-Java中高并发的情况下，什么情况会出现线程不安全，怎么解决" class="headerlink" title="12.Java中高并发的情况下，什么情况会出现线程不安全，怎么解决"></a>12.Java中高并发的情况下，什么情况会出现线程不安全，怎么解决</h3><p>线程不安全的常见原因：</p><ol><li>多线程调度的随机性：由于多线程是抢占式执行的，这导致多线程调度的随机性和无序性。当多个线程并发执行时，CPU可能会在不同的线程之间切换，导致线程的执行顺序变得不确定。这种不确定性可能导致共享数据的访问和修改出现问题，从而产生线程不安全的情况。</li><li>原子性问题：原子性是指不可分割的最小单位。一行代码可能包含多条CPU指令，如果不满足原子性，当多个线程同时访问和修改共享数据时，可能会出现数据不一致的问题。</li><li>竞态条件：当多个线程并发地访问和操作共享数据时，由于执行顺序的不确定性，可能导致程序出现错误的结果。例如，两个线程同时读取并递增一个变量的值，如果不进行同步控制，可能会导致递增操作被覆盖，最终得到的结果不符合预期。</li></ol><p>解决线程不安全的方法：</p><ol><li>使用同步机制：例如synchronized关键字或ReentrantLock等锁机制，可以确保同一时间只有一个线程能韵够访问和修改共享数据，从而避免线程安全问题。</li><li>使用线程安全的集合类：Java提供了一些线程安全的集合类，如ector、Hashtablel以及并发包java.uti1.concurrent下的集合类。这些集合类+内部实现了同步机制，可以在多线程环境下安全使用。</li><li>使用volatile关键字：volatile关键字可以确保变量的可见性，即当一个线程修改了变量的值，其他线程能够立即看到这个修改。这对于避免线程安全问题很有帮助。</li><li>使用原子类：Java提供了jawa.uti1.concurrent.atomic包下的原子类，如Atomi cInteger、AtomicLong等。这些原子类提供了线程安全的原子操作，可以简化线程安全的实现。</li><li>避免死锁：在设计多线程程序时，应注意避免死锁的发生。死锁是指两个或更多线程无限期地等待一个永远不会发生的条件。可以使用避免死锁的算法，例如按序申请锁，或设置超时时间等方法来避免死锁。</li></ol><h3 id="13-ReenTrantLock是怎么实现的"><a href="#13-ReenTrantLock是怎么实现的" class="headerlink" title="13.ReenTrantLock是怎么实现的"></a>13.ReenTrantLock是怎么实现的</h3><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#reentrantlock">ReenTrantLock详解</a></p><h2 id="某厂Java实习面经"><a href="#某厂Java实习面经" class="headerlink" title="某厂Java实习面经"></a>某厂Java实习面经</h2><ol><li><h3 id="Autowired和-resourse的区别"><a href="#Autowired和-resourse的区别" class="headerlink" title="@Autowired和@resourse的区别"></a>@Autowired和@resourse的区别</h3></li></ol><p>@Resource 和@Autowired 这两个注解的作用都是在 Spring 生态里面去实现 Bean </p><p>的依赖注入。 </p><p>下面我分别说一下@Autowired 和@Resource 这两个注解。 </p><ul><li>@Autowired 是根据 type 来匹配，@Resource 可以根据 name 和 type 来匹配，</li></ul><p>默认是 name 匹配。 </p><ul><li>@Autowired 是 Spring 定义的注解，@Resource 是 JSR 250 规范里面定义的注</li></ul><p>解，而 Spring 对 JSR 250 规范提供了支持。 </p><ul><li>@Autowired 如果需要支持 name 匹配，就需要配合@Primary 或者@Qualifier</li></ul><p>来实现</p><p>@Autowired注意点</p><ul><li>注解里面有一个 required 属性默认值是 true，表示强制要求 bean 实例的注入， 在应用启动的时候，如果 IOC 容器里面不存在对应类型的 Bean，就会报错。 当然，如果不希望自动注入，可以把这个属性设置成 false。</li><li>如果在 Spring IOC 容器里面存在多个相同类型的 Bean 实例，Spring 启动的时候，会提示一个错误，大概意思原本只能注入一个单实例 Bean，我们可以使用 @Primary 或者@Qualifier 这两个注解来解决。 @Primary 表示主要的 bean，当存在多个相同类型的 Bean 的时候，优先使用声明了 @Primary 的 Bean。@Qualifier 的作用类似于条件筛选，它可以根据 Bean 的名字找到需要装配的目标 Bean。</li></ul><p>@Resource 的注意点</p><ul><li>@Resource 是 JDK 提供的注解，只是 Spring 在实现上提供了这个注解的功能支持。 它的使用方式和@Autowired 完全相同，（如图）最大的差异于@Resource 可以支持 ByName 和 ByType 两种注入方式。 如果使用 name，Spring 就根据 bean 的名字进行依赖注入，如果使用 type，Spring 就根据类型实现依赖注入。 </li><li>如果两个属性都没配置，就先根据定义的属性名字去匹配，如果没匹配成功，再根据类型匹配。两个都没匹配到，就报错</li></ul><ol><li><h3 id="Redis的持久化策略，AOF数据量大，怎么解决？"><a href="#Redis的持久化策略，AOF数据量大，怎么解决？" class="headerlink" title="Redis的持久化策略，AOF数据量大，怎么解决？"></a>Redis的持久化策略，AOF数据量大，怎么解决？</h3></li></ol><p>AOF重写</p><p><a href="https://javaguide.cn/database/redis/redis-persistence.html">Redis持久化详解</a></p><h3 id="3-缓存穿透，缓存雪崩，缓存击穿，解决办法"><a href="#3-缓存穿透，缓存雪崩，缓存击穿，解决办法" class="headerlink" title="3.  缓存穿透，缓存雪崩，缓存击穿，解决办法"></a>3.  缓存穿透，缓存雪崩，缓存击穿，解决办法</h3><h3 id="4-ArrayList默认大小"><a href="#4-ArrayList默认大小" class="headerlink" title="4. ArrayList默认大小"></a>4. ArrayList默认大小</h3><p>从无参构造来看我认为应该是0，但是一般都认为是10</p><p><a href="https://javaguide.cn/java/collection/arraylist-source-code.html#arraylist-%E7%AE%80%E4%BB%8B">ArrayList详解</a></p><h3 id="5-HashMap线程安全吗，如何保证线程安全？"><a href="#5-HashMap线程安全吗，如何保证线程安全？" class="headerlink" title="5.  HashMap线程安全吗，如何保证线程安全？"></a>5.  HashMap线程安全吗，如何保证线程安全？</h3><p>线程不安全，用concurrentHashMap</p><p>详解看之前</p><ol><li><h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3></li><li><h3 id="虚拟机栈由什么组成"><a href="#虚拟机栈由什么组成" class="headerlink" title="虚拟机栈由什么组成"></a>虚拟机栈由什么组成</h3></li></ol><ul><li><strong>局部变量表</strong> 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</li><li><strong>操作数栈</strong> 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。</li><li><strong>动态链接</strong> 主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 <strong>动态连接</strong> 。</li><li><strong>方法返回地址</strong></li></ul><p><a href="https://javaguide.cn/java/jvm/memory-area.html#java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">详解</a></p><ol><li><h3 id="堆的内存结构，对象什么时候进入幸存者区"><a href="#堆的内存结构，对象什么时候进入幸存者区" class="headerlink" title="堆的内存结构，对象什么时候进入幸存者区"></a>堆的内存结构，对象什么时候进入幸存者区</h3></li><li><h3 id="GC算法，分别在什么时候使用"><a href="#GC算法，分别在什么时候使用" class="headerlink" title="GC算法，分别在什么时候使用"></a>GC算法，分别在什么时候使用</h3></li></ol><p><a href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html">垃圾回收算法详解</a></p><ol><li><h3 id="对象什么情况下不会一直进入老年代"><a href="#对象什么情况下不会一直进入老年代" class="headerlink" title="对象什么情况下不会一直进入老年代"></a>对象什么情况下不会一直进入老年代</h3></li><li><h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3></li></ol><p>查找上方</p><ol><li><h3 id="类加载的阶段有哪些"><a href="#类加载的阶段有哪些" class="headerlink" title="类加载的阶段有哪些"></a>类加载的阶段有哪些</h3></li></ol><p>类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析这三个阶段可以统称为连接（Linking）。</p><p><a href="https://javaguide.cn/java/jvm/class-loading-process.html">类加载详解</a></p><ol><li><h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h3></li></ol><p>ACID，详解看上方</p><ol><li><h3 id="事务隔离级别，innodb默认哪一种"><a href="#事务隔离级别，innodb默认哪一种" class="headerlink" title="事务隔离级别，innodb默认哪一种"></a>事务隔离级别，innodb默认哪一种</h3></li></ol><p>读未提交，读已提交，可重复读，序列化。默认是可重复读,详解看上方</p><ol><li><h3 id="MVCC底层原理"><a href="#MVCC底层原理" class="headerlink" title="MVCC底层原理"></a>MVCC底层原理</h3></li></ol><p>innodb对MVCC的实现依赖于</p><ol><li>隐藏字段</li></ol><p>在内部，<code>InnoDB</code> 存储引擎为每行数据添加了三个隐藏字段：</p><ul><li><code>DB_TRX_ID（6字节）</code>：表示最后一次插入或更新该行的事务 id。此外，<code>delete</code> 操作在内部被视为更新，只不过会在记录头 <code>Record header</code> 中的 <code>deleted_flag</code> 字段将其标记为已删除</li><li><code>DB_ROLL_PTR（7字节）</code> 回滚指针，指向该行的 <code>undo log</code> 。如果该行未被更新，则为空</li><li><code>DB_ROW_ID（6字节）</code>：如果没有设置主键且该表没有唯一非空索引时，<code>InnoDB</code> 会使用该 id 来生成聚簇索引</li></ul><ol><li>ReadView</li></ol><p>主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务”</p><p>主要有以下字段：</p><ul><li><code>m_low_limit_id</code>：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li><li><code>m_up_limit_id</code>：活跃事务列表 <code>m_ids</code> 中最小的事务 ID，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。小于这个 ID 的数据版本均可见</li><li><code>m_ids</code>：<code>Read View</code> 创建时其他未提交的活跃事务 ID 列表。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code> 不包括当前事务自己和已提交的事务（正在内存中）</li><li><code>m_creator_trx_id</code>：创建该 <code>Read View</code> 的事务 ID</li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YjM1MTgzMDM3YzI2OTlhOGI0ZDRmYmU4NTJjOTE2NTdfTWNqT21YbGl2S0RTZTd1dk1jQ2VhTDZtdTRpSzFNTjBfVG9rZW46UzZodmJwS05lb2FRY3N4ZFlxb2NrOUFxbmVoXzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><ol><li>undolog</li></ol><p><code>undo log</code> 主要有两个作用：</p><ul><li>当事务回滚时用于将数据恢复到修改前的样子</li><li>另一个作用是 <code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读</li></ul><p><a href="https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html#%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6-multi-version-concurrency-control">详解</a></p><ol><li><h3 id="MySQL默认存储引擎？什么情况下用innodb"><a href="#MySQL默认存储引擎？什么情况下用innodb" class="headerlink" title="MySQL默认存储引擎？什么情况下用innodb?"></a>MySQL默认存储引擎？什么情况下用innodb?</h3></li></ol><p><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#myisam-%E5%92%8C-innodb-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9">详解</a></p><ol><li><h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3></li></ol><p><a href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#udp-%E5%92%8C-tcp-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2-%E5%88%86%E5%88%AB%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF">详解</a></p><ol><li><h3 id="HTTP和TCP的区别"><a href="#HTTP和TCP的区别" class="headerlink" title="HTTP和TCP的区别"></a>HTTP和TCP的区别</h3></li><li><h3 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h3></li></ol><p><a href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86">详解</a></p><ol><li><h3 id="IOC-AOP"><a href="#IOC-AOP" class="headerlink" title="IOC,AOP"></a>IOC,AOP</h3></li></ol><p><a href="https://javaguide.cn/system-design/framework/spring/ioc-and-aop.html">详解</a></p><ol><li><h3 id="Bean的生命周期，Before和After有什么作用"><a href="#Bean的生命周期，Before和After有什么作用" class="headerlink" title="Bean的生命周期，Before和After有什么作用"></a>Bean的生命周期，Before和After有什么作用</h3></li></ol><p><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%86%E8%A7%A3%E4%B9%88">详解</a></p><ol><li><h3 id="Springboot使用过哪些注解？"><a href="#Springboot使用过哪些注解？" class="headerlink" title="Springboot使用过哪些注解？"></a>Springboot使用过哪些注解？</h3></li></ol><p>在使用SpringBoot的过程中，几乎没有了XML配置，采用注解+JavaConfig方式开发，这样做的好处是：</p><ul><li>采用纯java代码，不在需要配置繁杂的xml文件</li><li>在配置中也可享受面向对象带来的好处</li><li>类型安全对重构可以提供良好的支持</li><li>减少复杂配置文件的同时亦能享受到springIoC容器提供的功能</li></ul><p>常见注解</p><ul><li>@SpringBootApplication</li></ul><p>这个注解很常见了，每次在启动SpringBoot项目的时候，都会见到它，它作用在类上，标识该类为SpringBoot项目启动类。并且让SpringBoot自动给程序进行必要的配置，等同于@Configuration、@EnableAutoConfiguration、@ComponentScan这三个注解。</p><ul><li>@Configuration</li></ul><p>相当于传统Spring的xml配置文件。</p><p>如果第三方库需要用到xml文件，建议通过@Configuration类作为项目的配置主类，可以使用@ImportResource 注解加载xml配置文件。</p><ul><li>@EnableAutoConfiguration 自动配置。</li></ul><p>SpringBoot自动配置(auto-configuration)，尝试根据你添加的启动器(starter)自动配置你的SpringBoot应用。</p><p>你可以将@EnableAutoConfiguration注解或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。</p><p>如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。</p><ul><li>@ComponentScan</li></ul><p>如果某个类加上@ComponentScan注解，则该类会自动发现扫描组件。</p><p>也就是说，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。</p><p>我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，SpringBoot会扫描启动类所在包下以及子包下的使用了@Component、@Controller、@Service、@Repository等注解的类。</p><ul><li>@Controller</li></ul><p>@Controller注解用于定义控制器类，在SpringBoot中由控制器负责将用户发来的URL请求转发到对应的服务接口(Controller层)。</p><p>一般这个注解用在类上，控制器方法需要加上@RequestMapping注解。</p><ul><li>@ResponseBody</li></ul><p>如果控制器方法加上@ResponseBody注解，该方法的返回结果将直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。</p><p>在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。</p><p>比如异步获取json数据，加上@Responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用。</p><ul><li>@RestController</li></ul><p>@RestController注解是@Controller和@ResponseBody的合集。</p><p>使用在类上，表示该类是控制器，并且类中所有控制器方法的返回值直接填入HTTP响应体中，是RESTful风格的控制器，控制器方法返回JSON数据。</p><ul><li>@RequestMapping</li></ul><p>提供路由信息，负责URL到Controller中的具体方法的映射。</p><ul><li>@Import</li></ul><p>用来导入其他配置类（加了@Configuration注解的类）。</p><ul><li>@ImportResource</li></ul><p>用来加载xml配置文件。</p><ul><li>@PathVariable</li></ul><p>获取URL上的参数（Restful风格接口）。</p><ul><li>@Service</li></ul><p>一般用于修饰service层的组件</p><ul><li>@Repository</li></ul><p>使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。</p><ul><li>@Bean</li></ul><p>用@Bean标注方法等价于XML中配置的bean，意思是产生一个bean，并交给SpringBoot管理。</p><ul><li>@Value</li></ul><p>注入SpringBoot中的配置文件——application.properties配置的属性的值。</p><ul><li>@Inject</li></ul><p>等价于默认的@Autowired，只是没有required属性。</p><ul><li>@Component</li></ul><p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p><ul><li>@AutoWired</li></ul><p>自动导入依赖的bean。byType方式。把配置好的Bean拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。当加上（required&#x3D;false）时，就算找不到bean也不报错。</p><ul><li>@Qualifier</li></ul><p>当有多个同一类型的Bean时，可以用@Qualifier(“name”)来指定。与@Autowired配合使用。@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者。</p><ul><li>@Resource(name&#x3D;”name”,type&#x3D;”type”)</li></ul><p>没有括号内内容的话，默认byName。与@Autowired干类似的事。</p><ul><li>@JsonBackReference</li></ul><p>解决嵌套外链问题。</p><ul><li>@RepositoryRestResourcepublic</li></ul><p>配合spring-boot-starter-data-rest使用。</p><p>全局异常注解</p><ul><li>@ControllerAdvice</li></ul><p>包含@Component，可以被扫描到。统一处理异常。</p><ul><li>@ExceptionHandler(Exception.class)</li></ul><p>用在方法上面表示遇到这个异常就执行以下方法。</p><p>JPA注解</p><p>JPA是ORM思想的规范接口，存在两个核心：</p><p>建立表与实体类的映射。</p><p>建立表字段与实体类属性映射，操作实体类就是操作表。</p><p>Hibernate框架作为JPA的实现者之一。</p><p>@Entity&amp;@Table(name&#x3D;“表名”)</p><p>@Entity注解表明这是一个实体类。</p><p>@Table(name&#x3D;“表名”)映射一张表，但是如果表名和实体类名相同的话，@Table可以省略。</p><p>@MappedSuperClass</p><p>用在确定是父类的entity上。父类的属性子类可以继承。</p><p>@NoRepositoryBean</p><p>一般用作父类的repository，有这个注解，SpringBoot不会去实例化该repository。</p><p>@Column</p><p>建立表字段与实体类属性映射，如果字段名与列名相同，则可以省略。</p><p>@Id</p><p>表示该属性为主键。</p><p>@Transient</p><p>表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。</p><p>如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。</p><p>@Basic</p><p>@Basic(fetch&#x3D;FetchType.LAZY)：标记可以指定实体属性的加载方式</p><p>@GeneratedValue</p><p>@GeneratedValue(strategy &#x3D; GenerationType.SEQUENCE,generator &#x3D; “repair_seq”)表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。</p><p>@SequenceGeneretor</p><p>@SequenceGeneretor(name &#x3D; “repair_seq”, sequenceName &#x3D; “seq_repair”, allocationSize &#x3D; 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。</p><p>@JsonIgnore</p><p>作用是json序列化时将Java bean中的一些属性忽略掉,序列化和反序列化都受影响。</p><p>@OneToOne、@OneToMany、@ManyToOne</p><p>对应多表之间的一对一，一对多，多对一关系。</p><ol><li><h3 id="MyBatis怎么使用的"><a href="#MyBatis怎么使用的" class="headerlink" title="MyBatis怎么使用的"></a>MyBatis怎么使用的</h3></li></ol><p><a href="https://javaguide.cn/system-design/framework/mybatis/mybatis-interview.html">详解</a></p><ol><li><h3 id="主从redis集群了解吗"><a href="#主从redis集群了解吗" class="headerlink" title="主从redis集群了解吗"></a>主从redis集群了解吗</h3></li></ol><p><a href="https://xiaolincoding.com/redis/base/redis_interview.html#redis-%E9%9B%86%E7%BE%A4">详解</a></p><ol><li><h3 id="git怎么用的"><a href="#git怎么用的" class="headerlink" title="git怎么用的"></a>git怎么用的</h3></li></ol><p><a href="https://javaguide.cn/tools/git/git-intro.html">详解</a></p><ol><li><h3 id="Linux怎么抓一个日志"><a href="#Linux怎么抓一个日志" class="headerlink" title="Linux怎么抓一个日志"></a>Linux怎么抓一个日志</h3></li></ol><p><a href="https://javaguide.cn/cs-basics/operating-system/linux-intro.html#linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">详解</a></p><p>一：查看日志</p><p>1.使用cat查看日志</p><p>1）cat test.log   查看test.log日志文件的所有信息</p><p>2）cat -n test.log | grep “#”    查看test.log日志文件的中包含“#” 的行</p><p>3）分页 cat -n test.log | grep “get” | more  查看日志文件test.log 中包含“get”的字符，然后分页</p><p>4）重定向 cat -n test.log | grep “get” &gt;test1.log  查看日志文件test.log 中包含“get”的字符，然后写入到文件test1.log 中，（&gt;写入覆盖文件test1.log， &gt;&gt;追加到test1.log 文件后）</p><p>2.使用tail查看日志</p><p>1）tail -n  10 test.log   查看日志文件最后10行数据（和tail -n -10 test.log 意义一样）</p><p>2）tail -n +10 test.log   查看日志文件从10行开始，到末尾结束</p><ol><li>tail -f test.log -n 1000   动态获取查看最后1000条数据</li></ol><p>3.使用head查看日志</p><p>1）head -n 10 test.log   查看日志文件前10行数据（和head -n +10 test.log 意义一样）</p><p>2）head -n  -10 test.log   查看日志文件从头部开始，到倒数第十行结束</p><p>二：拉取日志</p><p>1）如果使用securecrt（secureCRTPortable）软件，可以执行 “ sz  test.log” 命令，将test.log 日志文件下载到本地，</p><p>如果sz命令不存在的话，执行“yum install lrzsz” 命令安装，安装好后使用sz命令下载；</p><h2 id="小米Java实习一面"><a href="#小米Java实习一面" class="headerlink" title="小米Java实习一面"></a>小米Java实习一面</h2><ol><li><h3 id="网络五层介绍"><a href="#网络五层介绍" class="headerlink" title="网络五层介绍"></a>网络五层介绍</h3></li><li><h3 id="http和https的区别"><a href="#http和https的区别" class="headerlink" title="http和https的区别"></a>http和https的区别</h3></li></ol><p><a href="https://xiaolincoding.com/network/2_http/http_interview.html#http-%E4%B8%8E-https">详解</a></p><ol><li><h3 id="https安全认证原理"><a href="#https安全认证原理" class="headerlink" title="https安全认证原理"></a>https安全认证原理</h3></li></ol><p><a href="https://xiaolincoding.com/network/2_http/http_interview.html#https-%E8%A7%A3%E5%86%B3%E4%BA%86-http-%E7%9A%84%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98">详解</a></p><ol><li><h3 id="平时接触过多线程没，说说用过的锁"><a href="#平时接触过多线程没，说说用过的锁" class="headerlink" title="平时接触过多线程没，说说用过的锁"></a>平时接触过多线程没，说说用过的锁</h3></li></ol><p>lock，sy，分布式锁</p><p>具体看一下之前的详解</p><ol><li><h3 id="sy关键字的实现原理"><a href="#sy关键字的实现原理" class="headerlink" title="sy关键字的实现原理"></a>sy关键字的实现原理</h3></li></ol><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97">详解</a></p><ol><li><h3 id="sql优化手段"><a href="#sql优化手段" class="headerlink" title="sql优化手段"></a>sql优化手段</h3></li><li><h3 id="索引使用原则"><a href="#索引使用原则" class="headerlink" title="索引使用原则"></a>索引使用原则</h3></li><li><h3 id="大量的数据查询慢怎么取考虑，入手点在哪？"><a href="#大量的数据查询慢怎么取考虑，入手点在哪？" class="headerlink" title="大量的数据查询慢怎么取考虑，入手点在哪？"></a>大量的数据查询慢怎么取考虑，入手点在哪？</h3></li></ol><p>看慢查询日志，explain查看，具体详解看前面的分析</p><ol><li><h3 id="有一些加索引的数据经常要增删改，又要经常查，怎么平衡这件事？"><a href="#有一些加索引的数据经常要增删改，又要经常查，怎么平衡这件事？" class="headerlink" title="有一些加索引的数据经常要增删改，又要经常查，怎么平衡这件事？"></a>有一些加索引的数据经常要增删改，又要经常查，怎么平衡这件事？</h3></li></ol><p>这个的话，我问了一下AI</p><p>在使用MySQL数据库时，索引对于提高查询效率至关重要，但同时也会对增删改操作产生影响，因为每次修改数据时，MySQL都需要更新索引。为了平衡查询效率和写操作的性能，可以采取以下几种策略：</p><ol><li><strong>选择合适的索引类型</strong>：根据数据的特点选择合适的索引类型，比如对于经常进行范围查询的列使用B-Tree索引，对于经常进行等值查询的列可以使用哈希索引。</li><li><strong>索引列的选择</strong>：只对经常参与查询条件的列创建索引，避免对所有列都创建索引，这样可以减少索引的维护开销。</li><li><strong>使用复合索引</strong>：如果查询经常涉及多个列，可以考虑使用复合索引，这样可以减少索引的数量，同时提高查询效率。</li><li><strong>定期优化索引</strong>：随着数据量的增加，索引可能会变得碎片化，定期使用<code>OPTIMIZE TABLE</code>命令来优化索引可以提高性能。</li><li><strong>写操作批量处理</strong>：尽量将写操作批量处理，减少单次写操作的频率，这样可以减少索引更新的次数。</li><li><strong>使用事务</strong>：合理使用事务可以减少索引的更新次数，因为事务中的写操作可以一次性提交，减少了索引的单独更新。</li><li><strong>分区表</strong>：对于非常大的表，可以考虑使用分区表来提高查询和写操作的性能。</li><li><strong>延迟索引维护</strong>：对于写入密集型的操作，可以考虑在写入操作完成后再更新索引。</li><li><strong>监控和分析</strong>：使用MySQL的慢查询日志和性能监控工具来分析查询性能，根据实际情况调整索引策略。</li><li><strong>读写分离</strong>：如果读操作远多于写操作，可以考虑使用读写分离的架构，将读操作和写操作分散到不同的服务器上。</li><li><strong>使用缓存</strong>：对于经常被查询但很少变更的数据，可以使用缓存来减少数据库的查询压力。</li><li><strong>考虑NoSQL解决方案</strong>：如果数据的写入非常频繁，并且对查询的实时性要求不高，可以考虑使用NoSQL数据库，如MongoDB或Cassandra，它们通常对写入操作有更好的支持。</li></ol><p>每种策略都有其适用场景，需要根据具体的业务需求和数据特点来选择最合适的方案。</p><ol><li><h3 id="可达性分析回收入手点"><a href="#可达性分析回收入手点" class="headerlink" title="可达性分析回收入手点"></a>可达性分析回收入手点</h3></li><li><h3 id="可达性分析哪些类型可以做root"><a href="#可达性分析哪些类型可以做root" class="headerlink" title="可达性分析哪些类型可以做root"></a>可达性分析哪些类型可以做root</h3></li></ol><ul><li>虚拟机栈(栈帧中的局部变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li><li>JNI（Java Native Interface）引用的对象</li></ul><p><a href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95">可达性分析法详解</a></p><ol><li><h3 id="年轻代，老年代的设计理由，有什么好处"><a href="#年轻代，老年代的设计理由，有什么好处" class="headerlink" title="年轻代，老年代的设计理由，有什么好处"></a>年轻代，老年代的设计理由，有什么好处</h3></li></ol><p>在Java虚拟机（JVM）中，堆内存被分为不同的区域，其中“年轻代”和“老年代”是堆内存管理中两个重要的概念。它们各自有不同的设计理由和好处：</p><ul><li>年轻代（Young Generation）</li></ul><p><strong>设计理由：</strong></p><ol><li><strong>对象生命周期短</strong>：大多数对象都是短暂存在的，年轻代用于存放新创建的对象。</li><li><strong>频繁垃圾回收</strong>：年轻代的对象频繁创建和销毁，因此需要频繁地进行垃圾回收。</li><li><strong>空间小</strong>：年轻代的空间相对较小，便于管理。</li></ol><p><strong>好处：</strong></p><ol><li><strong>快速回收</strong>：由于对象生命周期短，年轻代可以快速回收不再使用的对象。</li><li><strong>减少停顿时间</strong>：年轻代的垃圾回收（Minor GC）通常比老年代的垃圾回收（Major GC）要快，减少了程序的停顿时间。</li><li><strong>内存分配效率高</strong>：年轻代的内存分配可以更加高效，因为可以快速地分配和回收内存。</li></ol><ul><li>老年代（Old Generation）</li></ul><p><strong>设计理由：</strong></p><ol><li><strong>对象生命周期长</strong>：一些对象存活时间较长，会被提升到老年代。</li><li><strong>垃圾回收频率低</strong>：老年代的对象不需要频繁进行垃圾回收。</li><li><strong>空间大</strong>：老年代的空间相对较大，用于存放长期存活的对象。</li></ol><p><strong>好处：</strong></p><ol><li><strong>减少频繁垃圾回收</strong>：老年代的对象由于生命周期较长，不需要频繁进行垃圾回收，减少了垃圾回收的开销。</li><li><strong>优化垃圾回收算法</strong>：老年代可以使用不同的垃圾回收算法，如标记-清除、标记-整理等，这些算法更适合处理长期存活的对象。</li><li><strong>稳定内存使用</strong>：老年代的内存使用相对稳定，有助于避免频繁的垃圾回收导致的性能波动。</li></ol><p>​    年轻代和老年代的设计使得JVM可以更有效地管理内存，通过区分对象的生命周期来优化垃圾回收的性能。年轻代的快速回收机制适合处理大量短命对象，而老年代则适合长期存活的对象，两者的结合使用可以提高内存管理的效率和程序的运行性能。</p><ol><li><h3 id="引擎InnoDB的ACID的实现原理"><a href="#引擎InnoDB的ACID的实现原理" class="headerlink" title="引擎InnoDB的ACID的实现原理"></a>引擎InnoDB的ACID的实现原理</h3></li></ol><ul><li>A 表示 Atomic 原子性，也就是需要保证多个 DML 操作是原子的，要么都成功， 要么都失败。 那么，失败就意味着要对原本执行成功的数据进行回滚，所以 InnoDB 设计了一个 UNDO_LOG 表，在事务执行的过程中， 把修改之前的数据快照保存到UNDO_LOG里面，一旦出现错误，就直接从UNDO_LOG 里面读取数据执行反向操作就行了。 </li><li>C 表示一致性，表示数据的完整性约束没有被破坏，这个更多是依赖于业务层面的保证，数据库本身也提供了一些，比如主键的唯一余数，字段长度和类型的保证等等</li><li>I 表示事物的隔离性，也就是多个并行事务对同一个数据进行操作的时候，如何避免多个事务的干扰导致数据混乱的问题。 而 InnoDB 实现了 SQL92 的标准，提供了四种隔离级别的实现。分别是： RU（未提交读） RC（已提交读） RR（可重复读） Serializable（串行化） InnoDB 默认的隔离级别是 RR（可重复读），然后使用了 MVCC 机制解决了脏读和不可重复读的问题，然后使用了行锁&#x2F;表锁的方式解决了幻读的问题。</li><li>D表示持久性，也就是只要事务提交成功，那对于这个数据的结果的影响一定是永久性的。不能因为宕机或者其他原因导致数据变更失效。 理论上来说，事务提交之后直接把数据持久化到磁盘就行了，但是因为随机磁盘 IO 的效率确实很低，所以 InnoDB 设计了 Buffer Pool 缓冲区来优化，也就是数据发生变更的时候先更新内存缓冲区，然后在合适的时机再持久化到磁盘。 那在持久化这个过程中，如果数据库宕机，就会导致数据丢失，也就无法满足持久性了。所以 InnoDB 引入了 Redo_LOG 文件，这个文件存储了数据被修改之后的值，当我们通过事务对数据进行变更操作的时候，除了修改内存缓冲区里面的数据以外，还会把本次修改的值追加到 REDO_LOG 里面。 当提交事务的时候，直接把 REDO_LOG 日志刷到磁盘上持久化，一旦数据库出现宕机，在 Mysql 重启在以后可以直接用 REDO_LOG 里面保存的重写日志读取出来，再执行一 遍从而保证持久性。 </li><li>因此，在我看来，事务的实现原理的核心本质就是如何满足 ACID 的，在 InnDB 里面用到了 MVCC、行锁表锁、UNDO_LOG、REDO_LOG 等机制来保证。</li></ul><ol><li><h3 id="IOC源码讲讲印象最深的地方"><a href="#IOC源码讲讲印象最深的地方" class="headerlink" title="IOC源码讲讲印象最深的地方"></a>IOC源码讲讲印象最深的地方</h3></li></ol><p><a href="https://javaguide.cn/system-design/framework/spring/ioc-and-aop.html">详解</a></p><ol><li><h3 id="工厂模式设计"><a href="#工厂模式设计" class="headerlink" title="工厂模式设计"></a>工厂模式设计</h3></li></ol><p>查看之前的六中常见设计模式</p><ol><li><h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和${}的区别"></a>#{}和${}的区别</h3></li></ol><p>首先，Mybatis 提供到的#号占位符和$号占位符，都是实现动态 SQL 的一种方式，通过这两种方式把参数传递到 XML 之后， 在执行操作之前，Mybatis 会对这两种占位符进行动态解析。（如图）#号占位符，等同于 jdbc 里面的？号占位符。 它相当于向 PreparedStatement 中的预处理语句中设置参数， 而 PreparedStatement 中的 sql 语句是预编译的，SQL 语句中使用了占位符，规定了sql 语句的结构。 并且在设置参数的时候，如果有特殊字符，会自动进行转义。 所以#号占位符可以防止 SQL 注入。而使用$的方式传参，相当于直接把参数拼接到了原始的 SQL 里面，Mybatis 不会对它进行特殊处理。所以$和#最大的区别在于，前者是动态参数，后者是占位符， 动态参数无法防止 SQL 注入的问题，所以在实际应用中，应该尽可能的使用#号占位符。 另外，$符号的动态传参，可以适合应用在一些动态 SQL 场景中，比如动态传递表名、动态设置排序字段等</p><ol><li><h3 id="mybatis中xml配置解析原理"><a href="#mybatis中xml配置解析原理" class="headerlink" title="mybatis中xml配置解析原理"></a>mybatis中xml配置解析原理</h3></li><li><h3 id="mybatis从解析到执行sql语句的原理"><a href="#mybatis从解析到执行sql语句的原理" class="headerlink" title="mybatis从解析到执行sql语句的原理"></a>mybatis从解析到执行sql语句的原理</h3></li><li><h3 id="一级缓存、二级缓存的原理"><a href="#一级缓存、二级缓存的原理" class="headerlink" title="一级缓存、二级缓存的原理"></a>一级缓存、二级缓存的原理</h3></li></ol><p><a href="https://javaguide.cn/system-design/framework/mybatis/mybatis-interview.html">mybatis详解</a></p><p>Mybatis 里面设计了两级缓存来提升数据的检索效率，避免每次数据的访问都需要去查询数据库。先来看一级缓存，它是 SqlSession 级别的缓存，也叫本地缓存，因为每个用户在执行查询的时候都需要使用 SqlSession 来执行，为了避免每次都去查数据库，MyBatis 把查询出来的数据保存到 SqlSession 的本地缓存中，后续的 SQL 如果命中缓存，就可以直接从本地缓存读取。 </p><p>那如果想要实现跨 SqlSession 级别的缓存？一级缓存就无法实现了，因此，MyBatis 引入了二级缓存。当多个用户在查询数据的时候，只要有任何一个 SqlSession 拿到了数据就会放入到二级缓存里面，其他的 SqlSession 就可以从二级缓存加载数据。</p><p>接下来，我给大家详细分析一下 MyBatis 缓存机制的实现原理。先来看一级缓存的实现原理： 在 SqlSession 里面持有一个 Executor 的对象，每个 Executor 中有一个 LocalCache 对象。 当用户发起查询的时候，MyBatis 会根据执行语句在 Local Cache 里面查询，如果没命中，再去查询数据库并写入到 LocalCache，否则直接返回。 </p><p>所以，一级缓存的生命周期只在 SqlSession 级别，而且在多个 SqlSession 或者分布式环境下，可能会导致数据库写操作出现脏数据。那这个时候，就要使用二级缓存。下面来看二级缓存的具体实现原理：</p><p>二级缓存使用了一个叫做 CachingExecutor 的对象，对 Executor 进行了装饰，在进入一级缓存的查询流程之前，会先通过 CachingExecutor 进行二级缓存的查询。 </p><p>开启二级缓存以后，会被多个 SqlSession 共享，所以它是一个全局缓存。因此它的查询流程是先查二级缓存，再查一级缓存，最后再查数据库。 </p><p>另外，MyBatis 的二级缓存相对于一级缓存来说，实现了 SqlSession 之间缓存数据的共享，同时缓存粒度也能够控制到 Name Space 级别，并且还可以通过 Cache 接口实现类不同的组合，对 Cache 的可控性也更强</p><ol><li><h3 id="springboot自动装配原理"><a href="#springboot自动装配原理" class="headerlink" title="springboot自动装配原理"></a>springboot自动装配原理</h3></li></ol><p><a href="https://javaguide.cn/system-design/framework/spring/spring-boot-auto-assembly-principles.html">详解2</a></p><p>自动装配，简单来说就是自动把第三方组件的 Bean 装载到 Spring IOC 器里面，不需 </p><p>要开发人员再去写 Bean 的装配配置。 </p><p>在 Spring Boot 应用里面，只需要在启动类加上@SpringBootApplication 注解就可 </p><p>以实现自动装配。 </p><p>@SpringBootApplication 是一个复合注解，真正实现自动装配的注解是@EnableAutoConfiguration。 </p><p>自动装配的实现主要依靠三个核心关键技术。 </p><ol><li>引入 Starter 启动依赖组件的时候，这个组件里面必须要包含@Configuration 配置类，在这个配置类里面通过@Bean 注解声明需要装配到 IOC 容器的 Bean 对象。</li><li>这个配置类是放在第三方的 jar 包里面，然后通过 SpringBoot 中的约定优于配置思想，把这个配置类的全路径放在 classpath:&#x2F;META-INF&#x2F;spring.factories 文件中。这样 SpringBoot 就可以知道第三方 jar 包里面的配置类的位置，这个步骤主要是用到了 Spring 里面的 SpringFactoriesLoader 来完成的。 </li><li>SpringBoot 拿到第三方 jar 包里面声明的配置类以后，再通过 Spring 提供的ImportSelector 接口，实现对这些配置类的动态加载。在我看来，SpringBoot 是约定优于配置这一理念下的产物，所以在很多的地方，都会看到这类的思想。它的出现，让开发人员更加聚焦在了业务代码的编写上，而不需要去关心和业务无关的配置。</li></ol><p>其实，自动装配的思想，在 SpringFramework3.x 版本里面的@Enable 注解，就有了实现的雏形。@Enable 注解是模块驱动的意思，我们只需要增加某个@Enable 注解， 就自动打开某个功能，而不需要针对这个功能去做 Bean 的配置，@Enable 底层也是帮我们去自动完成这个模块相关 Bean 的注入。</p><ol><li><h3 id="Redis为什么比mysql快"><a href="#Redis为什么比mysql快" class="headerlink" title="Redis为什么比mysql快"></a>Redis为什么比mysql快</h3></li></ol><p>Redis 内部做了非常多的性能优化，比较重要的有下面几点：</p><ol><li><p>Redis 基于内存，内存的访问速度比磁盘快很多；</p></li><li><p>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用；</p></li><li><p>Redis 内置了多种优化过后的数据类型&#x2F;结构实现，性能非常高。</p></li><li><p>Redis 通信协议实现简单且解析高效。</p></li><li><h3 id="DDD架构的理解"><a href="#DDD架构的理解" class="headerlink" title="DDD架构的理解"></a>DDD架构的理解</h3></li></ol><p>抽空看一下</p><p><a href="https://blog.csdn.net/bookssea/article/details/127248954">详解</a></p><h2 id="美团到家一面"><a href="#美团到家一面" class="headerlink" title="美团到家一面"></a>美团到家一面</h2><ol><li><h3 id="jvm讲一下"><a href="#jvm讲一下" class="headerlink" title="jvm讲一下"></a>jvm讲一下</h3></li><li><h3 id="ArrayList扩容讲一下"><a href="#ArrayList扩容讲一下" class="headerlink" title="ArrayList扩容讲一下"></a>ArrayList扩容讲一下</h3></li><li><h3 id="reids为什么快"><a href="#reids为什么快" class="headerlink" title="reids为什么快"></a>reids为什么快</h3></li><li><h3 id="索引为什么用b-树，为什么不用别的"><a href="#索引为什么用b-树，为什么不用别的" class="headerlink" title="索引为什么用b+树，为什么不用别的"></a>索引为什么用b+树，为什么不用别的</h3></li><li><h3 id="事务ACID是什么"><a href="#事务ACID是什么" class="headerlink" title="事务ACID是什么"></a>事务ACID是什么</h3></li><li><h3 id="原子性是怎么保证的"><a href="#原子性是怎么保证的" class="headerlink" title="原子性是怎么保证的"></a>原子性是怎么保证的</h3></li><li><h3 id="Spring的注解讲一下"><a href="#Spring的注解讲一下" class="headerlink" title="Spring的注解讲一下"></a>Spring的注解讲一下</h3></li></ol><h2 id="腾讯PCG一面"><a href="#腾讯PCG一面" class="headerlink" title="腾讯PCG一面"></a>腾讯PCG一面</h2><ol><li><h3 id="zset底层数据结构"><a href="#zset底层数据结构" class="headerlink" title="zset底层数据结构"></a>zset底层数据结构</h3></li></ol><p><a href="https://javaguide.cn/database/redis/redis-skiplist.html">详解</a></p><ol><li><h3 id="hash在redis中的底层实现"><a href="#hash在redis中的底层实现" class="headerlink" title="hash在redis中的底层实现"></a>hash在redis中的底层实现</h3></li></ol><p><a href="https://javaguide.cn/database/redis/redis-data-structures-01.html#hash-%E5%93%88%E5%B8%8C">详解</a></p><ol><li><h3 id="mysql的ACID，隔离级别，默认隔离级别，Redis事务"><a href="#mysql的ACID，隔离级别，默认隔离级别，Redis事务" class="headerlink" title="mysql的ACID，隔离级别，默认隔离级别，Redis事务"></a>mysql的ACID，隔离级别，默认隔离级别，Redis事务</h3></li></ol><p>看前面</p><ol><li><h3 id="redis做缓存-缓存一致性问题，延迟双删"><a href="#redis做缓存-缓存一致性问题，延迟双删" class="headerlink" title="redis做缓存 缓存一致性问题，延迟双删"></a>redis做缓存 缓存一致性问题，延迟双删</h3></li></ol><p><a href="https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7">详解</a></p><ol><li><h3 id="缓存穿透，布隆过滤器原理"><a href="#缓存穿透，布隆过滤器原理" class="headerlink" title="缓存穿透，布隆过滤器原理"></a>缓存穿透，布隆过滤器原理</h3></li></ol><p><a href="https://javaguide.cn/cs-basics/data-structure/bloom-filter.html">布隆过滤器详解</a></p><ol><li><h3 id="计算机网络TCP-UDP-UDP出错了如何处理，TCP的可靠性如何保障，time-wait"><a href="#计算机网络TCP-UDP-UDP出错了如何处理，TCP的可靠性如何保障，time-wait" class="headerlink" title="计算机网络TCP,UDP,UDP出错了如何处理，TCP的可靠性如何保障，time_wait"></a>计算机网络TCP,UDP,UDP出错了如何处理，TCP的可靠性如何保障，time_wait</h3></li></ol><p>看TCP和UDP详解</p><h2 id="滴滴后端一面"><a href="#滴滴后端一面" class="headerlink" title="滴滴后端一面"></a>滴滴后端一面</h2><ol><li><h3 id="进程，线程，协程的区别"><a href="#进程，线程，协程的区别" class="headerlink" title="进程，线程，协程的区别"></a>进程，线程，协程的区别</h3></li><li><h3 id="进程的五种状态，如何切换"><a href="#进程的五种状态，如何切换" class="headerlink" title="进程的五种状态，如何切换"></a>进程的五种状态，如何切换</h3></li></ol><p><a href="https://xiaolincoding.com/os/4_process/process_base.html#_5-1-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">详解</a></p><ol><li><h3 id="http请求头有哪些"><a href="#http请求头有哪些" class="headerlink" title="http请求头有哪些"></a>http请求头有哪些</h3></li></ol><table><thead><tr><th>字段名</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>Accept</td><td>能够接受的回应内容类型（Content-Types）</td><td>Accept: text&#x2F;plain</td></tr><tr><td>Accept-Charset</td><td>能够接受的字符集</td><td>Accept-Charset: utf-8</td></tr><tr><td>Accept-Encoding</td><td>能够接受的编码方式列表</td><td>Accept-Encoding: gzip, deflate</td></tr><tr><td>Accept-Language</td><td>能够接受的回应内容的自然语言列表</td><td>Accept-Language: en-US</td></tr><tr><td>Authorization</td><td>用于超文本传输协议的认证的认证信息</td><td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D;</td></tr><tr><td>Cache-Control</td><td>用来指定在这次的请求&#x2F;响应链中的所有缓存机制 都必须 遵守的指令</td><td>Cache-Control: no-cache</td></tr><tr><td>Connection</td><td>该浏览器想要优先使用的连接类型</td><td>Connection: keep-alive Connection: Upgrade</td></tr><tr><td>Cookie</td><td>服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie</td><td>Cookie: $Version&#x3D;1; Skin&#x3D;new;</td></tr><tr><td>Content-Length</td><td>以 八位字节数组 （8位的字节）表示的请求体的长度</td><td>Content-Length: 348</td></tr><tr><td>Content-Type</td><td>请求体的 多媒体类型</td><td>Content-Type: application&#x2F;x-www-form-urlencoded</td></tr><tr><td>Date</td><td>发送该消息的日期和时间</td><td>Date: Tue, 15 Nov 1994 08:12:31 GMT</td></tr><tr><td>Expect</td><td>表明客户端要求服务器做出特定的行为</td><td>Expect: 100-continue</td></tr><tr><td>Host</td><td>服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号</td><td>Host: <a href="http://en.wikipedia.org/">en.wikipedia.org:80</a> Host: <a href="http://en.wikipedia.org/">en.wikipedia.org</a></td></tr><tr><td>If-Match</td><td>仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源</td><td>If-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>If-Modified-Since</td><td>允许在对应的内容未被修改的情况下返回304未修改</td><td>If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT</td></tr><tr><td>If-None-Match</td><td>允许在对应的内容未被修改的情况下返回304未修改</td><td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>If-Range</td><td>如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体</td><td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>Range</td><td>仅请求某个实体的一部分</td><td>Range: bytes&#x3D;500-999</td></tr><tr><td>User-Agent</td><td>浏览器的浏览器身份标识字符串</td><td>User-Agent: Mozilla&#x2F;5.0 (X11; Linux x86_64; rv:12.0) Gecko&#x2F;20100101 Firefox&#x2F;21.0</td></tr><tr><td>Origin</td><td>发起一个针对 跨来源资源共享 的请求</td><td>Origin: <a href="http://www.example-social-network.com/">http://www.example-social-network.com</a></td></tr></tbody></table><ol><li><h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3></li></ol><p><code>1xx</code> 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。</p><p><code>2xx</code> 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li>「200 OK」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li><li>「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li><li>「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul><p><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。</p><ul><li>「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li><li>「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</li><li>「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。</li></ul><p><code>4xx</code> 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。</p><ul><li>「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p><code>5xx</code> 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。</p><ul><li>「500 Internal Server Error」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「501 Not Implemented」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「503 Service Unavailable」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li></ul><p><a href="https://xiaolincoding.com/network/2_http/http_interview.html#http-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B">详解</a></p><ol><li><h3 id="GET与POST"><a href="#GET与POST" class="headerlink" title="GET与POST"></a>GET与POST</h3></li></ol><p><a href="https://xiaolincoding.com/network/2_http/http_interview.html#get-%E4%B8%8E-post">详解</a></p><ol><li><h3 id="常用的集合，hashtable和concurrentHashMap有什么区别"><a href="#常用的集合，hashtable和concurrentHashMap有什么区别" class="headerlink" title="常用的集合，hashtable和concurrentHashMap有什么区别"></a>常用的集合，hashtable和concurrentHashMap有什么区别</h3></li></ol><p><a href="https://javaguide.cn/java/collection/java-collection-questions-02.html#concurrenthashmap-%E5%92%8C-hashtable-%E7%9A%84%E5%8C%BA%E5%88%AB">区别</a></p><ol><li><h3 id="java的垃圾回收器有哪些"><a href="#java的垃圾回收器有哪些" class="headerlink" title="java的垃圾回收器有哪些"></a>java的垃圾回收器有哪些</h3></li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YWQwNWY2MzViYWY3NzFmM2VmY2FlMjRlM2NmYTJmYmNfRzRzMmliWm1WNGQ1THJaOTI4Qk1xTEtmdlRRdGxVOGZfVG9rZW46SkxiWGJaRnlYb3VNS094UGxvV2NtVFNUbm1lXzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><p><a href="https://javaguide.cn/java/jvm/jvm-intro.html#_3-5-%E4%BA%86%E8%A7%A3-%E5%90%84%E7%A7%8D%E5%90%84%E6%A0%B7%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8">详解</a></p><ol><li><h3 id="mysql的几种事务隔离级别"><a href="#mysql的几种事务隔离级别" class="headerlink" title="mysql的几种事务隔离级别"></a>mysql的几种事务隔离级别</h3></li></ol><p>读未提交，读已提交，可重复读，可串行化</p><ol><li><h3 id="脏读，幻读，不可重复读"><a href="#脏读，幻读，不可重复读" class="headerlink" title="脏读，幻读，不可重复读"></a>脏读，幻读，不可重复读</h3></li></ol><p><strong>脏读（Dirty read）</strong></p><p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p><p>例如：事务 1 读取某表中的数据 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 读取到 A &#x3D; 19,事务 1 回滚导致对 A 的修改并未提交到数据库， A 的值还是 20。</p><p><strong>不可重复读（Unrepeatable read）</strong></p><p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p><p>例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 再次读取 A &#x3D;19，此时读取的结果和第一次读取的结果不同。</p><p><strong>幻读（Phantom read）</strong></p><p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><p>例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</p><p><strong>不可重复读和幻读有什么区别？</strong></p><ul><li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li><li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li></ul><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把幻读区分出来的原因主要是解决幻读和不可重复读的方案不一样。</p><p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p><ol><li><h3 id="Spring-是如何整合MyBatis将Mapper接口注册为Bean的原理？"><a href="#Spring-是如何整合MyBatis将Mapper接口注册为Bean的原理？" class="headerlink" title="Spring:是如何整合MyBatis将Mapper接口注册为Bean的原理？"></a>Spring:是如何整合MyBatis将Mapper接口注册为Bean的原理？</h3></li></ol><p>1.首先MyBatis的Mapper接口核心是JDK动态代理</p><p>2.Spring会排除接口，无法注册到IOC容器中</p><p>3.MyBatis实现了BeanDefinitionRegistryPostProcessor可以动态注册BeanDefinition</p><p>4.需要自定义扫描器（继承Spring内部扫描器ClassPathBeanDefinitionScanner)重写排除接口的方法(isCandidateComponent)</p><p>5.但是接口虽然注册成了BeanDefinition但是无法实例化Bean因为接口无法实例化</p><p>6.需要将BeanDefinition的BeanClass替换成JDK动态代理的实例（偷天换日）</p><p>7.Mybatis通过FactoryBean的工厂方法设计模式可以自由控制Bean的实例化过程，可以在getObject方法中创建JDK动态代理</p><h2 id="某厂java后端实习二面"><a href="#某厂java后端实习二面" class="headerlink" title="某厂java后端实习二面"></a>某厂java后端实习二面</h2><ol><li><h3 id="http和https的区别-1"><a href="#http和https的区别-1" class="headerlink" title="http和https的区别"></a>http和https的区别</h3></li></ol><p><a href="https://javaguide.cn/cs-basics/network/http-vs-https.html">详解</a></p><p><strong>端口号</strong>：HTTP 默认是 80，HTTPS 默认是 443。</p><p><strong>URL 前缀</strong>：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</p><p><strong>安全性和资源消耗</strong>：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p><ol><li><h3 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别"></a>tcp和udp的区别</h3></li></ol><p><strong>是否面向连接</strong>：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</p><p><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</p><p><strong>是否有状态</strong>：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（<strong>这很渣男！</strong>）。</p><p><strong>传输效率</strong>：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</p><p><strong>传输形式</strong>：TCP 是面向字节流的，UDP 是面向报文的。</p><p><strong>首部开销</strong>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</p><p><strong>是否提供广播或多播服务</strong>：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</p><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否面向连接</td><td>是</td><td>否</td></tr><tr><td>是否可靠</td><td>是</td><td>否</td></tr><tr><td>是否有状态</td><td>是</td><td>否</td></tr><tr><td>传输效率</td><td>较慢</td><td>较快</td></tr><tr><td>传输形式</td><td>字节流</td><td>数据报文段</td></tr><tr><td>首部开销</td><td>20 ～ 60 bytes</td><td>8 bytes</td></tr><tr><td>是否提供广播或多播服务</td><td>否</td><td>是</td></tr></tbody></table><p><a href="https://javaguide.cn/cs-basics/network/other-network-questions2.html#tcp-%E4%B8%8E-udp-%E7%9A%84%E5%8C%BA%E5%88%AB-%E9%87%8D%E8%A6%81">详解</a></p><ol><li><h3 id="三次握手和四次挥手-1"><a href="#三次握手和四次挥手-1" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h3></li></ol><p><a href="https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html">详解</a></p><ol><li><h3 id="说说事物的四大特性-各个实现"><a href="#说说事物的四大特性-各个实现" class="headerlink" title="说说事物的四大特性 各个实现"></a>说说事物的四大特性 各个实现</h3></li></ol><ul><li>持久性是通过 redo log （重做日志）来保证的；</li><li>原子性是通过 undo log（回滚日志） 来保证的；</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li><li>一致性则是通过持久性+原子性+隔离性来保证；</li></ul><ol><li><h3 id="脏读和幻读的区别"><a href="#脏读和幻读的区别" class="headerlink" title="脏读和幻读的区别"></a>脏读和幻读的区别</h3></li></ol><ul><li>脏读：读到其他事务未提交的数据；</li><li>不可重复读：前后读取的数据不一致；</li><li>幻读：前后读取的记录数量不一致。</li></ul><ol><li><h3 id="对于springboot的理解，常用注解"><a href="#对于springboot的理解，常用注解" class="headerlink" title="对于springboot的理解，常用注解"></a>对于springboot的理解，常用注解</h3></li></ol><p>首先，说Springboot必须先说Spring，Spring提供了一种简单的方法通过依赖注入和面向切面编程，使用简单的Java对象实现了EJB的功能</p><p>但是虽然组件代码是轻量级的，但是配置确是重量级的，需要大量的xml，Spring2.5引入了基于注解的组件扫描，消除了大量针对程序自身组件的显式xml配置，Spring3.0引入基于Java的配置，这是一种类型安全的可重构配置方式，可以代替xml</p><p>尽管如此，我们依然没能逃脱配置的魔爪，开启某些Spring的特性的时候，依然需要显式的配置，比如事务管理，SpringMVC，还有一些第三方的配置，也需要显式的xml配置，比如thymeleaf的web视图，配置servlet和过滤器等，组件扫描减少了配置量，但是依然需要大量的配置</p><p>光是xml文件的就可能需要占用我们大量的时间，除此之外，相关库的依赖也非常让人头疼，不同库之间的版本冲突非常常见</p><p>所以就有了Springboot</p><p>Spring Boot可以轻松创建独立的生产级基于Spring的应用程序,只要通过 “just run”（可能是run ‘Application’或java -jar 或 tomcat 或 maven插件run 或 shell脚本）便可以运行项目。大部分Spring Boot项目只需要少量的配置即可</p><ul><li>开发基于Spring的应用程序很容易</li><li>SpringBoot项目所需的开发或工程时间明显减少，通常会提高整体的生厂力</li><li>SpringBoot不需要编写大量的样板代码，xml配置和注释</li><li>Spring引导应用程序可以容易地与Spring生态系统集成，SpringJDBC、SpringORM，SpringData，SpringSecurity等</li><li>遵循默认配置，以减少开发工作，默认配置可以修改</li><li>提供嵌入式的HTTP服务器，Tomcat和Jetty，可以轻松的开发和测试web应用程序</li><li>提供了命令行接口工具（CLI），用于开发和测试springBoot应用程序，如Java或者Groovy</li><li>提供和很多的插件，可以使用内置的工具（Maven或者Gradle）开发和测试SpringBoot应用程序</li></ul><ol><li><h3 id="AOP的使用，对底层的了解"><a href="#AOP的使用，对底层的了解" class="headerlink" title="AOP的使用，对底层的了解"></a>AOP的使用，对底层的了解</h3></li></ol><p><a href="https://javaguide.cn/system-design/framework/spring/ioc-and-aop.html#aop-aspect-oriented-programming">详解</a></p><ol><li><h3 id="创建索引需要注意什么"><a href="#创建索引需要注意什么" class="headerlink" title="创建索引需要注意什么"></a>创建索引需要注意什么</h3></li></ol><p>看前面的</p><ol><li><h3 id="索引失效场景"><a href="#索引失效场景" class="headerlink" title="索引失效场景"></a>索引失效场景</h3></li><li><h3 id="聚簇索引和非聚簇索引的区别-1"><a href="#聚簇索引和非聚簇索引的区别-1" class="headerlink" title="聚簇索引和非聚簇索引的区别"></a>聚簇索引和非聚簇索引的区别</h3></li><li><h3 id="各类垃圾回收算法以及优缺点"><a href="#各类垃圾回收算法以及优缺点" class="headerlink" title="各类垃圾回收算法以及优缺点"></a>各类垃圾回收算法以及优缺点</h3></li></ol><p><a href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html">详解</a></p><h2 id="京东Java实习业务面试"><a href="#京东Java实习业务面试" class="headerlink" title="京东Java实习业务面试"></a>京东Java实习业务面试</h2><ol><li><h3 id="说说类的加载机制"><a href="#说说类的加载机制" class="headerlink" title="说说类的加载机制"></a>说说类的加载机制</h3></li></ol><p><a href="https://javaguide.cn/java/jvm/class-loading-process.html">详解</a></p><ol><li><h3 id="说说JVM"><a href="#说说JVM" class="headerlink" title="说说JVM"></a>说说JVM</h3></li></ol><p><a href="https://javaguide.cn/home.html#jvm-%E5%BF%85%E7%9C%8B">详解</a></p><ol><li><h3 id="MongoDB和MySQL的区别以及各自的优势"><a href="#MongoDB和MySQL的区别以及各自的优势" class="headerlink" title="MongoDB和MySQL的区别以及各自的优势"></a>MongoDB和MySQL的区别以及各自的优势</h3></li></ol><p>MongoDB和MySQL的区别：</p><ol><li>数据库类型：</li></ol><p>MongoDB是一个文档型数据库，它存储的是文档型数据(如JSON格式)。</p><p>MySQL是一个关系型数据库，它存储的是结构化的表格数据。</p><ol><li>数据模式：</li></ol><p>MongoDB采用动态模式，这意味着同一个集合中的文档不需要有相同的字段和结构。</p><p>MySQL则需要预先定义字段。</p><ol><li>查询语言：</li></ol><p>MongoDB使用面向文档的查询语言，可以方便地对JSON格式的数据进行查询。</p><p>MySQL则使用标准的SQL语言进行数据库查询。</p><ol><li>索引：</li></ol><p>MongoDB可以对任何属性建立索引，这使得数据检索更加灵活。</p><p>MySQL则主要对表中的列建立索引。</p><ol><li>扩展性：</li></ol><p>MongoDB是一个基于分布式文件存储的数据库，可以方便地扩展到大量的数据和高并发场景。</p><p>MySQL的扩展性相对有限，通常通过垂直扩展（如升级硬件）来提高性能。</p><ol><li>事务处理：</li></ol><p>MongoDB:不支持传统的事务处理，这可能在某些需要高度数据一致性的场景中成为限制。</p><p>MySQL在复杂事务处理和数据完整性方面更可靠，提供了完善的事务管理机制。</p><p><em>MongoDB的优势：</em></p><ol><li>灵活性：由于MongoDB采用文档型存储和动态模式，它非常适合处理非结构化或半结构化数据，无需事先定义严格的数据模式。</li><li>易于扩展：MongoDB的分布式存储架构使得它能够轻松应对大量数据和高并发场景，非常适合构建大型、复杂的应用系统。</li><li>实时性：MongoDB对写入操作有较低的延迟，这使其非常适合实时应用，如物联网、在线游戏等。</li></ol><p><em>MySQL的优势：</em></p><ol><li><p>性能优越：MySQL支持大量的并发连接，同时拥有很高的查询速度，适用于各种规模的应用场景。</p></li><li><p>易用性：MySQL使用标准的SQL语言，对于熟悉SQL的开发人员来说非常友好，上手成本低。</p></li><li><p>灵活性：虽然MySQL是关系型数据库，但它支持多种存储引擎，用户可以根据不同需求选择不同的存储擎。</p></li><li><p>高可靠性：MySQL在稳定性方面表现出色，能的够在处理高负载的情况下保持高可靠性，适合构建关键业务应用。</p></li><li><h3 id="MySQL的事务"><a href="#MySQL的事务" class="headerlink" title="MySQL的事务"></a>MySQL的事务</h3></li></ol><p><a href="https://javaguide.cn/database/mysql/transaction-isolation-level.html">详解</a></p><ol><li><h3 id="说说Redis的淘汰机制"><a href="#说说Redis的淘汰机制" class="headerlink" title="说说Redis的淘汰机制"></a>说说Redis的淘汰机制</h3></li></ol><p><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E4%BA%86%E8%A7%A3%E4%B9%88">详解</a></p><ol><li><h3 id="Redis常用数据类型"><a href="#Redis常用数据类型" class="headerlink" title="Redis常用数据类型"></a>Redis常用数据类型</h3></li></ol><p><a href="https://xiaolincoding.com/redis/data_struct/command.html#string">详解</a></p><h2 id="用友Java开发面经"><a href="#用友Java开发面经" class="headerlink" title="用友Java开发面经"></a>用友Java开发面经</h2><ol><li><h3 id="java的基本数据类型"><a href="#java的基本数据类型" class="headerlink" title="java的基本数据类型"></a>java的基本数据类型</h3></li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NzM0MzgzZWNlNjkyOTRjYTUzY2MyNDlkYTljYmUxYjRfZzBTTldaQ1JrMUhkb1FZamhITGd0VWpZM3NUTVVjcWdfVG9rZW46S1I5Z2JGMDRBb0xFdmN4eUFRY2NPb1RDblJ2XzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><ol><li><h3 id="int和Integer的区别"><a href="#int和Integer的区别" class="headerlink" title="int和Integer的区别"></a>int和Integer的区别</h3></li></ol><p>Integer是int的包装类</p><ol><li><h3 id="ArrayList和HashMap的底层实现"><a href="#ArrayList和HashMap的底层实现" class="headerlink" title="ArrayList和HashMap的底层实现"></a>ArrayList和HashMap的底层实现</h3></li></ol><p><code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。</p><p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于等于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><p><code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p><ol><li><h3 id="数据库的ACID"><a href="#数据库的ACID" class="headerlink" title="数据库的ACID"></a>数据库的ACID</h3></li><li><h3 id="Mysql的原子性是用什么去实现的"><a href="#Mysql的原子性是用什么去实现的" class="headerlink" title="Mysql的原子性是用什么去实现的"></a>Mysql的原子性是用什么去实现的</h3></li></ol><p>undolog</p><ol><li><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3></li></ol><p>读未提交，读已提交，可重复读，可串行化</p><ol><li><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3></li></ol><p>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</p><p><a href="https://javaguide.cn/database/mysql/mysql-index.html">详解</a></p><ol><li><h3 id="innoDB默认使用什么类型的索引"><a href="#innoDB默认使用什么类型的索引" class="headerlink" title="innoDB默认使用什么类型的索引"></a>innoDB默认使用什么类型的索引</h3></li></ol><p>b+树</p><ol><li><h3 id="b-树和b树的区别"><a href="#b-树和b树的区别" class="headerlink" title="b+树和b树的区别"></a>b+树和b树的区别</h3></li></ol><p>看上</p><ol><li><h3 id="什么是索引下推"><a href="#什么是索引下推" class="headerlink" title="什么是索引下推"></a>什么是索引下推</h3></li></ol><p><a href="https://javaguide.cn/database/mysql/mysql-index.html#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8">详解</a></p><ol><li><h3 id="TCP协议是属于那一层的"><a href="#TCP协议是属于那一层的" class="headerlink" title="TCP协议是属于那一层的"></a>TCP协议是属于那一层的</h3></li></ol><p>传输层</p><ol><li><h3 id="浏览器地址栏输入url会发生什么"><a href="#浏览器地址栏输入url会发生什么" class="headerlink" title="浏览器地址栏输入url会发生什么"></a>浏览器地址栏输入url会发生什么</h3></li><li><h3 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h3></li></ol><p>Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><p><strong>Cookie 一般用来保存用户信息</strong> 比如 ① 我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；② 一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③ 登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><ol><li><h3 id="Session-Storage和Local-Storage的区别"><a href="#Session-Storage和Local-Storage的区别" class="headerlink" title="Session Storage和Local Storage的区别"></a>Session Storage和Local Storage的区别</h3></li></ol><p><a href="https://blog.csdn.net/weixin_42289279/article/details/134000908">详解</a></p><ol><li><h3 id="IOC和AOP是什么"><a href="#IOC和AOP是什么" class="headerlink" title="IOC和AOP是什么"></a>IOC和AOP是什么</h3></li></ol><p><a href="https://javaguide.cn/system-design/framework/spring/ioc-and-aop.html">详解</a></p><h2 id="招银后端一面"><a href="#招银后端一面" class="headerlink" title="招银后端一面"></a>招银后端一面</h2><ol><li><h3 id="MySql优化"><a href="#MySql优化" class="headerlink" title="MySql优化"></a>MySql优化</h3></li></ol><p>四个层面： </p><p>硬件和操作系统层面的优化 </p><p>架构设计层面的优化 </p><p>MySQL 程序配置优化 </p><p>SQL 优化</p><ol><li><h3 id="创建索引的要求，方法，规范"><a href="#创建索引的要求，方法，规范" class="headerlink" title="创建索引的要求，方法，规范"></a>创建索引的要求，方法，规范</h3></li></ol><p>索引的创建</p><p>定义有主键和外键的字段列一定要建立索引（数据库默认建立主键索引）；</p><p>对于查询频率高，频繁作为 WHERE 条件且不同值较多的列，以及频繁出现在关键字ORDER BY、GROUP BY、DISTINCT后面的列，需要建立索引；</p><p>经常与其他表进行JOIN连接的表，在连接字段上应该建立索引；</p><p>对于那些查询中很少涉及的列，重复值比较多的列（一般为逻辑型字段，比如性别，只有男、女、其他三种值，这种字段区分度不高）不要建立索引；</p><p>频繁更新的字段不适合建立索引；</p><p>索引应该建在小字段上，对于定义为text等文本数据类型的列不要建立索引；</p><p>表的数据量很少的情况下不适合建立索引；</p><p>限制每张表上的索引数量，不超过5个；</p><ol><li><h3 id="索引失效的场景"><a href="#索引失效的场景" class="headerlink" title="索引失效的场景"></a>索引失效的场景</h3></li><li><p>联合索引不满足最左匹配原则</p></li><li><p>使用了select *</p></li><li><p>索引列参与运算</p></li><li><p>索引列参使用了函数</p></li><li><p>错误的Like使用</p></li><li><p>类型隐式转换</p></li><li><p>使用OR操作</p></li><li><p>两列做比较</p></li><li><p>不等于比较</p></li><li><p>is not null</p></li><li><p>not in和not exists</p></li><li><p>order by导致索引失效(主键使用不会失效)</p></li><li><p>参数不同导致索引失效</p></li></ol><p><a href="https://blog.csdn.net/cxyxysam/article/details/135679765">详解</a></p><ol><li><h3 id="写一个sql语句，找出表A中重复的业务字段数据b"><a href="#写一个sql语句，找出表A中重复的业务字段数据b" class="headerlink" title="写一个sql语句，找出表A中重复的业务字段数据b"></a>写一个sql语句，找出表A中重复的业务字段数据b</h3></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> b,<span class="built_in">COUNT</span> (<span class="operator">*</span>) <span class="keyword">as</span> count <span class="keyword">FROM</span> A <span class="keyword">GROUP</span> <span class="keyword">BY</span> b <span class="keyword">HAVING</span> <span class="built_in">COUNT</span> (<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><ol><li><h3 id="Spring中的事务是用来干什么的"><a href="#Spring中的事务是用来干什么的" class="headerlink" title="Spring中的事务是用来干什么的"></a>Spring中的事务是用来干什么的</h3></li></ol><p><a href="https://javaguide.cn/system-design/framework/spring/spring-transaction.html">详解</a></p><ol><li><h3 id="事务的实现方式"><a href="#事务的实现方式" class="headerlink" title="事务的实现方式"></a>事务的实现方式</h3></li><li><h3 id="事务的注解"><a href="#事务的注解" class="headerlink" title="事务的注解"></a>事务的注解</h3></li><li><h3 id="如果希望在A方法调用B方法时，即使B方法报错也不回滚A方法的数据，怎么办"><a href="#如果希望在A方法调用B方法时，即使B方法报错也不回滚A方法的数据，怎么办" class="headerlink" title="如果希望在A方法调用B方法时，即使B方法报错也不回滚A方法的数据，怎么办"></a>如果希望在A方法调用B方法时，即使B方法报错也不回滚A方法的数据，怎么办</h3></li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MDY3NmU5OGVlNjAxZjAxZjhiZjhlYjEyOTU0ODJkMmJfRE5ncWJ2cW1kbGlaV1FHYjl2UU5pSEtkS1pzQTNBb2xfVG9rZW46SmpVOGJQcEpabzRmYTR4N2FsMGNlS2lhbkR3XzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><ol><li><h3 id="设计模式有了解吗"><a href="#设计模式有了解吗" class="headerlink" title="设计模式有了解吗"></a>设计模式有了解吗</h3></li></ol><p>看上面</p><ol><li><h3 id="单例模式，应用场景，写一下单例模式"><a href="#单例模式，应用场景，写一下单例模式" class="headerlink" title="单例模式，应用场景，写一下单例模式"></a>单例模式，应用场景，写一下单例模式</h3></li></ol><p>双重检查的单例模式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance==<span class="literal">null</span>)&#123;</span><br><span class="line">                    instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要double-check？单check不可以吗？</p><p>进行了两次<code>if(instance == null)</code>检查，这样就可以保证线程安全了。实例化代码只用执行一次，后面再访问时，直接<code>return</code>实例化的对象。</p><p>需要第二重 <code>if(instance ==null)</code>检查的原因</p><p>考虑这样一种情况，就是有两个线程同时到达，即同时调用 <code>getInstance()</code> 方法，此时由于 <code>instance == null</code> ，所以很明显，两个线程都可以通过第一重的 <code>singleton== null</code>，进入第一重 if 语句后，由于存在锁机制，所以会有一个线程进入 <code>lock</code> 语句并进入第二重 <code>singleton == null</code>，而另外的一个线程则会在 <code>lock</code> 语句的外面等待。</p><p>当第一个线程执行完 <code>new Singleton()</code>语句后，便会退出锁定区域，此时，第二个线程便可以进入 <code>lock</code> 语句块，此时，如果没有第二重<code>singleton == null</code> 的话，那么第二个线程还是可以调用<code>new Singleton（）</code>语句，这样第二个线程也会创建一个 Singleton实例，这样也还是违背了单例模式的初衷的，所以这里必须要使用双重检查锁定。</p><p>需要第一重 <code>if(instance ==null)</code>检查的原因</p><p>如果去掉第一重 <code>instance == null </code>，程序还是可以在多线程下安全运行的。</p><p>考虑在没有第一重 <code>instance == null</code> 的情况：当有两个线程同时到达，此时，由于<code>lock </code>机制的存在，假设第一个线程会进入 <code>lock</code> 语句块，并且可以顺利执行 <code>new Singleton（）</code>，当第一个线程退出 lock 语句块时， <code>instance</code>这个静态变量已不为<code>null </code>了，所以当第二个线程进入 <code>lock</code> 时，会被第二重<code> instance== null</code> 挡在外面，而无法执行<code> new Singleton（）</code>，所以在没有第一重<code>instance== null</code>的情况下，也是可以实现单例模式的。</p><p>那么为什么需要第一重 <code>instance== null</code> 呢？</p><p>这里就涉及一个性能问题了，因为对于单例模式的话，<code>new Singleton（）</code>只需要执行一次就 OK 了，而如果没有第一重<code>instance== null</code>的话，每一次有线程进入<code>getInstance（）</code>时，均会执行锁定操作来实现线程同步，这是非常耗费性能的，而如果我加上第一重<code>instance== null</code>的话，那么就只有在第一次执行锁定以实现线程同步，而以后的话，便只要直接返回 <code>Singleton</code> 实例就OK了，而根本无需再进入<code>lock</code>语句块了，这样就可以解决由线程同步带来的性能问题了。</p><p>第二个问题：为什么要使用<code>volatile</code>？</p><p>主要在于<code>instance = new Singleton()</code>这句，这并非是一个原子操作，事实上在 JVM 中这句话做了下面 3 件事情： 给<code> instance</code> 分配内存 调用 <code>Singleton</code> 的构造函数来初始化成员变量 将<code>instance</code>对象指向分配的内存空间（执行完这步<code>instance</code> 就为非 <code>null</code> 了）</p><p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第2步和第3步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，线程一被调度器暂停，此时线程二刚刚进来第一重检查，看到的 instance 已经是非 null 了（没有调用 <code>Singleton</code> 的构造函数来初始化成员变量，里面的值可能是null&#x2F;false&#x2F;0，总之不是构造函数中指定的值），然后直接使用线程二返回<code> instance</code>，程序就会报错或者是看到了非预期的值（因为此时属性的值是默认值而不是所需要的值）。</p><ol><li><h3 id="为什么MySQL不建议使用NULL作为列默认值"><a href="#为什么MySQL不建议使用NULL作为列默认值" class="headerlink" title="为什么MySQL不建议使用NULL作为列默认值"></a>为什么MySQL不建议使用NULL作为列默认值</h3></li><li><p>所有使用NULL值的情况，都可以通过一个有意义的值的表示，这样有利于代码的可读性和可维护性，并能从约束上增强业务数据的规范性。</p></li><li><p>NULL值到非NULL的更新无法做到原地更新，更容易发生索引分裂，从而影响性能。</p></li><li><p>NULL值在timestamp类型下容易出问题，特别是没有启用参数explicit_defaults_for_timestamp</p></li><li><p>NOT IN、!&#x3D; 等负向条件查询在有 NULL 值的情况下返回永远为空结果，查询容易出错</p></li><li><p>Null 列需要更多的存储空间：需要一个额外字节作为判断是否为 NULL 的标志位</p></li><li><p>NULL通过任一操作符与其它值比较都会得到NULL,除了&lt;&#x3D;&gt;.</p></li><li><p>NULL 代表一个不确定的值,就算是两个 NULL,它俩也不一定相等.(像不像 C 中未初始化的局部变量)</p></li><li><p>任何有返回值的表达式中有NULL参与时,都会得到另外一个NULL值.</p></li><li><p>对含有 NULL 值的列进行统计计算 count(),max(),min(),结果并不符合我们的期望值；使用count(<em>) 或者 count(null column)结果不同,count(null column)&lt;&#x3D;count(</em>).</p></li><li><p>干扰排序，分组,去重结果，虽然select NULL&#x3D;NULL的结果为false,但是在我们使用distinct,group by,order by时,NULL又被认为是相同值.</p></li></ol><p>总结</p><p>MySQL不建议使用NULL作为列默认值的原因有几个。首先，NULL在SQL中表示“未知”，而不是“空”或“不存在”。当列被设置为NULL默认值时，它可能会导致查询和数据处理时的困惑和错误。</p><p>其次，使用NULL默认值可能会导致查询和处理数据时的复杂性增加。在查询中，需要额外处理NULL值的情况，这可能会使查询逻辑变得复杂且容易出错。此外，对NULL值进行数学运算或连接操作时，结果可能不符合预期，需要额外处理或排除NULL值。</p><p>另外，使用NULL默认值也会影响索引和性能。在数据库中，索引是提高查询性能的重要手段，但索引通常不会包含NULL值。如果列默认值为NULL，则该列中的大量数据可能为NULL，这会导致索引效率下降，进而影响查询性能。</p><p>综上所述，为了避免产生歧义、增加查询复杂性、影响索引和性能，MySQL不建议使用NULL作为列默认值。相反，建议使用适当的默认值或允许空字符串作为默认值，这样可以更直观、简洁地表达数据意图，并提高数据库查询和处理的效率和准确性。</p><h2 id="美团门票度假java实习"><a href="#美团门票度假java实习" class="headerlink" title="美团门票度假java实习"></a>美团门票度假java实习</h2><ol><li><h3 id="介绍一下redission分布式锁"><a href="#介绍一下redission分布式锁" class="headerlink" title="介绍一下redission分布式锁"></a>介绍一下redission分布式锁</h3></li></ol><p>在当今的分布式系统架构中，多个进程或线程可能需要同时访问共享资源，这时候就需要引入分布式锁来保证数据的一致性和系统的稳定性。Redission是一个在Redis基础上实现的Java驻内存数据网格，提供了丰富的分布式对象和服务，其中包括分布式锁。</p><p>分布式锁需满足四个条件</p><p>首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p><ol><li><p>互斥性。在任意时刻，只有一个客户端能持有锁。</p></li><li><p>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</p></li><li><p>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了，即不能误解锁。</p></li><li><p>具有容错性。只要大多数Redis节点正常运行，客户端就能够获取和释放锁。</p></li><li><h3 id="redission分布式锁底层如何实现"><a href="#redission分布式锁底层如何实现" class="headerlink" title="redission分布式锁底层如何实现"></a>redission分布式锁底层如何实现</h3></li></ol><p>Redisson中的分布式锁基于Redis的Redlock算法实现，通过多个Redis节点来保证锁的分布式特性。Redlock算法要求客户端在获取锁时，需要向多个Redis节点发起请求，只有当大部分节点都成功获取锁时，才认为整个分布式系统成功获取了锁。这样可以有效避免单点故障，提高系统的可用性。</p><p>在Redisson中，分布式锁的实现主要包括以下几个步骤：</p><ol><li><p>客户端向Redis节点发送获取锁的请求，请求中包含锁的唯一标识和锁的过期时间。</p></li><li><p>Redis节点收到请求后，会检查当前是否有其他客户端持有该锁。如果有，则拒绝请求；如果没有，则将该锁标记为被当前客户端持有，并设置锁的过期时间。</p></li><li><p>客户端在持有锁期间，可以对共享资源进行访问。当访问完成后，客户端需要主动释放锁，以便其他客户端可以获取该锁。</p></li><li><p>如果客户端在持有锁期间出现宕机或其他异常情况，Redis节点会在锁的过期时间到达后自动释放该锁，避免死锁现象的发生。</p></li><li><h3 id="基于setnx实现的分布式锁有哪些缺点"><a href="#基于setnx实现的分布式锁有哪些缺点" class="headerlink" title="基于setnx实现的分布式锁有哪些缺点"></a>基于setnx实现的分布式锁有哪些缺点</h3></li></ol><p>基于setnx的分布式锁存在单点风险，如果存储的分布式锁key挂掉的话，就可能存在丢锁的风险。一旦丢锁，就会造成多个客户端同时握有锁，从而导致分布式锁失败。</p><ul><li>客户端A 从master拿到锁lock01</li><li>master正要把lock01同步(Redis的主从同步通常是异步的）给slave时，突然宕机了，导致lock01没同步给slave</li><li>主从切换，slave节点被晋级为master节点</li><li>客户端B到master拿lock01照样能拿到。这样必将导致同一把锁被多人使用。</li></ul><ol><li><h3 id="基于redis如何实现可重入的分布式锁"><a href="#基于redis如何实现可重入的分布式锁" class="headerlink" title="基于redis如何实现可重入的分布式锁"></a>基于redis如何实现可重入的分布式锁</h3></li></ol><ul><li>客户端获取 Redis 连接，通过 setnx 命令设置一个唯一的锁标识符，如果返回值是 1，表示获取到锁，否则锁已经被其他客户端持有，需要等待一段时间后重新获取锁。</li><li>在获取到锁之后，客户端需要设置一个过期时间，防止锁无法释放。</li><li>客户端释放锁时，需要判断锁是否是自己持有的，如果是，则可以通过 del 命令来释放锁。</li></ul><p>重入锁是指同一进程中的线程可以重复获取同一把锁。实现重入锁需要在锁的状态中保存持有者的标识符和持有次数，每次加锁时判断锁的状态中是否已经包含了当前线程的标识符，如果包含则持有次数加一，否则需要等待其他线程释放锁。</p><p>释放重入锁时，需要判断当前持有锁的线程是否是当前线程，如果是，则需要将持有次数减一，直到持有次数为 0 时才可以释放锁。</p><ol><li><h3 id="如何自己实现一个限流算法中的滑动窗口"><a href="#如何自己实现一个限流算法中的滑动窗口" class="headerlink" title="如何自己实现一个限流算法中的滑动窗口"></a>如何自己实现一个限流算法中的滑动窗口</h3></li></ol><p>利用zset实现滑动窗口限流</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjRlNzkxZTYxOGRkY2UzYWRlMzM4OTI4ZjdlMzllNjZfajlZSTFrZFZhcVJMaEFSaFE4d3dXQ21WRVR4ZnhFQ3hfVG9rZW46UW1TcmJZQk01b1VXUjN4ckdJWmNYaFBZbjFiXzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 滑动窗口限流. 需要注意的是，我们要定期清楚过期的key，否则会导致内存泄漏，可以使用ZREMRANGEBYSCORE方法实现.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 限流的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeWindow 单位时间，秒</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> limit 窗口大小，单位时间最大容许的令牌数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable 成功后的回调方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">slidingWindow</span><span class="params">(String key, <span class="type">int</span> timeWindow, <span class="type">int</span> limit, Runnable runnable)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (redisTemplate.hasKey(key)) &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">intervalTime</span> <span class="operator">=</span> timeWindow * <span class="number">1000L</span>;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">from</span> <span class="operator">=</span> currentTime - intervalTime;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForZSet().rangeByScore(key, from, currentTime).size();</span><br><span class="line">        <span class="keyword">if</span> (count != <span class="literal">null</span> &amp;&amp; count &gt;= limit) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RedisLimitException</span>(<span class="string">&quot;每&quot;</span> + timeWindow + <span class="string">&quot;秒最多只能访问&quot;</span> + limit + <span class="string">&quot;次.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;from key:&#123;&#125;~&#123;&#125;,current count:&#123;&#125;&quot;</span>, from, currentTime, count);</span><br><span class="line">    &#125;</span><br><span class="line">    redisTemplate.opsForZSet().add(key, UUID.randomUUID().toString(), currentTime);</span><br><span class="line">    Optional.ofNullable(runnable).ifPresent(o -&gt; o.run());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面实现了一个基于时间戳为主要窗口依据的滑动窗口限流逻辑，由于zset的数据量会随着时间的流失而变大，所以我们需要定期再根据score来清理它。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清期昨天的zset元素,这块应该写个任务调度，每天执行一次，清量需要的zset元素.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delByYesterday</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Instant</span> <span class="variable">currentInstant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">    <span class="type">Instant</span> <span class="variable">oneDayAgoInstant</span> <span class="operator">=</span> currentInstant.minusSeconds(<span class="number">86400</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">oneDayAgoTimeMillis</span> <span class="operator">=</span> oneDayAgoInstant.toEpochMilli();</span><br><span class="line">    redisTemplate.opsForZSet().removeRangeByScore(key, <span class="number">0</span>, oneDayAgoTimeMillis);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><h3 id="jvm内存结构"><a href="#jvm内存结构" class="headerlink" title="jvm内存结构"></a>jvm内存结构</h3></li></ol><p>虚拟机栈，本地方法栈，堆，程序计数器，方法区</p><p>详解看上面</p><ol><li><h3 id="本地方法栈和虚拟机栈的区别"><a href="#本地方法栈和虚拟机栈的区别" class="headerlink" title="本地方法栈和虚拟机栈的区别"></a>本地方法栈和虚拟机栈的区别</h3></li></ol><p>本地方法栈（Native Method Stacks）与虚拟机栈（VM Stack）在Java虚拟机中各自扮演着重要的角色，但它们之间存在一些显著的区别。</p><p>首先，两者的服务对象不同。虚拟机栈主要为Java方法（也就是字节码）服务，主管Java程序运行，保存方法的局部变量、部分结果，并参与方法的调用和返回。而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。本地方法是用其他语言（如C、C++）编写的方法，通过Java Native Interface（JNI）调用。因此，本地方法栈的存在主要是为了支持本地方法的调用。</p><p>其次，两者在结构上也有所不同。虚拟机栈是每个线程创建时都创建的，内部保存的单位是栈帧，对应一次次方法调用，其生命周期与线程一致。而本地方法栈与虚拟机栈一样，也是线程私有的，每个线程都有一个本地方法栈。这意味着每个线程都有自己独立的本地方法栈和虚拟机栈，它们之间进行独立的分配和释放。</p><p>最后，两者在异常处理上也有所区别。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时抛出异常。具体来说，当线程请求的栈容量超过固定大小时，会抛出StackOverflowError异常；而当没有足够的内存进行动态拓展时，会抛出OutOfMemoryError错误。</p><ol><li><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3></li></ol><p>加载-&gt;连接（验证，准备，解析）-&gt;初始化-&gt;使用-&gt;卸载</p><ol><li><h3 id="redis的常见数据结构"><a href="#redis的常见数据结构" class="headerlink" title="redis的常见数据结构"></a>redis的常见数据结构</h3></li><li><h3 id="zset的底层数据结构"><a href="#zset的底层数据结构" class="headerlink" title="zset的底层数据结构"></a>zset的底层数据结构</h3></li></ol><p><code>zset</code>也有两种不同的实现，分别是<code>zipList</code>和<code>skipList</code>。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NmRmNjI4MmQzZjMxNWIwMjk3ZmJjYzQyMmUxOGQzMzBfUTAwWGNaZ2ZJOGhyR1ZxUnRWSzJnUERwazFsNUVxUWhfVG9rZW46TXpCR2JwaDJsb2k5RTV4TnY1aWNxTDZsbkdlXzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><ol><li><h3 id="redis缓存穿透的原因和解决方案"><a href="#redis缓存穿透的原因和解决方案" class="headerlink" title="redis缓存穿透的原因和解决方案"></a>redis缓存穿透的原因和解决方案</h3></li></ol><p>看缓存三兄弟</p><ol><li><h3 id="mysql的索引底层数据结构"><a href="#mysql的索引底层数据结构" class="headerlink" title="mysql的索引底层数据结构"></a>mysql的索引底层数据结构</h3></li></ol><p>b+树</p><ol><li><h3 id="mysql对于两个不同的字段建立索引有几棵b-树"><a href="#mysql对于两个不同的字段建立索引有几棵b-树" class="headerlink" title="mysql对于两个不同的字段建立索引有几棵b+树"></a>mysql对于两个不同的字段建立索引有几棵b+树</h3></li></ol><p>如果是分别建立索引的话会有两棵，这两棵b+树互不干扰</p><ol><li><h3 id="mysql联合索引的最左前缀原理"><a href="#mysql联合索引的最左前缀原理" class="headerlink" title="mysql联合索引的最左前缀原理"></a>mysql联合索引的最左前缀原理</h3></li></ol><p>MySQL的联合索引（也称为复合索引或多列索引）的最左前缀原理是指，当MySQL使用联合索引进行查询时，它会从联合索引的最左列开始匹配查询条件。只有当查询条件使用了联合索引的最左侧列时，索引才会被有效利用。</p><p>具体来说，假设我们有一个联合索引 (a, b, c)，这个索引是按照列 a、b 和 c 的顺序进行排序的。现在，我们考虑以下几种查询情况：</p><p>单独查询列a：在这种情况下，查询条件使用了联合索引的最左列（列a），因此MySQL可以直接使用这个索引来快速定位到匹配的行。</p><p>查询列a和列b：查询条件同时包含了列a和列b，这也满足了最左前缀原则，因为列a是联合索引的最左列。MySQL会利用这个联合索引来加速查询。</p><p>查询列a、列b和列c：当查询条件包含了联合索引的所有列（列a、列b和列c）时，索引的使用效率是最高的，因为所有列都被用来定位数据。</p><p>然而，以下情况则不会有效地利用联合索引 (a, b, c)：</p><p>只查询列b或列c：由于列b和列c不是联合索引的最左列，因此当查询条件只包含这些列时，联合索引不会被使用。MySQL会进行全表扫描或者尝试使用其他可能的索引（如果有的话）。</p><p>最左前缀原则也适用于索引的列顺序。如果你有一个 (b, a, c) 的联合索引，那么它对于基于列 b 的查询是高效的，但对于基于列 a 的查询则不是，因为列 a 不是这个联合索引的最左列。</p><ol><li><h3 id="为什么不等于条件会导致索引失效"><a href="#为什么不等于条件会导致索引失效" class="headerlink" title="为什么不等于条件会导致索引失效"></a>为什么不等于条件会导致索引失效</h3></li></ol><p>一般情况，“！&#x3D;”操作会选择表中绝大部分数据（假设一个字段有10个可选值，平均分布，不等操作就会选出其中90%的数据），第2步操作时间和全表扫描时间差不多（看数据量来说9：10）。然而还需要加上第一步读取索引的时间。这样一来，所花的总时间就比不走索引还多。</p><p>对于这种情况，数据库当然选择不走索引了。</p><p>不过，不等于不能使用索引这个说法是不准确的。</p><p><strong>select col1,count(*) from table where col1!&#x3D;’xxxx’ 就可以走col1的索引。</strong> <strong>select col1, col2 from table where col1!&#x3D;’xxxx’ 可以走col1,col2上的复合索引</strong></p><p>什么情况下，”!&#x3D;” 和 “not in”可以走索引？ </p><p>直接读取索引，不用读取表里的数据，就可以获取所需数据的SQL，”!&#x3D;”和”not in”也可以走索引</p><p>换个说法是，满足Covering Index使用条件的SQL，”!&#x3D;”和”not in”也可以走索引</p><ol><li><h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3></li></ol><p>IO多路复用技术（select函数模型和poll函数模型）：进程通过告诉多路复用器（内核）（也就是select函数和poll函数）所有的socket号，多路复用器再去获取每一个socket的状态，当程序获取到某个socket号有事件发生了，则去该socket号上进行处理对应的事件，read事件或者是recived事件。（补充select函数与poll函数的区别是，前者底层是数组，所以有最大连接数的限制，后者是链表，无最大连接数的限制）</p><p>缺点：①同样与NIO相同，需要遍历所有socket，O（N）复杂度。②重复传递数据。因为内核是无状态的，每次都要根据进程不断重复从用户态向内核态传递所有的socket号去遍历每一个socket，获取它们的状态。浪费资源与效率，可以使用一个记事本记录每个socket的监听事件。</p><p>IO多路复用技术（epoll函数模型）：epoll函数模型主要是调用了三个函数：epoll_create() , epoll_ctl() , epoll_wait()；</p><p>底层流程：①通过epoll_create() 函数创建一个文件，返回一个文件描述符（Linus系统一切对象皆为文件）fd ② 创建socket接口号4，绑定socket号与端口号，监听事件，标记为非阻塞。通过epoll_ctl() 函数将该socket号 以及 需要监听的事件（如listen事件）写入fd中。③循环调用epoll_wait() 函数进行监听，返回已经就绪事件序列的长度（返回0则说明无状态，大于0则说明有n个事件已就绪）。例如如果有客户端进行连接，则再调用accept()函数与4号socket进行连接，连接后返回一个新的socket号，且需要监听读事件，则再通过epoll_ctl()将新的socket号以及对应的事件（如read读事件）写入fd中，epoll_wait()进行监听。循环往复。</p><p>优点：不需要再遍历所有的socket号来获取每一个socket的状态，只需要管理活跃的连接。即监听在通过epoll_create()创建的文件中注册的socket号以及对应的事件。只有产生就绪事件，才会处理，所以操作都是有效的，为O(1).</p><h2 id="美团优选"><a href="#美团优选" class="headerlink" title="美团优选"></a>美团优选</h2><ol><li><h3 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h3></li></ol><p><code>ThreadPoolExecutor</code> 3 个最重要的参数：</p><ul><li><code>corePoolSize</code> : 任务队列未达到队列容量时，最大可以同时运行的线程数量。（核心线程数量）</li><li><code>maximumPoolSize</code> : 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。（线程的最大线程数）</li><li><code>workQueue</code>: 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数 :</p><ul><li><code>keepAliveTime</code>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁。</li><li><code>unit</code> : <code>keepAliveTime</code> 参数的时间单位。</li><li><code>threadFactory</code> :executor 创建新线程的时候会用到。（线程工厂）</li><li><code>handler</code> :拒绝策略</li></ul><ol><li><h3 id="封装，继承，多态的底层原理和好处"><a href="#封装，继承，多态的底层原理和好处" class="headerlink" title="封装，继承，多态的底层原理和好处"></a>封装，继承，多态的底层原理和好处</h3></li></ol><ul><li>封装</li></ul><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空调制冷，空调本身就没有意义了</p><ul><li>继承</li></ul><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p><ul><li>多态</li></ul><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><p>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</p><p>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</p><p>多态不能调用“只在子类存在但在父类不存在”的方法；</p><p>如果子类重写了父类的方法，真正执行的是子类重写的方法，如果子类没有重写父类的方法，执行的是父类的方法。</p><ol><li><h3 id="java的泛型"><a href="#java的泛型" class="headerlink" title="java的泛型"></a>java的泛型</h3></li></ol><p>Java 泛型（Generics） 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。</p><p>泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。</p><ol><li><h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3></li></ol><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p><p><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p><ol><li><h3 id="equals和"><a href="#equals和" class="headerlink" title="equals和&#x3D;&#x3D;"></a>equals和&#x3D;&#x3D;</h3></li></ol><p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p><ul><li>对于基本数据类型来说，<code>==</code> 比较的是值。</li><li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li></ul><p>因为 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p><p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p><ol><li><h3 id="redis底层"><a href="#redis底层" class="headerlink" title="redis底层"></a>redis底层</h3></li><li><h3 id="缓存三兄弟以及解决方案"><a href="#缓存三兄弟以及解决方案" class="headerlink" title="缓存三兄弟以及解决方案"></a>缓存三兄弟以及解决方案</h3></li><li><h3 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h3></li><li><h3 id="SpringIOC以及循环依赖和注解失效的场景"><a href="#SpringIOC以及循环依赖和注解失效的场景" class="headerlink" title="SpringIOC以及循环依赖和注解失效的场景"></a>SpringIOC以及循环依赖和注解失效的场景</h3></li></ol><p><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96">详解</a></p><ol><li><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3></li></ol><p>MyBatis的基本工作原理就是：先封装SQL，接着调用JDBC操作数据库，最后把数据库返回的表结果封装成Java类。</p><ol><li><h3 id="MySql的b-树和最左匹配原则"><a href="#MySql的b-树和最左匹配原则" class="headerlink" title="MySql的b+树和最左匹配原则"></a>MySql的b+树和最左匹配原则</h3></li><li><h3 id="ES有了解过吗"><a href="#ES有了解过吗" class="headerlink" title="ES有了解过吗"></a>ES有了解过吗</h3></li></ol><p><strong>ElasticSearch是一个基于<a href="https://so.csdn.net/so/search?q=Lucene&spm=1001.2101.3001.7020">Lucene</a>的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。</strong>Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。</p><p>使用场景</p><p>1、为用户提供按关键字查询的全文搜索功能。 2、实现企业海量数据的处理分析的解决方案。大数据领域的重要一份子，如著名的ELK框架(ElasticSearch,Logstash,Kibana)，。</p><p>特点:</p><p>天然分片，天然集群</p><p>es 把数据分成多个shard，下图中的P0-P2，多个shard可以组成一份完整的数据，这些shard可以分布在集群中的各个机器节点中。随着数据的不断增加，集群可以增加多个分片，把多个分片放到多个机子上，已达到负载均衡，横向扩展。</p><p>在实际运算过程中，每个查询任务提交到某一个节点，该节点必须负责将数据进行整理汇聚，再返回给客户端，也就是一个简单的节点上进行Map计算，在一个固定的节点上进行Reduces得到最终结果向客户端返回。</p><p>天然索引</p><p>ES 所有数据都是默认进行索引的，这点和mysql正好相反，mysql是默认不加索引，要加索引必须特别说明，ES只有不加索引才需要说明。</p><p>而ES使用的是倒排索引和Mysql的B+Tree索引不同</p><h2 id="滴滴日常实习"><a href="#滴滴日常实习" class="headerlink" title="滴滴日常实习"></a>滴滴日常实习</h2><ol><li><h3 id="线程池参数-1"><a href="#线程池参数-1" class="headerlink" title="线程池参数"></a>线程池参数</h3></li></ol><p>核心线程数<code>corePoolSize</code>，线程的最大线程数<code>maximumPoolSize</code>，当线程数达到最大线程数时，新加进来的线程会加在<code>workQueue</code>。。。</p><ol><li><h3 id="Java的集合"><a href="#Java的集合" class="headerlink" title="Java的集合"></a>Java的集合</h3></li></ol><p>List,Map,Queue,Set</p><p><a href="https://javaguide.cn/java/collection/java-collection-questions-01.html#%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0">详解</a></p><ol><li><h3 id="HashMap扩容机制"><a href="#HashMap扩容机制" class="headerlink" title="HashMap扩容机制"></a>HashMap扩容机制</h3></li></ol><p>当数组长度达到阈值时（默认为0.75），需要进行扩容操作，将数组长度扩大为原来的两倍，并将原有元素重新分布到新数组中。</p><ol><li><h3 id="链表转化为红黑树的机制"><a href="#链表转化为红黑树的机制" class="headerlink" title="链表转化为红黑树的机制"></a>链表转化为红黑树的机制</h3><p> 第一次添加元素的时候，默认初期长度为16，当往map中继续添加元素的时候，通过hash值跟数组长度取“与”来决定放在数组的哪个位置，如果出现放在同一个位置的时候，优先以链表的形式存放，在同一个位置的个数又达到了8个（代码是&gt;&#x3D;7,从0开始即第8个开始判断是否转化成红黑树），如果数组的长度还小于64的时候，则会扩容数组。如果数组的长度大于等于64的话，才会将该节点的链表转换成树。在扩容完成之后，如果某个节点的是树，同时现在该节点的个数又小于等于6个了，则会将该树转为链表。</p></li><li><h3 id="hashMap是线程安全的还是线程不安全的"><a href="#hashMap是线程安全的还是线程不安全的" class="headerlink" title="hashMap是线程安全的还是线程不安全的"></a>hashMap是线程安全的还是线程不安全的</h3></li></ol><p>不安全的</p><ol><li><h3 id="hashMap为什么不安全"><a href="#hashMap为什么不安全" class="headerlink" title="hashMap为什么不安全"></a>hashMap为什么不安全</h3></li></ol><p>1.并发修改异常：如果多个线程同时尝试修改HashMap的状态，而没有适当的同步措施，就可能导</p><p>ConcurrentModificationException</p><p>2.数据不一致：在没有同步的情况下，一个线程可能会看到另一个线程正在修改的中间状态，导致</p><p>读取到的数据不一致。</p><p>3.死循环：HashMap在扩容时会重新计算哈希值并重新分配元素到新的桶中。如果多个线程同时进</p><p>行扩容操作，可能会导致死循环。</p><p>4.快速失败迭代器：HashMap的迭代器是快速失败的，意味着如果检测到HashMap在迭代过程中被</p><p>修改，迭代器会立即抛出ConcurrentModificationException.。在多线程环境中，这种修改很可能是由另一个线程引起的。</p><ol><li><h3 id="线程安全应该用哪一个"><a href="#线程安全应该用哪一个" class="headerlink" title="线程安全应该用哪一个"></a>线程安全应该用哪一个</h3></li></ol><p>ConcurrentHashMap</p><ol><li><h3 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h3></li></ol><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p><ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li>**<code>Error</code>**：<code>Error</code> 属于程序无法处理的错误 ，不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><p>Checked Exception 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p><p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、<code>ClassNotFoundException</code>、<code>SQLException</code>…。</p><p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p><ul><li><code>NullPointerException</code>(空指针错误)</li><li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li><li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li><li><code>ClassCastException</code>（类型转换错误）</li><li><code>ArithmeticException</code>（算术错误）</li><li><code>SecurityException</code> （安全错误比如权限不够）</li><li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li></ul><ol><li><h3 id="项目中有没有用到反射"><a href="#项目中有没有用到反射" class="headerlink" title="项目中有没有用到反射"></a>项目中有没有用到反射</h3></li><li><h3 id="spring中哪里用到反射"><a href="#spring中哪里用到反射" class="headerlink" title="spring中哪里用到反射"></a>spring中哪里用到反射</h3></li></ol><p>Spring 框架中广泛使用了反射机制，它在多个方面都有应用，以下是一些主要的使用场景：</p><ol><li><p><strong>依赖注入（DI）</strong>：</p><ol><li>Spring 使用反射来实现依赖注入。它通过扫描类定义中的注解（如 <code>@Autowired</code>），动态地创建对象并注入依赖。</li></ol></li><li><p><strong>AOP（面向切面编程）</strong>：</p><ol><li>反射用于创建代理对象，这是 Spring AOP 实现方法拦截和增强的基础。</li></ol></li><li><p><strong>Bean 工厂</strong>：</p><ol><li>Spring 的 Bean 工厂使用反射来实例化、配置和组装 Bean。它通过反射获取 Bean 类的构造函数、字段和方法信息。</li></ol></li><li><p><strong>注解驱动</strong>：</p><ol><li>反射用于处理 Java 5 引入的注解，Spring 利用注解来简化配置，如 <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code> 等。</li></ol></li><li><p><strong>类型转换</strong>：</p><ol><li>Spring 的类型转换服务使用反射来转换属性值，例如，将字符串转换为特定的类型。</li></ol></li><li><p><strong>资源访问</strong>：</p><ol><li>Spring 利用反射来访问类路径下的资源文件，如加载配置文件。</li></ol></li><li><p><strong>事件发布</strong>：</p><ol><li>事件发布机制中，Spring 使用反射来调用事件监听器方法。</li></ol></li><li><p><strong>数据访问</strong>：</p><ol><li>在数据访问层，如 Hibernate 或 JPA，Spring 使用反射来处理实体类的元数据。</li></ol></li><li><p><strong>Spring MVC</strong>：</p><ol><li>在 Spring MVC 中，反射用于处理控制器方法的参数绑定，以及调用处理方法。</li></ol></li><li><p><strong>动态代理</strong>：</p><ol><li>Spring 为实现事务管理和其他 AOP 功能，使用动态代理来创建代理对象。</li></ol></li><li><p><strong>JMX 集成</strong>：</p><ol><li>Spring 允许将 Spring 管理的 Bean 暴露为 JMX MBeans，这需要使用反射来访问和管理 Bean 的属性和方法。</li></ol></li><li><p><strong>测试支持</strong>：</p><ol><li>Spring 提供的测试框架（如 Spring TestContext Framework）使用反射来设置测试环境和执行测试。</li></ol></li><li><h3 id="Java中有哪些锁"><a href="#Java中有哪些锁" class="headerlink" title="Java中有哪些锁"></a>Java中有哪些锁</h3></li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ODI3ZGM2OWM0ZTQxNDdiMGI5YTI5MDE0NjE2OGE4YzlfTGJScXpSMXJmanUxY09Id3NFRWIwVk9jb21tRUc0NUdfVG9rZW46TzljYmJSRjBsb3BxUTh4TjhhY2NBdjhLbkJkXzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><p><a href="https://blog.csdn.net/Pireley/article/details/136375023">详解</a></p><ol><li><h3 id="对方法和代码块加锁应该用哪一个"><a href="#对方法和代码块加锁应该用哪一个" class="headerlink" title="对方法和代码块加锁应该用哪一个"></a>对方法和代码块加锁应该用哪一个</h3></li></ol><p>sychronized</p><ol><li><h3 id="AQS原理，构建用了哪些锁"><a href="#AQS原理，构建用了哪些锁" class="headerlink" title="AQS原理，构建用了哪些锁"></a>AQS原理，构建用了哪些锁</h3></li></ol><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#aqs-%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">详解</a>   CLH队列锁</p><p>CLH(Craig,Landin,and Hagersten) 队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。在 CLH 同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）</p><p>AQS 使用 int 成员变量 <code>state</code> 表示同步状态，通过内置的 线程等待队列 来完成获取资源线程的排队工作。</p><ol><li><h3 id="threadLocal原理"><a href="#threadLocal原理" class="headerlink" title="threadLocal原理"></a>threadLocal原理</h3></li></ol><p><strong>最终的变量是放在了当前线程的</strong> <strong><code>ThreadLocalMap</code></strong> <strong>中，并不是存在</strong> <strong><code>ThreadLocal</code></strong> <strong>上，</strong><strong><code>ThreadLocal</code></strong> <strong>可以理解为只是</strong>**<code>ThreadLocalMap</code>**<strong>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p><p><strong>每个</strong>**<code>Thread</code><strong><strong>中都具备一个</strong></strong><code>ThreadLocalMap</code><strong><strong>，而</strong></strong><code>ThreadLocalMap</code><strong><strong>可以存储以</strong></strong><code>ThreadLocal</code>**<strong>为 key ，Object 对象为 value 的键值对。</strong></p><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-03.html#threadlocal-%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97">原理</a></p><ol><li><h3 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h3></li></ol><p><a href="https://javaguide.cn/system-design/framework/spring/ioc-and-aop.html#aop-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AB%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B">详解</a></p><ol><li><h3 id="注入Bean用哪些注解"><a href="#注入Bean用哪些注解" class="headerlink" title="注入Bean用哪些注解"></a>注入Bean用哪些注解</h3></li><li><p><strong>构造函数注入</strong>：</p><ol><li>使用<code>@Autowired</code>在构造函数上进行注入。</li></ol></li><li><p><strong>Setter方法注入</strong>：</p><ol><li>使用<code>@Autowired</code>在Setter方法上进行注入。</li></ol></li><li><p><strong>字段注入</strong>：</p><ol><li>使用<code>@Autowired</code>直接在字段上进行注入。</li></ol></li><li><p><strong>JSR-330注入</strong>：</p><ol><li>使用<code>@Inject</code>进行注入，这是JSR-330标准的一部分。</li></ol></li><li><p><strong>资源注入</strong>：</p><ol><li>使用<code>@Resource</code>进行注入，这同样是Java EE的一部分，可以通过名称进行注入。</li></ol></li><li><p><strong>指定注入</strong>：</p><ol><li>使用<code>@Qualifier</code>与<code>@Autowired</code>或<code>@Inject</code>结合使用，用于解决同名Bean的注入问题。</li></ol></li><li><p><strong>条件注入</strong>：</p><ol><li>使用<code>@Profile</code>指定在哪个环境下注入特定的Bean。</li></ol></li><li><p><strong>延迟注入</strong>：</p><ol><li>使用<code>@Lazy</code>与<code>@Autowired</code>结合使用，实现延迟加载Bean。</li></ol></li><li><p><strong>配置注入</strong>：</p><ol><li>使用<code>@Configuration</code>类结合<code>@Bean</code>注解，用于配置Bean。</li></ol></li><li><p><strong>属性注入</strong>：</p><ol><li>使用<code>@Value</code>注解注入配置文件中的属性值。</li></ol></li><li><p><strong>方法注入</strong>：</p><ol><li>使用<code>@Lookup</code>进行方法级别的注入，这是JSR-330的一部分。</li></ol></li><li><p><strong>优先级注入</strong>：</p><ol><li>使用<code>@Primary</code>指定当存在多个候选Bean时优先注入的Bean。</li></ol></li><li><h3 id="cglib动态代理的原理"><a href="#cglib动态代理的原理" class="headerlink" title="cglib动态代理的原理"></a>cglib动态代理的原理</h3></li></ol><p><a href="https://javaguide.cn/java/basis/proxy.html#_3-2-cglib-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6">详解</a></p><ol><li><h3 id="JDK动态代理为什么只能代理有接口的类"><a href="#JDK动态代理为什么只能代理有接口的类" class="headerlink" title="JDK动态代理为什么只能代理有接口的类"></a>JDK动态代理为什么只能代理有接口的类</h3></li></ol><p>是因为JDK动态代理本身机制决定的，首先在java里面动态代理是Proxy.newProxyInstance()这个方法来实现的，它需要传入被动态代理的一个接口类，还是取决于JDK动态代理的的一个底层实现，JDK动态代理会在程序运行期间，去动态生产一个代理类，叫$Proxy0,那么这个动态生成的代理类会去继承一个java.lang.reflect.Proxy这样一个类，同时还会去实现被代理类的接口，在java里面不支持多种继承的，而每个动态代理都继承一个Proxy，所以就导致的JDK里面的动态代理只能代理接口，而不能代理实现类,cglib实现动态代理的逻辑是使用子类继承代理类，就没有单继承的限制了。</p><p><strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</p><ol><li><h3 id="MVC是指哪三层"><a href="#MVC是指哪三层" class="headerlink" title="MVC是指哪三层"></a>MVC是指哪三层</h3></li><li><p><strong>Model（模型）</strong>：</p><ol><li>模型层代表数据和业务逻辑。它负责数据的存储、检索和处理，以及执行应用程序的业务规则。</li></ol></li><li><p><strong>View（视图）</strong>：</p><ol><li>视图层负责呈现数据（即模型）给用户。它通常是用户界面的一部分，显示数据并允许用户与应用程序交互。</li></ol></li><li><p><strong>Controller（控制器）</strong>：</p><ol><li>控制器层接收用户的输入并调用模型和视图去完成用户的请求。它充当模型和视图之间的中介，解释用户的输入，并将其转化为模型状态的改变，然后选择合适的视图来显示。</li></ol></li></ol><p>在Web应用程序中，MVC模式通常被用来构建服务器端的应用程序，其中：</p><ul><li><strong>Model</strong> 可以是JavaBeans或具有业务逻辑的POJO（Plain Old Java Object）。</li><li><strong>View</strong> 可以是JSP、HTML页面或任何其他模板引擎生成的输出。</li><li><strong>Controller</strong> 可以是Servlet、Struts Action或Spring MVC Controller</li></ul><ol><li><h3 id="实现这三层分别用哪些注解"><a href="#实现这三层分别用哪些注解" class="headerlink" title="实现这三层分别用哪些注解"></a>实现这三层分别用哪些注解</h3></li></ol><p><strong>Model（模型层）：</strong></p><p>模型层通常不需要特定的Spring MVC注解，因为它主要包含业务逻辑和数据访问代码。但是，可以使用以下几个注解：</p><ul><li><code>@Entity</code>：用于标识一个实体类，通常与JPA（Java Persistence API）一起使用。</li><li><code>@Table</code>：用于指定实体类对应的数据库表。</li><li><code>@Id</code>：用于标识实体类中的主键字段。</li><li><code>@Column</code>：用于映射实体类的字段到数据库表的列。</li><li><code>@ManyToOne</code>、<code>@OneToMany</code>、<code>@OneToOne</code>、<code>@ManyToMany</code>：用于标识实体类之间的关联关系。</li></ul><p><strong>View（视图层）：</strong></p><p>视图层在Spring MVC中通常由JSP、HTML页面或Thymeleaf等模板引擎来实现。视图层本身不使用Spring特定的注解，但是可以通过以下方式与Spring MVC集成：</p><ul><li>使用JSP标签库：例如<code>&lt;spring:bind path=&quot;...&quot; /&gt;</code>，用于数据绑定和显示错误信息。</li><li>使用模板引擎（如Thymeleaf）的特定注解或语法。</li></ul><p><strong>Controller（控制器层）：</strong></p><p>控制器层是Spring MVC的核心，用于处理用户请求和响应。以下是一些常用的注解：</p><ul><li><code>@Controller</code>：用于标识一个类为控制器。</li><li><code>@RestController</code>：用于标识一个类为控制器，并且所有的方法返回值都是JSON格式，它组合了<code>@Controller</code>和<code>@ResponseBody</code>。</li><li><code>@RequestMapping</code>：用于映射HTTP请求到控制器的处理方法上，可以标注在类或方法上。</li><li><code>@GetMapping</code>、<code>@PostMapping</code>、<code>@PutMapping</code>、<code>@DeleteMapping</code>：用于简化@RequestMapping的配置，分别对应HTTP的GET、POST、PUT、DELETE请求。</li><li><code>@Autowired</code>：用于自动装配Spring容器中的Bean。</li><li><code>@PathVariable</code>：用于从URL路径中提取变量。</li><li><code>@RequestParam</code>：用于从请求参数中提取数据。</li><li><code>@RequestBody</code>：用于读取请求的主体内容，通常用于接收JSON或XML格式的请求数据。</li><li><code>@ResponseBody</code>：用于指示方法的返回值应该直接作为响应的正文返回，而不是返回一个视图（View）。</li><li><code>@ExceptionHandler</code>：用于全局异常处理。</li><li><code>@ControllerAdvice</code>：用于定义全局的控制器增强功能，如异常处理、响应构建等。</li></ul><ol><li><h3 id="取一个自己设置好的变量用哪个注解"><a href="#取一个自己设置好的变量用哪个注解" class="headerlink" title="取一个自己设置好的变量用哪个注解"></a>取一个自己设置好的变量用哪个注解</h3></li></ol><p><strong>@Value，@Autowired，@Resource，@Inject</strong></p><ol><li><h3 id="自动装配用哪个注解"><a href="#自动装配用哪个注解" class="headerlink" title="自动装配用哪个注解"></a>自动装配用哪个注解</h3></li></ol><p>@Autowired：按属性进行注入，如果有多个属性相同的Bean，再按照Bean的id注入；可以通过@Qualifier(“id”) 指定id；可以设置@Primary 为首选Bean，可以指定@Autowired(required &#x3D; false) 找不到Bean不强行注入；</p><p>@Resource：默认按组件名称进行装配的；不支持@Primary功能，不支持@Autowired（reqiured&#x3D;false）;</p><p>@Inject：需要导入javax.inject的包，和Autowired的功能一样支持@Primary注解； 没有required&#x3D;false的功能；</p><ol><li><h3 id="MySQL事务隔离级别"><a href="#MySQL事务隔离级别" class="headerlink" title="MySQL事务隔离级别"></a>MySQL事务隔离级别</h3></li></ol><p>读未提交，读已提交，可重复读，串行化</p><ol><li><h3 id="MySQL索引分类"><a href="#MySQL索引分类" class="headerlink" title="MySQL索引分类"></a>MySQL索引分类</h3></li><li><p><strong>单列索引 vs 复合索引</strong>：</p><ol><li><strong>单列索引</strong>：索引只包含单个列。</li><li><strong>复合索引</strong>（也称为多列索引或组合索引）：索引包含两个或更多列。</li></ol></li><li><p><strong>聚簇索引 vs 非聚簇索引</strong>：</p><ol><li><strong>聚簇索引</strong>（Clustered Index）：表中的数据行根据索引列的顺序进行物理排序和存储。在InnoDB存储引擎中，主键默认是一个聚簇索引。</li><li><strong>非聚簇索引</strong>（Non-Clustered Index）：索引结构和数据存储是分开的，索引列可以不是表中的主键。大多数索引类型都是非聚簇索引。</li></ol></li><li><p><strong>唯一索引 vs 非唯一索引</strong>：</p><ol><li><strong>唯一索引</strong>：索引列的值必须唯一，但可以有空值。</li><li><strong>非唯一索引</strong>：索引列的值可以有重复。</li></ol></li><li><p><strong>主键索引 vs 非主键索引</strong>：</p><ol><li><strong>主键索引</strong>：表中主键列上的索引，必须是唯一索引，不允许有空值。</li><li><strong>非主键索引</strong>：除了主键索引之外的所有索引。</li></ol></li><li><p><strong>全文索引</strong>：</p><ol><li>用于对文本数据进行全文搜索，可以提高搜索效率。</li></ol></li><li><p><strong>空间索引</strong>：</p><ol><li>用于地理空间数据类型，支持空间数据的查询。</li></ol></li><li><p><strong>索引视图</strong>：</p><ol><li>一种特殊的索引，它实际上是一个存储在索引中的视图。</li></ol></li><li><p><strong>覆盖索引</strong>：</p><ol><li>当一个查询只需要访问索引中的列，而不需要访问表中的数据行时，这个索引被称为覆盖索引。</li></ol></li><li><p><strong>外部索引</strong>：</p><ol><li>由外部存储引擎管理的索引，不是由MySQL服务器直接管理。</li></ol></li><li><p><strong>隐藏索引</strong>：</p><ol><li>MySQL 5.7及以上版本支持隐藏索引，它们对优化器是透明的，不会自动用于查询优化。</li></ol></li><li><p><strong>普通索引</strong>：</p><ol><li>这是最基本的索引类型，没有附加的约束或特性。</li></ol></li><li><p><strong>索引分区</strong>：</p><ol><li>将索引分成多个部分，每个部分包含表的一部分数据，以提高查询性能。</li></ol></li><li><h3 id="对多个字段加索引用什么索引"><a href="#对多个字段加索引用什么索引" class="headerlink" title="对多个字段加索引用什么索引"></a>对多个字段加索引用什么索引</h3></li></ol><p>联合索引</p><ol><li><h3 id="redis内存淘汰策略"><a href="#redis内存淘汰策略" class="headerlink" title="redis内存淘汰策略"></a>redis内存淘汰策略</h3></li></ol><p><a href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E4%BA%86%E8%A7%A3%E4%B9%88">详解</a></p><p>Redis 提供了 6 种内存淘汰策略：</p><ol><li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最近最少使用的数据淘汰。</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选将要过期的数据淘汰。</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中任意选择数据淘汰。</li><li><strong>allkeys-lru（least recently used）</strong>：从数据集（<code>server.db[i].dict</code>）中移除最近最少使用的数据淘汰。</li><li><strong>allkeys-random</strong>：从数据集（<code>server.db[i].dict</code>）中任意选择数据淘汰。</li><li><strong>no-eviction</strong>（默认内存淘汰策略）：禁止驱逐数据，当内存不足以容纳新写入数据时，新写入操作会报错。</li></ol><p>4.0 版本后增加以下两种：</p><ol><li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最不经常使用的数据淘汰。</li><li><strong>allkeys-lfu（least frequently used）</strong>：从数据集（<code>server.db[i].dict</code>）中移除最不经常使用的数据淘汰。</li></ol><h2 id="淘天java"><a href="#淘天java" class="headerlink" title="淘天java"></a>淘天java</h2><ol><li><h3 id="介绍java异常体系"><a href="#介绍java异常体系" class="headerlink" title="介绍java异常体系"></a>介绍java异常体系</h3></li><li><h3 id="sychronized底层原理，锁升级过程"><a href="#sychronized底层原理，锁升级过程" class="headerlink" title="sychronized底层原理，锁升级过程"></a>sychronized底层原理，锁升级过程</h3></li></ol><p><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#synchronized-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97">原理详解</a></p><ol><li><h3 id="分库分表介绍，什么时候做分库，mysql的连接数跟什么有关系"><a href="#分库分表介绍，什么时候做分库，mysql的连接数跟什么有关系" class="headerlink" title="分库分表介绍，什么时候做分库，mysql的连接数跟什么有关系"></a>分库分表介绍，什么时候做分库，mysql的连接数跟什么有关系</h3></li></ol><p><a href="https://javaguide.cn/high-performance/read-and-write-separation-and-library-subtable.html#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8">详解</a></p><p>MySQL的连接数是指能够同时与MySQL数据库建立连接的客户端数量。MySQL的连接数可以通过配置文件进行设置，具体取决于MySQL版本、硬件资源、操作系统和使用场景等因素。默认情况下MySQL的最大连接数为100，但可以通过修改配置文件中的max_connections参数来增加连接数。MySQL底层实现连接数的原理是，对于每个连接，MySQL会为其分配一定的内存空间，包括连接缓存、语句缓存、结果缓存等。连接数的增加会占用更多的内存资源，如果同时有大量的连接请求，可能会导致内存不足而影响性能。因此，在设置连接数时，需要综合考虑硬件资源和应用场景，以避免连接数过多导致系统负载过高。另外，MySQL还采用了连接池技术来优化连接管理。连接池是一种管理连接的机制，它通过在启动时预先创建一定数量的连接，以满足后续连接请求的需要。当连接请求结束后，连接不会被关闭，而是重新放回到连接池中，供下一次请求使用。这样可以减少连接的创建和销毁过程，提高系统性能和可靠性。</p><ol><li><h3 id="http和https的区别-2"><a href="#http和https的区别-2" class="headerlink" title="http和https的区别"></a>http和https的区别</h3></li><li><h3 id="mvcc是怎么实现的，什么是幻读，怎么解决幻读，select-for-update加的是什么锁"><a href="#mvcc是怎么实现的，什么是幻读，怎么解决幻读，select-for-update加的是什么锁" class="headerlink" title="mvcc是怎么实现的，什么是幻读，怎么解决幻读，select for update加的是什么锁"></a>mvcc是怎么实现的，什么是幻读，怎么解决幻读，select for update加的是什么锁</h3></li></ol><p><code>MVCC</code> 的实现依赖于：隐藏字段、Read View、undo log。<a href="https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html">详解</a></p><p>幻读它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和 <code>Next-key Lock</code> 来解决幻读问题：</p><p><strong>1、执行普通</strong> **<code>select</code>**<strong>，此时会以</strong> <strong><code>MVCC</code></strong> <strong>快照读的方式读取数据</strong></p><p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p><p><strong>2、执行 select…for update&#x2F;lock in share mode、insert、update、delete 等当前读</strong></p><p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-next-key-locks">Next-key Lock</a>来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</p><ol><li><h3 id="Transational注解括号里面有哪些常见的参数"><a href="#Transational注解括号里面有哪些常见的参数" class="headerlink" title="@Transational注解括号里面有哪些常见的参数"></a>@Transational注解括号里面有哪些常见的参数</h3></li></ol><p><code>@Transactional</code> 注解是 Spring 框架中用于声明事务管理的方法。它通常用于声明在方法执行期间需要进行事务管理。以下是一些常见的参数：</p><ol><li><p><strong>value</strong>: 指定使用的事务管理器名称。如果项目中配置了多个事务管理器，可以使用此参数指定使用哪一个。</p></li><li><p><strong>propagation</strong>: 事务的传播行为。常见的值包括：</p><ol><li><code>Propagation.REQUIRED</code>（默认）：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li><li><code>Propagation.REQUIRES_NEW</code>：总是创建一个新的事务，如果当前存在事务，则挂起当前事务。</li><li><code>Propagation.MANDATORY</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li><li><code>Propagation.SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行。</li><li><code>Propagation.NOT_SUPPORTED</code>：以非事务方式执行，如果当前存在事务，则挂起当前事务。</li><li><code>Propagation.NEVER</code>：以非事务方式执行，如果当前存在事务，则抛出异常。</li></ol></li><li><p><strong>isolation</strong>: 事务的隔离级别。常见的值包括：</p><ol><li><code>Isolation.DEFAULT</code>：使用后端数据库的默认隔离级别。</li><li><code>Isolation.READ_UNCOMMITTED</code>：读未提交。</li><li><code>Isolation.READ_COMMITTED</code>：读已提交。</li><li><code>Isolation.REPEATABLE_READ</code>：可重复读。</li><li><code>Isolation.SERIALIZABLE</code>：串行化。</li></ol></li><li><p><strong>timeout</strong>: 事务的超时时间，单位为秒。如果事务在这个时间内没有完成，则自动回滚。</p></li><li><p><strong>readOnly</strong>: 指定事务是否为只读事务。只读事务可以提供一些性能优化。</p></li><li><p><strong>rollbackFor</strong>: 指定在遇到哪些异常时事务应该回滚。可以指定一个异常类或者异常类的数组。</p></li><li><p><strong>noRollbackFor</strong>: 指定在遇到哪些异常时事务不应该回滚。可以指定一个异常类或者异常类的数组。</p></li><li><h3 id="介绍一下zset"><a href="#介绍一下zset" class="headerlink" title="介绍一下zset"></a>介绍一下zset</h3></li><li><h3 id="有哪些常用的线程池，Excutors里的线程池有哪些问题"><a href="#有哪些常用的线程池，Excutors里的线程池有哪些问题" class="headerlink" title="有哪些常用的线程池，Excutors里的线程池有哪些问题"></a>有哪些常用的线程池，Excutors里的线程池有哪些问题</h3></li></ol><p><code>FixedThreadPool</code>：固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p><p><code>SingleThreadExecutor</code>： 只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</p><p><code>CachedThreadPool</code>： 可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</p><p><code>ScheduledThreadPool</code>：给定的延迟后运行任务或者定期执行任务的线程池。</p><p>FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。</p><p>CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</p><ol><li><h3 id="介绍一下jdk1-8的jvm内存区域"><a href="#介绍一下jdk1-8的jvm内存区域" class="headerlink" title="介绍一下jdk1.8的jvm内存区域"></a>介绍一下jdk1.8的jvm内存区域</h3></li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MDZhMWZjMDJjYzU0MDczOTFiMjJlZmViY2I3M2M5OThfSUMzd3VtZVRqcDdjM1RmdXNTNnc4RnMwTzJqUUNhODlfVG9rZW46U0NpVWJMV3Nib1pLWkh4Y0VVOWN6Smh2bmljXzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><ol><li><h3 id="介绍一下双亲委派机制"><a href="#介绍一下双亲委派机制" class="headerlink" title="介绍一下双亲委派机制"></a>介绍一下双亲委派机制</h3></li><li><h3 id="介绍一下CAP理论，为什么能同时满足两个"><a href="#介绍一下CAP理论，为什么能同时满足两个" class="headerlink" title="介绍一下CAP理论，为什么能同时满足两个"></a>介绍一下CAP理论，为什么能同时满足两个</h3></li></ol><p><a href="https://javaguide.cn/distributed-system/protocol/cap-and-base-theorem.html#cap-%E7%90%86%E8%AE%BA">详解</a></p><p>CAP 也就是 Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性） 这三个单词首字母组合。</p><p>CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。</p><ol><li><h3 id="ThreadLocal介绍一下"><a href="#ThreadLocal介绍一下" class="headerlink" title="ThreadLocal介绍一下"></a>ThreadLocal介绍一下</h3></li><li><h3 id="Wait-sleep的区别"><a href="#Wait-sleep的区别" class="headerlink" title="Wait sleep的区别"></a>Wait sleep的区别</h3></li></ol><p><strong>共同点</strong>：两者都可以暂停线程的执行。</p><p><strong>区别</strong>：</p><ul><li><strong><code>sleep()</code></strong> <strong>方法没有释放锁，而</strong> <strong><code>wait()</code></strong> <strong>方法释放了锁</strong> 。</li><li><code>wait()</code> 通常被用于线程间交互&#x2F;通信，<code>sleep()</code>通常被用于暂停执行。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li><li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。</li></ul><ol><li><h3 id="二叉树中序遍历的时间复杂度"><a href="#二叉树中序遍历的时间复杂度" class="headerlink" title="二叉树中序遍历的时间复杂度"></a>二叉树中序遍历的时间复杂度</h3></li></ol><p>O（n）</p><ol><li><h3 id="xms和xss能干什么"><a href="#xms和xss能干什么" class="headerlink" title="xms和xss能干什么"></a>xms和xss能干什么</h3></li></ol><p><a href="https://javaguide.cn/java/jvm/jvm-parameters-intro.html#_2-1-%E6%98%BE%E5%BC%8F%E6%8C%87%E5%AE%9A%E5%A0%86%E5%86%85%E5%AD%98%E2%80%93xms%E5%92%8C-xmx">详解</a></p><h2 id="高德一面"><a href="#高德一面" class="headerlink" title="高德一面"></a>高德一面</h2><ol><li><h3 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h3></li></ol><table><thead><tr><th>创建对象方式</th><th>是否调用了构造器</th></tr></thead><tbody><tr><td>new关键字</td><td>是</td></tr><tr><td>Class.newInstance</td><td>是</td></tr><tr><td>Constructor.newInstance</td><td>是</td></tr><tr><td>Clone</td><td>否</td></tr><tr><td>反序列化</td><td>否</td></tr></tbody></table><p><a href="https://cloud.tencent.com/developer/article/1497720">详解</a></p><ol><li><h3 id="类加载的过程-1"><a href="#类加载的过程-1" class="headerlink" title="类加载的过程"></a>类加载的过程</h3></li></ol><p>加载-连接(验证、准备和解析)-初始化</p><ol><li><h3 id="类加载发生几次"><a href="#类加载发生几次" class="headerlink" title="类加载发生几次"></a>类加载发生几次</h3></li></ol><p>一次，双亲委派机制</p><ol><li><h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3></li></ol><p><a href="https://javaguide.cn/java/jvm/jvm-parameters-intro.html#_4-%E5%A4%84%E7%90%86-oom">详解</a></p><ol><li><h3 id="threadLocal使用场景，基本原理，有什么坑"><a href="#threadLocal使用场景，基本原理，有什么坑" class="headerlink" title="threadLocal使用场景，基本原理，有什么坑"></a>threadLocal使用场景，基本原理，有什么坑</h3></li><li><h3 id="内存泄漏为什么要手动remove"><a href="#内存泄漏为什么要手动remove" class="headerlink" title="内存泄漏为什么要手动remove"></a>内存泄漏为什么要手动remove</h3></li><li><h3 id="thread怎么配合线程池使用"><a href="#thread怎么配合线程池使用" class="headerlink" title="thread怎么配合线程池使用"></a>thread怎么配合线程池使用</h3></li><li><h3 id="JWT组成"><a href="#JWT组成" class="headerlink" title="JWT组成"></a>JWT组成</h3></li></ol><p><a href="https://javaguide.cn/system-design/security/basis-of-authority-certification.html#%E4%BB%80%E4%B9%88%E6%98%AF-jwt-jwt-%E7%94%B1%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90">详解</a></p><ol><li><h3 id="讲讲TOKEN"><a href="#讲讲TOKEN" class="headerlink" title="讲讲TOKEN"></a>讲讲TOKEN</h3></li></ol><p><a href="https://blog.csdn.net/sunyctf/article/details/126509232">详解</a></p><h2 id="袋鼠云Java实习面经"><a href="#袋鼠云Java实习面经" class="headerlink" title="袋鼠云Java实习面经"></a>袋鼠云Java实习面经</h2><ol><li><h3 id="int类型占多少位"><a href="#int类型占多少位" class="headerlink" title="int类型占多少位"></a>int类型占多少位</h3></li></ol><p>32位</p><ol><li><h3 id="JVM内存结构-方法区里存的是什么？方法区是怎么实现的"><a href="#JVM内存结构-方法区里存的是什么？方法区是怎么实现的" class="headerlink" title="JVM内存结构?方法区里存的是什么？方法区是怎么实现的?"></a>JVM内存结构?方法区里存的是什么？方法区是怎么实现的?</h3></li></ol><p>JVM内存结构分为线程私有和线程共享两类，线程共享的有堆，方法区，直接内存，线程私有的有虚拟机栈，本地方法栈，程序计数器。</p><p>方法区会存储已被虚拟机加载的 类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</p><p>jdk1.7及以前，方法区的实现是永久代，jdk1.8及以后是元空间</p><ol><li><h3 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3></li></ol><p>复制算法、标记清除算法、标记整理算法和分代收集算法</p><ol><li><h3 id="类加载的过程-2"><a href="#类加载的过程-2" class="headerlink" title="类加载的过程"></a>类加载的过程</h3></li></ol><p>加载-连接(验证，准备，解析)-初始化</p><p>类加载过程的第一步，主要完成下面 3 件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流。</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li><li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口。</li></ol><p>验证阶段主要由四个检验阶段组成：</p><ol><li>文件格式验证（Class 文件格式检查）</li><li>元数据验证（字节码语义检查）</li><li>字节码验证（程序语义检查）</li><li>符号引用验证（类的正确性检查）</li></ol><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</p><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p>初始化阶段是执行初始化方法 <clinit> ()方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</p><ol><li><h3 id="线程池的创建方式"><a href="#线程池的创建方式" class="headerlink" title="线程池的创建方式"></a>线程池的创建方式</h3></li></ol><p>方式一：通过ThreadPoolExecutor构造函数来创建（推荐）。</p><p>方式二：通过 Executor 框架的工具类 <code>Executors</code> 来创建。</p><ol><li><h3 id="有哪些参数"><a href="#有哪些参数" class="headerlink" title="有哪些参数"></a>有哪些参数</h3></li></ol><p>核心参数有以下三个</p><p><strong><code>corePoolSize</code></strong> <strong>:</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</p><p><strong><code>maximumPoolSize</code></strong> <strong>:</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</p><p><strong><code>workQueue</code>****:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p><ol><li><h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3></li></ol><p>线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。</p><ul><li>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。</li><li>线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。</li></ul><ol><li><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3></li></ol><p><a href="https://javaguide.cn/java/basis/unsafe.html#cas-%E6%93%8D%E4%BD%9C">详解</a></p><p>CAS 即比较并替换（Compare And Swap)，是实现并发算法时常用到的一种技术。CAS 操作包含三个操作数——内存位置、预期原值及新值。执行 CAS 操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS 是一条 CPU 的原子指令（cmpxchg 指令），不会造成所谓的数据不一致问题，<code>Unsafe</code> 提供的 CAS 方法（如 <code>compareAndSwapXXX</code>）底层实现即为 CPU 指令 <code>cmpxchg</code> 。</p><ol><li><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3></li></ol><p><a href="https://javaguide.cn/java/concurrent/aqs.html">详解</a></p><p>AQS 就是一个抽象类，主要用来构建锁和同步器。</p><p>AQS 为构建锁和同步器提供了一些通用功能的实现，因此，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>等等皆是基于 AQS 的。</p><p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是基于 <strong>CLH 锁</strong> （Craig, Landin, and Hagersten locks） 实现的。</p><p>AQS 使用 <strong>int 成员变量</strong> <strong><code>state</code></strong> <strong>表示同步状态</strong>，通过内置的 <strong>FIFO 线程等待&#x2F;等待队列</strong> 来完成获取资源线程的排队工作。</p><p><code>state</code> 变量由 <code>volatile</code> 修饰，用于展示当前临界资源的获锁情况。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWE4OTlkZmRkOWFkMDhjZGQ3OGJhZTM5MDM5N2YxNTlfSm5DQ3hwazNHUlRtQkkxNzczQURiVHE2WjZ1dWhqYldfVG9rZW46UmJjVmIzWmp4b0FIMzh4M25UdGN4d044bmhlXzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><ol><li><h3 id="ABA问题了解过吗"><a href="#ABA问题了解过吗" class="headerlink" title="ABA问题了解过吗"></a>ABA问题了解过吗</h3></li></ol><p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 <strong>“ABA”问题。</strong></p><p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。JDK 1.5 以后的 <code>AtomicStampedReference</code> 类就是用来解决 ABA 问题的，其中的 <code>compareAndSet()</code> 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p><ol><li><h3 id="SPI知道吗"><a href="#SPI知道吗" class="headerlink" title="SPI知道吗"></a>SPI知道吗</h3></li></ol><p><a href="https://javaguide.cn/java/basis/java-basic-questions-03.html#spi">详解</a></p><ol><li><h3 id="ThreadLocal有什么用，底层原理知道吗"><a href="#ThreadLocal有什么用，底层原理知道吗" class="headerlink" title="ThreadLocal有什么用，底层原理知道吗"></a>ThreadLocal有什么用，底层原理知道吗</h3></li><li><h3 id="Join（）是做什么的"><a href="#Join（）是做什么的" class="headerlink" title="Join（）是做什么的"></a>Join（）是做什么的</h3></li></ol><p>连接查询</p><ol><li><h3 id="索引有哪些种类"><a href="#索引有哪些种类" class="headerlink" title="索引有哪些种类"></a>索引有哪些种类</h3></li></ol><p>主键索引，聚簇索引，非聚簇索引，单列索引，联合索引，非主键索引，唯一索引，非唯一索引，</p><p>全文索引，索引视图</p><ol><li><h3 id="事务的四大特性-1"><a href="#事务的四大特性-1" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h3></li></ol><p>A:原子性：指的是一个事务是一个完整的操作，要么全部成功，要么全部失败</p><p>C：一致性: 意思是事务在操作前后，数据是保持一致的，比如转账操作，转账业务双方在事务前后的总钱数是不变得</p><p>I：隔离性: 多个事务在执行的时候，是互不干扰的，一个事务的执行不会影响另一个事务。</p><p>D：持久性:指的是，事务一旦提交，对数据库的操作是永久的</p><ol><li><h3 id="MySQL主从同步，从库是怎么存数据的"><a href="#MySQL主从同步，从库是怎么存数据的" class="headerlink" title="MySQL主从同步，从库是怎么存数据的"></a>MySQL主从同步，从库是怎么存数据的</h3></li></ol><p>主从复制</p><ul><li>主库将数据库中数据的变化写入到 binlog</li><li>从库连接主库</li><li>从库会创建一个 I&#x2F;O 线程向主库请求更新的 binlog</li><li>主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I&#x2F;O 线程负责接收</li><li>从库的 I&#x2F;O 线程将接收的 binlog 写入到 relay log 中。</li><li>从库的 SQL 线程读取 relay log 同步数据到本地（也就是再执行一遍 SQL ）。</li></ul><p><a href="https://javaguide.cn/high-performance/read-and-write-separation-and-library-subtable.html#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">详解</a></p><ol><li><h3 id="mvcc底层"><a href="#mvcc底层" class="headerlink" title="mvcc底层"></a>mvcc底层</h3></li></ol><p>底层是基于隐藏字段，readview，undolog实现</p><ol><li><h3 id="回表是什么"><a href="#回表是什么" class="headerlink" title="回表是什么"></a>回表是什么</h3></li></ol><p>在MySQL数据库中，回表（<code>Look Up</code>）指的是在进行索引查询时，首先通过索引定位到对应页，然后再根据行的物理地址找到所需的数据行。换句话说，回表是指根据索引查询到的主键值再去访问主键索引，从而获取完整的数据记录。</p><p>什么情况下会触发回表？</p><ul><li>索引不Cover所有需要查询的字段</li><li>使用了非聚簇索引</li><li>使用了覆盖索引但超过了最大索引长度</li></ul><p>哪些情况下不会触发回表？</p><p>覆盖索引</p><p>使用聚簇索引</p><ol><li><h3 id="创建索引有什么需要注意的点"><a href="#创建索引有什么需要注意的点" class="headerlink" title="创建索引有什么需要注意的点"></a>创建索引有什么需要注意的点</h3></li></ol><p>索引不是创建地越多越好，因为维护索引也是需要代价的</p><p>非必要的列没必要创建索引，比如说性别，如果男和女比例是1：1,那就没必要创建</p><p>注意一些索引实现的场景，创建联合索引的时候注意最左前缀原则</p><p>最好在占用内存较少的字段上建立索引</p><ol><li><h3 id="TCP和UDP的区别-1"><a href="#TCP和UDP的区别-1" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3></li></ol><p><strong>是否面向连接</strong>：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</p><p><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</p><p><strong>是否有状态</strong>：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（<strong>这很渣男！</strong>）。</p><p><strong>传输效率</strong>：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</p><p><strong>传输形式</strong>：TCP 是面向字节流的，UDP 是面向报文的。</p><p><strong>首部开销</strong>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</p><p><strong>是否提供广播或多播服务</strong>：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</p><ol><li><h3 id="HTTPS是如何保证安全的"><a href="#HTTPS是如何保证安全的" class="headerlink" title="HTTPS是如何保证安全的"></a>HTTPS是如何保证安全的</h3></li></ol><p>HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL&#x2F;TLS 协议用作加密和安全认证。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ODYxNzVlOGNjMjc4ZWVmODA1MjkyNzRmYjRkMGNiNGZfa0tldm1oaFBCQUFsOWltSGlPcGhOMmxHZjBTaVY0OXRfVG9rZW46UnF6ZmJJZjhObzBac2x4TkVTemNlOFg3bmhQXzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><p><strong>端口号</strong>：HTTP 默认是 80，HTTPS 默认是 443。</p><p><strong>URL 前缀</strong>：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</p><p><strong>安全性和资源消耗</strong>：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p><ol><li><h3 id="网络IO模型了解吗，说说IO多路复用"><a href="#网络IO模型了解吗，说说IO多路复用" class="headerlink" title="网络IO模型了解吗，说说IO多路复用"></a>网络IO模型了解吗，说说IO多路复用</h3></li></ol><h2 id="Redis-MySql-高频-java面试"><a href="#Redis-MySql-高频-java面试" class="headerlink" title="Redis+MySql 高频 java面试"></a>Redis+MySql 高频 java面试</h2><ol><li><h3 id="redis作为缓存，mysql的数据如何与redis进行同步呢（双写一致性）"><a href="#redis作为缓存，mysql的数据如何与redis进行同步呢（双写一致性）" class="headerlink" title="redis作为缓存，mysql的数据如何与redis进行同步呢（双写一致性）"></a>redis作为缓存，mysql的数据如何与redis进行同步呢（双写一致性）</h3></li></ol><p>回答时要先介绍业务背景1. 一致性要求较高 2. 允许延迟一致</p><ol><li>如果是把文章的热点数据存入到了缓存中，虽然是热点数据，但是实时要求性并没有那么高，所以，可以采用异步的方案同步的数据</li></ol><p>允许延时一致的业务，采用异步通知</p><ul><li>使用MQ中间中间件，更新数据之后，通知缓存删除</li><li>利用canal中间件，不需要修改业务代码，伪装为mysql的一个从节点，canali通过读取binlog数据更新缓存</li></ul><ol><li>如果库存存入到了缓存中，这个需要实时的进行数据同步，为了保证数据的强一致，就需要采用redisson提供的读写锁来保证数据的同步</li></ol><p>强一致性的，采用Redisson提供的读写锁</p><ul><li>共享锁：读锁readLock,加锁之后，其他线程可以共享读操作</li><li>排他锁：独占锁writeLock也叫，加锁之后，阻塞其他线程读写操作</li></ul><p>听说过延时双删吗？为什么不用它呢？</p><p>​     延迟双删，如果是写操作，我们先把缓存中的数据删除，然后更新数据库，最后再延时删除</p><p>缓存中的数据，其中这个延时多久不太好确定，在延时的过程中可能会出现脏数据，并不能保证强一</p><p>致性，所以没有采用它。</p><ol><li><h3 id="redis作为缓存，-数据的持久化是怎么做的"><a href="#redis作为缓存，-数据的持久化是怎么做的" class="headerlink" title="redis作为缓存， 数据的持久化是怎么做的"></a>redis作为缓存， 数据的持久化是怎么做的</h3></li></ol><p>在Redis中提供了两种数据持久化的方式：1.RDB  2.AOF</p><p>RDB是一个快照文件，它是把redis内存存储的数据写到磁盘上，当redis实例宕机恢复数据的时候，方便从RDB的快照文件中恢复数据。</p><p>AOF的含义是追加文件，当redis操作写命令的时候，都会存储这个文件中，当redis实例宕机恢复数据</p><p>的时候，会从这个文件中再次执行一遍命令来恢复数据</p><p>RDB因为是二进制文件，在保存的时候体积也是比较小的，它恢复的比较快，但是它有可能会丢数据，我通常在项目中会使用AOF来恢复数据，虽然AOF恢复的速度慢一些，但是它丢数据的风险要小很多，在AOF文件中可以设置刷盘策略。</p><ol><li><h3 id="redis的数据过期策略"><a href="#redis的数据过期策略" class="headerlink" title="redis的数据过期策略"></a>redis的数据过期策略</h3></li></ol><p>Redⅰs对数据设置数据的有效时间，数据过期以后，就需要将数据从内存中删除掉。可以按照不同的规则进行删除，这种删除规则就被称之为数据的删除策略（数据过期策略）</p><p>redis里面提供了两种过期策略:惰性删除、定期删除</p><p>惰性删除：设置该key过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key</p><p>优点：对CPU友好，只会在使用该key时才会进行过期检查，对于很多用不到的ky不用浪费时间进行过期检查</p><p>缺点：对内存不友好，如果一个key已经过期，但是一直没有使用，那么该ky就会一直存在内存中，内存永远不会释放</p><p>定期删除：每隔一段时间，我们就对一些key进行检查，删除里面过期的key(从一定数量的数据库中取出一定数量的随机key进行检查，并删除其中的过期key)。</p><p>定期清理有两种模式：</p><p>SLOW模式是定时任务，执行频率默认为10hz,每次不超过25ms,以通过修改配置文件redis..conf的hz选项来调整这个次数</p><p>FAST模式执行频率不固定，但两次间隔不低于2ms,每次耗时不超过1ms</p><p>优点：可以通过限制删除操作执行的时长和频率来减少删除操作对CPU的影响。另外定期删除，也能有效释放过期键占用的内存。</p><p>缺点：难以确定删除操作执行的时长和频率。</p><p>Redis的过期删除策略：惰性删除+定期删除两种策略进行配合使用</p><ol><li><h3 id="redis的数据淘汰策略"><a href="#redis的数据淘汰策略" class="headerlink" title="redis的数据淘汰策略"></a>redis的数据淘汰策略</h3></li></ol><p>数据的淘汰策略：当Redis中的内存不够用时，此时在向Redis中添加新的key,那么Redis就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。</p><p>Redis支持8种不同策略来选择要删除的key:</p><ol><li>noeviction:不淘汰任何key,但是内存满时不允许写入新数据，默认就是这种策略。</li><li>volatile-ttl:对设置了TTL的key,比较key的剩余TTL值，TTL越小越先被淘汰</li><li>allkeys-random:对全体key,随机进行淘汰。</li><li>volatile-random:对设置了TTL的key,随机进行淘汰。</li><li>allkeys–lru:对全体key,基于LRU算法进行淘汰</li><li>volatile-lru:对设置了TTL的key,基于LRU算法进行淘汰</li><li>allkeys-lfu:对全体key,基于LFU算法进行淘汰</li><li>volatile-lfu:对设置了TTL的key,基于LFU算法进行淘汰</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NWYzMWUyMWJhMDE0NTkzNTVkYTFkODA5NDFkZmUxOGVfNDF0OWhnSGo0dHhRbXc5dmt6UUV5Q1FoZkpTWmsxdkZfVG9rZW46WVFZUGJscmg5b3dCY1V4aWkyRGNYaHVFbmZkXzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><p>优先使用allkeys-lru策略。充分利用LRU算法的优势，把最近最常访问的数据留在缓存中。如果业务有明显的冷热数据区分，建议使用。</p><p>如果业务中数据访问频率差别不大，没有明显冷热数据区分，建议使用allkeys-random,随机选择淘汰。</p><p>如果业务中有置顶的需求，可以使用volatile-lru策略，同时置顶数据不设置过期时间，这些数据就一直不被删除,会淘汰其他设置过期时间的数据。</p><p>如果业务中有短时高频访问的数据，可以使用allkeys-lfu或volatile-lfu策略。</p><p>扩展问题：</p><p>1.数据库有1000万数据，Redis.只能缓存20w数据，如何保证Redis中的数据都是热点数据？</p><p>使用allkeys-lru(挑选最近最少使用的数据淘汰)淘汰策略，留下来的都是经常访问的热点数据</p><p>2.Redis的内存用完了会发生什么？</p><p>主要看数据淘汰策略是什么？如果是默认的配置(noeviction),会直接报错</p><ol><li><h3 id="redis分布式锁时如何实现的"><a href="#redis分布式锁时如何实现的" class="headerlink" title="redis分布式锁时如何实现的"></a>redis分布式锁时如何实现的</h3></li></ol><p>在redis中提供了一个命令setnx(SET if not exists)由于redis的单线程的，用了命令之后，只能有一个客户端对某一个key设置值，在没有过期或删除key的时候是其他客户端是不能设置这个key的redis的setnx指令不好控制Redis实现分布式锁有效时长，我当时采用的redis的一个框架redisson实现的。在redisson中需要手动加锁，并且可以控制锁的失效时间和等待时间，当锁住的一个业务还没有执行完成的时候，在redisson中引入了一个看门狗机制，就是说每隔一段时间就检查当前业务是否还持有锁，如果持有就增加加锁的持有时间，当业务执行完成之后需要使用释放锁就可以了还有一个好处就是，在高并发下，一个业务有可能会执行很快，先客户1持有锁的时候，客户2来了以后并不会马上拒绝，它会自选不断尝试获取锁，如果客户1释放之后，客户2就可以马上持有锁，性能也得到了提升。</p><p>Redisson:实现分布式锁如何合理的控制锁的有效时长？</p><p>在redisson的分布式锁中，提供了一个WatchDog(看门狗)，一个线程获取锁成功以后，</p><p>WatchDog会给持有锁的线程续期（默认是每隔10秒续期一次）</p><p>Redisson的这个锁，可以重入吗？</p><p>可以重入，多个锁重入需要判断是否是当前线程，在redis中进行存储的时候使用的hash结构</p><p>来存储线程信息和重入的次数</p><p>Redisson锁能解决主从数据一致的问题吗？</p><p>不能解决，但是可以使用redisson提供的红锁来解决，但是这样的话，性能就太低了，如果</p><p>业务中非要保证数据的强一致性，建议采用zookeeper3实现的分布式锁</p><ol><li><h3 id="Redis集群有哪些方案"><a href="#Redis集群有哪些方案" class="headerlink" title="Redis集群有哪些方案"></a>Redis集群有哪些方案</h3></li></ol><h4 id="主从复制（主从同步）"><a href="#主从复制（主从同步）" class="headerlink" title="主从复制（主从同步）"></a>主从复制（主从同步）</h4><p>介绍一下主从同步</p><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。一般都是一主多从，主节点负责写数据，从节点负责读数据</p><p>主从同步数据的流程</p><p>全量同步：</p><ol><li>从节点请求主节点同步数据(replication id、offset)</li><li>主节点判断是否是第一次请求，是第一次就与从节点同步版本信息(replication id和offset)</li><li>主节点执行bgsave,生成rdb文件后，发送给从节点去执行</li><li>在rdb生成执行期间，主节点会以命令的方式记录到缓冲区（一个日志文件)</li><li>把生成之后的命令日志文件发 送给从节点进行同步</li></ol><p>增量同步：</p><ol><li>从节点请求主节点同步数据，主节点判断不是第一次请求，不是第一次就获取从节点的offset值</li><li>主节点从命令日志中获取offset值之后的数据发送给从节点进行数据同步</li></ol><h4 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h4><p>怎么保证Redis的高并发高可用</p><p>​    首先可以搭建主从集群，再加上使用redis中的哨兵模式，哨兵模式可以实现主从集群的自动故障恢复，里面就包含了对主从服务的监控、自动故障恢复、通知；如果masteri故障，Sentinel会将一</p><p>个slave提升为master。当故障实例恢复后也以新的master为主；同时Sentinel也充当Redis客户端的服</p><p>务发现来源，当集群发生故障转移时，会将最新信息推送给Rdis的客户端，所以一般项目都会采用哨</p><p>兵的模式来保证redis的高并发高可用</p><p>你们使用redis是单点还是集群，哪种集群</p><p>​    我们当时使用的是主从(1主1从)加哨兵。一般单节点不超过10G内存，如果Redis内存不足则可以给不同服务分配独立的Redis主从节点。尽量不做分片集群。因为集群维护起来比较麻烦，并且集群之间的心跳检测和数据通信会消耗大量的网络带宽，也没有办法使用lua脚本和事务</p><p>redis集群脑裂，该怎么解决呢？</p><p>  这个在项目很少见，不过脑裂的问题是这样的，我们现在用的是reds的哨兵模式集群的有的时候由于网络等原因可能会出现脑裂的情况，就是说，由于redis master节点和redis slave节点和sentinel处于不同的网络分区，使得sentinel没有能够心跳感知到master,所以通过选举的方式提升了一个salve为master,这样就存在了两个master,就像大脑分裂了一样，这样会导致客户端还在old master那里写入数据，新节点无法同步数据，当网络恢复后，sentinel会将old masterl降为slave,这时再从新的master同步数据，这会导致old master中的大量数据丢失。</p><p>关于解决的话，我记得在redis的配置中可以设置：第一可以设置最少的slave节点个数，比如设置至少</p><p>要有一个从节点才能同步数据，第二个可以设置主从数据复制和同步的延迟时间，达不到要求就拒绝</p><p>请求，就可以避免大量的数据丢失</p><h4 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h4><p>redis的分片集群有什么作用</p><ul><li>集群中有多个master,每个master保存不同数据</li><li>每个master都可以有多个slave节点</li><li>master之间通过ping监测彼此健康状态</li><li>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</li></ul><p>Redis分片集群中数据是怎么存储和读取的？</p><ul><li>Redis分片集群引入了哈希槽的概念，Redis集群有16384个哈希槽</li><li>将16384个插槽分配到不同的实例</li><li>读写数据：根据key的有效部分计算哈希值，对16384取余（有效部分，如果ky前面有大括号，大括号的内容就是有效部分，如果没有，则以ky本身做为有效部分)余数做为插槽，寻找插槽所在的实例</li></ul><ol><li><h3 id="MySQL如何定位慢查询"><a href="#MySQL如何定位慢查询" class="headerlink" title="MySQL如何定位慢查询"></a>MySQL如何定位慢查询</h3></li></ol><p>当压测的时候有的接口非常的慢，接口的响应时间超过了2秒以上，如果系统部署了运维的监控系统Skywalking,在展示的报表中可以看到是哪一个接口比较慢，并且可以分析这个接口哪部分比较慢，这里可以看到SQL的具体的执行时间，所以可以定位是哪个sql出了问题</p><p>如果，项目中没有这种运维的监控系统，其实在MySQL中也提供了慢日志查询的功能，可以在MySQL</p><p>的系统配置文件中开启这个慢日志的功能，并且也可以设置SQL执行超过多少时间来记录到一个日志文</p><p>件中。</p><ol><li><h3 id="sql语句执行的很慢，该如何分析"><a href="#sql语句执行的很慢，该如何分析" class="headerlink" title="sql语句执行的很慢，该如何分析"></a>sql语句执行的很慢，该如何分析</h3></li></ol><p>​      如果一条sql执行很慢的话，我们通常会使用mysql自动的执行计划explain来去查看这条sql的执行情况，比如在这里面可以通过key和key_len检查是否命中了索引，如果本身已经添加了索引，也可以判断索引是否有失效的情况，第二个，可以通过type字段查看sql是否有进一步的优化空间，是否存在全索引扫描或全盘扫描，第三个可以通过extra建议来判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复</p><ol><li><h3 id="聚集索引选取规则："><a href="#聚集索引选取规则：" class="headerlink" title="聚集索引选取规则："></a>聚集索引选取规则：</h3></li></ol><ul><li>如果存在主键，主键索引就是聚集索引。</li><li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引。</li><li>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</li></ul><ol><li><h3 id="知道什么叫覆盖索引吗"><a href="#知道什么叫覆盖索引吗" class="headerlink" title="知道什么叫覆盖索引吗"></a>知道什么叫覆盖索引吗</h3></li></ol><p>覆盖索引是指查询使用了索引，返回的列，必须在索引中全部能够找到</p><p>使用id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</p><p>如果返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用select*</p><ol><li><h3 id="索引创建的原则"><a href="#索引创建的原则" class="headerlink" title="索引创建的原则"></a>索引创建的原则</h3></li><li><p>针对于数据量较大，且查询比较频繁的表建立索引。单表超过10万数据（增加用户体验）</p></li><li><p>针对于常作为查询条件(where)、排序(order by)、分组(group by)操作的字段建立索引。</p></li><li><p>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p></li><li><p>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</p></li><li><p>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p></li><li><p>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p></li><li><p>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</p></li><li><h3 id="什么情况下索引会失效"><a href="#什么情况下索引会失效" class="headerlink" title="什么情况下索引会失效"></a>什么情况下索引会失效</h3></li></ol><p>常见的五种:</p><ul><li>违反最左前缀法则</li><li>范围查询右边的列，不能使用索引</li><li>不要在索引列上进行运算操作，索引将失效</li><li>字符串不加单引号，造成索引失效。（类型转换）</li><li>以%开头的Like模糊查询，索引失效</li></ul><ol><li>并发事务问题</li></ol><p>脏读：一个事务读到另外一个事务还没有提交的数据。</p><p>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</p><p>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了”幻影”。</p><ol><li><h3 id="解释一下mvcc"><a href="#解释一下mvcc" class="headerlink" title="解释一下mvcc"></a>解释一下mvcc</h3></li></ol><p>MySQL中的多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突</p><ul><li>隐藏字段：</li></ul><p>①trx_id(事务id),记录每一次操作的事务id,是自增的</p><p>②roll_pointer(回滚指针)，指向上一个版本的事务版本记录地址</p><ul><li>undo log:</li></ul><p>①回滚日志，存储老版本数据</p><p>②版本链：多个事务并行操作某一行记录，记录不同事务修改数据的版本，通过roll_pointer指针形成一个链表</p><ul><li>readView解决的是一个事务查询选择版本的问题</li></ul><p>根据readView的匹配规则和当前的一些事务id判断该访问那个版本的数据</p><p>不同的隔离级别快照读是不一样的，最终的访问的结果不一样</p><p>RC：每一次执行快照读时生成ReadView</p><p>RR: 仅在事务中第一次执行快照读时生成ReadView,后续复用</p><h2 id="Spring面试题"><a href="#Spring面试题" class="headerlink" title="Spring面试题"></a>Spring面试题</h2><ol><li><h3 id="Spring框架中的单例bean是线程安全的吗"><a href="#Spring框架中的单例bean是线程安全的吗" class="headerlink" title="Spring框架中的单例bean是线程安全的吗"></a>Spring框架中的单例bean是线程安全的吗</h3></li></ol><p>不是线程安全的，是这样的</p><p>当多用户同时请求一个服务时，容器会给每一个请求分配一个线程，这时多个线程会并发执行该请求对应的业务逻辑（成员方法），如果该处理逻辑中有对该单列状态的修改（体现为该单例的成员属性)，则必须考虑线程同步问题。</p><p>Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。</p><p>比如：我们通常在项目中使用的Spring bean都是不可变的状态（比如Service类和DAO类），所以在某种程度上说Spring的单例bean是线程安全的。</p><p>如果你的bean有多种状态的话（比如View Model&gt;对象），就需要自行保证线程安全。最浅显的解决办法就是将多态bean的作用由”singleton”变更为”prototype”。</p><p>因为一般在spring的bean的中都是注入无状态的对象，没有线程安全问题，如果在bean中定义了可修改的成员变量，是要考虑线程安全问题的，可以使用多例或者加锁来解决</p><ol><li><h3 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h3></li></ol><p>面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合，实现方式主要有动态代理，和字节码操作等方式</p><p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理</p><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><ol><li><h3 id="项目中有没有使用到AOP"><a href="#项目中有没有使用到AOP" class="headerlink" title="项目中有没有使用到AOP"></a>项目中有没有使用到AOP</h3></li></ol><p>记录操作日志，缓存，spring实现的事务</p><p>记录日志:</p><p>核心是：使用aop中的环绕通知+切点表达式（找到要记录日志的方法），通过环绕通知的参数获取请求方法的参数（类、方法、注解、请求方式等)，获取到这些参数以后，保存到数据库</p><ol><li><h3 id="Spring中的事务是如何实现的"><a href="#Spring中的事务是如何实现的" class="headerlink" title="Spring中的事务是如何实现的"></a>Spring中的事务是如何实现的</h3></li></ol><p>Spring支持编程式事务管理和声明式事务管理两种方式。</p><ul><li>编程式事务控制：需使用TransactionTemplate:来进行实现，对业务代码有侵入性，项目中很少使用</li><li>声明式事务管理：声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</li></ul><p>其本质是通过AOP功能，对方法前后进行拦截，在执行方法之前开启事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p><ol><li><h3 id="Spring事务失效的场景以及解决方法"><a href="#Spring事务失效的场景以及解决方法" class="headerlink" title="Spring事务失效的场景以及解决方法"></a>Spring事务失效的场景以及解决方法</h3></li></ol><p>异常捕获处理，自己处理了异常，没有抛出，解决：手动抛出</p><p>抛出检查异常，配置rollbackFor属性为Exception.class</p><p>非public方法导致的事务失效，改为public</p><ol><li><h3 id="Spring的bean的生命周期"><a href="#Spring的bean的生命周期" class="headerlink" title="Spring的bean的生命周期"></a>Spring的bean的生命周期</h3></li><li><p>通过BeanDefinition获取bean的定义信息</p></li><li><p>调用构造函数实例化bean</p></li><li><p>bean的依赖注入</p></li><li><p>处理Aware接口(BeanNameAware、BeanFactoryAware、ApplicationContextAware)</p></li><li><p>Bean的后置处理器BeanPostProcessor–前置</p></li><li><p>初始化方法(InitializingBean、init-method)</p></li><li><p>Bean的后置处理器BeanPostProcessor-后置</p></li><li><p>销毁bean</p></li><li><h3 id="Spring的循环依赖问题"><a href="#Spring的循环依赖问题" class="headerlink" title="Spring的循环依赖问题"></a>Spring的循环依赖问题</h3></li></ol><p>循环依赖：循环依赖其实就是循环引用，也就是两个或两个以上的bea互相特有对方，最终形成闭环。比如A依赖于B,B依赖于A</p><p>循环依赖在spring中是允许存在，spring框架依据三级缓存已经解决了大部分的循环依赖</p><p>一级缓存：单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象</p><p>二级缓存：缓存早期的bean对象（生命周期还没走完）</p><p>三级缓存：缓存的是ObjectFactory,.表示对象工厂，用来创建某个对象的</p><p>简单介绍一下流程</p><ol><li><h3 id="构造方法出现了循环依赖怎么解决呢"><a href="#构造方法出现了循环依赖怎么解决呢" class="headerlink" title="构造方法出现了循环依赖怎么解决呢"></a>构造方法出现了循环依赖怎么解决呢</h3></li></ol><p>A依赖于B,B依赖于A,注入的方式是构造函数</p><p>原因：由于bean的生命周期中构造函数是第一个执行的，spring框架并不能解决构造函数的的依赖注入</p><p>解决方案：使用@Lazy进行獭加载，什么时候需要对象再进行bean对象的创建</p><ol><li><h3 id="SpringMVC的执行流程"><a href="#SpringMVC的执行流程" class="headerlink" title="SpringMVC的执行流程"></a>SpringMVC的执行流程</h3></li></ol><p>视图版本JSP流程</p><ol><li>用户发送出请求到前端控制器DispatcherServlet</li><li>DispatcherServletl收到请求调用HandlerMapping(处理器映射器)</li><li>HandlerMapping:找到具体的处理器，生成处理器对象及处理器拦截器（如果有），再一起返回给DispatcherServlet。</li><li>DispatcherServleti调用HandlerAdapter(处理器适配器)</li><li>HandlerAdapter经过适配调用具体的处理器(Handler&#x2F;Controller)</li><li>Controller执行完成返回ModelAndView对象</li><li>HandlerAdapter将Controller执行结果ModelAndViewi返回给DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover(视图解析器)</li><li>ViewReslover解析后返回具体View(视图)</li><li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）</li><li>DispatcherServlet响应用户</li></ol><p>前后端开发，接口开发流程</p><ol><li><p>用户发送出请求到前端控制器DispatcherServlet</p></li><li><p>DispatcherServlet收到请求调用HandlerMapping(处理器映射器)</p></li><li><p>HandlerMapping?找到具体的处理器，生成处理器对象及处理器拦截器（如果有），再一起返回给DispatcherServlet。</p></li><li><p>DispatcherServleti调用HandlerAdapter(处理器适配器)</p></li><li><p>HandlerAdaptera经过适配调用具体的处理器(Handler&#x2F;Controller)</p></li><li><p>方法上添加了@ResponseBody</p></li><li><p>通过HttpMessageConverter来返回结果转换为JSON并响应</p></li><li><h3 id="Springboot的自动配置原理"><a href="#Springboot的自动配置原理" class="headerlink" title="Springboot的自动配置原理"></a>Springboot的自动配置原理</h3></li></ol><p>自动装配，简单来说就是自动把第三方组件的 Bean 装载到 Spring IOC 器里面，不需 </p><p>要开发人员再去写 Bean 的装配配置。 </p><p>在 Spring Boot 应用里面，只需要在启动类加上@SpringBootApplication 注解就可以实现自动装配。 @SpringBootApplication 是一个复合注解，它包括了@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan，真正实现自动装配的注解是@EnableAutoConfiguration。 </p><p>自动装配的实现主要依靠三个核心关键技术。 </p><ol><li><p>引入 Starter 启动依赖组件的时候，这个组件里面必须要包含@Configuration 配置类，在这个配置类里面通过@Bean 注解声明需要装配到 IOC 容器的 Bean 对象。</p></li><li><p>这个配置类是放在第三方的 jar 包里面，然后通过 SpringBoot 中的约定优于配置思想，把这个配置类的全路径放在 classpath:&#x2F;META-INF&#x2F;spring.factories 文件中。这样 SpringBoot 就可以知道第三方 jar 包里面的配置类的位置，这个步骤主要是用到了 Spring 里面的 SpringFactoriesLoader 来完成的。 </p></li><li><p>SpringBoot 拿到第三方 jar 包里面声明的配置类以后，再通过 Spring 提供的ImportSelector 接口，实现对这些配置类的动态加载。在我看来，SpringBoot 是约定优于配置这一理念下的产物，所以在很多的地方，都会看到这类的思想。它的出现，让开发人员更加聚焦在了业务代码的编写上，而不需要去关心和业务无关的配置。 </p></li><li><h3 id="Spring的常见注解"><a href="#Spring的常见注解" class="headerlink" title="Spring的常见注解"></a>Spring的常见注解</h3></li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MjllNzA0MTY5YWMyZGI3Mzg5NDc4YWYxZDk1OWMyYjJfbU1DMHA4WFRMdElIUjZxaE9EbEY2Y2JKZ3RDanVwR3lfVG9rZW46VFdZQmJrc1d5b0x2Njl4c2dVVGNRU2QzbjljXzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><ol><li><h3 id="SpringMVC的常见注解"><a href="#SpringMVC的常见注解" class="headerlink" title="SpringMVC的常见注解"></a>SpringMVC的常见注解</h3></li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MDFhN2UwNGFmZTE2OWVhNDQwNTkwNDcyZTI5MWNjZDNfaDAzOEFxTGp6VEdCdW9nWFpHMjFFcWJSTUNnaTN0V25fVG9rZW46UDZwSmJJYjU2b2NqWFp4WEhyRWN0OTZqbk9zXzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><ol><li><h3 id="SpringBoot的常见注解"><a href="#SpringBoot的常见注解" class="headerlink" title="SpringBoot的常见注解"></a>SpringBoot的常见注解</h3></li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YTU3MWIxY2U0ODliNzdkM2Q5YjNiYTUzYTM1OTQ5MGRfVVJwdkpQR0xYVzZRamJ3QW5VUTRqRXhWcmdnZEhHUE9fVG9rZW46Q3djNWJaT21ob3ZhbTR4T3pqUmNTTUxZbjdmXzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><ol><li><h3 id="Mybatis的执行流程是什么"><a href="#Mybatis的执行流程是什么" class="headerlink" title="Mybatis的执行流程是什么"></a>Mybatis的执行流程是什么</h3></li><li><p>读取MyBatis配置文件：mybatis-config.xml加载运行环境和映射文件</p></li><li><p>构造会话工厂SqlSessionFactory</p></li><li><p>会话工厂创建SqlSession对象（包含了执行SQL语句的所有方法）</p></li><li><p>操作数据库的接口，Executor执行器，同时负责查询缓存的维护</p></li><li><p>Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息</p></li><li><p>输入参数映射</p></li><li><p>输出结果映射</p></li><li><h3 id="Mybatis是否支持延迟加载"><a href="#Mybatis是否支持延迟加载" class="headerlink" title="Mybatis是否支持延迟加载"></a>Mybatis是否支持延迟加载</h3></li></ol><p>延迟加载的意思是：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。</p><p>Mybatis支持一对一关联对象和一对多关联集合对象的延迟加载</p><p>在Mybatisi配置文件中，可以配置是否启用延迟加载lazyLoading Enabled&#x3D;true|false,默认是关闭的</p><p>延迟加载的底层原理知道吗？</p><p>使用CGLIB创建目标对象的代理对象</p><p>当调用目标方法时，进入拦截器invoke方法，发现目标方法是null值，执行sql查询</p><p>获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了</p><h2 id="微服务面试题"><a href="#微服务面试题" class="headerlink" title="微服务面试题"></a>微服务面试题</h2><ol><li><h3 id="Spring-Cloud组件有哪些？"><a href="#Spring-Cloud组件有哪些？" class="headerlink" title="Spring Cloud组件有哪些？"></a>Spring Cloud组件有哪些？</h3></li></ol><p>因为我项目中使用的是SpringCloudAlibba,所以使用的是阿里巴巴的组件</p><p>主要由五个</p><p>注册中心&#x2F;配置中心 Nacos</p><p>负载均衡  Ribbon</p><p>服务调用   Feign</p><p>服务保护   sentinel</p><p>服务网关   Gateway</p><ol><li><h3 id="服务注册和发现是什么意思-Spring-Cloud如何实现服务注册发现？"><a href="#服务注册和发现是什么意思-Spring-Cloud如何实现服务注册发现？" class="headerlink" title="服务注册和发现是什么意思?Spring Cloud如何实现服务注册发现？"></a>服务注册和发现是什么意思?Spring Cloud如何实现服务注册发现？</h3></li></ol><p>我先说一下eureka的流程吧</p><p>服务注册：服务提供者需要把自己的信息注册到eureka,由eureka:来保存这些信息，比如服务名称、ip、端口等等</p><p>服务发现：消费者向eureka拉取服务列表信息，如果服务提供者有集群，则消费者会利用负载均衡算法，选择一个发起调用</p><p>服务监控：服务提供者会每隔30秒向eureka发送心跳，报告健康状态，如果eureka服务90秒没接收到心跳，从eureka中剔除</p><p>nacos还额外增加了一些功能</p><p>Nacos与eureka的共同点（注册中心）</p><p>都支持服务注册和服务拉取</p><p>都支持服务提供者心跳方式做健康检测</p><p>Nacos与Eureka的区别（注册中心）</p><p>Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</p><p>临时实例心跳不正常会被剔除，非临时实例侧不会被剔除</p><p>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</p><p>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</p><p>Nacosi还支持了配置中心，eureka则只有注册中心，也是选择使用nacos的一个重要原因</p><ol><li><h3 id="负载均衡是如何实现的"><a href="#负载均衡是如何实现的" class="headerlink" title="负载均衡是如何实现的"></a>负载均衡是如何实现的</h3></li></ol><p>微服务的负载均衡主要使用了一个组件Ribbon,比如，我们在使用feign远程调用的过程中，底层的负</p><p>载均衡就是使用了ribbon</p><ol><li><h3 id="Ribbon负载均衡策略有哪些"><a href="#Ribbon负载均衡策略有哪些" class="headerlink" title="Ribbon负载均衡策略有哪些"></a>Ribbon负载均衡策略有哪些</h3></li></ol><ul><li>RoundRobinRule:简单轮询服务列表来选择服务器</li><li>WeightedResponseTimeRule:按照权重来选择服务器，响应时间越长，权重越小</li><li>RandomRule:随机选择一个可用的服务器</li><li>ZoneAvoidanceRule:区域敏感策略，以区域可用的服务器为基础进行服务器的选择。使用Zone对服务器进行分类，这个Zone可以理解为一个机房、一个机架等。而后再对Zone内的多个服务做轮（默认）</li></ul><ol><li><h3 id="如果想自定义负载均衡策略如何实现？"><a href="#如果想自定义负载均衡策略如何实现？" class="headerlink" title="如果想自定义负载均衡策略如何实现？"></a>如果想自定义负载均衡策略如何实现？</h3></li></ol><p>提供了两种方式：</p><ol><li><p>创建类实现IRule接口，可以指定负载均衡策略（全局）</p></li><li><p>在客户端的配置文件中，可以配置某一个服务调用的负载均衡策略（局部）</p></li><li><h3 id="什么是服务雪崩，怎么解决这个问题？"><a href="#什么是服务雪崩，怎么解决这个问题？" class="headerlink" title="什么是服务雪崩，怎么解决这个问题？"></a>什么是服务雪崩，怎么解决这个问题？</h3></li></ol><ul><li>服务雪崩：一个服务失败，导致整条链路的服务都失败的情形</li><li>服务降级：服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃，一般在实际开发中与feign接口整合，编写降级逻辑</li><li>服务熔断：默认关闭，需要手动打开，如果检测到10秒内请求的失败率超过50%，就触发熔断机制。之后每隔5秒重新尝试请求微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求</li></ul><ol><li><h3 id="微服务是怎么监控的？"><a href="#微服务是怎么监控的？" class="headerlink" title="微服务是怎么监控的？"></a>微服务是怎么监控的？</h3></li></ol><p>当时项目中采用的skywalking进行监控的</p><ol><li><p>skywalking主要可以监控接口、服务、物理实例的一些状态。特别是在压测的时候可以看到众多服务中哪些服务和接口比较慢，可以针对性的分析和优化。</p></li><li><p>如果项目上线，还可以在skywalking设置告警规侧，如果报错，可以分别设置给相关负责人发短信和发邮件，第一时间知道项目的bug情况，第一时间修复</p></li><li><h3 id="限流怎么做的？"><a href="#限流怎么做的？" class="headerlink" title="限流怎么做的？"></a>限流怎么做的？</h3></li></ol><p>为什么要限流？</p><ol><li>并发的突然增大（突发流量）</li><li>防止用户恶意刷接口</li></ol><ul><li>常规限流:采用漏桶算法进行限流</li><li>nginx限流</li></ul><p>控制速率（突发流量），使用的漏桶算法来实现过滤，让请求以固定的速率处理请求，可以应对突发流量，控制并发数，限制单个ip的链接数和并发链接的总数</p><ul><li>网关限流</li></ul><p>在spring cloud gateway中支持局部过滤器RequestRateLimiter来做限流，使用的是令牌桶算法</p><p>可以根据ip或路径进行限流，可以设置每秒填充平均速率，和令牌桶总容量</p><ol><li><h3 id="分布式系统理论–CAP和BASE"><a href="#分布式系统理论–CAP和BASE" class="headerlink" title="分布式系统理论–CAP和BASE"></a>分布式系统理论–CAP和BASE</h3></li></ol><p>CAP定理（一致性、可用性、分区容错性）</p><p>分布式系统节点通过网络连接，一定会出现分区问题(P)</p><p>当分区出现时，系统的一致性(C)和可用性(A)就无法同时满足</p><p>BASE理论是针对CAP提出的解决方案</p><ul><li>基本可用</li><li>软状态</li><li>最终一致</li></ul><p>解决分布式事务的思想和模型：</p><ul><li>最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据(AP)</li><li>强一致思想：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚(CP)</li></ul><ol><li><h3 id="项目中的微服务使用哪种分布式事务解决方案"><a href="#项目中的微服务使用哪种分布式事务解决方案" class="headerlink" title="项目中的微服务使用哪种分布式事务解决方案"></a>项目中的微服务使用哪种分布式事务解决方案</h3></li></ol><p>可采用的方案(seata|MQ)–我用的就是seata</p><ol><li><p>seata的XA模式，CP,需要互相等待各个分支事务提交，可以保证强一致性，性能差</p></li><li><p>seata的AT模式，AP,底层使用undo log实现，性能好</p></li><li><p>seatal的TCC模式，AP,性能较好，不过需要人工编码实现</p></li><li><p>MQ模式实现分布式事务，在A服务写数据的时候，需要在同一个事务内发送消息到另外一个事务,异步，性能最好</p></li><li><h3 id="分布式服务的接口幂等性如何设计"><a href="#分布式服务的接口幂等性如何设计" class="headerlink" title="分布式服务的接口幂等性如何设计"></a>分布式服务的接口幂等性如何设计</h3></li></ol><ul><li>幂等：多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致</li><li>如果是新增数据，可以使用数据库的唯一索引</li><li>如果是新增或修改数据：</li></ul><ol><li>分布式锁，性能较低；</li><li>使用token+redis来实现，性能较好：</li></ol><p>第一次请求，生成一个唯一token存入redis,返回给前端</p><p>第二次请求，业务处理，携带之前的token,到redisi进行验证，如果存在，可以执行业务，删除token;</p><p>如果不存在，则直接返回，不处理业务</p><ol><li><h3 id="分布式任务调度"><a href="#分布式任务调度" class="headerlink" title="分布式任务调度"></a>分布式任务调度</h3></li></ol><p>以xxl-job为例，此外的还有SpringTask、elastic-job等</p><ol><li>路由策略</li></ol><p>xxI-jobJ提供了很多的路由策略，平时用的较多就是：轮询、故障转移、分片广播、</p><ol><li>任务执行失败怎么解决？</li></ol><ul><li>路由策略选择故障转移，使用健康的实例来执行任务</li><li>设置重试次数</li><li>查看日志+邮件告警来通知相关负责人解决</li></ul><ol><li>如果有大数据量的任务同时都需要执行，怎么解决？</li></ol><ul><li>让多个实例一块去执行（部署集群），路由策略分片广播</li><li>在任务执行的代码中可以获取分片总数和当前分片，按照取模的方式分摊到各个实例执行</li></ul><h2 id="消息中间件面试题"><a href="#消息中间件面试题" class="headerlink" title="消息中间件面试题"></a>消息中间件面试题</h2><ol><li><h3 id="RabbitMQ-如何保证消息不丢失"><a href="#RabbitMQ-如何保证消息不丢失" class="headerlink" title="RabbitMQ-如何保证消息不丢失"></a>RabbitMQ-如何保证消息不丢失</h3></li></ol><ul><li>开启生产者确认机制，确保生产者的消息能到达队列</li><li>开启持久化功能，确保消息未消费前在队列中不会丢失</li><li>开启消费者确认机制为auto,由spring确认消息处理成功后完成ack</li><li>开启消费者失败重试机制，多次重试失败后将消息投递到异常交换机，交由人工处理</li></ul><ol><li><p>第一个是开启生产者确认机制，确保生产者的消息能到达队列，如果报错可以先记录到日志中，再去修复数据</p></li><li><p>第二个是开启持久化功能，确保消息未消费前在队列中不会丢失，其中的交换机、队列、和消息都要做持久化</p></li><li><p>第三个是开启消费者确认机制为auto,由spring确认消息处理成功后完成ack,当然也需要设置一定的重试次数，如果设置了3次，如果重试3次还没有收到消息，就将失败后的消息投递到异常交换机，交由人工处理</p></li><li><h3 id="RabbitMQ消息的重复消费问题如何解决的"><a href="#RabbitMQ消息的重复消费问题如何解决的" class="headerlink" title="RabbitMQ消息的重复消费问题如何解决的"></a>RabbitMQ消息的重复消费问题如何解决的</h3></li></ol><p>因为我当时处理的支付（订单业务唯一标识），它有一个业务的唯一标识，再处理消息时，先到数据库查询一下，这个数据是否存在，如果不存在，说明没有处理过，这个时候就可以正常处理这个消息了。如果己经存在这个数据了，就说明消息重复消费了，我们就不需要再消费了</p><p>其他解决方案:</p><p>其实这个就是典型的幂等的问题，比如，redis分布式锁、数据库的锁都是可以的</p><ol><li><h3 id="RabbitMQ中死信交换机？-RabbitMQ延迟队列了解过吗"><a href="#RabbitMQ中死信交换机？-RabbitMQ延迟队列了解过吗" class="headerlink" title="RabbitMQ中死信交换机？(RabbitMQ延迟队列了解过吗?)"></a>RabbitMQ中死信交换机？(RabbitMQ延迟队列了解过吗?)</h3></li></ol><p>延迟队列&#x3D;死信交换机+TTL(生存时间)</p><p>如果消息超时未消费就会变成死信，在RabbitMQ中如果消息成为死信，队列可以绑定一个死信交换</p><p>机，在死信交换机上可以绑定其他队列，在我们发消息的时候可以按照需求指定TTL的时间，这样就实</p><p>现了延迟队列的功能了。</p><p>我记得RabbitMQ还有一种方式可以实现延迟队列，在RabbitMQ中安装一个死信插件，这样更方便一</p><p>些，我们只需要在声明交互机的时候，指定这个就是死信交换机，然后在发送消息的时候直接指定超</p><p>时时间就行了，相对于死信交换机+TTL要省略了一些步骤</p><ol><li><h3 id="RabbitMQ如果有100万消息堆积在MQ-如何解决（消息堆积怎么解决）"><a href="#RabbitMQ如果有100万消息堆积在MQ-如何解决（消息堆积怎么解决）" class="headerlink" title="RabbitMQ如果有100万消息堆积在MQ,如何解决（消息堆积怎么解决）"></a>RabbitMQ如果有100万消息堆积在MQ,如何解决（消息堆积怎么解决）</h3></li></ol><ul><li>增加更多消费者，提高消费速度</li><li>在消费者内开启线程池加快消息处理速度</li><li>扩大队列容积，提高堆积上限，采用惰性队列:</li></ul><ol><li><p>在声明队列的时候可以设置属性x-queue-mode为lazy,即为惰惟队列</p></li><li><p>基于磁盘存储，消息上限高</p></li><li><p>性能比较稳定，但基于磁盘存储，受限于磁盘O，时效性会降低</p></li><li><h3 id="RabbitMQ的高可用机制"><a href="#RabbitMQ的高可用机制" class="headerlink" title="RabbitMQ的高可用机制"></a>RabbitMQ的高可用机制</h3></li></ol><p>在生产环境下，可以采用镜像模式搭建的集群，共有3个节点</p><p>镜像队列结构是一主多从（从就是镜像），所有操作都是主节点完成，然后同步给镜像节点</p><p>主宕机后，镜像节点会替代成新的主（如果在主从同步完成前，主就已经宕机，可能出现数据丢失）</p><p>出现丢数据怎么解决呢？</p><p>我们可以采用仲裁队列，与镜像队列一样，都是主从模式，支持主从数据同步，主从同步基于Rft协议，强一致。</p><p>并且使用起来也非常简单，不需要额外的配置，在声明队列的时候只要指定这个是仲裁队列即可</p><ol><li><h3 id="Kafka是如何保证消息不丢失"><a href="#Kafka是如何保证消息不丢失" class="headerlink" title="Kafka是如何保证消息不丢失"></a>Kafka是如何保证消息不丢失</h3></li></ol><p>需要从三个层面去解决这个问题：</p><ol><li>生产者发送消息到Brocker丢失</li></ol><ul><li>设置异步发送，发送失败使用回调进行记录或重发</li><li>失败重试，参数配置，可以设置重次数</li></ul><ol><li>消息在Brocker中存储丢失</li></ol><ul><li>发送确认acks,选择all,让所有的副本都参与保存数据后确认</li></ul><ol><li>消费者从Brocker接收消息丢失</li></ol><ul><li>关闭自动提交偏移量，开启手动提交偏移量</li><li>提交方式，最好是同步+异步提交</li></ul><p>回答：</p><p>第一个是生产者发送消息的时候，可以使用异步回调发送，如果消息发送失败，我们可以通过回调获</p><p>取失败后的消息信息，可以考虑重试或记录日志，后边再做补偿都是可以的。同时在生产者这边还可</p><p>以设置消息重试，有的时候是由于网络抖动的原因导致发送不成功，就可以使用重试机制来解决</p><p>第二个在broker中消息有可能会丢失，我们可以通过kafka的复制机制来确保消息不丢失，在生产者发</p><p>送消息的时候，可以设置一个acks,就是确认机制。我们可以设置参数为al,这样的话，当生产者发送消息到了分区之后，不仅仅只在leader分区保存确认，在follwer分区也会保存确认，只有当所有的副本都保存确认以后才算是成功发送了消息，所以，这样设置就很大程度了保证了消息不会在broker丢失</p><p>第三个有可能是在消费者端丢失消息，kafka消费消息都是按照offset进行标记消费的，消费者默认是自</p><p>动按期提交己经消费的偏移量，默认是每隔5s提交一次，如果出现重平衡的情况，可能会重复消费或</p><p>丢失数据。我们一般都会禁用掉自动提价偏移量，改为手动提交，当消费成功以后再报告给broker消</p><p>费的位置，这样就可以避免消息丢失和重复消费了</p><ol><li><h3 id="Kafka中消息的重复消费问题如何解决的？"><a href="#Kafka中消息的重复消费问题如何解决的？" class="headerlink" title="Kafka中消息的重复消费问题如何解决的？"></a>Kafka中消息的重复消费问题如何解决的？</h3></li></ol><ul><li>关闭自动提交偏移量，开启手动提交偏移量</li><li>提交方式，最好是同步+异步提交</li><li>幂等方案</li></ul><p>回答:</p><p>  kafka消费消息都是按照offseti进行标记消费的，消费者默认是自动按期提交已经消费的偏移量，默认是每隔5s提交一次，如果出现重平衡的情况，可能会重复消费或丢失数据。我们一般都会禁用掉自动提价偏移量，改为手动提交，当消费成功以后再报告给broker消费的位置，这样就可以避免消息丢失和重复消费了</p><ol><li><h3 id="Kafka是如何保证消费的顺序性"><a href="#Kafka是如何保证消费的顺序性" class="headerlink" title="Kafka是如何保证消费的顺序性"></a>Kafka是如何保证消费的顺序性</h3></li></ol><p>问题原因：</p><p>一个topic的数据可能存储在不同的分区中，每个分区都有一个按照顺序的存储的偏移量，如果消费者关联了多个分区不能保证顺序性</p><p>解决方案：</p><ul><li>发送消息时指定分区号</li><li>发送消息时按照相同的业务设置相同的key</li></ul><p>回答:</p><p>kafka默认存储和消费消息，是不能保证顺序性的，因为一个topic数据可能存储在不同的分区中，每个</p><p>分区都有一个按照顺序的存储的偏移量，如果消费者关联了多个分区不能保证顺序性</p><p>如果有这样的需求的话，我们是可以解决的，把消息都存储同一个分区下就行了，有两种方式都可以</p><p>进行设置，第一个是发送消息时指定分区号，第二个是发送消息时按照相同的业务设置相同的ky,因</p><p>为默认情况下分区也是通过key的hashcode值来选择分区的，hash值如果一样的话，分区肯定也是一样</p><p>的</p><ol><li><h3 id="Kafka的高可用机制"><a href="#Kafka的高可用机制" class="headerlink" title="Kafka的高可用机制"></a>Kafka的高可用机制</h3></li><li><p>集群：</p></li></ol><p>一个kafka集群由多个oroker3实例组成，即使某一台宕机，也不耽误其他broker继续对外提供服务</p><ol><li>复制机制：</li></ol><p>一个topic有多个分区，每个分区有多个副本，有一个leader,其余的是follower,副本存储在不同的broker中所有的分区副本的内容是都是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader,保证了系统的容错性、高可用性</p><ol><li><h3 id="解释一下复制机制中的ISR"><a href="#解释一下复制机制中的ISR" class="headerlink" title="解释一下复制机制中的ISR"></a>解释一下复制机制中的ISR</h3></li></ol><p>ISR(in-sync replica)需要同步复制保存的follower</p><p>分区副本分为了两类，一个是ISR,与ileader副本同步保存数据，另外一个普通的副本，是异步同步数据，当leader挂掉之后，会优先从ISR副本列表中选取一个作为leader</p><ol><li><h3 id="Kafka数据清理机制"><a href="#Kafka数据清理机制" class="headerlink" title="Kafka数据清理机制"></a>Kafka数据清理机制</h3></li></ol><p>Kafka存储结构</p><ul><li>Kafka中topic的数据存储在分区上，分区如果文件过大会分段存储segment</li><li>每个分段都在磁盘上以索引(xxxx.index)和日志文件(xxx.log)的形式存储</li><li>分段的好处是，第一能够减少单个文件内容的大小，查找数据方便，第二方便kafka进行日志清理。</li></ul><p>日志的清理策略有两个：</p><ul><li>根据消息的保留时间，当消息保存的时间超过了指定的时间，就会触发清理，默认是168小时（7天)</li><li>根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息。（默认关闭）</li></ul><ol><li><h3 id="Kafka中实现高性能的设计"><a href="#Kafka中实现高性能的设计" class="headerlink" title="Kafka中实现高性能的设计"></a>Kafka中实现高性能的设计</h3></li></ol><ul><li>消息分区：不受单台服务器的限制，可以不受限的处理更多的数据</li><li>顺序读写：磁盘顺序读写，提升读写效率</li><li>页缓存：把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问</li><li>零拷贝：减少上下文切换及数据拷贝</li><li>消息压缩：减少磁盘1O和网络1O</li><li>分批发送：将消息打包批量发送，减少网络开销</li></ul><h2 id="集合面试题"><a href="#集合面试题" class="headerlink" title="集合面试题"></a>集合面试题</h2><ol><li><h3 id="为什么数组索引从0开始呢？假如从1开始不行吗？"><a href="#为什么数组索引从0开始呢？假如从1开始不行吗？" class="headerlink" title="为什么数组索引从0开始呢？假如从1开始不行吗？"></a>为什么数组索引从0开始呢？假如从1开始不行吗？</h3></li></ol><p>在根据数组索引获取元素的时候，会用索引和寻址公式来计算内存所对应的元素</p><p>数据，寻址公式是：数组的首地址+索引乘以存储数据的类型大小</p><p>如果数组的索引从1开始，寻址公式中，就需要增加一次减法操作，对于CPU来说</p><p>就多了一次指令，性能不高。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OWUyNGJiYWM3MGFiMzY1MDM4NTIxNjAyOWZlNWVmMmZfbndVQllIVUk5Z0ZBUXlkUzFLeXR5VG9UUTBKWWZBdTFfVG9rZW46Wmpzc2JuMVhnb0VGVlJ4ZmtscGNYRTVwbmplXzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><ol><li><h3 id="ArrayList底层的实现原理是什么"><a href="#ArrayList底层的实现原理是什么" class="headerlink" title="ArrayList底层的实现原理是什么"></a>ArrayList底层的实现原理是什么</h3></li><li><p>ArrayList底层是用动态的数组实现的</p></li><li><p>ArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10</p></li><li><p>ArrayListi在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组</p></li><li><p>ArrayList在添加数据的时候</p></li></ol><ul><li>确保数组已使用长度(size)加1之后足够存下下一个数据</li><li>计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）</li><li>确保新增的数据有地方存储之后，则将新元素添加到位于size的位置上。</li><li>返回添加成功布尔值。</li></ul><ol><li><h3 id="ArrayList-list-new-ArrayList-10-中的list扩容几次"><a href="#ArrayList-list-new-ArrayList-10-中的list扩容几次" class="headerlink" title="ArrayList list &#x3D;new ArrayList(10)中的list扩容几次"></a>ArrayList list &#x3D;new ArrayList(10)中的list扩容几次</h3></li></ol><p>该语句只是声明和实例了一个ArrayList,指定了容量为10，未扩容 </p><ol><li><h3 id="在使用ArrayList和LinkedList时，如何保证线程安全"><a href="#在使用ArrayList和LinkedList时，如何保证线程安全" class="headerlink" title="在使用ArrayList和LinkedList时，如何保证线程安全"></a>在使用ArrayList和LinkedList时，如何保证线程安全</h3></li></ol><p>如果需要保证线程安全，有两种方案：</p><ul><li>在方法内使用，局部变量则是线程安全的</li><li>使用线程安全的ArrayListi和LinkedList</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Object&gt;syncArrayList Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">List&lt;Object&gt;syncLinkedList Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br></pre></td></tr></table></figure><ol><li><h3 id="hashMapl的寻址算法"><a href="#hashMapl的寻址算法" class="headerlink" title="hashMapl的寻址算法"></a>hashMapl的寻址算法</h3></li></ol><p>计算对象的hashCode</p><p>再进行调用hash（）方法进行二次哈希，hashcode值右移16位再异或运算，让哈希分布更为均匀最后(capacity-1)&amp;hash得到索引</p><ol><li><h3 id="为何HashMap的数组长度一定是2的次幂？"><a href="#为何HashMap的数组长度一定是2的次幂？" class="headerlink" title="为何HashMap的数组长度一定是2的次幂？"></a>为何HashMap的数组长度一定是2的次幂？</h3></li><li><p>计算索引时效率更高：如果是2的次幂可以使用位与运算代替取模</p></li><li><p>扩容时重新计算索引效率更高：hash&amp;oldCap&#x3D;&#x3D;0的元素留在原来位置，否则新位置&#x3D;旧位置+oldCap</p></li><li><h3 id="jdk1-7的hashmap扩容时发生的死循环问题"><a href="#jdk1-7的hashmap扩容时发生的死循环问题" class="headerlink" title="jdk1.7的hashmap扩容时发生的死循环问题"></a>jdk1.7的hashmap扩容时发生的死循环问题</h3></li></ol><p>在jdk1.7的nashmap中在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环</p><p>比如说，现在有两个线程</p><p>线程一：读取到当前的hashmap数据，数据中一个链表，在准备扩容时，线程二介入</p><p>线程二：也读取nashmap,直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB,扩容后的顺序是BA,线程二执行结束。</p><p>线程一：继续执行的时候就会出现死循环的问题。</p><p>线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的neXt指向了A,所以B-&gt;A-&gt;B,形成循环。</p><p>当然，JDK8将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），尾插法，就避免了jdk7中死循环的问题。</p><h2 id="并发编程面试题："><a href="#并发编程面试题：" class="headerlink" title="并发编程面试题："></a>并发编程面试题：</h2><ol><li><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3></li></ol><ul><li>进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务</li><li>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低（上下文切换指的是从一个线程切换到另一个线程）</li></ul><ol><li><h3 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h3></li></ol><p>现在都是多核CPU,在多核CPU下</p><ul><li>并发是同一时间应对多件事情的能力，多个线程轮流使用一个或多个CPU</li><li>并行是同一时间动手做多件事情的能力，4核CPU同时执行4个线程</li></ul><ol><li><h3 id="创建线程的方式有哪些？"><a href="#创建线程的方式有哪些？" class="headerlink" title="创建线程的方式有哪些？"></a>创建线程的方式有哪些？</h3></li></ol><ul><li>继承Thread类</li><li>实现runnable接口</li><li>实现Callable接口</li><li>线程池创建线程（项目中使用方式）</li></ul><ol><li><h3 id="使用runnable和callable都可以创建线程，它们有什么区别呢？"><a href="#使用runnable和callable都可以创建线程，它们有什么区别呢？" class="headerlink" title="使用runnable和callable都可以创建线程，它们有什么区别呢？"></a>使用runnable和callable都可以创建线程，它们有什么区别呢？</h3></li></ol><ul><li>Runnable接口run方法没有返回值</li><li>Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</li><li>Callable接口的call(方法允许抛出异常；而Runnable接口的run（）方法的异常只能在内部消化，不能继续上抛</li></ul><ol><li><h3 id="线程的run-和start-有什么区别？"><a href="#线程的run-和start-有什么区别？" class="headerlink" title="线程的run()和start()有什么区别？"></a>线程的run()和start()有什么区别？</h3></li></ol><ul><li>start():用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。</li><li>run():封装了要被线程执行的代码，可以被调用多次。</li></ul><ol><li><h3 id="线程包括哪些状态，状态之间是如何变化的"><a href="#线程包括哪些状态，状态之间是如何变化的" class="headerlink" title="线程包括哪些状态，状态之间是如何变化的"></a>线程包括哪些状态，状态之间是如何变化的</h3></li><li><p>线程包括哪些状态</p></li></ol><p>新建(NEW)、可运行(RUNNABLE)、阻塞(BLOCKED)、等待(WAITING)、时间等待(TIMED_WALTING)、终止(TERMINATED)</p><ol><li>线程状态之间是如何变化的</li></ol><p>创建线程对象是新建状态</p><p>调用了start()方法转变为可执行状态</p><p>线程获取到了CPU的执行权，执行结束是终止状态</p><p>在可执行状态的过程中，如果没有获取CPU的执行权，可能会切换其他状态:</p><p>如果没有获取锁(synchronized或lock)进入阻塞状态，获得锁再切换为可执行状态</p><p>如果线程调用了wait(0方法进入等待状态，其他线程调用notify()唤醒后可切换为可执行状态</p><p>如果线程调用了sleep(50)方法，进入计时等待状态，到时间后可切换为可执行状态</p><ol><li><h3 id="新建T1、T2、T3三个线程，如何保证它们按顺序执行？"><a href="#新建T1、T2、T3三个线程，如何保证它们按顺序执行？" class="headerlink" title="新建T1、T2、T3三个线程，如何保证它们按顺序执行？"></a>新建T1、T2、T3三个线程，如何保证它们按顺序执行？</h3></li></ol><p>使用join()方法</p><ol><li><h3 id="wait和sleep-方法的不同"><a href="#wait和sleep-方法的不同" class="headerlink" title="wait和sleep()方法的不同"></a>wait和sleep()方法的不同</h3></li></ol><p>共同点</p><p>wait0,wait(long)和sleep(long)的效果都是让当前线程暂时放弃CPU的使用权，进入阻塞状态</p><p>不同点</p><ol><li>方法归属不同</li></ol><p>sleep(long)是Thread的静态方法</p><p>而wait0,wait(long)都是Object的成员方法，每个对象都有</p><ol><li>醒来时机不同</li></ol><p>执行sleep((long)和wait(ong)的线程都会在等待相应毫秒后醒来</p><p>wait(long)和wait0还可以被notify唤醒，wait0如果不唤醒就一直等下去</p><p>它们都可以被打断唤醒</p><ol><li>锁特性不同（重点）</li></ol><p>wait方法的调用必须先获取wait对象的锁，而sleep则无此限制</p><p>wait方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃cpu,但你们还可以用）</p><p>而sleep如果在synchronized代码块中执行，并不会释放对象锁（我放弃cpu,你们也用不了）</p><ol><li><h3 id="如何停止一个正在运行的线程？"><a href="#如何停止一个正在运行的线程？" class="headerlink" title="如何停止一个正在运行的线程？"></a>如何停止一个正在运行的线程？</h3></li></ol><p>有三种方式可以停止线程</p><ul><li>使用退出标志，使线程正常退出，也就是当u方法完成后线程终止</li><li>使用stop方法强行终止（不推荐，方法已作废）</li><li>使用interrupt方法中断线程</li></ul><ol><li><p>打断阻塞的线程(sleep,wait,join)的线程，线程会抛出InterruptedException异常</p></li><li><p>打断正常的线程，可以根据打断状态来标记是否退出线程</p></li><li><h3 id="synchronized关键字的底层原理"><a href="#synchronized关键字的底层原理" class="headerlink" title="synchronized关键字的底层原理"></a>synchronized关键字的底层原理</h3></li></ol><ul><li>Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】</li><li>它的底层由monitor实现的，monitor是jvm级别的对象（c++实现)，线程获得锁需要使用对象（锁）关联monitor</li><li>在monitor内部有三个属性，分别是owner、.entrylist、waitset</li><li>其中owner是关联的获得锁的线程，并且只能关联一个线程；entrylist关联的是处于阻塞状态的线程；waitset关联的是处于Waiting状态的线程</li></ul><p>但是Monitor实现的锁属于重量级锁，于是jdk1.6对synchronized做了优化，引入了锁升级</p><p>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。</p><ul><li>重量级锁：底层使用的Monito实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。</li><li>轻量级锁：线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性</li><li>偏向锁：一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark word中是否是自己的线程id即可，而不是开销相对较大的CAS命令</li></ul><ol><li><h3 id="谈谈JMM-Java内存模型"><a href="#谈谈JMM-Java内存模型" class="headerlink" title="谈谈JMM(Java内存模型)"></a>谈谈JMM(Java内存模型)</h3></li></ol><ul><li>JMM(Java Memory Model)Java内存模型，定义了共享内存中多线程程序读写操作的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性</li><li>JMM把内存分为两块，一块是私有线程的工作区域（工作内存），一块是所有线程的共享区域（主内存）</li><li>线程跟线程之间是相互隔离，线程跟线程交互需要通过主内存</li></ul><ol><li><h3 id="说一下CAS"><a href="#说一下CAS" class="headerlink" title="说一下CAS"></a>说一下CAS</h3></li></ol><ul><li>CAS的全称是：Compare And Swap(比较再交换)；它体现的一种乐观锁的思想在无锁状态下保证线程操作数据的原子性。</li><li>CAS使用到的地方很多：AQS框架、AtomicXXX类</li><li>在操作共享变量的时候使用的自旋锁，效率上更高一些</li><li>CAS的底层是调用的Unsafe类中的方法，都是操作系统提供的，其他语言实现</li></ul><ol><li><h3 id="对volatile的理解"><a href="#对volatile的理解" class="headerlink" title="对volatile的理解"></a>对volatile的理解</h3></li><li><p>保证线程间的可见性</p></li></ol><p>用volatile修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</p><ol><li>禁止进行指令重排序</li></ol><p>指令重排：用volatile修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</p><ol><li><h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS?"></a>什么是AQS?</h3></li></ol><ul><li>是多线程中的队列同步器。是一种锁机制，它是做为一个基础框架使用的,像ReentrantLock、.Semaphore都是基于AQS实现的</li><li>AQS内部维护了一个先进先出的双向队列(CLH队列)，队列中存储的排队的线程</li><li>在AQS内部还有一个属性state,这个state就相当于是一个资源，默认是0(无锁状态)，如果队列中的有一个线程修改成功了state为1，则当前线程就相等于获取了资源</li><li>在对state修改的时候使用的cas操作，保证多个线程修改的情况下原子性</li></ul><ol><li><h3 id="ReentrantLock的实现原理"><a href="#ReentrantLock的实现原理" class="headerlink" title="ReentrantLock的实现原理"></a>ReentrantLock的实现原理</h3></li></ol><p>ReentrantLock表示支持重新进入的锁，调用Iock方法获取了锁之后，再</p><p>次调用ock,是不会再阻塞</p><p>ReentrantLock主要利用CAS+AQS队列来实现</p><p>支持公平锁和非公平锁，在提供的构造器的中无参默认是非公平锁，也可</p><p>以传参 设置为公平锁</p><ol><li><h3 id="synchronized和Lock有什么区别？"><a href="#synchronized和Lock有什么区别？" class="headerlink" title="synchronized和Lock有什么区别？"></a>synchronized和Lock有什么区别？</h3></li></ol><ul><li>语法层面</li></ul><p>synchronized是关键字，源码在jvm中，用c++语言实现</p><p>Lock是接口，源码由jdk提供，用java语言实现</p><p>使用synchronized时，退出同步代码块锁会自动释放，而使用Lock时，需要手动调用unlock方法释放锁</p><ul><li>功能层面</li></ul><p>二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能</p><p>Lock提供了许多synchronized不具备的功能，例如公平锁、可打断、可超时、多条件变量</p><p>Lock有适合不同场景的实现，如ReentrantLock,ReentrantReadWriteLock(读写锁)</p><ul><li>性能层面</li></ul><p>在没有竞争时，synchronized做了很多优化，如偏向锁、轻量级锁，性能不赖</p><p>在竞争激烈时，Lock的实现通常会提供更好的性能</p><ol><li><h3 id="聊一下ConcurrentHashMap"><a href="#聊一下ConcurrentHashMap" class="headerlink" title="聊一下ConcurrentHashMap"></a>聊一下ConcurrentHashMap</h3></li><li><p>底层数据结构：</p></li></ol><p>JDK1.7底层采用分段的数组+链表实现</p><p>JDK1.8采用的数据结构跟HashMap1.8的结构一样，数组+链表&#x2F;红黑二叉树</p><ol><li>加锁的方式</li></ol><p>JDK1.7采用Segment分段锁，底层使用的是ReentrantLock</p><p>JDK1.8采用CAS添加新节点，采用synchronized锁定链表或红黑二叉树的首节点，相对Segment分段锁粒度更细，性能更好</p><ol><li><h3 id="导致并发程序出现问题的根本原因是什么"><a href="#导致并发程序出现问题的根本原因是什么" class="headerlink" title="导致并发程序出现问题的根本原因是什么"></a>导致并发程序出现问题的根本原因是什么</h3></li><li><p>原子性   synchronized、lock</p></li><li><p>内存可见性  volatile、synchronized、lock</p></li><li><p>有序性   volatile</p></li><li><h3 id="线程池的核心参数以及执行原理"><a href="#线程池的核心参数以及执行原理" class="headerlink" title="线程池的核心参数以及执行原理"></a>线程池的核心参数以及执行原理</h3></li></ol><ul><li>corePoolSize核心线程数目</li><li>maximumPoolSize最大线程数目&#x3D;（核心线程+敕急线程的最大数目）</li><li>keepAliveTime生存时间-救急线程的生存时间，生存时间内没有新任务，此线程资源会释放</li><li>unit时间单位-救急线程的生存时间单位，如秒、毫秒等</li><li>workQueue-当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</li><li>threadFactory线程工厂-可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li><li>handler拒绝策略-当所有线程都在繁忙，workQueue也放满时，会触发拒绝策略</li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NzNkNTM2OTQzMTRjMDBhNDE4ODY1NjY1NjE3NWY3ZjdfeWpRR2dzU3ZKTUNKcEZBMGJ6cHpmelZTR1JQeW5Ha3BfVG9rZW46UTVEb2JiQU01b1h3Rlh4ZUdNZGNNd1VTbkxnXzE3MTk4MTI2Nzg6MTcxOTgxNjI3OF9WNA" alt="img"></p><p>拒绝策略</p><ol><li><p>AbortPolicy:直接抛出异常，默认策略；</p></li><li><p>CallerRunsPolicy:用调用者所在的线程来执行任务；</p></li><li><p>DiscardOldestPolicy:丢弃阻塞队列中靠最前的任务，并执行当前任务；</p></li><li><p>DiscardPolicy:直接丢弃任务；</p></li><li><h3 id="线程池中有哪些常见的阻塞队列"><a href="#线程池中有哪些常见的阻塞队列" class="headerlink" title="线程池中有哪些常见的阻塞队列"></a>线程池中有哪些常见的阻塞队列</h3></li></ol><p>workQueue-当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务</p><ol><li><p>ArrayBlockingQueue:基于数组结构的有界阻塞队列，FIFO。</p></li><li><p>LinkedBlockingQueue:基于链表结构的有界阻塞队列，FIFO。</p></li><li><p>DelayedWorkQueue：是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的</p></li><li><p>SynchronousQueue:不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</p></li><li><h3 id="如何确定核心线程数"><a href="#如何确定核心线程数" class="headerlink" title="如何确定核心线程数"></a>如何确定核心线程数</h3></li><li><p>高并发、任务执行时间短→(CPU核数+1)，减少线程上下文的切换</p></li><li><p>并发不高、任务执行时间长</p></li></ol><ul><li>IO密集型的任务→(CPU核数2+1)</li><li>计算密集型任务→(CPU核数+1)</li></ul><ol><li><p>并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考(2)</p></li><li><h3 id="线程池的种类有哪些"><a href="#线程池的种类有哪些" class="headerlink" title="线程池的种类有哪些"></a>线程池的种类有哪些</h3></li><li><p>newFixedThreadPool:创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待</p></li><li><p>newSingleThreadExecutor:创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FO)执行</p></li><li><p>newCachedThreadPool:创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</p></li><li><p>newScheduledThreadPool:可以执行延迟任务的线程池，支持定时及周期性任务执行</p></li><li><h3 id="为什么不建议用Executorst创建线程池"><a href="#为什么不建议用Executorst创建线程池" class="headerlink" title="为什么不建议用Executorst创建线程池"></a>为什么不建议用Executorst创建线程池</h3></li><li><p>FixedThreadPool SingleThreadPool</p></li></ol><p>允许的请求队列长度为Integer.MAX VALUE,可能会堆积大量的请求，从而导致OOM。</p><ol><li>CachedThreadPool</li></ol><p>允许的创建线程数量为Integer.MAX VALUE,可能会创建大量的线程，从而导致OOM。</p><ol><li><h3 id="如何控制某个方法允许并发访问线程的数量"><a href="#如何控制某个方法允许并发访问线程的数量" class="headerlink" title="如何控制某个方法允许并发访问线程的数量"></a>如何控制某个方法允许并发访问线程的数量</h3></li></ol><p>在多线程中提供了一个工具类Semaphore,信号量。在并发的情况下，可以控制方法的访问量</p><ol><li><p>创建Semaphorex对象，可以给一个容量</p></li><li><p>acquire(）可以请求一个信号量，这时候的信号量个数-1</p></li><li><p>release0释放一个信号量，此时信号量个数+1</p></li><li><h3 id="谈谈你对ThreadLocal的理解"><a href="#谈谈你对ThreadLocal的理解" class="headerlink" title="谈谈你对ThreadLocal的理解"></a>谈谈你对ThreadLocal的理解</h3></li><li><p>ThreadLocal可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】,避免争用引发的线程安全问题</p></li><li><p>ThreadLocal同时实现了线程内的资源共享</p></li><li><p>每个线程内有一个ThreadLocalMap类型的成员变量，用来存储资源对象</p></li></ol><ul><li>调用set方法，就是以ThreadLocal自己作为key,资源对象作为value,放入当前线程的ThreadLocalMap集合中</li><li>调用get方法，就是以ThreadLocal自己作为key,到当前线程中查找关联的资源值</li><li>调用remove方法，就是以ThreadLocal自己作为key,移除当前线程关联的资源值</li></ul><ol><li>ThreadLocall内存泄漏问题</li></ol><p>ThreadLocalMap中的key是弱引用，值为强引用；key会被GC释放内存，关联value的内存并不会释放。建议主动remove释放key,value</p><h2 id="JVM面试题"><a href="#JVM面试题" class="headerlink" title="JVM面试题"></a>JVM面试题</h2><ol><li><h3 id="说一下类装载的执行过程？"><a href="#说一下类装载的执行过程？" class="headerlink" title="说一下类装载的执行过程？"></a>说一下类装载的执行过程？</h3></li></ol><ul><li>加载：查找和导入class文件</li><li>验证：保证加载类的准确性</li><li>准备：为类变量分配内存并设置类变量初始值</li><li>解析：把类中的符号引用转换为直接引用</li><li>初始化：对类的静态变量，静态代码块执行初始化操作</li><li>使用：JVM开始从入口方法开始执行用户的程序代码</li><li>卸载：当用户程序代码执行完毕后，VM便开始销毁创建的Class对象。</li></ul><ol><li><h3 id="java内存泄露的排查思路？"><a href="#java内存泄露的排查思路？" class="headerlink" title="java内存泄露的排查思路？"></a>java内存泄露的排查思路？</h3></li></ol><p>内存泄漏通常是指堆内存，通常是指一些大对象不被回收的情况</p><p>1、通过jmap或设置jvm参数获取堆内存快照dump</p><p>2、通过工具，VisualVM去分析dump文件，VisualVM可以加载离线的dump文件</p><p>3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题</p><p>4、找到对应的代码，通过阅读上下文的情况，进行修复即可</p><ol><li><h3 id="CPU飙高排查方案与思路？"><a href="#CPU飙高排查方案与思路？" class="headerlink" title="CPU飙高排查方案与思路？"></a>CPU飙高排查方案与思路？</h3></li></ol><p>1.使用top命令查看占用cpu的情况</p><p>2.通过top命令查看后，可以查看是哪一个进程占用cpu较高</p><p>3.使用ps命令查看进程中的线程信息</p><p>4.使用jstacki命令查看进程中哪些线程出现了问题，最终定位问题</p><h2 id="设计模式面试题"><a href="#设计模式面试题" class="headerlink" title="设计模式面试题"></a>设计模式面试题</h2><ol><li>工厂模式</li></ol><ul><li>简单工厂</li></ul><p>所有的产品都共有一个工厂，如果新增产品，则需要修改代码，违反开闭原则是一种编程习惯，可以借鉴这种编程思路</p><ul><li>工厂方法模式</li></ul><p>给每个产品都提供了一个工厂，让工厂专门负责对应的产品的生产，遵循开闭原侧项目中用的最多</p><ul><li>抽象工厂方法模式</li></ul><p>如果有多个纬度的产品需要配合生产时，优先建议采用抽象工厂（工厂的工厂）一般的企业开发中的较少</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在日常开发遇到的不同场景下的应对思路总结</title>
      <link href="/2024/07/01/%E5%9C%A8%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%BA%94%E5%AF%B9%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/"/>
      <url>/2024/07/01/%E5%9C%A8%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%BA%94%E5%AF%B9%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>​    作为一名开发人员，要知道我们每天都会面对很多场景，我们要想着如何去解决它们，因此，开展此专栏主要是想记录一下我日常开发遇到的一些场景以及和各种大佬交流时谈及的场景，以期日后如果能遇到类似场景，能够快速定位问题。</p><p>如果某天我不更新的，两种可能：我无所不能了&#x2F;我无了</p><p>这几篇老文章都是我之前用飞书云文档写的，因转换格式问题，本文之前已写完的文档图片太多了，不想一一转化了，大家可以访问我的飞书云文档来查看这些图片–<a href="https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e,%E4%B8%8D%E8%BF%87%E5%90%8E%E7%BB%AD%E8%A1%A5%E5%85%85%E7%9A%84%E9%83%BD%E4%BC%9A%E6%9C%89%E5%9B%BE%E7%89%87">https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e,不过后续补充的都会有图片</a></p><h1 id="基于Redis实现短信验证码的登录并解决登陆状态刷新的问题。"><a href="#基于Redis实现短信验证码的登录并解决登陆状态刷新的问题。" class="headerlink" title="基于Redis实现短信验证码的登录并解决登陆状态刷新的问题。"></a>基于<strong>Redis</strong>实现短信验证码的登录并解决登陆状态刷新的问题。</h1><h2 id="1-1-设计key的结构"><a href="#1-1-设计key的结构" class="headerlink" title="1.1 设计key的结构"></a>1.1 设计key的结构</h2><p>​     我们需要保存在redis中的数据一共有两种，第一种是验证码，第二种是用户信息。那么针对这两种不同的信息，我们应该分别设计怎样的key呢？Redis中的key应该满足两点：</p><ol><li>唯一性</li><li>方便携带</li></ol><p>​      针对验证码，我们可以用手机号来做key，这样的话就可以很好的保证key的唯一性</p><p>​      针对用户信息，我们同样可以使用手机号作为key，但是有一个问题需要考虑，就是此时我们已经不用session进行用户校验了，那么服务器在做登录拦截时使用什么作为校验凭证呢？最好的方案就是使用redis中用户信息的key，前端在访问时通过访问头携带key来访问，如果通过key能在redis中找到数据，说明用户已登录。那么这种情况下我们最好不要使用手机号作为key，这毕竟属于用户比较隐私的信息，我们在后台生成一个随机串token，用这个token来作为key就比较合适了。</p><h2 id="1-2-设计整体访问流程"><a href="#1-2-设计整体访问流程" class="headerlink" title="1.2 设计整体访问流程"></a>1.2 设计整体访问流程</h2><ol><li>发送短信验证码：将手机号作为key，生成的验证码作为value存到redis中，等登录的时候，再去校验验证码是否一致。</li><li>验证码登录、注册：将用户发过来的手机号和验证码进行校验，查询redis对应的验证码，检验是否和发送过来的验证码是否一致，如果一致查询是否存在用户信息，如果不存在则去创建用户信息，最后将该用户信息存入redis中，以token作为key，用户信息作为value。为了后续的校验登录状态。</li><li>校验登录状态：根据请求携带的token去redis查询对应的用户信息，如果没有则拦截，如果有则保存到Threadlocal中，并且放行。</li></ol><p>代码实现：</p><ul><li>UserController层：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送手机验证码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;code&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(<span class="meta">@RequestParam(&quot;phone&quot;)</span> String phone)</span> &#123;</span><br><span class="line">    <span class="comment">// 发送短信验证码并保存验证码</span></span><br><span class="line">    <span class="keyword">return</span> userService.sendCode(phone);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loginForm 登录参数，包含手机号、验证码；或者手机号、密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> LoginFormDTO loginForm)</span>&#123;</span><br><span class="line">    <span class="comment">// 实现登录功能</span></span><br><span class="line">    <span class="keyword">return</span> userService.login(loginForm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前登录的用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/me&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">me</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 通过ThreadLocal获取当前登录的用户信息并返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(UserHolder.getUser());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>新建 LoginInterceptor拦截器</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里stringRedisTemplate并不能直接在ioc容器中获取，因为本类并没有交给spring容器管理。但是MvcConfig会创造本类的对象，我们只需要通过构造器让MvcConfig传入即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate redisTemplate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        log.info(<span class="string">&quot;拦截到请求：&#123;&#125;&quot;</span>,uri);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//前端是通过请求头&quot;authorization&quot;携带token令牌的，我们需要先判断token令牌是否携带</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断token是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isBlank(token))&#123;</span><br><span class="line">            <span class="comment">//token为空直接返回</span></span><br><span class="line">            log.info(<span class="string">&quot;用户未登录，请求已被拦截：&#123;&#125;&quot;</span>,uri);</span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//组装key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.LOGIN_USER_KEY + token;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过key获取redis中的用户信息</span></span><br><span class="line">        Map&lt;Object, Object&gt; map = redisTemplate.opsForHash().entries(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(map == <span class="literal">null</span>||map.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//map为null说明令牌是瞎编的，直接返回</span></span><br><span class="line">            log.info(<span class="string">&quot;key不正确，请求已被拦截：&#123;&#125;&quot;</span>,uri);</span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将map集合转化为userDto对象</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存用户信息到ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//刷新token有效期，用户每访问一次服务器都需要刷新一次token有效期，避免用户在一直活跃的情况下令牌失效</span></span><br><span class="line">        redisTemplate.expire(key,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;用户已登录，id为&#123;&#125;&quot;</span>,user.getId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//在请求结束后销毁ThreadLocal中的用户信息</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>新建MvcConfig配置类，让拦截器生效</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//在创建对象时将stringRedisTemplate传给拦截器使用</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>(stringRedisTemplate))</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span></span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>UserService层</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phone</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="comment">//校验手机号是否正确</span></span><br><span class="line">        <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将验证码存放在redis中</span></span><br><span class="line">        <span class="comment">//这里使用String类型，key使用固定前缀+手机号码，值为验证码，并设置有效期为两分钟</span></span><br><span class="line">        redisTemplate.opsForValue().set(RedisConstants.LOGIN_CODE_KEY+phone,code,RedisConstants.LOGIN_CODE_TTL,TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送短信验证码成功</span></span><br><span class="line">        log.info(<span class="string">&quot;短信验证码发送成功：&#123;&#125;&quot;</span>,code);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录验证</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loginForm</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从redis中获取验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> redisTemplate.opsForValue().get(RedisConstants.LOGIN_CODE_KEY+phone);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断手机号是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(phone == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断验证码是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(code == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//校验手机号是否合法</span></span><br><span class="line">        <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断验证码是否正确</span></span><br><span class="line">        <span class="keyword">if</span>(!code.equals(loginForm.getCode()))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断用户是否存在</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;用户不存在，创建新用户：&#123;&#125;&quot;</span>,phone);</span><br><span class="line">            <span class="comment">//调用创建用户方法</span></span><br><span class="line">           user =  createNewUser(phone);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用redis保存用户信息</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里使用uuid随机生成redis的key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userToken</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里为了避免不同业务的key冲突，给key加上前缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userTokenKey</span> <span class="operator">=</span> RedisConstants.LOGIN_USER_KEY+userToken;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Hash类型存储用户信息，存储数据前，需要先将对象转换成map集合</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转换成map集合的过程中还需要做处理，因为StringRedisTemplate只能只针对字符串进行序列化，因此我们要将userDTO中每个 属性都转换成字符串</span></span><br><span class="line">        Map&lt;String, Object&gt; map = BeanUtil.beanToMap(</span><br><span class="line">                userDTO,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">                CopyOptions.create() <span class="comment">//自定义拷贝选项</span></span><br><span class="line">                        .ignoreNullValue() <span class="comment">//允许属性为null</span></span><br><span class="line">                        .setFieldValueEditor((fileName,fileValue)-&gt;fileValue.toString()) <span class="comment">//对属性值进行编辑，把所有属性值转换成字符串</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存数据到redis</span></span><br><span class="line">        redisTemplate.opsForHash().putAll(userTokenKey,map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置redis有效期</span></span><br><span class="line">        redisTemplate.expire(userTokenKey,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里需要将token信息返回给前端，前端需要token令牌来访问</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(userToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phone</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createNewUser</span><span class="params">(String phone)</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setNickName(SystemConstants.USER_NICK_NAME_PREFIX+RandomUtil.randomString(<span class="number">10</span>));</span><br><span class="line">        user.setPhone(phone);</span><br><span class="line">        save(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-解决状态登录刷新问题"><a href="#1-3-解决状态登录刷新问题" class="headerlink" title="1.3 解决状态登录刷新问题"></a>1.3 解决状态登录刷新问题</h2><p>初始方案思路总结：</p><p>在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的</p><p>优化方案</p><p>既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。</p><p>代码实现:</p><ul><li>新建一个RefreshTokenInterceptor拦截器，负责刷新令牌和保存用户信息等工作</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里stringRedisTemplate并不能直接在ioc容器中获取，因为本类并没有交给spring容器管理。但是MvcConfig会创造本类的对象，我们只需要通过构造器让MvcConfig传入即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate redisTemplate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        log.info(<span class="string">&quot;RefreshTokenInterceptor拦截到请求：&#123;&#125;&quot;</span>,uri);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//前端是通过请求头&quot;authorization&quot;携带token令牌的，我们需要先判断token令牌是否携带</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断token是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isBlank(token))&#123;</span><br><span class="line">            <span class="comment">//令牌不存在是不需要刷新的，直接放给下一个拦截器处理</span></span><br><span class="line">            log.info(<span class="string">&quot;令牌不存在，RefreshTokenInterceptor已放行请求：&#123;&#125;&quot;</span>,uri);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//组装key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.LOGIN_USER_KEY + token;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过key获取redis中的用户信息</span></span><br><span class="line">        Map&lt;Object, Object&gt; map = redisTemplate.opsForHash().entries(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(map == <span class="literal">null</span>||map.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//用户不存在的话也不需要刷新令牌，直接放行给下一个拦截器处理</span></span><br><span class="line">            log.info(<span class="string">&quot;令牌不存在，RefreshTokenInterceptor已放行请求：&#123;&#125;&quot;</span>,uri);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将map集合转化为userDto对象</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存用户信息到ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//刷新token有效期</span></span><br><span class="line">        redisTemplate.expire(key,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;用户已登录，RefreshTokenInterceptor已放行请求，用户为&#123;&#125;&quot;</span>,user.getId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//在请求结束后销毁ThreadLocal中的用户信息</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改LoginInterceptor的代码，因为很多工作我们已经在RefreshTokenInterceptor中做了，因此在LoginInterceptor我们只需要判断ThreadLocal中有没有用户信息即可</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        log.info(<span class="string">&quot;LoginInterceptor拦截到请求：&#123;&#125;&quot;</span>,uri);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(UserHolder.getUser() == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//说明用户未登录,直接拦截</span></span><br><span class="line">            log.info(<span class="string">&quot;用户未登录，LoginInterceptor未放行请求&#123;&#125;&quot;</span>,uri);</span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        log.info(<span class="string">&quot;LoginInterceptor已放行请求：&#123;&#125;&quot;</span>,uri);</span><br><span class="line">        <span class="comment">//说明用户已登录，直接放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>还需要在MvcConfig中修改拦截器配置</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 添加拦截器并排除不需要拦截的路径，即不用登录也可以访问的页面</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span></span><br><span class="line">                ).order(<span class="number">1</span>);<span class="comment">//</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Mongodb实现评论的功能"><a href="#Mongodb实现评论的功能" class="headerlink" title="Mongodb实现评论的功能"></a>Mongodb实现评论的功能</h1><p>为什么用mongdb存储内推信息的评论</p><p>1.文档存储模型：MongoDB是一个面向文档的数据库，这意味着它存储数据的方式更接近于JSON格</p><p>式。对于文章评论，这意味着可以将评论作为一个整体文档进行存储，而不需要像关系型数据库那样将其分解为多个表和字段。这种灵活性使得MongoDB在处理复杂的数据结构时更加方便。</p><p>2.动态模式：MongoDB不需要预先定义数据结构，可以存储不同格式的文档。这对于文章评论来说非常有用，因为不同的评论可能有不同的字段和格式。相比之下，MySQL等传统关系型数据库需要预先定义表结构，这可能会限制灵活性。</p><p>3.水平扩展：MongoDB的分布式架构使其能够轻松地在多个服务器之间进行数据分区和复制，从而实现水平扩展。这对于处理大量文章评论非常有用，因为可以很容易地增加更多的服务器来处理更高的负载。而MySQL等传统关系型数据库在扩展方面可能面临更多的挑战。</p><p>4.查询性能：MongoDB的查询性能通常优于传统关系型数据库，尤其是在处理大量数据时。MongoDB</p><p>使用BSON(Binary JSON)格式存储数据，这使得它能够更高效地执行复杂查询和索引操作。这对于</p><p>文章评论系统来说非常重要，因为它们通常需要支持高效的查询和搜索功能。</p><p>5.实时更新：MongoDB支持实时更新和插入操作，这使得它非常适合处理实时评论。相比之下，传</p><p>统关系型数据库可能需要在更新数据时执行更多的锁定和事务操作，这可能会影响性能：</p><p>​    当然，MongoDB也有其局限性，例如在处理复杂的事务和连接操作方面可能不如MySQL等传统关系型数据库。因此，在选择数据库时，需要根据具体需求和场景进行权衡。</p><ol><li><h2 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a><strong>表结构</strong></h2></li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ODI4YTUxODhjOWQyOTBkNDY1MWEzMTFmOGFhOTcwZGRfa1RoaGxpWUdrZml2N2h2R0d3YXNMZ0ZYbXhhR0VhWGtfVG9rZW46UkMzZWJ5cXZWb2FiOHd4RVd5VWNqNXlEbndnXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h2 id="2-使用技术SpringDataMongoDB"><a href="#2-使用技术SpringDataMongoDB" class="headerlink" title="2.使用技术SpringDataMongoDB"></a>2.<strong>使用技术SpringDataMongoDB</strong></h2><p>SpringData家族成员之一，用于操作MongoDB的持久层框架，封装了底层的mongodb-driver。</p><h2 id="3-搭建工程-pom-xml引入依赖："><a href="#3-搭建工程-pom-xml引入依赖：" class="headerlink" title="3.搭建工程,pom.xml引入依赖："></a>3.<strong>搭建工程,pom.xml引入依赖：</strong></h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>article<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-application-yml中配置mongodb"><a href="#4-application-yml中配置mongodb" class="headerlink" title="4.application.yml中配置mongodb"></a><strong>4.application.yml中配置mongodb</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">#数据源配置</span><br><span class="line">data:</span><br><span class="line">mongodb:</span><br><span class="line"># 主机地址</span><br><span class="line">host: <span class="number">192.168</span><span class="number">.40</span><span class="number">.141</span></span><br><span class="line"># 数据库</span><br><span class="line">database: articledb</span><br><span class="line"># 默认端口是<span class="number">27017</span></span><br><span class="line">port: <span class="number">27017</span></span><br><span class="line">#也可以使用uri连接</span><br><span class="line">#uri: mongodb:<span class="comment">//192.168.40.134:27017/</span></span><br></pre></td></tr></table></figure><h2 id="5-文章评论实体类的编写-根据数据库表生成"><a href="#5-文章评论实体类的编写-根据数据库表生成" class="headerlink" title="5.文章评论实体类的编写(根据数据库表生成)"></a><strong>5.文章评论实体类的编写(根据数据库表生成)</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.article.po;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.index.Indexed;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.mapping.Document;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.mapping.Field;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 文章评论实体类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//把一个java类声明为mongodb的文档，可以通过collection参数指定这个类对应的文档。</span></span><br><span class="line"><span class="comment">//@Document(collection=&quot;mongodb 对应 collection 名&quot;)</span></span><br><span class="line"><span class="comment">// 若未加 @Document ，该 bean save 到 mongo 的 comment collection</span></span><br><span class="line"><span class="comment">// 若添加 @Document ，则 save 到 comment collection</span></span><br><span class="line"><span class="meta">@Document(collection=&quot;comment&quot;)</span><span class="comment">//可以省略，如果省略，则默认使用类名小写映射集合</span></span><br><span class="line"><span class="comment">//复合索引</span></span><br><span class="line"><span class="comment">// @CompoundIndex( def = &quot;&#123;&#x27;userid&#x27;: 1, &#x27;nickname&#x27;: -1&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Comment</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"><span class="comment">//主键标识，该属性的值会自动对应mongodb的主键字段&quot;_id&quot;，如果该属性名就叫“id”,则该注解可以省略，否则必须写</span></span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="keyword">private</span> String id;<span class="comment">//主键</span></span><br><span class="line"><span class="comment">//该属性对应mongodb的字段的名字，如果一致，则无需该注解</span></span><br><span class="line"><span class="meta">@Field(&quot;content&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String content;<span class="comment">//吐槽内容</span></span><br><span class="line"><span class="keyword">private</span> Date publishtime;<span class="comment">//发布日期</span></span><br><span class="line"><span class="comment">//添加了一个单字段的索引</span></span><br><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">private</span> String userid;<span class="comment">//发布人ID</span></span><br><span class="line"><span class="keyword">private</span> String nickname;<span class="comment">//昵称</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime createdatetime;<span class="comment">//评论的日期时间</span></span><br><span class="line"><span class="keyword">private</span> Integer likenum;<span class="comment">//点赞数</span></span><br><span class="line"><span class="keyword">private</span> Integer replynum;<span class="comment">//回复数</span></span><br><span class="line"><span class="keyword">private</span> String state;<span class="comment">//状态</span></span><br><span class="line"><span class="keyword">private</span> String parentid;<span class="comment">//上级ID</span></span><br><span class="line"><span class="keyword">private</span> String articleid;</span><br><span class="line"><span class="comment">//getter and setter.....</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.content = content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Date <span class="title function_">getPublishtime</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> publishtime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPublishtime</span><span class="params">(Date publishtime)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.publishtime = publishtime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserid</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> userid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserid</span><span class="params">(String userid)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.userid = userid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getNickname</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nickname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNickname</span><span class="params">(String nickname)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> LocalDateTime <span class="title function_">getCreatedatetime</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createdatetime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCreatedatetime</span><span class="params">(LocalDateTime createdatetime)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.createdatetime = createdatetime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">getLikenum</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> likenum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLikenum</span><span class="params">(Integer likenum)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.likenum = likenum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">getReplynum</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> replynum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setReplynum</span><span class="params">(Integer replynum)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.replynum = replynum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.state = state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getParentid</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> parentid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParentid</span><span class="params">(String parentid)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.parentid = parentid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getArticleid</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> articleid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setArticleid</span><span class="params">(String articleid)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.articleid = articleid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Comment&#123;&quot;</span> +</span><br><span class="line"><span class="string">&quot;id=&#x27;&quot;</span> + id + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&quot;, content=&#x27;&quot;</span> + content + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&quot;, publishtime=&quot;</span> + publishtime +</span><br><span class="line"><span class="string">&quot;, userid=&#x27;&quot;</span> + userid + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&quot;, nickname=&#x27;&quot;</span> + nickname + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&quot;, createdatetime=&quot;</span> + createdatetime +</span><br><span class="line"><span class="string">&quot;, likenum=&quot;</span> + likenum +</span><br><span class="line"><span class="string">&quot;, replynum=&quot;</span> + replynum +</span><br><span class="line"><span class="string">&quot;, state=&#x27;&quot;</span> + state + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&quot;, parentid=&#x27;&quot;</span> + parentid + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&quot;, articleid=&#x27;&quot;</span> + articleid + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-为合适字段建立索引"><a href="#6-为合适字段建立索引" class="headerlink" title="6.为合适字段建立索引"></a>6.为合适字段建立索引</h2><p>索引可以大大提升查询效率，一般在查询字段上添加索引，索引的添加可以通过Mongo的命令来添加，也可以在Java的实体类中通过注解添加。</p><p>1）单字段索引注解@Indexed</p><p>org.springframework.data.mongodb.core.index.Indexed.class</p><p>声明该字段需要索引，建索引可以大大的提高查询效率。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">db.comment.createIndex(&#123;<span class="string">&quot;userid&quot;</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>2）复合索引注解@CompoundIndex</p><p>org.springframework.data.mongodb.core.index.CompoundIndex.class</p><p>复合索引的声明，建复合索引可以有效地提高多字段的查询效率。</p><p>Mongo命令参考：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">db.comment.createIndex(&#123;<span class="string">&quot;userid&quot;</span>:<span class="number">1</span>,<span class="string">&quot;nickname&quot;</span>:-<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="7-创建controller、sevice、mapper层"><a href="#7-创建controller、sevice、mapper层" class="headerlink" title="7.创建controller、sevice、mapper层"></a><strong>7.创建controller、sevice、mapper层</strong></h2><p>mapper层的CommentRepository要继承自MongoRepository并指定实体类和id</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.article.dao;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.article.po.Comment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Pageable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.repository.MongoRepository;</span><br><span class="line"><span class="comment">//评论的持久层接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommentRepository</span> <span class="keyword">extends</span> <span class="title class_">MongoRepository</span>&lt;Comment,String&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service里面的评论的增删改查方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.article.service;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.article.dao.CommentRepository;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.article.po.Comment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">//评论的业务层</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommentService</span> &#123;</span><br><span class="line"><span class="comment">//注入dao</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CommentRepository commentRepository;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 保存一个评论</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> comment</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveComment</span><span class="params">(Comment comment)</span>&#123;</span><br><span class="line"><span class="comment">//如果需要自定义主键，可以在这里指定主键；如果不指定主键，MongoDB会自动生成主键</span></span><br><span class="line"><span class="comment">//设置一些默认初始值。。。</span></span><br><span class="line"><span class="comment">//调用dao</span></span><br><span class="line">commentRepository.save(comment);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 更新评论</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> comment</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateComment</span><span class="params">(Comment comment)</span>&#123;</span><br><span class="line"><span class="comment">//调用dao</span></span><br><span class="line">commentRepository.save(comment);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据id删除评论</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteCommentById</span><span class="params">(String id)</span>&#123;</span><br><span class="line"><span class="comment">//调用dao</span></span><br><span class="line">commentRepository.deleteById(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查询所有评论</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Comment&gt; <span class="title function_">findCommentList</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//调用dao</span></span><br><span class="line"><span class="keyword">return</span> commentRepository.findAll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据id查询评论</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Comment <span class="title function_">findCommentById</span><span class="params">(String id)</span>&#123;</span><br><span class="line"><span class="comment">//调用dao</span></span><br><span class="line"><span class="keyword">return</span> commentRepository.findById(id).get();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-根据上级ID查询内推评论的分页列表"><a href="#8-根据上级ID查询内推评论的分页列表" class="headerlink" title="8.根据上级ID查询内推评论的分页列表"></a><strong>8.根据上级ID查询内推评论的分页列表</strong></h2><ol><li><h3 id="CommentRepository新增方法定义"><a href="#CommentRepository新增方法定义" class="headerlink" title="CommentRepository新增方法定义"></a>CommentRepository新增方法定义</h3></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据父id，查询子评论的分页列表</span></span><br><span class="line">Page&lt;Comment&gt; <span class="title function_">findByParentid</span><span class="params">(String parentid, Pageable pageable)</span>;</span><br></pre></td></tr></table></figure><ol><li><h3 id="CommentService新增方法"><a href="#CommentService新增方法" class="headerlink" title="CommentService新增方法"></a>CommentService新增方法</h3></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据父id查询分页列表</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> parentid</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> page</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> size</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;Comment&gt; <span class="title function_">findCommentListPageByParentid</span><span class="params">(String parentid,<span class="type">int</span> page ,<span class="type">int</span> size)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> commentRepository.findByParentid(parentid, PageRequest.of(page-<span class="number">1</span>,size));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-MongoTemplate实现评论点赞"><a href="#9-MongoTemplate实现评论点赞" class="headerlink" title="9.MongoTemplate实现评论点赞"></a><strong>9.MongoTemplate实现评论点赞</strong></h2><p>我们一开始用的是根据id查出来评论的点赞数，然后+1，但是后面觉得这么做效率太低了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 点赞-效率低</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateCommentThumbupToIncrementingOld</span><span class="params">(String id)</span>&#123;</span><br><span class="line"><span class="type">Comment</span> <span class="variable">comment</span> <span class="operator">=</span> CommentRepository.findById(id).get();</span><br><span class="line">comment.setLikenum(comment.getLikenum()+<span class="number">1</span>);</span><br><span class="line">CommentRepository.save(comment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以后面用MongoTemplate类来实现对某列的操作从而进行了优化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 点赞数+1</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateCommentLikenum</span><span class="params">(String id)</span>&#123;</span><br><span class="line"><span class="comment">//查询对象</span></span><br><span class="line">Query query=Query.query(Criteria.where(<span class="string">&quot;_id&quot;</span>).is(id));</span><br><span class="line"><span class="comment">//更新对象</span></span><br><span class="line">Update update=<span class="keyword">new</span> <span class="title class_">Update</span>();</span><br><span class="line"><span class="comment">//局部更新，相当于$set</span></span><br><span class="line"><span class="comment">// update.set(key,value)</span></span><br><span class="line"><span class="comment">//递增$inc</span></span><br><span class="line"><span class="comment">// update.inc(&quot;likenum&quot;,1);</span></span><br><span class="line">update.inc(<span class="string">&quot;likenum&quot;</span>);</span><br><span class="line"><span class="comment">//参数1：查询对象</span></span><br><span class="line"><span class="comment">//参数2：更新对象</span></span><br><span class="line"><span class="comment">//参数3：集合的名字或实体类的类型Comment.class</span></span><br><span class="line">mongoTemplate.updateFirst(query,update,<span class="string">&quot;comment&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一个版本</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户点赞与取消点赞评论根据评论id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> commentId 被点赞评论id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isThumbup true : 点赞 ； false : 取消点赞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">thumbup</span><span class="params">(String commentId, Boolean isThumbup)</span> &#123;</span><br><span class="line">        <span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Query</span>(Criteria.where(<span class="string">&quot;cid&quot;</span>).is(commentId)); <span class="comment">//设置修改条件</span></span><br><span class="line">        <span class="type">Update</span> <span class="variable">update</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Update</span>();</span><br><span class="line">        <span class="keyword">if</span>(isThumbup)&#123; <span class="comment">//点赞操作</span></span><br><span class="line">            update.inc(<span class="string">&quot;thumbup&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//取消点赞操作</span></span><br><span class="line">            update.inc(<span class="string">&quot;thumbup&quot;</span>,-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mongoTemplate.updateFirst(query,update,<span class="string">&quot;comment&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="印象最深-解决深分页问题"><a href="#印象最深-解决深分页问题" class="headerlink" title="印象最深-解决深分页问题"></a>印象最深-解决深分页问题</h1><p>先说一下背景吧:遇到的问题:因为我们用的是Navicat模拟了十万的假数据，数据量比较大，把数据录入MySQL表之后，在前后端联调时发现了翻页越到后面显示的越慢，起初不知道深度分页这个问题，以为只是网络的原因，就一直搁置着这个问题，但是心里总是感觉不得劲，后来我在刷抖音时刚好刷到有大佬聊这个问题，于是我就尝试在我们的系统上进行了修改，最后解决了这个问题，虽然说这个只是一个小优化，但是解了我心里的一个结，所以我对这个确实印象深刻。</p><p>​    然后我说一下什么是深分页吧，深分页就是 mysql的limit关键字 ，它需要设置偏移量和它查询的条数进行分页，如果limit的偏移量数值设置的比较大，它还要扫描偏移量的全部数据然后舍弃掉。比如 limit 1000 10,它需要扫描1010条数据并且丢弃掉前面的1000条，只返回最后的10条，了解到它的解决方法，</p><ul><li>首先是可以设置避免直接查询太深的页码，让偏移量少一点，就是不设置跳转的功能，但是我觉得这种可能会减少用户的体验感。</li></ul><p>所以就想着从sql上做优化，上网搜索了一下，主要有两种方法</p><ul><li>一种就是要记录上一次查询到哪了，这一次就筛选掉之前的数据，减少limit的丢弃量，那么知道上次分页的最后一个数据的id并且id是自增的，那就可以根据id筛选掉不需要的数据，偏移量直接不写，只需要具体的条数就可以了，比如：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select from table where id&gt;? and 其他条件 limit ?</span><br></pre></td></tr></table></figure><ul><li>第二种就是id不是自增的，就利用子查询，只查询id作为外部查询的id in的条件，通过索引覆盖减少回表，从而尽可能提升查询效率 比如：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select from table where id <span class="title function_">in</span> <span class="params">(select id from (select id from table where 条件 limit ?,?)</span>t)</span><br></pre></td></tr></table></figure><p>我们这个项目用的是第二种方式。</p><h1 id="采用CompletableFuture异步编程实现数据汇总"><a href="#采用CompletableFuture异步编程实现数据汇总" class="headerlink" title="采用CompletableFuture异步编程实现数据汇总"></a>采用<strong>CompletableFuture</strong>异步编程实现数据汇总</h1><p>传统的Future异步编程实现起来非常复杂，它需要实现FutureTask方法并实现Callable内部类，再结合Thread或者线程池的方式实现，获得返回值要调用FutureTask的get方法，他会阻塞后面的代码，但是如果后面的代码不依赖返回值的话，我们希望它们能以并行的方式去执行，那我们就能结合<strong>CompletableFuture去改造</strong></p><p>它提供了两种异步任务：</p><ul><li>runAsync(),方法执行任务是没有返回值的</li><li>supplyAsync()方法执行任务则支持返回值</li></ul><p>两种组合处理：</p><ul><li>anyOf返回跑的最快的那个future。最快的如果异常都玩完</li><li>allOf全部并行执行，如果需要获得返回值，需要配合thenApply,异常会抛出不影响其他任何任务</li></ul><p>异步回调方法：不会阻碍后面的任务执行</p><ul><li>whenComplete()没有返回值，且返回的CompletableFuture为任务结果，而非回调结果</li><li>handle()有返回值，且返回的CompletableFuture为回调结果</li></ul><p>上面两个方法出现异常不会中断throwable:参数会接收前面的任务的异常异常会通过get抛出到主线程</p><ul><li>链式处理：–出现异常后面的任务会中断处理任务中感知不到异常异常会通过get抛出到主线程</li></ul><ol><li>thenRun(Runnable runnable): 对异步任务的结果进行操作，不能传入参，也没有返回值</li><li>thenAccept(Consumer consumer):可传入参数</li><li>thenApply(Function function）:可传入参数，并返回结果</li></ol><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span><span class="keyword">throws</span> ExecutionException,InterruptedException&#123;</span><br><span class="line">CompletableFuture&lt;Integer&gt;future1 CompletableFuture.supplyAsync(()-&gt;<span class="number">15</span>);</span><br><span class="line">CompletableFuture&lt;Integer&gt;future2 CompletableFuture.supplyAsync(()-&gt;<span class="number">10</span>);</span><br><span class="line">CompletableFuture&lt;Integer&gt;allFutures CompletableFuture.allOf(future1,future2)</span><br><span class="line">thenApply(res -&gt;&#123;</span><br><span class="line"><span class="keyword">return</span> future1.join()+future2.join();</span><br><span class="line"><span class="comment">//TODO....</span></span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(allFutures.join());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看一下我采用CompletableFuture异步编程后的思路(简单展示思路，并非项目真实代码)</p><p>controller层</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/surveys&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SurveyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SurveyService surveyService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SurveyController</span><span class="params">(SurveyService surveyService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.surveyService = surveyService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/process&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">processSurveyConcurrently</span><span class="params">(<span class="meta">@RequestBody</span> SurveyData data,</span></span><br><span class="line"><span class="params">                                                            <span class="meta">@RequestParam</span> SurveyStatus newStatus)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> surveyService.processSurveyConcurrentlyAsync(data, newStatus);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service层</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SurveyService.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SurveyServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SurveyService</span> &#123;</span><br><span class="line">    <span class="comment">//先用一个mapper实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SurveyMapper surveyMapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SurveyServiceImpl</span><span class="params">(SurveyMapper surveyMapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.surveyMapper = surveyMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">saveSurveyDataAsync</span><span class="params">(SurveyData data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.runAsync(() -&gt; surveyMapper.saveSurveyData(data), executorService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">updateSurveyStatusAsync</span><span class="params">(String surveyId, SurveyStatus status)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.runAsync(() -&gt; surveyMapper.updateSurveyStatus(surveyId, status), executorService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;AnalysisResult&gt; <span class="title function_">analyzeSurveyResultsAsync</span><span class="params">(SurveyData data)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里只是一个示例，实际的数据处理更复杂</span></span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnalysisResult</span>();</span><br><span class="line">        &#125;, executorService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">processSurveyConcurrentlyAsync</span><span class="params">(SurveyData data, SurveyStatus newStatus)</span> &#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; saveFuture = saveSurveyDataAsync(data);</span><br><span class="line">        CompletableFuture&lt;AnalysisResult&gt; analyzeFuture = analyzeSurveyResultsAsync(data);</span><br><span class="line">        CompletableFuture&lt;Void&gt; updateFuture = updateSurveyStatusAsync(data.getSurveyId(), newStatus);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.allOf(saveFuture, analyzeFuture, updateFuture)</span><br><span class="line">            .thenRun(() -&gt; System.out.println(<span class="string">&quot;All operations completed successfully!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapper层</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SurveyMapper.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SurveyMapper</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">saveSurveyData</span><span class="params">(SurveyData data)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateSurveyStatus</span><span class="params">(String surveyId, SurveyStatus status)</span>;</span><br><span class="line">    SurveyData <span class="title function_">getSurveyDataById</span><span class="params">(String surveyId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于Spring-Task定时任务调度实现定期清理回访问卷数据"><a href="#基于Spring-Task定时任务调度实现定期清理回访问卷数据" class="headerlink" title="基于Spring Task定时任务调度实现定期清理回访问卷数据"></a>基于<strong>Spring Task</strong>定时任务调度实现定期清理回访问卷数据</h1><p>这个场景呢，也是我在开发学院科研项目时遇到的场景，主要呢就是实现两个功能，一是超时的问卷，二是每天凌晨触发一次清理一直处于未审核通过的问卷。</p><p>具体做法（涉及到项目内部，所以这里只展示一下大体实现）</p><p>首先呢，要在启动类上加上  @EnableScheduling  &#x2F;&#x2F;开启任务调度</p><p>然后创建一个定时任务类QuestionnaireTask ，并注入QuestionnaireMapper</p><h2 id="5-1-处理超时问卷"><a href="#5-1-处理超时问卷" class="headerlink" title="5.1. 处理超时问卷"></a>5.1. 处理超时问卷</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0 * * * * ? &quot;)</span><span class="comment">//每分钟触发一次</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processTimeoutQuestionnaire</span><span class="params">()</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;定时处理超时问卷,&#123;&#125;&quot;</span>, LocalDateTime.now());</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime .now().plusMinutes(-<span class="number">15</span>);</span><br><span class="line">    <span class="comment">//获取已超时的问卷</span></span><br><span class="line">    List&lt;questionnaires&gt; questionnaireList = QuestionnaireMapper.getByStatusAndQuestionnaireTimeLT(Questionnaires.COLLECT,time);</span><br><span class="line">    <span class="keyword">if</span> (questionnaireList!=<span class="literal">null</span>&amp;&amp;questionnaireList .size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (Questionnaires questionnaires: questionnaireList ) &#123;</span><br><span class="line">            <span class="comment">//问卷处理(此处为演示，具体逻辑在mapper层实现)</span></span><br><span class="line">            QuestionnaireMapper.update(questionnaires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-每天凌晨触发一次清理一直处于未发布状态的问卷"><a href="#5-2-每天凌晨触发一次清理一直处于未发布状态的问卷" class="headerlink" title="5.2 每天凌晨触发一次清理一直处于未发布状态的问卷"></a>5.2 每天凌晨触发一次清理一直处于未发布状态的问卷</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 1 * * ?&quot;)</span> <span class="comment">//每天凌晨一点触发一次</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processAuditQuestionnaires</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now().plusMinutes(-<span class="number">60</span>);</span><br><span class="line">    List&lt;Questionnaires&gt; questionnairesList = questionnaireMapper.getByStatusAndOrderTimeLT(Questionnaires.UNPUBLISH, time);</span><br><span class="line">    <span class="keyword">if</span> (questionnairesList !=<span class="literal">null</span>&amp;&amp;questionnairesList .size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (Questionnaires questionnaires : questionnairesList ) &#123;</span><br><span class="line">            <span class="comment">//演示</span></span><br><span class="line">            questionnaireMapper.delete(questionnaires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于SpringData-Elasticsearch操纵Elasticsearch的实现检索中药材sku信息、热销药材"><a href="#基于SpringData-Elasticsearch操纵Elasticsearch的实现检索中药材sku信息、热销药材" class="headerlink" title="基于SpringData Elasticsearch操纵Elasticsearch的实现检索中药材sku信息、热销药材"></a>基于<strong>SpringData</strong> <strong>Elasticsearch</strong>操纵<strong>Elasticsearch</strong>的实现检索中药材<strong>sku</strong>信息、热销药材</h1><p>   此项目是微服务项目，不同的功能分成了不同的模块，通过feign相互调用，下面只针对service-search模块做介绍，远程调用其他模块不做详细介绍。（search模块还完成上下架的功能，此处不做具体介绍，在rabbitMQ功能使用时具体介绍）</p><p>先在service-search引入<strong>SpringData</strong> <strong>Elasticsearch</strong> 的依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</span><span class="comment">//取消数据源自动配置</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceSearchApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ServiceSearchApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>application-dev.yml中进行配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">elasticsearch:</span><br><span class="line">  rest:</span><br><span class="line">    uris: http:<span class="comment">//localhost:9201</span></span><br></pre></td></tr></table></figure><p>controller层</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;api/search/sku&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SkuApiController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SkuService skuService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;inner/findHotSkuList&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;SkuEs&gt; <span class="title function_">findHotSkuList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> skuService.findHotSkuList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;&#123;page&#125;/&#123;limit&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">listSku</span><span class="params">(<span class="meta">@PathVariable(&quot;page&quot;)</span> Integer page, <span class="meta">@PathVariable(&quot;limit&quot;)</span> Integer limit, SkuEsQueryVo skuEsQueryVo)</span> &#123;</span><br><span class="line">    <span class="comment">//0代表第一页</span></span><br><span class="line">    <span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> PageRequest.of(page - <span class="number">1</span>, limit);</span><br><span class="line">    Page&lt;SkuEs&gt; pageModel = skuService.search(pageable, skuEsQueryVo);</span><br><span class="line">    <span class="keyword">return</span>  Result.ok(pageModel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新热度</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;inner/incrHotScore/&#123;skuId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">incrHotScore</span><span class="params">(<span class="meta">@PathVariable(&quot;skuId&quot;)</span> Long skuId)</span>&#123;</span><br><span class="line">    skuService.incrHotScore(skuId);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service层</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SkuServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SkuService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SkuRepository skuRepository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ProductFeignClient productFeignClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ActivityFeignClient activityFeignClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取热度高的中药</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;SkuEs&gt; <span class="title function_">findHotSkuList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> PageRequest.of(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    Page&lt;SkuEs&gt; pageModel = skuRepository.findByOrderByHotScoreDesc(pageable);</span><br><span class="line">    List&lt;SkuEs&gt; skuEsList = pageModel.getContent();</span><br><span class="line">    <span class="keyword">return</span> skuEsList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询中药</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;SkuEs&gt; <span class="title function_">search</span><span class="params">(Pageable pageable, SkuEsQueryVo skuEsQueryVo)</span> &#123;</span><br><span class="line">    Page&lt;SkuEs&gt; pageModel=<span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//向vo里面设置wareId</span></span><br><span class="line">    skuEsQueryVo.setWareId(AuthContextHolder.getWareId());</span><br><span class="line">    <span class="comment">//根据springData命名规范定义方法查询</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keyword</span> <span class="operator">=</span> skuEsQueryVo.getKeyword();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(keyword))&#123;</span><br><span class="line">        pageModel=skuRepository.findByCategoryIdAndWareId(skuEsQueryVo.getCategoryId(),skuEsQueryVo.getWareId(),pageable);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pageModel=skuRepository.findByKeywordAndWareId(skuEsQueryVo.getKeyword(),skuEsQueryVo.getWareId(),pageable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询中药参加的优惠活动</span></span><br><span class="line">    List&lt;SkuEs&gt; skuEsList = pageModel.getContent();</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(skuEsList))&#123;</span><br><span class="line">        List&lt;Long&gt; skuIdList = skuEsList.stream().map(SkuEs::getId).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">//远程调用service-activity</span></span><br><span class="line">        <span class="comment">//返回Map&lt;Long,List&lt;String&gt;&gt;</span></span><br><span class="line">        Map&lt;Long,List&lt;String&gt;&gt; skuIdToRuleListMap=activityFeignClient.findActivity(skuIdList);</span><br><span class="line">        <span class="comment">//封装获取数据到skuEs里面ruleList</span></span><br><span class="line">        <span class="keyword">if</span> (skuIdToRuleListMap!=<span class="literal">null</span>)&#123;</span><br><span class="line">            skuEsList.forEach(skuEs -&gt; &#123;</span><br><span class="line">                skuEs.setRuleList(skuIdToRuleListMap.get(skuEs.getId()));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pageModel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新中药热度</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incrHotScore</span><span class="params">(Long skuId)</span> &#123;</span><br><span class="line">    String key=<span class="string">&quot;hotScore&quot;</span>;</span><br><span class="line">    <span class="type">Double</span> <span class="variable">hotScore</span> <span class="operator">=</span> redisTemplate.opsForZSet().incrementScore(key, <span class="string">&quot;skuId&quot;</span> + skuId, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//规则</span></span><br><span class="line">    <span class="keyword">if</span> (hotScore%<span class="number">10</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        Optional&lt;SkuEs&gt; optionalSkuEs = skuRepository.findById(skuId);</span><br><span class="line">        SkuEs skuEs=optionalSkuEs.get();</span><br><span class="line">        skuEs.setHotScore(Math.round(hotScore));</span><br><span class="line">        skuRepository.save(skuEs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>repository层</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SkuRepository</span> <span class="keyword">extends</span> <span class="title class_">ElasticsearchRepository</span>&lt;SkuEs,Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Page&lt;SkuEs&gt; <span class="title function_">findByOrderByHotScoreDesc</span><span class="params">(Pageable pageable)</span>;</span><br><span class="line"></span><br><span class="line">    Page&lt;SkuEs&gt; <span class="title function_">findByCategoryIdAndWareId</span><span class="params">(Long categoryId, Long wareId, Pageable pageable)</span>;</span><br><span class="line"></span><br><span class="line">    Page&lt;SkuEs&gt; <span class="title function_">findByKeywordAndWareId</span><span class="params">(String keyword, Long wareId, Pageable pageable)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于Redisson的分布式锁生成订单，锁定库存"><a href="#基于Redisson的分布式锁生成订单，锁定库存" class="headerlink" title="基于Redisson的分布式锁生成订单，锁定库存"></a>基于<strong>Redisson<strong><strong>的</strong></strong>分布式锁</strong>生成订单，锁定库存</h1><p>因为在分布式环境下，多个服务不能靠普通锁进行锁定，索引就用到了Redission分布式锁，</p><p>Redisson分布式锁解决分布式环境下并发安全问题，完全实现了juc的功能，不仅有锁，还都是分布式锁</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YTBlZWNhMmY4YmI5MjIwNDE1NTFhNTZkMzVlZjg0YmFfaDl1cGE3UzVkbHpqcndPQTNOTkJ4Q2ZwNjhCSVNZSW1fVG9rZW46R3dFVWJQbWNWb2t2UEN4TGJDUWNncHh6bmljXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">假设此时两个用户的请求同时到来，但是落在了不同的机器上，那么这两个请求是可以同时执行了，还是会出现库存超卖的问题。为什么呢？因为上图中的两个A系统，运行在两个不同的JVM里面，他们加的锁只对属于自己JVM里面的线程有效，对于其他JVM的线程是无效的。因此，这里的问题是Java提供的原生锁机制在多机部署场景下失效了这是因为两台机器加的锁不是同一个锁(两个锁在不同的JVM里面)。那么，我们只要保证两台机器加的锁是同一个锁，问题不就解决了吗？此时，就该分布式锁登场了，分布式锁的思路是：在整个系统提供一个全局、唯一的获取锁的“东西”，然后每个系统在需要加锁时，都去问这个“东西”拿到一把锁，这样不同的系统拿到的就可以认为是同一把锁。至于这个“东西”，可以是Redis、Zookeeper，也可以是数据库</span><br></pre></td></tr></table></figure><p>Redisson分布式锁解决分布式环境下并发安全问题，完全实现了juc的功能，不仅有锁，还都是分布式锁</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YTJmZGU2YWViN2FmY2VmM2FjYjAxYzdlNmYyMzk5ODJfN3FKUHlpenJ0OVMzMk9PQ3cxRmhTVFpyWmxvUEhsTVNfVG9rZW46TksyUmJCTkt0b2JRQ2p4ODJpN2NVZ0lYbk5kXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p>步骤</p><ol><li>添加Redisson配置类</li></ol><p><strong>service-util模块添加Redisson配置类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;spring.redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String addresses;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="number">3000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">connectionPoolSize</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionMinimumIdleSize=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">pingConnectionInterval</span> <span class="operator">=</span> <span class="number">60000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">ADDRESS_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;redis://&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动装配</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    RedissonClient <span class="title function_">redissonSingle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">//  判断redis 的host是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(host))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;host is  empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  配置host，port等参数</span></span><br><span class="line">        <span class="type">SingleServerConfig</span> <span class="variable">serverConfig</span> <span class="operator">=</span> config.useSingleServer()</span><br><span class="line">                <span class="comment">//redis://127.0.0.1:7181</span></span><br><span class="line">                .setAddress(ADDRESS_PREFIX + <span class="built_in">this</span>.host + <span class="string">&quot;:&quot;</span> + port)</span><br><span class="line">                .setTimeout(<span class="built_in">this</span>.timeout)</span><br><span class="line">                .setPingConnectionInterval(pingConnectionInterval)</span><br><span class="line">                .setConnectionPoolSize(<span class="built_in">this</span>.connectionPoolSize)</span><br><span class="line">                .setConnectionMinimumIdleSize(<span class="built_in">this</span>.connectionMinimumIdleSize);</span><br><span class="line">        <span class="comment">//  判断进入redis 是否密码</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(<span class="built_in">this</span>.password)) &#123;</span><br><span class="line">            serverConfig.setPassword(<span class="built_in">this</span>.password);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// RedissonClient redisson = Redisson.create(config);</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>添加OrderApiController方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(value = &quot;Order管理&quot;, tags = &quot;Order管理&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/api/order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderApiController</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Resource</span></span><br><span class="line">        <span class="keyword">private</span> OrderInfoService orderService;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@ApiOperation(&quot;确认订单&quot;)</span></span><br><span class="line">        <span class="meta">@GetMapping(&quot;auth/confirmOrder&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> Result <span class="title function_">confirm</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.ok(orderService.confirmOrder());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@ApiOperation(&quot;生成订单&quot;)</span></span><br><span class="line">        <span class="meta">@PostMapping(&quot;auth/submitOrder&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> Result <span class="title function_">submitOrder</span><span class="params">(<span class="meta">@RequestBody</span> OrderSubmitVo orderParamVo, HttpServletRequest request)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取到用户Id</span></span><br><span class="line">                <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> AuthContextHolder.getUserId();</span><br><span class="line">                <span class="keyword">return</span> Result.ok(orderService.submitOrder(orderParamVo));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ApiOperation(&quot;获取订单详情&quot;)</span></span><br><span class="line">        <span class="meta">@GetMapping(&quot;auth/getOrderInfoById/&#123;orderId&#125;&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> Result <span class="title function_">getOrderInfoById</span><span class="params">(<span class="meta">@PathVariable(&quot;orderId&quot;)</span> Long orderId)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Result.ok(orderService.getOrderInfoById(orderId));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>添加OrderInfoService方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderInfoService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;OrderInfo&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 确认订单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    OrderConfirmVo <span class="title function_">confirmOrder</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成订单</span></span><br><span class="line">    Long <span class="title function_">submitOrder</span><span class="params">(OrderSubmitVo orderParamVo)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//订单详情</span></span><br><span class="line">    OrderInfo <span class="title function_">getOrderInfoById</span><span class="params">(Long orderId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>添加OrderInfoServiceImpl方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">submitOrder</span><span class="params">(OrderSubmitVo orderSubmitVo)</span> &#123;</span><br><span class="line">        <span class="comment">//添加当前用户</span></span><br><span class="line">        orderSubmitVo.setUserId(AuthContextHolder.getUserId());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.防重：redis</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">orderNo</span> <span class="operator">=</span> orderSubmitVo.getOrderNo();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(orderNo))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">YYJJException</span>(ResultCodeEnum.ILLEGAL_REQUEST);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if(redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1]) then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (Boolean)redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(RedisConst.ORDER_REPEAT + orderNo), orderNo);</span><br><span class="line">        <span class="comment">//                if (!flag)&#123;</span></span><br><span class="line">        <span class="comment">//                        throw new GmallException(ResultCodeEnum.REPEAT_SUBMIT);</span></span><br><span class="line">        <span class="comment">//                &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.验库存并锁定库存</span></span><br><span class="line">        <span class="comment">// List&lt;Long&gt; skuIdList = orderSubmitVo.getSkuIdList();</span></span><br><span class="line">        List&lt;CartInfo&gt; cartInfoList = cartFeignClient.getCartCheckedList(AuthContextHolder.getUserId());</span><br><span class="line">        List&lt;CartInfo&gt; commonSkuList = cartInfoList.stream().filter(cartInfo -&gt; cartInfo.getSkuType() == SkuType.COMMON.getCode()).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(commonSkuList)) &#123;</span><br><span class="line">                List&lt;SkuStockLockVo&gt; commonStockLockVoList = commonSkuList.stream().map(item -&gt; &#123;</span><br><span class="line">                        <span class="type">SkuStockLockVo</span> <span class="variable">skuStockLockVo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkuStockLockVo</span>();</span><br><span class="line">                        skuStockLockVo.setSkuId(item.getSkuId());</span><br><span class="line">                        skuStockLockVo.setSkuNum(item.getSkuNum());</span><br><span class="line">                        <span class="keyword">return</span> skuStockLockVo;</span><br><span class="line">                &#125;).collect(Collectors.toList());</span><br><span class="line">                <span class="comment">//是否锁定</span></span><br><span class="line">                <span class="type">Boolean</span> <span class="variable">isLockCommon</span> <span class="operator">=</span> productFeignClient.checkAndLock(commonStockLockVoList, orderSubmitVo.getOrderNo());</span><br><span class="line">                <span class="keyword">if</span> (!isLockCommon)&#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">YYJJException</span>(ResultCodeEnum.ORDER_STOCK_FALL);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;CartInfo&gt; seckillSkuList = cartInfoList.stream().filter(cartInfo -&gt; cartInfo.getSkuType() == SkuType.SECKILL.getCode()).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(seckillSkuList)) &#123;</span><br><span class="line">                List&lt;SkuStockLockVo&gt; seckillStockLockVoList = seckillSkuList.stream().map(item -&gt; &#123;</span><br><span class="line">                        <span class="type">SkuStockLockVo</span> <span class="variable">skuStockLockVo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkuStockLockVo</span>();</span><br><span class="line">                        skuStockLockVo.setSkuId(item.getSkuId());</span><br><span class="line">                        skuStockLockVo.setSkuNum(item.getSkuNum());</span><br><span class="line">                        <span class="keyword">return</span> skuStockLockVo;</span><br><span class="line">                &#125;).collect(Collectors.toList());</span><br><span class="line">                <span class="comment">//是否锁定</span></span><br><span class="line">                <span class="type">Boolean</span> <span class="variable">isLockSeckill</span> <span class="operator">=</span> seckillFeignClient.checkAndMinusStock(seckillStockLockVoList, orderSubmitVo.getOrderNo());</span><br><span class="line">                <span class="keyword">if</span> (!isLockSeckill)&#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">YYJJException</span>(ResultCodeEnum.ORDER_STOCK_FALL);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.下单</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">orderId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                orderId = <span class="built_in">this</span>.saveOrder(orderSubmitVo, cartInfoList);</span><br><span class="line">        </span><br><span class="line">                <span class="comment">// 订单正常创建成功的情况下，发送消息定时关单</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">normalOrderOvertime</span> <span class="operator">=</span> orderSetService.getNormalOrderOvertime();</span><br><span class="line">                <span class="comment">//rabbitService.sendDelayMessage(MqConst.EXCHANGE_ORDER_DIRECT, MqConst.ROUTING_CANCEL_ORDER, orderSubmitVo.getOrderNo(), normalOrderOvertime);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">// 出现异常立马解锁库存 标记订单时无效订单</span></span><br><span class="line">                <span class="comment">//rabbitService.sendMessage(MqConst.EXCHANGE_ORDER_DIRECT, MqConst.ROUTING_ROLLBACK_STOCK, orderSubmitVo.getOrderNo());</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">GmallException</span>(ResultCodeEnum.CREATE_ORDER_FAIL);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5.异步删除购物车中对应的记录。不应该影响下单的整体流程</span></span><br><span class="line">        rabbitService.sendMessage(MqConst.EXCHANGE_ORDER_DIRECT, MqConst.ROUTING_DELETE_CART, orderSubmitVo.getUserId())</span><br><span class="line">        <span class="keyword">return</span> orderId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;Exception.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">saveOrder</span><span class="params">(OrderSubmitVo orderSubmitVo, List&lt;CartInfo&gt; cartInfoList)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> AuthContextHolder.getUserId();</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isEmpty(cartInfoList)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">YYJJException</span>(ResultCodeEnum.DATA_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LeaderAddressVo</span> <span class="variable">leaderAddressVo</span> <span class="operator">=</span> userFeignClient.getLeaderAddressVoByUserId(userId);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == leaderAddressVo) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">YYJJException</span>(ResultCodeEnum.DATA_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算购物项分摊的优惠减少金额，按比例分摊，退款时按实际支付金额退款</span></span><br><span class="line">        Map&lt;String, BigDecimal&gt; activitySplitAmountMap = <span class="built_in">this</span>.computeActivitySplitAmount(cartInfoList);</span><br><span class="line">        Map&lt;String, BigDecimal&gt; couponInfoSplitAmountMap = <span class="built_in">this</span>.computeCouponInfoSplitAmount(cartInfoList, orderSubmitVo.getCouponId());</span><br><span class="line">        <span class="comment">//sku对应的订单明细</span></span><br><span class="line">        List&lt;OrderItem&gt; orderItemList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 保存订单明细</span></span><br><span class="line">        <span class="keyword">for</span> (CartInfo cartInfo : cartInfoList) &#123;</span><br><span class="line">                <span class="type">OrderItem</span> <span class="variable">orderItem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderItem</span>();</span><br><span class="line">                orderItem.setId(<span class="literal">null</span>);</span><br><span class="line">                orderItem.setCategoryId(cartInfo.getCategoryId());</span><br><span class="line">                <span class="keyword">if</span>(cartInfo.getSkuType() == SkuType.COMMON.getCode()) &#123;</span><br><span class="line">                        orderItem.setSkuType(SkuType.COMMON);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        orderItem.setSkuType(SkuType.SECKILL);</span><br><span class="line">                &#125;</span><br><span class="line">                orderItem.setSkuId(cartInfo.getSkuId());</span><br><span class="line">                orderItem.setSkuName(cartInfo.getSkuName());</span><br><span class="line">                orderItem.setSkuPrice(cartInfo.getCartPrice());</span><br><span class="line">                orderItem.setImgUrl(cartInfo.getImgUrl());</span><br><span class="line">                orderItem.setSkuNum(cartInfo.getSkuNum());</span><br><span class="line">                orderItem.setLeaderId(orderSubmitVo.getLeaderId());</span><br><span class="line"></span><br><span class="line">                <span class="comment">//促销活动分摊金额</span></span><br><span class="line">                <span class="type">BigDecimal</span> <span class="variable">splitActivityAmount</span> <span class="operator">=</span> activitySplitAmountMap.get(<span class="string">&quot;activity:&quot;</span>+orderItem.getSkuId());</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">null</span> == splitActivityAmount) &#123;</span><br><span class="line">                        splitActivityAmount = <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                orderItem.setSplitActivityAmount(splitActivityAmount);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//优惠券分摊金额</span></span><br><span class="line">                <span class="type">BigDecimal</span> <span class="variable">splitCouponAmount</span> <span class="operator">=</span> couponInfoSplitAmountMap.get(<span class="string">&quot;coupon:&quot;</span>+orderItem.getSkuId());</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">null</span> == splitCouponAmount) &#123;</span><br><span class="line">                        splitCouponAmount = <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                orderItem.setSplitCouponAmount(splitCouponAmount);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//优惠后的总金额</span></span><br><span class="line">                <span class="type">BigDecimal</span> <span class="variable">skuTotalAmount</span> <span class="operator">=</span> orderItem.getSkuPrice().multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(orderItem.getSkuNum()));</span><br><span class="line">                <span class="type">BigDecimal</span> <span class="variable">splitTotalAmount</span> <span class="operator">=</span> skuTotalAmount.subtract(splitActivityAmount).subtract(splitCouponAmount);</span><br><span class="line">                orderItem.setSplitTotalAmount(splitTotalAmount);</span><br><span class="line">                orderItemList.add(orderItem);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存订单</span></span><br><span class="line">        <span class="type">OrderInfo</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderInfo</span>();</span><br><span class="line">        order.setUserId(userId);</span><br><span class="line"><span class="comment">//                private String nickName;</span></span><br><span class="line">        order.setOrderNo(orderSubmitVo.getOrderNo());</span><br><span class="line">        order.setOrderStatus(OrderStatus.UNPAID);</span><br><span class="line">        order.setProcessStatus(ProcessStatus.UNPAID);</span><br><span class="line">        order.setCouponId(orderSubmitVo.getCouponId());</span><br><span class="line">        order.setLeaderId(orderSubmitVo.getLeaderId());</span><br><span class="line">        order.setLeaderName(leaderAddressVo.getLeaderName());</span><br><span class="line">        order.setLeaderPhone(leaderAddressVo.getLeaderPhone());</span><br><span class="line">        order.setTakeName(leaderAddressVo.getTakeName());</span><br><span class="line">        order.setReceiverName(orderSubmitVo.getReceiverName());</span><br><span class="line">        order.setReceiverPhone(orderSubmitVo.getReceiverPhone());</span><br><span class="line">        order.setReceiverProvince(leaderAddressVo.getProvince());</span><br><span class="line">        order.setReceiverCity(leaderAddressVo.getCity());</span><br><span class="line">        order.setReceiverDistrict(leaderAddressVo.getDistrict());</span><br><span class="line">        order.setReceiverAddress(leaderAddressVo.getDetailAddress());</span><br><span class="line">        order.setWareId(cartInfoList.get(<span class="number">0</span>).getWareId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算订单金额</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">originalTotalAmount</span> <span class="operator">=</span> <span class="built_in">this</span>.computeTotalAmount(cartInfoList);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">activityAmount</span> <span class="operator">=</span> activitySplitAmountMap.get(<span class="string">&quot;activity:total&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == activityAmount) activityAmount = <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">couponAmount</span> <span class="operator">=</span> couponInfoSplitAmountMap.get(<span class="string">&quot;coupon:total&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == couponAmount) couponAmount = <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">totalAmount</span> <span class="operator">=</span> originalTotalAmount.subtract(activityAmount).subtract(couponAmount);</span><br><span class="line">        <span class="comment">//计算订单金额</span></span><br><span class="line">        order.setOriginalTotalAmount(originalTotalAmount);</span><br><span class="line">        order.setActivityAmount(activityAmount);</span><br><span class="line">        order.setCouponAmount(couponAmount);</span><br><span class="line">        order.setTotalAmount(totalAmount);</span><br><span class="line">        </span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">profitRate</span> <span class="operator">=</span> orderSetService.getProfitRate();</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">commissionAmount</span> <span class="operator">=</span> order.getTotalAmount().multiply(profitRate);</span><br><span class="line">        order.setCommissionAmount(commissionAmount);</span><br><span class="line"></span><br><span class="line">        orderInfoMapper.insert(order);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存订单项</span></span><br><span class="line">        <span class="keyword">for</span>(OrderItem orderItem : orderItemList) &#123;</span><br><span class="line">                orderItem.setOrderId(order.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        orderItemService.saveBatch(orderItemList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新优惠券使用状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> != order.getCouponId()) &#123;</span><br><span class="line">                activityFeignClient.updateCouponInfoUseStatus(order.getCouponId(), userId, order.getId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下单成功，记录用户商品购买个数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">orderSkuKey</span> <span class="operator">=</span> RedisConst.ORDER_SKU_MAP + orderSubmitVo.getUserId();</span><br><span class="line">        BoundHashOperations&lt;String, String, Integer&gt; hashOperations = redisTemplate.boundHashOps(orderSkuKey);</span><br><span class="line">        cartInfoList.forEach(cartInfo -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(hashOperations.hasKey(cartInfo.getSkuId().toString())) &#123;</span><br><span class="line">                        <span class="type">Integer</span> <span class="variable">orderSkuNum</span> <span class="operator">=</span> hashOperations.get(cartInfo.getSkuId().toString()) + cartInfo.getSkuNum();</span><br><span class="line">                        hashOperations.put(cartInfo.getSkuId().toString(), orderSkuNum);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        redisTemplate.expire(orderSkuKey, DateUtil.getCurrentExpireTimes(), TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        <span class="keyword">return</span> order.getId();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BigDecimal <span class="title function_">computeTotalAmount</span><span class="params">(List&lt;CartInfo&gt; cartInfoList)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">total</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (CartInfo cartInfo : cartInfoList) &#123;</span><br><span class="line">                <span class="type">BigDecimal</span> <span class="variable">itemTotal</span> <span class="operator">=</span> cartInfo.getCartPrice().multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(cartInfo.getSkuNum()));</span><br><span class="line">                total = total.add(itemTotal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算购物项分摊的优惠减少金额</span></span><br><span class="line"><span class="comment"> * 打折：按折扣分担</span></span><br><span class="line"><span class="comment"> * 现金：按比例分摊</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cartInfoParamList</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, BigDecimal&gt; <span class="title function_">computeActivitySplitAmount</span><span class="params">(List&lt;CartInfo&gt; cartInfoParamList)</span> &#123;</span><br><span class="line">        Map&lt;String, BigDecimal&gt; activitySplitAmountMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//促销活动相关信息</span></span><br><span class="line">        List&lt;CartInfoVo&gt; cartInfoVoList = activityFeignClient.findCartActivityList(cartInfoParamList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//活动总金额</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">activityReduceAmount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(cartInfoVoList)) &#123;</span><br><span class="line">                <span class="keyword">for</span>(CartInfoVo cartInfoVo : cartInfoVoList) &#123;</span><br><span class="line">                        <span class="type">ActivityRule</span> <span class="variable">activityRule</span> <span class="operator">=</span> cartInfoVo.getActivityRule();</span><br><span class="line">                        List&lt;CartInfo&gt; cartInfoList = cartInfoVo.getCartInfoList();</span><br><span class="line">                        <span class="keyword">if</span>(<span class="literal">null</span> != activityRule) &#123;</span><br><span class="line">                                <span class="comment">//优惠金额， 按比例分摊</span></span><br><span class="line">                                <span class="type">BigDecimal</span> <span class="variable">reduceAmount</span> <span class="operator">=</span> activityRule.getReduceAmount();</span><br><span class="line">                                activityReduceAmount = activityReduceAmount.add(reduceAmount);</span><br><span class="line">                                <span class="keyword">if</span>(cartInfoList.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                                        activitySplitAmountMap.put(<span class="string">&quot;activity:&quot;</span>+cartInfoList.get(<span class="number">0</span>).getSkuId(), reduceAmount);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        <span class="comment">//总金额</span></span><br><span class="line">                                        <span class="type">BigDecimal</span> <span class="variable">originalTotalAmount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0</span>);</span><br><span class="line">                                        <span class="keyword">for</span>(CartInfo cartInfo : cartInfoList) &#123;</span><br><span class="line">                                                <span class="type">BigDecimal</span> <span class="variable">skuTotalAmount</span> <span class="operator">=</span> cartInfo.getCartPrice().multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(cartInfo.getSkuNum()));</span><br><span class="line">                                                originalTotalAmount = originalTotalAmount.add(skuTotalAmount);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="comment">//记录除最后一项是所有分摊金额， 最后一项=总的 - skuPartReduceAmount</span></span><br><span class="line">                                        <span class="type">BigDecimal</span> <span class="variable">skuPartReduceAmount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0</span>);</span><br><span class="line">                                        <span class="keyword">if</span> (activityRule.getActivityType() == ActivityType.FULL_REDUCTION) &#123;</span><br><span class="line">                                                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, len=cartInfoList.size(); i&lt;len; i++) &#123;</span><br><span class="line">                                                        <span class="type">CartInfo</span> <span class="variable">cartInfo</span> <span class="operator">=</span> cartInfoList.get(i);</span><br><span class="line">                                                        <span class="keyword">if</span>(i &lt; len -<span class="number">1</span>) &#123;</span><br><span class="line">                                                                <span class="type">BigDecimal</span> <span class="variable">skuTotalAmount</span> <span class="operator">=</span> cartInfo.getCartPrice().multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(cartInfo.getSkuNum()));</span><br><span class="line">                                                                <span class="comment">//sku分摊金额</span></span><br><span class="line">                                                                <span class="type">BigDecimal</span> <span class="variable">skuReduceAmount</span> <span class="operator">=</span> skuTotalAmount.divide(originalTotalAmount, <span class="number">2</span>, RoundingMode.HALF_UP).multiply(reduceAmount);</span><br><span class="line">                                                                activitySplitAmountMap.put(<span class="string">&quot;activity:&quot;</span>+cartInfo.getSkuId(), skuReduceAmount);</span><br><span class="line"></span><br><span class="line">                                                                skuPartReduceAmount = skuPartReduceAmount.add(skuReduceAmount);</span><br><span class="line">                                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                                <span class="type">BigDecimal</span> <span class="variable">skuReduceAmount</span> <span class="operator">=</span> reduceAmount.subtract(skuPartReduceAmount);</span><br><span class="line">                                                                activitySplitAmountMap.put(<span class="string">&quot;activity:&quot;</span>+cartInfo.getSkuId(), skuReduceAmount);</span><br><span class="line">                                                        &#125;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, len=cartInfoList.size(); i&lt;len; i++) &#123;</span><br><span class="line">                                                        <span class="type">CartInfo</span> <span class="variable">cartInfo</span> <span class="operator">=</span> cartInfoList.get(i);</span><br><span class="line">                                                        <span class="keyword">if</span>(i &lt; len -<span class="number">1</span>) &#123;</span><br><span class="line">                                                                <span class="type">BigDecimal</span> <span class="variable">skuTotalAmount</span> <span class="operator">=</span> cartInfo.getCartPrice().multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(cartInfo.getSkuNum()));</span><br><span class="line"></span><br><span class="line">                                                                <span class="comment">//sku分摊金额</span></span><br><span class="line">                                                                <span class="type">BigDecimal</span> <span class="variable">skuDiscountTotalAmount</span> <span class="operator">=</span> skuTotalAmount.multiply(activityRule.getBenefitDiscount().divide(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;10&quot;</span>)));</span><br><span class="line">                                                                <span class="type">BigDecimal</span> <span class="variable">skuReduceAmount</span> <span class="operator">=</span> skuTotalAmount.subtract(skuDiscountTotalAmount);</span><br><span class="line">                                                                activitySplitAmountMap.put(<span class="string">&quot;activity:&quot;</span>+cartInfo.getSkuId(), skuReduceAmount);</span><br><span class="line"></span><br><span class="line">                                                                skuPartReduceAmount = skuPartReduceAmount.add(skuReduceAmount);</span><br><span class="line">                                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                                <span class="type">BigDecimal</span> <span class="variable">skuReduceAmount</span> <span class="operator">=</span> reduceAmount.subtract(skuPartReduceAmount);</span><br><span class="line">                                                                activitySplitAmountMap.put(<span class="string">&quot;activity:&quot;</span>+cartInfo.getSkuId(), skuReduceAmount);</span><br><span class="line">                                                        &#125;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        activitySplitAmountMap.put(<span class="string">&quot;activity:total&quot;</span>, activityReduceAmount);</span><br><span class="line">        <span class="keyword">return</span> activitySplitAmountMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, BigDecimal&gt; <span class="title function_">computeCouponInfoSplitAmount</span><span class="params">(List&lt;CartInfo&gt; cartInfoList, Long couponId)</span> &#123;</span><br><span class="line">        Map&lt;String, BigDecimal&gt; couponInfoSplitAmountMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == couponId) <span class="keyword">return</span> couponInfoSplitAmountMap;</span><br><span class="line">        <span class="type">CouponInfo</span> <span class="variable">couponInfo</span> <span class="operator">=</span> activityFeignClient.findRangeSkuIdList(cartInfoList, couponId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> != couponInfo) &#123;</span><br><span class="line">                <span class="comment">//sku对应的订单明细</span></span><br><span class="line">                Map&lt;Long, CartInfo&gt; skuIdToCartInfoMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (CartInfo cartInfo : cartInfoList) &#123;</span><br><span class="line">                        skuIdToCartInfoMap.put(cartInfo.getSkuId(), cartInfo);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//优惠券对应的skuId列表</span></span><br><span class="line">                List&lt;Long&gt; skuIdList = couponInfo.getSkuIdList();</span><br><span class="line">                <span class="keyword">if</span>(CollectionUtils.isEmpty(skuIdList)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> couponInfoSplitAmountMap;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//优惠券优化总金额</span></span><br><span class="line">                <span class="type">BigDecimal</span> <span class="variable">reduceAmount</span> <span class="operator">=</span> couponInfo.getAmount();</span><br><span class="line">                <span class="keyword">if</span>(skuIdList.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">//sku的优化金额</span></span><br><span class="line">                        couponInfoSplitAmountMap.put(<span class="string">&quot;coupon:&quot;</span>+skuIdToCartInfoMap.get(skuIdList.get(<span class="number">0</span>)).getSkuId(), reduceAmount);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//总金额</span></span><br><span class="line">                        <span class="type">BigDecimal</span> <span class="variable">originalTotalAmount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">for</span> (Long skuId : skuIdList) &#123;</span><br><span class="line">                                <span class="type">CartInfo</span> <span class="variable">cartInfo</span> <span class="operator">=</span> skuIdToCartInfoMap.get(skuId);</span><br><span class="line">                                <span class="type">BigDecimal</span> <span class="variable">skuTotalAmount</span> <span class="operator">=</span> cartInfo.getCartPrice().multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(cartInfo.getSkuNum()));</span><br><span class="line">                                originalTotalAmount = originalTotalAmount.add(skuTotalAmount);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//记录除最后一项是所有分摊金额， 最后一项=总的 - skuPartReduceAmount</span></span><br><span class="line">                        <span class="type">BigDecimal</span> <span class="variable">skuPartReduceAmount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">if</span> (couponInfo.getCouponType() == CouponType.CASH || couponInfo.getCouponType() == CouponType.FULL_REDUCTION) &#123;</span><br><span class="line">                                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, len=skuIdList.size(); i&lt;len; i++) &#123;</span><br><span class="line">                                        <span class="type">CartInfo</span> <span class="variable">cartInfo</span> <span class="operator">=</span> skuIdToCartInfoMap.get(skuIdList.get(i));</span><br><span class="line">                                        <span class="keyword">if</span>(i &lt; len -<span class="number">1</span>) &#123;</span><br><span class="line">                                                <span class="type">BigDecimal</span> <span class="variable">skuTotalAmount</span> <span class="operator">=</span> cartInfo.getCartPrice().multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(cartInfo.getSkuNum()));</span><br><span class="line">                                                <span class="comment">//sku分摊金额</span></span><br><span class="line">                                                <span class="type">BigDecimal</span> <span class="variable">skuReduceAmount</span> <span class="operator">=</span> skuTotalAmount.divide(originalTotalAmount, <span class="number">2</span>, RoundingMode.HALF_UP).multiply(reduceAmount);</span><br><span class="line">                                                couponInfoSplitAmountMap.put(<span class="string">&quot;coupon:&quot;</span>+cartInfo.getSkuId(), skuReduceAmount);</span><br><span class="line"></span><br><span class="line">                                                skuPartReduceAmount = skuPartReduceAmount.add(skuReduceAmount);</span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                <span class="type">BigDecimal</span> <span class="variable">skuReduceAmount</span> <span class="operator">=</span> reduceAmount.subtract(skuPartReduceAmount);</span><br><span class="line">                                                couponInfoSplitAmountMap.put(<span class="string">&quot;coupon:&quot;</span>+cartInfo.getSkuId(), skuReduceAmount);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                couponInfoSplitAmountMap.put(<span class="string">&quot;coupon:total&quot;</span>, couponInfo.getAmount());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> couponInfoSplitAmountMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>service-product模块创建方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;锁定库存&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;inner/checkAndLock/&#123;orderNo&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">checkAndLock</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;SkuStockLockVo&gt; skuStockLockVoList, <span class="meta">@PathVariable</span> String orderNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> skuInfoService.checkAndLock(skuStockLockVoList, orderNo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>SkuInfoService实现锁定库存方法</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;Exception.class&#125;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">checkAndLock</span><span class="params">(List&lt;SkuStockLockVo&gt; skuStockLockVoList,</span></span><br><span class="line"><span class="params">                                                        String orderToken)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(skuStockLockVoList))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">GmallException</span>(ResultCodeEnum.DATA_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有，验库存并锁库存，要具备原子性</span></span><br><span class="line">        skuStockLockVoList.forEach(skuStockLockVo -&gt; &#123;</span><br><span class="line">                checkLock(skuStockLockVo);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要有一个锁定失败，所有锁定成功的商品要解锁库存</span></span><br><span class="line">        <span class="keyword">if</span> (skuStockLockVoList.stream().anyMatch(skuStockLockVo -&gt; !skuStockLockVo.getIsLock())) &#123;</span><br><span class="line">                <span class="comment">// 获取所有锁定成功的，遍历解锁库存</span></span><br><span class="line">                skuStockLockVoList.stream().filter(SkuStockLockVo::getIsLock).forEach(skuStockLockVo -&gt; &#123;</span><br><span class="line">                        skuInfoMapper.unlockStock(skuStockLockVo.getSkuId(), skuStockLockVo.getSkuNum());</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 响应锁定状态</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果所有都锁定成功的情况下，需要缓存锁定信息到redis。以方便将来解锁库存 或者 减库存</span></span><br><span class="line">        <span class="comment">// 以orderToken作为key，以lockVos锁定信息作为value</span></span><br><span class="line">        <span class="built_in">this</span>.redisTemplate.opsForValue().set(RedisConst.SROCK_INFO + orderToken, skuStockLockVoList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 锁定库存成功之后，定时解锁库存。</span></span><br><span class="line">        <span class="comment">//this.rabbitTemplate.convertAndSend(&quot;ORDER_EXCHANGE&quot;, &quot;stock.ttl&quot;, orderToken);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkLock</span><span class="params">(SkuStockLockVo skuStockLockVo)</span>&#123;</span><br><span class="line">        <span class="comment">//公平锁，就是保证客户端获取锁的顺序，跟他们请求获取锁的顺序，是一样的。</span></span><br><span class="line">        <span class="comment">// 公平锁需要排队</span></span><br><span class="line">        <span class="comment">// ，谁先申请获取这把锁，</span></span><br><span class="line">        <span class="comment">// 谁就可以先获取到这把锁，是按照请求的先后顺序来的。</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">rLock</span> <span class="operator">=</span> <span class="built_in">this</span>.redissonClient</span><br><span class="line">                        .getFairLock(RedisConst.SKUKEY_PREFIX + skuStockLockVo.getSkuId());</span><br><span class="line">        rLock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 验库存：查询，返回的是满足要求的库存列表</span></span><br><span class="line">                <span class="type">SkuInfo</span> <span class="variable">skuInfo</span> <span class="operator">=</span> skuInfoMapper.checkStock(skuStockLockVo.getSkuId(), skuStockLockVo.getSkuNum());</span><br><span class="line">                <span class="comment">// 如果没有一个仓库满足要求，这里就验库存失败</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == skuInfo) &#123;</span><br><span class="line">                        skuStockLockVo.setIsLock(<span class="literal">false</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 锁库存：更新</span></span><br><span class="line">                <span class="type">Integer</span> <span class="variable">row</span> <span class="operator">=</span> skuInfoMapper.lockStock(skuStockLockVo.getSkuId(), skuStockLockVo.getSkuNum());</span><br><span class="line">                <span class="keyword">if</span> (row == <span class="number">1</span>) &#123;</span><br><span class="line">                        skuStockLockVo.setIsLock(<span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                rLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于RabbitMQ实现中药材上下架、生成订单完成，删除采购车数据、支付完成之后，更新订单状态和扣减库存等。"><a href="#基于RabbitMQ实现中药材上下架、生成订单完成，删除采购车数据、支付完成之后，更新订单状态和扣减库存等。" class="headerlink" title="基于RabbitMQ实现中药材上下架、生成订单完成，删除采购车数据、支付完成之后，更新订单状态和扣减库存等。"></a>基于<strong>RabbitMQ</strong>实现中药材上下架、生成订单完成，删除采购车数据、支付完成之后，更新订单状态和扣减库存等。</h1><p>rabbitMQ是我这个项目中大量用到的消息中间件，一是我觉得它是专门做这个消息中</p><p>消息队列提供一个异步通信机制，消息的发送者不必一直等待到消息被成功处理才返回，而是立即返回。消息中间件负责处理网络通信，如果网络连接不可用，消息被暂存于队列当中，当网络畅通的时候在将消息转发给相应的应用程序或者服务，当然前提是这些服务订阅了该队列。如果在商品服务和订单服务之间使用消息中间件，既可以提高并发量，又降低服务之间的耦合度。</p><p>RabbitMQ就是这样一款消息队列。RabbitMQ是一个开源的消息代理的队列服务器，用来通过普通协议在完全不同的应用之间共享数据。</p><p>使用步骤：</p><p><strong>安装rabbitMQ</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#拉取镜像</span><br><span class="line">docker pull rabbitmq:<span class="number">3.8</span>-management</span><br><span class="line">#创建容器启动</span><br><span class="line">docker run -d --restart=always -p <span class="number">5672</span>:<span class="number">5672</span> -p <span class="number">15672</span>:<span class="number">15672</span> --name rabbitmq rabbitmq:<span class="number">3.8</span>-management</span><br></pre></td></tr></table></figure><p><strong>rabbitMQ服务后台</strong></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MmVlOGYxYjJjNjg4ZDMzOWM2MTBlZTM0M2ZlYWFhYTVfa1Vub1M5ekhFbUV5S1AySmVJeFJPdE5iSWQwY2VsMk1fVG9rZW46Uk5LOWJ6aFBCb0ZyNlp4OThOVWNXQTNqbmRoXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p><strong>在common搭建rabbit_util模块，在rabbit_util引入依赖</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--rabbitmq消息队列--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p><strong>添加service方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  引入操作rabbitmq 的模板</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange  交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routingKey    路由键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message   消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessage</span><span class="params">(String exchange,String routingKey, Object message)</span>&#123;</span><br><span class="line">        <span class="comment">//  调用发送数据的方法</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchange,routingKey,message);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送延迟消息的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange  交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routingKey    路由键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message   消息内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delayTime 延迟时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendDelayMessage</span><span class="params">(String exchange,String routingKey, Object message, <span class="type">int</span> delayTime)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  在发送消息的时候设置延迟时间</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, routingKey, message, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">                <span class="comment">//  设置一个延迟时间</span></span><br><span class="line">                message.getMessageProperties().setDelay(delayTime*<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> message;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置mq消息转换器</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MQConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加消息的确认配置</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MQProducerAckConfig</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ReturnCallback,RabbitTemplate.ConfirmCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  我们发送消息使用的是 private RabbitTemplate rabbitTemplate; 对象</span></span><br><span class="line">    <span class="comment">//  如果不做设置的话 当前的rabbitTemplate 与当前的配置类没有任何关系！</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  设置 表示修饰一个非静态的void方法，在服务器加载Servlet的时候运行。并且只执行一次！</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="built_in">this</span>);</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示消息是否正确发送到了交换机上</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData   消息的载体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack   判断是否发送到交换机上</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause 原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送失败！&quot;</span>+cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息如果没有正确发送到队列中，则会走这个方法！如果消息被正常处理，则这个方法不会走！</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replyCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replyText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routingKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(Message message, <span class="type">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消息主体: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        System.out.println(<span class="string">&quot;应答码: &quot;</span> + replyCode);</span><br><span class="line">        System.out.println(<span class="string">&quot;描述：&quot;</span> + replyText);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息使用的交换器 exchange : &quot;</span> + exchange);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息使用的路由键 routing : &quot;</span> + routingKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里举例上下架功能，其他的功能用法都是相似的</p><p><strong>service-product添加发送MQ消息方法</strong></p><p>引入依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.YYJJ&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rabbit-util&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>service-product配置文件添加MQ配置</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rabbitmq:</span><br><span class="line">  host: <span class="number">192.168</span><span class="number">.56</span><span class="number">.101</span></span><br><span class="line">  port: <span class="number">5672</span></span><br><span class="line">  username: guest</span><br><span class="line">  password: guest</span><br><span class="line">  publisher-confirm-type: CORRELATED  #发布确认模式，消息是否被成功发送到交换机</span><br><span class="line">  publisher-returns: <span class="literal">true</span></span><br><span class="line">  listener:</span><br><span class="line">    simple:</span><br><span class="line">      prefetch: <span class="number">1</span></span><br><span class="line">      concurrency: <span class="number">3</span></span><br><span class="line">      acknowledge-mode: manual   #消费端手动确认</span><br></pre></td></tr></table></figure><p><strong>SkuInfoServiceImpl的publish方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitService rabbitService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;Exception.class&#125;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(Long skuId, Integer status)</span> &#123;</span><br><span class="line">        <span class="comment">// 更改发布状态</span></span><br><span class="line">        <span class="keyword">if</span>(status == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">SkuInfo</span> <span class="variable">skuInfoUp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkuInfo</span>();</span><br><span class="line">                skuInfoUp.setId(skuId);</span><br><span class="line">                skuInfoUp.setPublishStatus(<span class="number">1</span>);</span><br><span class="line">                skuInfoMapper.updateById(skuInfoUp);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//上架：发送mq消息同步es</span></span><br><span class="line">                rabbitService.sendMessage(MqConst.EXCHANGE_GOODS_DIRECT, MqConst.ROUTING_GOODS_UPPER, skuId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">SkuInfo</span> <span class="variable">skuInfoUp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkuInfo</span>();</span><br><span class="line">                skuInfoUp.setId(skuId);</span><br><span class="line">                skuInfoUp.setPublishStatus(<span class="number">0</span>);</span><br><span class="line">                skuInfoMapper.updateById(skuInfoUp);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//下架：发送mq消息同步es</span></span><br><span class="line">                rabbitService.sendMessage(MqConst.EXCHANGE_GOODS_DIRECT, MqConst.ROUTING_GOODS_LOWER, skuId);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>service-search添加接收MQ消息方法</strong></p><p><strong>service-search引入依赖</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.YYJJ&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rabbit-util&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>添加SkuReceiver接收MQ消息方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SkuReceiver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SkuService skuService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上架</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> skuId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(value = MqConst.QUEUE_GOODS_UPPER, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(value = MqConst.EXCHANGE_GOODS_DIRECT),</span></span><br><span class="line"><span class="meta">            key = &#123;MqConst.ROUTING_GOODS_UPPER&#125;</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">upperSku</span><span class="params">(Long skuId, Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != skuId) &#123;</span><br><span class="line">            skuService.upperSku(skuId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 第一个参数：表示收到的消息的标号</span></span><br><span class="line"><span class="comment">             * 第二个参数：如果为true表示可以签收多个消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下架</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> skuId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(value = MqConst.QUEUE_GOODS_LOWER, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(value = MqConst.EXCHANGE_GOODS_DIRECT),</span></span><br><span class="line"><span class="meta">            key = &#123;MqConst.ROUTING_GOODS_LOWER&#125;</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lowerSku</span><span class="params">(Long skuId, Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != skuId) &#123;</span><br><span class="line">            skuService.lowerSku(skuId);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扫码登录到底是怎么实现的？"><a href="#扫码登录到底是怎么实现的？" class="headerlink" title="扫码登录到底是怎么实现的？"></a><strong>扫码登录到底是怎么实现的？</strong></h1><p>​    扫码登录的本质是，通过已经登录过的 App 应用，扫描未登录的 Web 端程序中的二维 </p><p>码， 通过某种机制触发登录凭证的写入从而实现 Web 端自动登录的过程。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MzUwYTg2NWI3MDMwMjdjODlkMjM0YzgzNWIzODBiN2FfVWVVV29RcDBOdzU0a3UxeGdwWlZEY1VYV0lvMzhrQUZfVG9rZW46VER4dWJUUmFTb2RyQ2Z4ZDlRRmNuV1dKblFoXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p>​                 （图是网上找的，思路和图片都出自XX科技）</p><ul><li>首先，在网页端打开登录页面，展示一个二维码，这个二维码有一个唯一编号是服</li></ul><p>务端生成的。然后浏览器定时轮询这个二维码的状态 </p><ul><li>接着，APP 扫描这个二维码，把 APP 的 token 信息、二维码 ID 发送给 Server 端，</li></ul><p>Server 收到请求后修改二维码的扫码状态，并生成一个临时 token </p><ul><li>此时，网页端展示的二维码状态会提示已扫码，待确认。 而 APP 端扫码之后，会</li></ul><p>提示确认授权的操作。 </p><ul><li>于是，用户确认登录后，携带临时 token 给到 server，server 端修改二维码状态</li></ul><p>并为网页端生成授权 token </p><ul><li>最后，网页端轮询到状态变化并获取到 token，从而完成扫码授权。</li></ul><h1 id="订单超时自动取消功能如何设计"><a href="#订单超时自动取消功能如何设计" class="headerlink" title="订单超时自动取消功能如何设计"></a><strong>订单超时自动取消功能如何设计</strong></h1><p>这个功能和我做的问卷超时功能有异曲同工之妙，但是在网上看，发现这样的场景有多种不同的解决方案，并且还添加了很多优化，这里我要做一下记录，之后可能还要优化我们的项目:</p><p>直接写个定时任务去轮询数据库，根据订单时间找到超时的订单把它取消就行了</p><ol><li>轮询会存在延迟时间，也就是没办法准时实现订单的取消 </li><li>轮询数据库，会给数据库造成很大的压力，如果订单表的数据量比较大的情况下，</li></ol><p>轮询的效率也会比较低。 </p><p>如果要考虑到性能、又要考虑到实时性，有没有更好的方案呢？ </p><p>当然有，比如 </p><ol><li>时间轮算法（如图），这种算法是采用了一个环状数组+链表的方式来管理延迟任</li></ol><p>务，我们只需要计算这个订单的超时时间，再加入到时间轮里面即可。 </p><p>时间轮算法唯一的缺点就是无法持久化，所以需要在服务重启后做一次数据预热。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YzZiZmM0NzQ0Nzg4NGFkYTYwNWRhMDc1NmIxMjVjMjlfN0VmVFVoSDVmemdJMU1JaVdLNEUwQ0NnYkRZZHNCd2tfVG9rZW46QTV3Y2I0RWM3b29QQWV4QVdQM2NzNmdMbnZiXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><ol><li>利用主流 MQ 中的延迟消息功能，消息发送到 Broker 上以后并不会立刻投递，而</li></ol><p>是根据消息中设置的延迟时间去投递。我们只需要把新的订单并计算这个订单的超 </p><p>时时间发送到 MQ 中即可。 </p><p>MQ 这种实现方式在性能、可扩展性、稳定性上都比较好，是一个不错的选择。</p><h1 id="项目中如何保证的接口幂等"><a href="#项目中如何保证的接口幂等" class="headerlink" title="项目中如何保证的接口幂等"></a><strong>项目中如何保证的接口幂等</strong></h1><p>这个概念是我第一次接触，认真学习了一下，了解了一下如何保证接口幂等</p><p>首先，什么是幂等？ </p><p>简单来说，就是一个接口，使用相同的参数重复执行的情况下，对数据造成的改变只发生一次。 比如支付操作，如果支付接口被重复调了 N 次，那资金的扣减只发生一次，这就是幂等</p><p>然后说问题，</p><p>在分布式架构中，由于引入了网络通信导致一个请求，除了成功&#x2F;失败以外，还多了一个未知状态。 </p><p>也就是如果一次远程接口调用失败，有可能这个请求在服务端执行成功了。而客户端为了确保本次请求执行成功，可能会发起重试的操作，导致同一个接口被重复调用了多次</p><p>为了保证服务端接口的幂等性，我们就需要在服务端的接口中去识别当前请求是重复请求，从而不再进行数据的变更操作。</p><p>通常的解决方案有几种:</p><ul><li>使用数据库唯一索引的方式实现， 我们可以专门创建一个消息表，里面有一个消息内容的字段并且设置为唯一索引，每次收到消息以后生成 md5 值插入到这个消息表里面。一旦出现重复消息，就会抛异常，我们可以捕获这个异常来避免重复对数据做变更</li><li>使用 Redis 里面的 setNx 命令，我们可以把当前请求中带有唯一标识的信息存储到Redis 里面，根据 setNx 命令返回的结果来判断是否是重复执行，如果是则丢弃该请求。</li><li>使用状态机的方式来实现幂等，在很多的业务场景中，都会存在业务状态的流转，并且这些状态流转只会前进，所以我们在对数据进行修改的时候，只需要在条件里面带上状态，就能避免数据被重复修改的问题</li></ul><p>不管采用哪种方案，核心本质都是需要去识别当前请求是重复请求。</p><h1 id="消息推送中的已读消息和未读消息设计"><a href="#消息推送中的已读消息和未读消息设计" class="headerlink" title="消息推送中的已读消息和未读消息设计"></a><strong>消息推送中的已读消息和未读消息设计</strong></h1><p>(方案来自于咕泡科技)</p><p>“站内信”有两个基本功能：</p><p><strong>点到点的消息传送。</strong>用户给用户发送站内信，管理员给用户发送站内信。 </p><p><strong>点到面的消息传送。</strong>管理员给用户（指定满足某一条件的用户群）群发消息</p><p>只需要设计一个消息内容表和一个用户通知表，当创建一条系统通知后，数据插入到消息内容表。消息内容包含了发送渠道，根据发送渠道决定后续动作。如果是站内渠道，在插入消息内容后异步地插入记录到用户通知表。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ODljMzcwZjhlNjY1MzcwZGRiMTQ5OWJmZWE5NmNjZmNfcm5pMlpXNTBmWnZjWWFrcFdmdG1VWXFzZmVOUVA1dHlfVG9rZW46UGowZmJjMHcwb0lndkN4SDZaZGM1elRUblBjXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p>这个方案看起来没什么问题，但实际上，我们把所有用户通知的消息全部放在一个表里 </p><p>面，如果有 10W 个用户，那么同样的消息需要存储 10W 条很明显，会带来两个问题： </p><ol><li>随着用户量的增加，发送一次消息需要插入到数据库中的数据量会越来越大，导致</li></ol><p>耗时会越来越长 </p><ol><li>用户通知表的数据量会非常大，对未读消息的查询效率会严重下降</li></ol><p>所以上面这种方案很明显行不通，要解决这两个问题，有两个参考解决思路。 </p><p>第一个方式（如图），先取消用户通知表， 避免在发送平台消息的时候插入大量重复数据问题。其次增加一个“message_offset”站内消息进度表，每个用户维护一个消息消费的进度 Offset。每个用户去获取未读消息的时候，只需要查询大于当前维护的 msg_id_offset的数据即可。在这种设计方式中，即便我们发送给 10W 人，也只需要在消息内容表里面插入一条记录即可。</p><p>在性能上和数据量上都有较大的提升。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MzUwNzE1ZGViOWMxYjc2ZjZjNTk1ZTExMGViZjEzM2VfVE1sbHg5WnVod01nQ2tGQjh6c09kbjd5ZGc2Zmd5OE1fVG9rZW46S0c1dmJJYUsyb1dYVEt4VlJZOWNLUVFCbmxkXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p>第二种方式，和第一种方式类似，使用 Redis 中的 Set 集合来保存已经读取过的消息 id。使用 userid_read_message 作为 key，这样就可以为每个用户保存已经读取过的所有消息的 id。当用户读取了未读消息后， 就直接在 redis 的已读消息 id 的 set 中新增一条记录。这样，在已经得知到已读消息的数量和具体消息 id 的情况下，我们可以直接使用消息id 来查询没有消费过的数据</p><h1 id="布隆过滤器到底是什么东西？它有什么用"><a href="#布隆过滤器到底是什么东西？它有什么用" class="headerlink" title="布隆过滤器到底是什么东西？它有什么用"></a><strong>布隆过滤器到底是什么东西？它有什么用</strong></h1><p>首先想一个问题？如果想判断一个元素是否存在某个集合里面该怎么做？</p><p>一般的解决方案是先把所有元素保存起来，然后通过循环比较来确定。但是如果我们有几千万甚至上亿的数据的时候，虽然可以通过不同的数据结构来优化数据检索的时间复杂度，但是整体的效率依然很慢，而且会占用非常多的内存空间，这个问题该怎么解决呢？</p><p>这个时候，位图就派上了用场， BitMap 的基本原理就是用一个 bit 位来存储当前数据是否存在的状态值，也就是把一个数据通过 hash 运算取模后落在 bit 位组成的数组中，通过 1 对该位置进行标记。这种方式适用于大规模数据，但数据状态又不是很多的情况，通常是用来判断某个数据存不存在的。</p><p>布隆过滤器就是在位图的基础上做的一个优化设计</p><p>它的原理是，当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。检索的时候，使用同样的方式去映射，只要看到每个映射的位置的值是不是 1，就可以大概知道该元素是否存在集合中了。如果这些点有任何一个 0，则被检查的元素一定不在；如果都是 1，则被检查的元素很可能存在。</p><h1 id="会员批量过期的方案怎么实现？"><a href="#会员批量过期的方案怎么实现？" class="headerlink" title="会员批量过期的方案怎么实现？"></a><strong>会员批量过期的方案怎么实现？</strong></h1><p>​    有一张 200W 数据量的会员表，每个会员会有长短不一的到期时间，现在想在快到 </p><p>期之前发送邮件通知提醒续费，该怎么实现？</p><p>首先把握住场景的核心问题:</p><ul><li>200W 数据意味着数据量比较大 </li><li>每个会员都有过期时间，需要能够筛选出快过期的会员</li></ul><p>四种解决方案： </p><ol><li>第一种，系统不主动轮询，而是等用户登录到系统以后，触发一次检查。如果发现会员的过期时间小于设定的阈值，就触发一次弹窗和邮件提醒。这种方式规避了轮询问题，不会对数据库和后端应用程序造成任何压力。 缺点是，如果用户一直不登陆，就一直无法实现会员过期，并且也无法提前去根据运营策略发送续期的提醒消息。 </li><li>第二种，我们可以使用搜索引擎，比如 Solr、或者 Elasticsearch。把会员表里面的会员 id 和会员到期时间存储一份到搜索引擎中。搜索引擎的优势在于大数据量的快速检索，并且具有高可扩展性和高可靠性，非常适合大规模数据的处理。 </li><li>第三种，可以使用 Redis 来实现。用户开通会员以后，在 Redis 里面存储这个会员 id，以及设置这个 id 的过期时间。然后可以使用 redis 的过期提醒功能，把配置项 notify-keyspace-events 改为 notify-keyspace-events “Ex”当 Redis 里面的 key 过期以后，会触发一个 key 过期事件，我们可以在应用程序中监听这个事件来处理。 </li><li>第四种，可以直接使用 MQ 提供的延迟队列，当用户开通会员以后，直接计算这个会员的过期时间，然后发送一个延迟消息到 MQ 上，一旦消息达到过期时间，消费者就可以消费这个消息来触发会员过期的提醒。</li></ol><h1 id="日常开发中常见的限流算法"><a href="#日常开发中常见的限流算法" class="headerlink" title="日常开发中常见的限流算法"></a>日常开发中<strong>常见的限流算法</strong></h1><p>  限流算法是一种系统保护策略，主要是避免在流量高峰导致系统被压垮，造成系统不可用的问题</p><p>  日常开发中常见的限流算法有 4 种。</p><ol><li>计数器限流，一般用在单一维度的访问频率限制上，比如短信验证码每隔 60s 只能发送一次，或者接口调用次数等，它的实现方法很简单，每调用一次就加 1，处理结束以后减一。</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MmVhYTBiZjY1MzkxODQ1ZDJjNjg0MjViMTBiMjFlMTFfVzljVU1jVm9LenMxdlhVTFZZckR4MGFPWlNPeHI5RXBfVG9rZW46WEhOUGJJUmRob2hGQWd4UXNlNmNZMUNzbjFiXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><ol><li>滑动窗口限流，本质上也是一种计数器，只是通过以时间为维度的可滑动窗口设计，来减少了临界值带来的并发超过阈值的问题。每次进行数据统计的时候，只需要统计这个窗口内每个时间刻度的访问量就可以了。Spring Cloud里面的熔断框架Hystrix ，以及Spring Cloud Alibaba里面的Sentinel都采用了滑动窗口来做数据统计</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OTY5YTcyN2QxMDkxNGVkMDE1OTgxNjhjZGU4OWI3YjVfcHJuSW1zU3QwRWNpWnIzMFVhdjA2cmNXRGIzdUxNOGJfVG9rZW46VFFxb2JQdHhlb1VEUGl4bWQ1SWNFU3NzblF1XzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><ol><li>漏桶算法，它是一种恒定速率的限流算法，不管请求量是多少，服务端的处理效率是恒定的。基于 MQ 来实现的生产者消费者模型，其实算是一种漏桶限流算法</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MjJjMTUwMjAxM2RlNmU5MjJjZGZlYTZhNmZlNDRlYzZfcmpvbjhOMGdsQjlDZmhmZW5WdVMzMnc2SUhzak4xbWJfVG9rZW46UnNQcGJHNnpOb2p5NWt4ZDlwZGNiWktIbk5mXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><ol><li>令牌桶算法，相对漏桶算法来说，它可以处理突发流量的问题。它的核心思想是，令牌桶以恒定速率去生成令牌保存到令牌桶里面，桶的大小是固定的，令牌桶满了以后就不再生成令牌。每个客户端请求进来的时候，必须要从令牌桶获得一个令牌才能访问，否则排队等待。 在流量低峰的时候，令牌桶会出现堆积，因此当出现瞬时高峰的时候，有足够多的令牌可以获取，因此令牌桶能够允许瞬时流量的处理。网关层面的限流、或者接口调用的限流，都可以使用令牌桶算法，像Google 的 Guava，和 Redisson 的限流，都用到了令牌桶算法 在我看来，限流的本质是实现系统保护，最终选择什么样的算法，一方面取决于统计的精准度，另一方面考虑限流维度和场景的需求。</li></ol><h1 id="一致性-Hash-算法出现的场景和如何解决"><a href="#一致性-Hash-算法出现的场景和如何解决" class="headerlink" title="一致性 Hash 算法出现的场景和如何解决"></a><strong>一致性 Hash 算法出现的场景和如何解决</strong></h1><p>一致性 hash，是一种比较特殊的 hash 算法，它的核心思想是解决在分布式环境下，hash 表中可能存在的动态扩容和缩容的问题</p><ul><li>那么为什么会出现一致性 hash?</li></ul><p>一般情况下，我们会使用 hash 表的方式以 key-value 的方式来存储数据，但是当数据量比较大的时候，我们就会把数据存储到多个节点上，然后通过 hash 取模的方法来决定当前 key 存储到哪个节点上。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NjZjMDM4ODYxZmI4OGY3MTc4ZjgyNGU1NzFjNmVjMzZfbmt0MjdjeXJCcEozeFN3Ujk5ZERKM05qS0FYa1p1cU1fVG9rZW46VW1YZGJJRkpobzBsRUJ4bUJqRGNsc3I1bkNRXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p>这种方式有一个非常明显的问题，就是当存储节点增加或者减少的时候，原本的映射关系就会发生变化。也就是需要对所有数据按照新的节点数量重新映射一遍，这个涉及到大量的数据迁移和重新映射，迁移代价很大</p><ul><li>一致性 hash 的工作原理</li></ul><p>一致性 hash 就是用来优化这种动态变化场景的算法，它的具体工作原理也很简单。 </p><p>首先，一致性 Hash 是通过一个 Hash 环的数据结构来实现的，（如图），这个环的起点是 0，终点是 2^32-1。 </p><p>也就是这个环的数据分布范围是[0,2^32-1]</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=N2IxN2VlMDBiYzVhMWNhNjg1MDIxZjcyYTE2MGNjNjNfczVvZEd0bW41OEprekVFRUxFV0c1QjlUQ1prTFc5bWlfVG9rZW46SkF5bGJIU1Bkb3lXWVp4VzNXeGNPR1E3bjllXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p>然后我们把存储节点的 ip 地址作为 key 进行 hash 之后，会在 Hash 环上确定一个位置。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MDJmN2EwMjBhMjYyZDhjNGIzYzgwYjc2NzE2MjhjOGFfQUZKVWowNThjT1NwRHBVbVJOS0g2b1EwaHR4bzI4aHdfVG9rZW46UlJCcmJpOFh1b0JiRjF4R2wyRGNXdnJ2bnRiXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p>接下来，就是把需要存储的目标 key 使用 hash 算法计算后得到一个 hash 值，同样也会落到 hash 环的某个位置上。然后这个目标 key 会按照顺时针的方向找到离自己最近的一个节点进行数据存储。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NmIxZGU3YTA2YTJjMjEwOTk4ODgyYjNkNTdiZjI5YjZfTEs0Wm9iejE1dGk0UDczYVA0cWhrRERrVmJ4N3Y1TXpfVG9rZW46WWNFd2JVbGJPb29YRFF4TmtNc2N3UjQ1blpiXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><ul><li>为什么一致性 Hash 比普通 hash 算法好</li></ul><p>假设现在需要新增一个节点node4，那数据的映射关系的影响范围只限于node3和 node1，只有少部分的数据需要重新映射迁移就行了,如果是已经存在的节点 node1 因为故障下线了，只那只需要把原本分配在 node1 上的数据重新分配到 node2 上就行了。 同样对数据影响的范围非常小,所以，在我看来，一致性 hash 算法的好处是扩展性很强，在增加或者减少服务器的时候，数据迁移范围比较小。 另外，在一致性 Hash 算范里面，为了避免 hash 倾斜导致数据分配不均匀的情况，我们可以使用虚拟节点的方式来解决</p><h1 id="设计一个秒杀系统"><a href="#设计一个秒杀系统" class="headerlink" title="设计一个秒杀系统"></a><strong>设计一个秒杀系统</strong></h1><p>秒杀场景中有三个核心要素：</p><ol><li><strong>高性能</strong></li><li><strong>一致性</strong></li><li><strong>高可用性</strong></li></ol><h2 id="如何提高性能？"><a href="#如何提高性能？" class="headerlink" title="如何提高性能？"></a><strong>如何提高性能？</strong></h2><p>   秒杀场景核心的问题是如何解决海量请求带来的性能问题，那么我们如何在有限的资源下，尽最大的限度去提高服务器访问性能？总结有这几点：热点数据处理、流量削峰、资源隔离、服务器优化。</p><h2 id="热点数据处理"><a href="#热点数据处理" class="headerlink" title="热点数据处理"></a><strong>热点数据处理</strong></h2><p><strong>1、什么是热点数据？</strong></p><p>我理解的热点数据指的是用户请求量非常高的那些数据，在秒杀场景中，热点数据就是那些要被秒杀的商品数据。</p><p>这些热点请求会大量占用服务器的资源，如果不对这些数据进行处理，那么会严重占用资源，进而影响系统的性能，导致其他业务也受影响。</p><p>热点数据又可以分为“静态热点数据”和“动态热点数据”。</p><p><strong>2、静态热点数据</strong></p><p>静态热点数据指的是可以提前预知的热点数据，比如秒杀场景，需要参与本次秒杀的商家提前报名，并将秒杀的商品录入热点分析系统中。业务系统通过这次提前录入的热点数据，进行预加载，甚至可以将数据放入本地缓存中，这样做的好处可以有效缓解避缓存集群的压力，避免流量集中时压垮缓存集群。</p><p>如何更新本地缓存？</p><p>   可用做法是将热点数据录入热点分析平台，本地对热点数据进行订阅，并根据订阅规则去更新本地缓存即可。</p><p><strong>3、动态热点数据</strong></p><p>动态指的就是不能提前预知哪些数据是热点的，需要通过数据收集与分析，或者通过大数据平台预测。</p><p>   做法可以是通过在网关平台中做一个用于收集日志的异步日志收集系统，通过采集商品请求的日志，处理后发送到热点分析平台，热点分析平台通过一些列的分析计算将这些热点商品进行热点数据处理，后端通过订阅这些热点数据就可以识别哪些商品是热点数据了。</p><h2 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a><strong>流量削峰</strong></h2><p>在服务器资源固定的情况下，说明处理能力是有峰值存在的，如果不对请求处理进行处理的话，很可能会在流量峰值的瞬间压垮服务器，但流量峰值存在的时间不长，其实服务器的处理能力大部分时间都是处于闲置状态，那么我们可不可以将峰值集中的请求分散到其他时间呢？</p><ol><li>消息队列</li></ol><p>消息队列除了在解耦、异步场景之外，最大的作用场景是用于流量削峰，面对海量流量请求，可以将这些请求数据用异步的方式先存放在消息队列中，而消息队列一般都能够存储大量消息，消息会被消费端订阅消费，这样就有效地将峰值均摊到其他时间进行处理了。</p><p>如上，消息队列就像我们平常见到的水库一样，当洪水来临时，拦住并对其进行储蓄，以减少对下游的冲击，避免了洪水的灾害。</p><p>目前有大量优秀的开源消息队列框架，如 RocketMQ、Kafka 等，而我之前在中通时主要负责消息平台的建设与维护工作，中通每天面对几千万的订单流量依然那么稳固，其中消息队列起了很大的“防洪”作用！</p><ol><li>答题</li></ol><p>除了利用消息队列对请求进行“储蓄”达到削峰的目的之外，还可以通过在用户发起请求前，对用户进行一些校验操作，比如答题、输入验证码等等，这种答题机制，除了可以防止买家在秒杀过程中使用作弊脚本之外，在秒杀场景中最主要的作还是将请求分散到各个时间点，秒杀场景一般都是集中在某个点进行，比如 0 点时刻，如果没有答题机制，几乎所有的流量都在 0 点时刻涌入服务器中，如果有答题机制，就能延缓用户的请求，从而达到请求分散到各个时间点的目的。</p><h2 id="如何保持一致性？"><a href="#如何保持一致性？" class="headerlink" title="如何保持一致性？"></a><strong>如何保持一致性？</strong></h2><p>秒杀场景，本质上就是在海量买家同时请求购买时，能够准确并将商品卖出去。</p><p>在秒杀的高并发读写请求过程中，需要保证商品不会发生“超卖”现象，因为秒杀的商品是数量一定的，但会有成千上万个用户在同一时间下单购买，在减扣库存过程中如何保证商品数量的准确性至关重要。</p><h3 id="减扣库存方案分析"><a href="#减扣库存方案分析" class="headerlink" title="减扣库存方案分析"></a><strong>减扣库存方案分析</strong></h3><p>1、下单减扣库存</p><p>  买家只要完成下单，立即减扣商品库存，这种方式实现是最简单而且也是最精准的，通常可以在下单时利用数据库事务能力即可保证减扣库存的准确性，但需要考虑买家下单后不付款的情况。</p><p>2、付款减扣库存</p><p>  即买家下单后，并不立即减库存，而是等到有用户付款后才真正减库存，否则库存一直保留给其他买家。但因为付款时才减库存，如果并发比较高，有可能出现买家下单后付不了款的情况，因为可能商品已经被其他人买走了。</p><p>  当只有买家下单后，并且已完成付款，才执行库存的减扣，这种方式好处是避免了买家不付款导致实际没有卖出这么多商品的情况，但这种方式会造成用户体验不好，因为这会导致有些用户付款时商品有可能被人买走了导致付款失败的问题。</p><p>3、预扣库存</p><p>  这种方式结合以上两种方式的优点，当买家下单后，预扣库存，只会其保留一定的时间，比如 10 分钟，在这段时间内如果买家不付款，则将库存自动释放，其它买家可以继续抢购。这种做法需要买家付款前，再做一次商品库是否还有保留，如果没有保留，则再次尝试预扣，预扣失败则不允许继续付款；如果有保留，付款完成后执行真正的减扣库存动作。</p><p>但预扣库存依然没有彻底解决减扣库存链路中存在的问题，比如有些买家可以在释放的瞬间立马又重新下单一次，相当于将库存无限地保留下去，因此我们还需要将记录用户下单次数，如果连续下单超过一定次数，或者超过下单并不付款次数，就拦截用户下单请求。</p><p>总结：</p><p>  一般最简单的做法就是使用下单减库存的方式，因为在秒杀场景中，商品的性价比通常很高，秒杀就是创造一种只有少量买家能买到的场景，一般来说买家只要“秒”到商品了，极少情况会出现退款的，即使发生了少量退款，造成实际卖出去的商品会比数据上少，也是可以通过候补来解决。</p><h3 id="如何减扣库存？"><a href="#如何减扣库存？" class="headerlink" title="如何减扣库存？"></a><strong>如何减扣库存？</strong></h3><p>减扣库存动作应该放在哪里执行？</p><p>下面具体分析一下减扣库存的几种实现方式：</p><ol><li>如果链路涉及的逻辑比较简单的，比如下单减库存这种方式，最简单的做法就是在下单时，利用数据库的本地事务机制进行对库存的减扣，比如使用 where 库存 &gt;0不满足就回滚；</li><li>将库存数量值放在缓存中，比如 Redis，并做持久化处理。</li></ol><p>需要注意的是，如果遇到减扣库存的逻辑很复杂，比如减扣库存之后需要在同一个事务中做一些其他事情，那么就不能使用第二种方式了，只能使用第一种方式在数据库层面上面操作，以保证同在一个事务中。面对这种情况，你可以将热点数据进行数据库隔离，把这些热点商品单独放在一个数据库中。</p><h2 id="如何实现高可用性？"><a href="#如何实现高可用性？" class="headerlink" title="如何实现高可用性？"></a><strong>如何实现高可用性？</strong></h2><p>最后，为了保证秒杀系统的高可用性，必须要对系统进行兜底处理，以便遇到极端的情况系统依然能够运转，通常的做法有服务降级、服务限流、拒绝请求等方式处理。</p><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a><strong>服务降级</strong></h3><p>当请求量达到系统承受的能力时，需要对系统的一些非核心功能进行关闭操作，尽可能将资源留给秒杀核心链路。</p><p>比如在秒杀系统中，还存在其他非核心的功能，我们可以在系统中设计一些动态开关，比如在网关层在路由开关，将这些非核心的请求直接在最外层拒掉。</p><p>还有就是对页面展示的数据进行精简化，用降低用户体验换取核心链路的稳定运行。</p><h3 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a><strong>服务限流</strong></h3><p>限流的目的是通过对并发访问&#x2F;请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，常用的有 QPS 限流，用户请求排队限流，需要设置过期时间，一旦超过过期时间则丢弃，这样做是为了用户请求可以做到快速失败的效果，这种机制在 RocketMQ 中也有相关的应用，RocketMQ broker 会对客户端请求进行排队限流处理，当请求在队列中超过了过期时间，则丢弃，客户端快速失败进行第二轮重试。</p><h3 id="拒绝请求"><a href="#拒绝请求" class="headerlink" title="拒绝请求"></a><strong>拒绝请求</strong></h3><p>如果服务降级、服务限流都不能解决问题，最后的兜底，那就是直接拒绝用户请求，比如直接给用户返回 “服务器繁忙，请稍后再试”等提示文案。只会发生在服务器负载过载时会启动，因此只会发生短暂不可用时刻，由于此时服务依然还在稳定运行中，等负载下降时，可以快速恢复正常服务。</p><h1 id="在-2G-大小的文件中，找出高频-top100-的单词"><a href="#在-2G-大小的文件中，找出高频-top100-的单词" class="headerlink" title="在 2G 大小的文件中，找出高频 top100 的单词"></a><strong>在 2G 大小的文件中，找出高频 top100 的单词</strong></h1><ol><li>把 2G 的文件进行分割成大小为 512KB 小文件，总共得到 2048 个小文件，避免一</li></ol><p>次性读入整个文件造成内存不足。 </p><ol><li>定义一个长度为 2048 的 hash 表数组，用来统计每个小文件中单词出现的频率。 </li><li>使用多线程并行遍历 2048 个小文件，针对每个单词进行 hash 取模运算分别存储</li></ol><p>到长度为 2048 的 hash 表数组中 </p><p>inthash&#x3D;Math.abs(word.hashCode() %hashTableSize); </p><p>hashTables[hash].merge(word, 1, Integer::sum); </p><ol><li>接着再遍历这 2048 个 hash 表，把频率前 100 的单词存入小顶堆中 </li><li>最后，小顶堆中最终得到的 100 个单词，就是 top 100 了。</li></ol><p>这种解决方案的核心思想是将大文件分割为多个小文件，然后采用分治和堆的算法，来 </p><p>解决这个问题</p><h1 id="设计一个发红包的API"><a href="#设计一个发红包的API" class="headerlink" title="设计一个发红包的API"></a>设计一个发红包的API</h1><p>让你设计一个微信发红包API，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。</p><p>如果是随机红包，根据发红包的人输入的钱数，默认精确到分，也就是0.01元。</p><p>最小的不可再分的单元就是0.01元。</p><p>如果红包的分数是10份，那么就把红包比如50元，那么可以生成1-4991的随机整数。</p><p>极端案例，一个人分得49.91元，剩余九个人每人分得0.01元。</p><p>第一个人分完，剩下的按照这个规则继续。</p><p>微信红包的规则为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">红包金额的区间为 <span class="number">0.01</span> - 平均值的<span class="number">2</span>倍</span><br></pre></td></tr></table></figure><p>该规则为 微信团队公布的算法。</p><p>这也就是说，假设给10个人发送100元的红包，那么：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第一个人得到金额的区间为[<span class="number">0.01</span>,<span class="number">20</span>]</span><br></pre></td></tr></table></figure><p>假设前三个人领到的红包为50元，那么此时红包还剩下 7个人 没有领取红包，红包还剩下 50元 ，那么下一个人可以得到的最大金额为：</p><p>(100-50)&#x2F;(10-3)*2&#x3D;14.29</p><p>第四个人得到的金额的区间为[0.01,14.29]</p><h1 id="实现一个登录拉黑功能，给你一批要拉黑的用户名和手机号，实现拉黑和把已经登陆的被拉黑的用户踢下线。"><a href="#实现一个登录拉黑功能，给你一批要拉黑的用户名和手机号，实现拉黑和把已经登陆的被拉黑的用户踢下线。" class="headerlink" title="实现一个登录拉黑功能，给你一批要拉黑的用户名和手机号，实现拉黑和把已经登陆的被拉黑的用户踢下线。"></a>实现一个登录拉黑功能，给你一批要拉黑的用户名和手机号，实现拉黑和把已经登陆的被拉黑的用户踢下线。</h1><p>在Spring Boot项目中实现登录拉黑功能，可以采用以下一些思路和步骤：</p><h2 id="1-黑名单数据模型设计"><a href="#1-黑名单数据模型设计" class="headerlink" title="1. 黑名单数据模型设计"></a>1. 黑名单数据模型设计</h2><p>首先，需要设计一个数据模型来存储黑名单中的用户名和手机号。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blacklist</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String phoneNumber;</span><br><span class="line">    <span class="comment">// 省略其他字段和getter/setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-黑名单管理接口"><a href="#2-黑名单管理接口" class="headerlink" title="2. 黑名单管理接口"></a>2. 黑名单管理接口</h2><p>提供一个管理接口，允许管理员添加和删除黑名单中的用户名和手机号。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/blacklist&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlacklistController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BlacklistService blacklistService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; addBlacklist(<span class="meta">@RequestBody</span> Blacklist blacklist) &#123;</span><br><span class="line">        blacklistService.addBlacklist(blacklist);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/remove/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; removeBlacklist(<span class="meta">@PathVariable</span> Long id) &#123;</span><br><span class="line">        blacklistService.removeBlacklist(id);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-用户认证拦截"><a href="#3-用户认证拦截" class="headerlink" title="3. 用户认证拦截"></a>3. 用户认证拦截</h2><p>在用户登录时，通过拦截器或过滤器检查用户是否在黑名单中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlacklistAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BlacklistService blacklistService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> ...; <span class="comment">// 获取用户名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">phoneNumber</span> <span class="operator">=</span> ...; <span class="comment">// 获取手机号</span></span><br><span class="line">        <span class="keyword">if</span> (blacklistService.isBlacklisted(username, phoneNumber)) &#123;</span><br><span class="line">            <span class="comment">// 用户在黑名单中，拒绝访问</span></span><br><span class="line">            response.sendError(HttpServletResponse.SC_FORBIDDEN, <span class="string">&quot;账号已被拉黑&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-在线用户管理"><a href="#4-在线用户管理" class="headerlink" title="4. 在线用户管理"></a>4. 在线用户管理</h2><p>对于已经登录的用户，需要有一种机制来检查他们是否被添加到黑名单中，并在必要时将其踢下线。</p><h3 id="使用WebSocket"><a href="#使用WebSocket" class="headerlink" title="使用WebSocket"></a>使用WebSocket</h3><ul><li>通过WebSocket与在线用户保持连接。</li><li>定时检查黑名单，如果发现在线用户被拉黑，则通过WebSocket发送下线通知。</li></ul><h3 id="使用轮询"><a href="#使用轮询" class="headerlink" title="使用轮询"></a>使用轮询</h3><ul><li>用户端定时发送请求到服务器，检查是否被拉黑。</li><li>如果检测到用户被拉黑，服务器返回特定的响应，前端据此进行下线处理。</li></ul><h2 id="5-用户会话管理"><a href="#5-用户会话管理" class="headerlink" title="5. 用户会话管理"></a>5. 用户会话管理</h2><ul><li>使用Spring Session来管理用户会话。</li><li>当用户被拉黑时，可以清除其会话。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlacklistSessionListener</span> <span class="keyword">implements</span> <span class="title class_">SessionDestroyedEvent</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SessionRepository sessionRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(SessionDestroyedEvent event)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">principalName</span> <span class="operator">=</span> (String) event.getPrincipal();</span><br><span class="line">        <span class="comment">// 根据用户名查找会话并清除</span></span><br><span class="line">        sessionRepository.deleteById(principalName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-事件驱动"><a href="#6-事件驱动" class="headerlink" title="6. 事件驱动"></a>6. 事件驱动</h2><ul><li>使用事件发布&#x2F;订阅模式，当黑名单更新时，发布事件。</li><li>订阅者监听事件，如果发现有在线用户被拉黑，执行下线操作。</li></ul><h2 id="7-前端交互"><a href="#7-前端交互" class="headerlink" title="7. 前端交互"></a>7. 前端交互</h2><ul><li>前端页面需要处理来自后端的拉黑通知。</li><li>可以设计一个提示框或弹窗，告知用户账号已被拉黑，并引导用户退出。</li></ul><h2 id="8-安全性考虑"><a href="#8-安全性考虑" class="headerlink" title="8. 安全性考虑"></a>8. 安全性考虑</h2><ul><li>确保黑名单数据的安全性，避免未授权访问。</li><li>对敏感操作（如添加&#x2F;删除黑名单）进行权限验证。</li></ul><h2 id="9-性能优化"><a href="#9-性能优化" class="headerlink" title="9. 性能优化"></a>9. 性能优化</h2><ul><li>考虑黑名单查询的性能，可能需要对数据库进行优化，如建立索引。</li><li>对于大规模用户，考虑使用缓存来减少数据库访问。</li></ul><h2 id="10-测试"><a href="#10-测试" class="headerlink" title="10. 测试"></a>10. 测试</h2><ul><li>对所有新增的功能进行单元测试和集成测试，确保功能的正确性和稳定性。</li></ul><h1 id="怎么判断一个手机号是否为新用户"><a href="#怎么判断一个手机号是否为新用户" class="headerlink" title="怎么判断一个手机号是否为新用户"></a>怎么判断一个手机号是否为新用户</h1><p>在Java面试中，判断一个手机号是否为新用户的问题通常涉及到数据库查询和用户管理的知识。以下是几种可能的解决方案：</p><h2 id="1-数据库查询"><a href="#1-数据库查询" class="headerlink" title="1. 数据库查询"></a>1. 数据库查询</h2><p>最直接的方法是在用户数据库中查询这个手机号是否存在。如果不存在，那么这个手机号就是新用户。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNewUser</span><span class="params">(String phoneNumber)</span> &#123;</span><br><span class="line">    <span class="comment">// 假设有一个UserRepository来访问数据库</span></span><br><span class="line">    <span class="keyword">return</span> !userRepository.existsByPhoneNumber(phoneNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-缓存检查"><a href="#2-缓存检查" class="headerlink" title="2. 缓存检查"></a>2. 缓存检查</h2><p>如果系统对性能要求较高，可以使用缓存来存储已注册的手机号。首先检查缓存，如果缓存中没有这个手机号，再查询数据库。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNewUser</span><span class="params">(String phoneNumber)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cache.containsKey(phoneNumber)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存中没有，查询数据库</span></span><br><span class="line">    <span class="keyword">return</span> !userRepository.existsByPhoneNumber(phoneNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-散列集合"><a href="#3-散列集合" class="headerlink" title="3. 散列集合"></a>3. 散列集合</h2><p>在某些情况下，如果用户数据量不是非常大，可以在内存中使用HashSet来存储所有已注册的手机号。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; registeredPhoneNumbers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNewUser</span><span class="params">(String phoneNumber)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !registeredPhoneNumbers.contains(phoneNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法，比如注册用户时更新HashSet</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-异步检查"><a href="#4-异步检查" class="headerlink" title="4. 异步检查"></a>4. 异步检查</h2><p>如果注册流程对实时性要求不高，可以采用异步的方式来检查手机号是否为新用户，以减少对主线程的阻塞。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;Boolean&gt; <span class="title function_">isNewUserAsync</span><span class="params">(String phoneNumber)</span> &#123;</span><br><span class="line">    <span class="comment">// 异步执行数据库查询</span></span><br><span class="line">    <span class="keyword">return</span> executor.submit(() -&gt; !userRepository.existsByPhoneNumber(phoneNumber));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-批量检查"><a href="#5-批量检查" class="headerlink" title="5. 批量检查"></a>5. 批量检查</h2><p>如果需要同时检查多个手机号，可以设计一个批量查询的方法，以减少数据库的访问次数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, Boolean&gt; <span class="title function_">isNewUsers</span><span class="params">(Collection&lt;String&gt; phoneNumbers)</span> &#123;</span><br><span class="line">    Map&lt;String, Boolean&gt; isNewUserMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 批量查询数据库</span></span><br><span class="line">    List&lt;User&gt; users = userRepository.findAllByPhoneNumberIn(phoneNumbers);</span><br><span class="line">    <span class="keyword">for</span> (String phoneNumber : phoneNumbers) &#123;</span><br><span class="line">        isNewUserMap.put(phoneNumber, !users.stream().anyMatch(user -&gt; user.getPhoneNumber().equals(phoneNumber)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isNewUserMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-利用分布式系统"><a href="#6-利用分布式系统" class="headerlink" title="6. 利用分布式系统"></a>6. 利用分布式系统</h2><p>在分布式系统中，可以使用分布式缓存或分布式数据库来存储和查询手机号，以提高系统的扩展性和可用性。</p><h2 id="7-考虑数据一致性"><a href="#7-考虑数据一致性" class="headerlink" title="7. 考虑数据一致性"></a>7. 考虑数据一致性</h2><p>在设计解决方案时，需要考虑数据一致性问题。例如，如果用户刚刚注册，但是数据还没有同步到所有的数据库副本或缓存节点，可能会错误地判断为新用户。</p><h1 id="平台系统，好几个业务线，其中一个业务线消息生产过多，消息队列积压大量消息，去只想任务时大量操作在A业务里面获取，读取消息要很久，导致其他业务不能使用，如何快速处理"><a href="#平台系统，好几个业务线，其中一个业务线消息生产过多，消息队列积压大量消息，去只想任务时大量操作在A业务里面获取，读取消息要很久，导致其他业务不能使用，如何快速处理" class="headerlink" title="平台系统，好几个业务线，其中一个业务线消息生产过多，消息队列积压大量消息，去只想任务时大量操作在A业务里面获取，读取消息要很久，导致其他业务不能使用，如何快速处理"></a>平台系统，好几个业务线，其中一个业务线消息生产过多，消息队列积压大量消息，去只想任务时大量操作在A业务里面获取，读取消息要很久，导致其他业务不能使用，如何快速处理</h1><ol><li>增加消费者线程数：</li></ol><p>分析当前消费者线程的处理能力，适当增加消费者线程数，以加快消息的消费速度。</p><ol><li>并发优化：</li></ol><p>对A业务中的消息处理逻辑进行并发优化，如使用线程池、并行流等，提高消息处理的并发度。</p><ol><li>批量获取与处理：</li></ol><p>修改消息处理逻辑，使其能够批量获取消息并进行处理，减少每次获取和处理消息的开销。</p><ol><li>消息过滤与优先级：</li></ol><p>在消息队列中增加过滤机制，只处理重要或紧急的消息，暂时忽略非关键消息。</p><p>使用优先级队列，确保重要消息优先被处理。</p><ol><li>异步处理：</li></ol><p>如果A业务的处理逻辑不是实时性要求非常高的，可以考虑将其异步化处理，使用如Spig的</p><p>@Asyc注解或其他异步处理框架。</p><ol><li>缓存策略：</li></ol><p>如果八业务中存在频繁查询数据库或其他服务的操作，可以考虑使用缓存来减少查询次数，提高处</p><p>理速度。</p><ol><li>限流与降级：</li></ol><p>在消息生产者端实施限流策略，控制消息的生产速度。</p><p>对A业务进行降级处理，如暂时关闭一些非核心功能，确保系统整体稳定性。</p><ol><li>队列拆分与扩容：</li></ol><p>如果可能，将消息队列按业务线或消息类型进行拆分，降低单一队列的压力。</p><p>根据需要增加消息队列实例或调整其配置，提高队列的处理能力。</p><ol><li>监控与告警：</li></ol><p>加强消息队列和A业务的监控，实时观察队列长度、处理速度等指标。</p><p>设置合理的告警阈值，当出现异常时及时通知相关人员进行处理。</p><ol><li>错误处理与重试：</li></ol><p>完善错误处理逻辑，当消息处理失败时记录错误信息，并进行合理重试。</p><p>设置重试间隔和最大重试次数，避免无限重试导致的资源浪费和性能问题。</p><h1 id="大型Excel上传到服务器解析到数据库的系统设计"><a href="#大型Excel上传到服务器解析到数据库的系统设计" class="headerlink" title="大型Excel上传到服务器解析到数据库的系统设计"></a>大型Excel上传到服务器解析到数据库的系统设计</h1><p>设计一个用于大型Excel文件上传到服务器并解析到数据库的系统涉及多个步骤，需要仔细规划以确保性能和准确性。</p><p>需求分析</p><p>文件大小限制：确定系统能处理的最大文件大小。</p><p>文件格式：明确支持的Xcel文件格式（如.xs,Xsx)。</p><p>解析需求：确定需要解析的Excel内容（如特定的工作表、单元格范围等）。</p><p>数据库设计：根据Excel内容设计数据库表结构。</p><p>系统架构设计</p><p>总体流程：用户上传Ecl文件→后端接收并存储制临时文件一解析Excel内容→将数据写入数据库→清</p><p>理临时文件。</p><p>文件上传</p><p>前端：提供文件选择和上传的U界面。</p><p>后端：</p><p>接收前端上传的文件。</p><p>将文件保存到临时存储位置。</p><p>返回上传成功的响应给前端。</p><p> Excel解析</p><p>读取文件：使用Apache POI读取临时存储的Excel文件,使用easyExcel解析：利用easyExcel的流式读取特性，逐行解析Ecel内容，而不是一次性加载整个文件到内存。</p><p>解析内容：遍历工作表、行和单元格，提取需要的数据。</p><p>数据校验：对提取的数据讲行校验，确保数据的有效性和完整性</p><p>数据库写入</p><p>连接数据库：建立与数据库的连接。</p><p>批量写入：使用批处理技术将数据批量写入数据库，提高性能。</p><p>错误处理：捕获并处理数据库写入过程中可能出现的错误。</p><p>清理到临时文件</p><p>解析并写入数据库成功后，删除临时存储的Excel文件。</p><h1 id="wx加好友怎么实时同步到好友列表"><a href="#wx加好友怎么实时同步到好友列表" class="headerlink" title="wx加好友怎么实时同步到好友列表"></a>wx加好友怎么实时同步到好友列表</h1><p>涉及到数据库操作、WebSocket、HTTP轮询或者Server-Sent Events等技术。</p><p>1.数据库模型：</p><p>首先，我们需要一个数据库来存储用户信息和好友关系。</p><p>2.添加好友请求：</p><p>当用户发起添加好友请求时，后端需要记录这个请求。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/friends&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriendController</span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> FriendshipService friendshipService;</span><br><span class="line"><span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;?&gt;addFriend(<span class="meta">@RequestBody</span> AddFriendRequest request)&#123;</span><br><span class="line">/验证请求参数</span><br><span class="line">/发起添加好友请求</span><br><span class="line">friendshipService.addFriendRequest(request.getFromUserId(),request.getToU</span><br><span class="line"><span class="keyword">return</span> ResponseEntity.ok(“请求已发送<span class="string">&quot;)：</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">@Service</span></span><br><span class="line"><span class="string">public class FriendshipService&#123;</span></span><br><span class="line"><span class="string">@Autowired</span></span><br><span class="line"><span class="string">private FriendshipRepository friendshipRepository;</span></span><br><span class="line"><span class="string">public void addFriendRequest (int fromUserId,int toUserId)&#123;</span></span><br><span class="line"><span class="string">Friendship friendship new Friendship(fromUserId,toUserId,&quot;</span>pending<span class="string">&quot;);</span></span><br><span class="line"><span class="string">friendshipRepository.save(friendship);</span></span><br><span class="line"><span class="string">//这里可以发送通知给被请求方，或者通过WebSocket推送消息</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>3.实时更新好友列表：</p><p>为了实时更新好友列表，可以使用VebSocketi进行双向通信。下面是一个简化的WebSocket实现：</p><p>VebSocket配置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">EnableWebSocketMessageBroker</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span>&#123;</span><br><span class="line">registry.addEndpoint(<span class="string">&quot;/ws&quot;</span>).withSockJS();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageBroker</span> <span class="params">(MessageBrokerRegistry config)</span>&#123;</span><br><span class="line">config.enableSimpleBroker (<span class="string">&quot;/topic&quot;</span>);</span><br><span class="line">config.setApplicationDestinationPrefixes(<span class="string">&quot;/app&quot;</span>):</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置WebSocket消息处理器</p><p>前端需要使用WebSocket客户端来连接到服务器，并监听&#x2F;topic&#x2F;friendsl以接收实时更新的好友列表。</p><p>1.用户发起好友请求</p><p>前端用户可以通过一个界面选择并发送好友请求给另一个用户。这个请求会发送到后端服务。</p><p>2.后端处理好友请求</p><p>后端服务接收到好友请求后，需要进行一系列的验证和处理，包括检查用户是否存在、是否已经发送过好友请求等。</p><p>3.存储好友请求</p><p>一旦好友请求被验证和处理，它应该被存储在数据库中，等待对方用户的确认。</p><p>4.通知对方用户</p><p>可以通过推送通知、邮件或其他方式通知对方用户收到了好友请求。</p><p>5.对方用户确认或拒绝好友请求</p><p>对方用户可以通过前端界面确认或拒绝好友请求。这一操作同样会发送到后端服务进行处理</p><p>6.更新好友关系</p><p>如果对方用户确认了好友请求，后端服务需要更新数据库中的好友关系，并可能需要触发一些额外的逻辑，比如通知新好友、发送欢迎消息等。</p><p>7.实时同步好友列表</p><p>为了实现好友列表的实时更新，可以使用WebSocket或Server–Sent Events(SSE)等技术。当好友关系发生变化时，后端服务可以主动向前端推送更新。</p><h1 id="wx头像更换怎么实时同步更新给所有好友"><a href="#wx头像更换怎么实时同步更新给所有好友" class="headerlink" title="wx头像更换怎么实时同步更新给所有好友"></a>wx头像更换怎么实时同步更新给所有好友</h1><p>在微信这样的社交应用中，当某个用户更换头像时，需要实时地将这个更新同步给该用户的所有好友。为了实现这一功能，通常需要采用以下几种关键技术：</p><p>1.消息队列：用于异步处理头像更新事件，并通知相关的服务进行同步。</p><p>2.缓存：为了减轻数据库压力和提高响应速度，通常会将好友关系和头像信息存储在缓存中。</p><p>3.WebSocket或长轮询：用于实时地将头像更新推送给好友。</p><p>以下是一个简化的实现方案：</p><ol><li>用户上传新头像</li></ol><p>用户通过前端界面选择并上传新的头像。前端将头像数据发送给后端。</p><ol><li>后端处理头像更新</li></ol><ul><li>后端接收到头像数据后，先存储到对象存储服务(如AWSS3、阿里云OSS等)或本地文件系统中，并获取头像的访问URL。</li><li>更新数据库中该用户的头像URL。</li><li>将头像更新事件发送到消息队列（如Kafka、RabbitMQ等)。</li></ul><ol><li>消息队列消费者处理头像更新事件</li></ol><ul><li>消息队列的消费者监听头像更新事件</li><li>当接收到头像更新事件时，从数据库中或缓存中获取该用户的好友列表。</li><li>对于每个好友，生成一个包含新头像URL的更新消息。</li></ul><ol><li>将头像更新消息推送给好友</li></ol><ul><li>如果系统使用WebSocket,则可以通过WebSocket连接将更新消息推送给在线的好友。</li><li>如果好友不在线或WebSocket连接不可用，可以将更新消息存储在消息存储服务（如Redis)中，等待好友下次上线时拉取。</li><li>对于使用长轮询的方式，可以在轮询请求中返回最新的更新消息</li></ul><ol><li>好友接收并显示新头像</li></ol><ul><li>好友收到头像更新消息后，根据消息中的新头像URL加载并显示新头像。</li><li>如果使用了缓存机制，可能还需要清理旧的头像缓存，确保显示的是最新的头像。</li></ul><p>注意事项：</p><p>安全性：确保头像上传和处理的安全性，防止恶意文件上传和SQL注入等安全问题。</p><p>性能优化：对于大量用户和频繁的头像更新，需要优化数据库和缓存的读写性能，以及消息队列的处理速度。</p><p>容错处理：考虑在各个环节中添加适当的容错处理机制，如重试、降级等，以确保系统的稳定性和可用性。隐私保护：在处理用户头像等个人信息时，雲要尊守相关的隐私政策和法律法规</p><h1 id="wx不同设备登录怎么保持消息一致性"><a href="#wx不同设备登录怎么保持消息一致性" class="headerlink" title="wx不同设备登录怎么保持消息一致性"></a>wx不同设备登录怎么保持消息一致性</h1><ol><li>用户登录与设备管理</li></ol><ul><li>设备识别：当用户在新设备上登录时，系统应记录该设备与用户的绑定关系。可以使用设备D(如手机的MEI号、UUID等)作为唯一标识符。</li><li>登录验证：确保使用安全的登录验证机制，如OAuh2.0或WT,以验证用户身份和设备合法性。</li></ul><ol><li>消息存储与同步</li></ol><ul><li>消息存储：所有消息应存储在可靠的消息存储服务中，如数据库或消息队列（如Kafka、RabbitMQ等)。每条消息都应包含发送者、接收者、内容、时间戳等关键信息。</li><li>消息同步机制：</li></ul><p>当用户在新设备上登录时，系统应检查该用户的未读消息，并通过WebSocket、HTTP长轮询或推</p><p>送通知等方式将这些消息推送到新设备上。</p><p>对于实时消息，可以使用WebSocket建立持久连接，以便实时推送新消息到所有登录设备。</p><ol><li>消息状态管理</li></ol><ul><li>消息状态更新：当用户阅读消息时，系统应更新消息的状态（如“已读”状态）。这可以通过调用后端API来实现，API将更新数据库中消息的状态。</li><li>状态同步：当消息状态更新后，系统应通知其他登录设备同步更新消息状态。这可以通过WebSocket的实时通信功能实现。</li></ul><ol><li>安全性考虑</li></ol><ul><li>数据加密：传输和存储的消息应进行加密处理，以防止数据泄露。</li><li>访问控制：确保只有授权的设备可以访问和接收用户的消息。使用访问令牌或身份验证机制来验证设备的合法性。</li></ul><ol><li>辅助措施</li></ol><ul><li>冲突解决：在多个设备同时操作时（如同时标记消息为已读），需要实现冲突解决机制，确保数据的一致性。</li><li>日志记录：记录所有与消息同步相关的操作日志，以便在出现问题时进行排查和审计。</li></ul><ol><li>技术和工具选择</li></ol><ul><li>消息队列：使用高性能的消息队列服务来处理消息的存储和同步，确保消息的可靠性和实时性。</li><li>WebSocket:利用VebSockets实现实时通信和消息推送，确保消息的及时到达和同步。</li><li>数据库：选择适合业务需求的数据库系统来存储消息和用户状态信息，确保数据的安全性和一致性</li></ul><p>注意事项</p><ul><li>在实现过程中，需要考虑到不同网络环境和设备性能的差异，确保方案的健壮性和可扩展性。</li><li>对于大量用户和高并发场景，需要进行充分的性能叙测试和优化，以确保系统的稳定性和性能。</li></ul><h1 id="拿一个身份信息去请求多个不同服务的积分接口，需要快速求出平均积分，如何实现？"><a href="#拿一个身份信息去请求多个不同服务的积分接口，需要快速求出平均积分，如何实现？" class="headerlink" title="拿一个身份信息去请求多个不同服务的积分接口，需要快速求出平均积分，如何实现？"></a>拿一个身份信息去请求多个不同服务的积分接口，需要快速求出平均积分，如何实现？</h1><ol><li>定义积分接口：首先，我们需要定义各个服务提供的积分接口。这些接口应该有统一的请求和响应格</li></ol><p>式，以便我们可以统一处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PointService</span> t</span><br><span class="line">CompletableFuture&lt;Double&gt;getPoints(String identity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了CompletableFuture来代表一个异步的积分获取操作。</p><ol><li>实现并发请求：接下来，我们可以使用Java的并发工具，如CompletableFuture或ExecutorService,来并发地请求各个服务的积分接口。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;CompletableFuture&lt;Double&gt;&gt;futures <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (PointService service services)&#123;</span><br><span class="line">futures.add(service.getPoints(identity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>等待所有请求完成：然后，我们需要等待所有的请求都完成。这可以通过completableFuture.allof方法实现。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt;allFutures CompletableFuture.al10f(futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>))</span><br><span class="line">a11 Futures.join():<span class="comment">//等待所有请求完成</span></span><br></pre></td></tr></table></figure><ol><li>计算平均积分：当所有的请求都完成后，我们可以遍历futures:列表，获取每个服务的积分，并计算平均值。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Double&gt;points futures.stream()</span><br><span class="line">.map(CompletableFuture:join)/获取每个Futuref的结果</span><br><span class="line">collect(Collectors.toList());</span><br><span class="line"><span class="type">double</span> sum points.stream().mapToDouble(Double:doubleValue).sum();</span><br><span class="line"><span class="type">double</span> average sum points.size():</span><br></pre></td></tr></table></figure><ol><li>异常处理：在实际的应用中，我们还需要考虑异常处理。如果某个服务请求失败，我们应该能够捕获这个异常，并记录或处理它，而不是让整个程序崩溃。这可以通过在Comp1etab1 eFuture.上添加异常处理函数来实现。</li><li>优化和扩展：这个方案是一个基本的实现，但在实际应用中可能还需要进一步优化和扩展。例如，如果服务的数量非常多，或者每个服务的响应时间很长，那么可能需要考虑使用更高效的并发控制策略，如连接池或线程池。此外，还可以考虑使用更复杂的并发控制工具，如Reactive Programming或Project Reactor,来更好地做处理并发请求和响应。</li></ol><h1 id="防沉迷系统时间登录的模拟"><a href="#防沉迷系统时间登录的模拟" class="headerlink" title="防沉迷系统时间登录的模拟"></a>防沉迷系统时间登录的模拟</h1><ol><li>时间处理与比较：</li></ol><ul><li>使用Java的日期和时间APl(如LocalDateTime、ZonedDateTimes等)来处理时间相关的逻辑。</li><li>可以通过比较当前时间与设定的允许登录时间段来判断用户是否可以登录。</li></ul><ol><li>数据库管理：</li></ol><ul><li>使用数据库（如MySQL、Oracles等）来存储用户的基本信息、登录记录以及防沉迷设置。</li><li>通过查询数据库来判断用户的年龄和登录状态，以及记录用户的登录时间和行为。</li></ul><ol><li>认证与授权：</li></ol><ul><li>使用JWT(JSON Web Tokens)或OAuth等认证机制来验证用户的身份和权限。</li><li>对于未成年用户，可以根据其身份信息启用或调整防沉迷限制。</li></ul><ol><li>定时任务与调度：</li></ol><ul><li>利用Java的定时任务框架（如Quartz、Spring Task等）来定期检查用户的登录状态和时间。</li><li>可以设置定时任务来强制未成年用户在特定时间下线或限制其登绿。</li></ul><ol><li>日志记录与监控：</li></ol><ul><li>使用日志框架（如Log4j、SLF4J等）记录用户的登绿行为、时间以及任何与防沉迷系统相关的操</li></ul><p>作。</p><ul><li>通过监控工具实时监控系统的运行状态和用户行为，以便及时发现和处理异常情况。</li></ul><ol><li>异常处理与错误反馈：</li></ol><ul><li>使用java的异常处理机制来处理在登录过程中可能出现的各种异常情况。</li><li>对于不满足登录条件的用户，提供友好的错误提示和反馈。</li></ul><ol><li>缓存技术：</li></ol><ul><li>利用缓存技术（如Redis、Memcached等）来提高系统的响应速度和性能。</li><li>可以将用户的登录状态、时间等常用信息缓存起来，减少数据库访问次数。</li></ul><h1 id="现在有一个交易性的数据，日增长量可能达到千万级别的数据，交易完成后数据就不会发生变化了，但是会频繁地查询数据，请针对这个场景对数据库的设计和表的设计给出一些建议"><a href="#现在有一个交易性的数据，日增长量可能达到千万级别的数据，交易完成后数据就不会发生变化了，但是会频繁地查询数据，请针对这个场景对数据库的设计和表的设计给出一些建议" class="headerlink" title="现在有一个交易性的数据，日增长量可能达到千万级别的数据，交易完成后数据就不会发生变化了，但是会频繁地查询数据，请针对这个场景对数据库的设计和表的设计给出一些建议"></a>现在有一个交易性的数据，日增长量可能达到千万级别的数据，交易完成后数据就不会发生变化了，但是会频繁地查询数据，请针对这个场景对数据库的设计和表的设计给出一些建议</h1><ol><li>表结构的设计</li></ol><p>字段精简：只保留必要的字段，避免冗余和不必要的复杂结构。</p><p>选择合适的数据类型：使用最小的合适数据类型来存储数据，例如使用INT代替VARCHAR来存储整</p><p>数，使用DATETIME或TIMESTAMP来存储时间戳。</p><p>固定长度字段：尽量使用固定长度的字段，因为M小ySQL处理固定长度的字段更快。</p><ol><li>索引优化</li></ol><p>主键索引：确保表有一个唯一且简短的主键，这通常是交易引D或类似的唯一标识符。</p><p>查询优化索引：为经常用于查询的字段（如用户D、交易类型、时间等）创建索引。但要注意，</p><p>过多的索引会影响写入性能，因此需要权衡。</p><p>复合索引：如果经常按多个字段进行查询，考虑创建复合索引。</p><p>避免全表扫描：通过合适的索引来避免全表扫描，从而提高查询效率。</p><ol><li>分区</li></ol><p>水平分区：考虑按时间范围或某种业务逻辑对数据进行水平分区，这样可以将查询分散到不同的分</p><p>区上，提高查询效率。</p><ol><li>读写分离</li></ol><p>读写分离：实施读写分离策略，将读操作和写操作分散到不同的数据库实例成服务器上。可以使用</p><p>MySQL的主从复制功能来实现。</p><ol><li>缓存</li></ol><p>查询缓存：虽然MySQL有查询缓存功能，但在高并发和繁更新的场景下，查询缓存可能会导致性能下降。因此，需要根据实际情况决定是否启用查询缓存。</p><p>应用层缓存：使用Redis等内存数据库在应用层缓存频繁查询的数据，减少对MySQL的访问压力。</p><h1 id="在使用数据库时，数据库的CPU使用率非常高，如何排查这个问题"><a href="#在使用数据库时，数据库的CPU使用率非常高，如何排查这个问题" class="headerlink" title="在使用数据库时，数据库的CPU使用率非常高，如何排查这个问题"></a>在使用数据库时，数据库的CPU使用率非常高，如何排查这个问题</h1><p>一般而言，cpu使用率飙升可归纳为以下两点：</p><ul><li>大量的慢sql占用了cpu资源，拖垮了数据库，这类的慢sql常常表现为：查询的数据量过大，全表扫描、锁抢占甚至死锁、复杂查询等</li><li>QPS过高，本质上是数据库的承载的流量过大</li></ul><p><strong>慢<strong><strong>sql</strong></strong>优化思路</strong></p><ul><li>1.扫描数据库记录数较多。</li></ul><p>考虑表是否设置了合理的索引，表字段是否设置了合理的数据类型，sql是否有效的利用了索引等。</p><ul><li>2.sql中是否有做了大量的聚合、计算？</li></ul><p>考虑将sql简化，把逻辑操作上浮到业务中去做。</p><ul><li>3.sql返回的记录数过多。 考虑分页实现，通过limit将一次请求转为多次请求。</li><li>4.表中是否冗余字段过多？ 表若为宽表，包含大量冗余字段，可考虑分表。</li><li>5.库中是否有很多张表？ 此时可考虑将表拆分到多个库中，分库。</li><li>6.若库的读写较多，锁争抢激励，甚至死锁。 可考虑多库做读写分离。</li><li>7.机器的本身性能较低，不符合业务需求。 可考虑机器升级了。</li></ul><p><strong>qps****过高优化思路。</strong></p><ul><li>1.qps过高时，考虑是否可以使用缓存。</li><li>2.使用批量操作，将多个操作合并为一次请求，但此种方式需要考虑是否可以一次批量的数据有多大，避免造成慢sql。</li><li>3.考虑分库、读写分离，减少对一个机器的访问压力。</li><li>4.机器升级，没什么是钱解决不了的。</li></ul><h1 id="实现b站弹幕设计"><a href="#实现b站弹幕设计" class="headerlink" title="实现b站弹幕设计"></a>实现b站弹幕设计</h1><p>架构设计考虑以下几个场景：</p><ul><li>支持直播弹幕回放</li><li>用户进入直播间可以推送最新几秒的弹幕数据</li><li>长连模式和短连模式可以做降级切换</li></ul><p>为了不影响读写的性能，采用读写分离架构。</p><ul><li>写服务：若不考虑历史弹幕可回放，可以直接使用 Redis 作为唯一存储。若考虑支持弹幕的回放，数据还是需要持久化，可以考虑使用 MySQL 或者 TiDB，暂且认为写入不是较大的瓶颈。如果有更高性能的写需求，HBase、OpenTSDB 等都可以解决问题。</li><li>读服务：Redis 主要用于读缓存，缓存直播间最新的弹幕数据，采用直播间 ID 作为 Key。系统读服务最大 QPS &#x3D; Redis 集群QPS。</li></ul><p>Redis 存储结构选择：SortedSet。</p><ul><li>提交弹幕：ZADD，score 设置为时间戳。进一步优化可以只存储时间的 delta 值，减少<a href="https://cloud.tencent.com/product/cdcs?from_column=20065&from=20065">数据存储</a>量。</li><li>弹幕查询：ZRANGEBYSCORE 定时轮询弹幕数据。</li></ul><p>有什么问题？</p><ul><li>系统性能与 Redis 集群容量强相关，性能提升需要扩容 Redis，成本高。</li><li>Redis 重复请求较多，相同直播间会存在很多重复的轮询请求。</li></ul><p><strong>缓存优化</strong></p><p>如果能让最新的实时弹幕数据都能命中本地缓存，那性能是最高的，同时大幅度降低了 Redis 的读取压力。所以弹幕读服务可以每秒轮询 Redis 数据，构建本地缓存。</p><p>热点问题：</p><ul><li>假设同时在线的直播间有 10000 个，读服务机器有 50 台，那么每秒轮询 Redis 的 QPS &#x3D; 10000 * 50 &#x3D; 50w，读取请求线性膨胀。</li><li>本地内存的使用量也随直播间的数量增长而膨胀，每个直播间的缓存的数据量降低，导致本地缓存的命中率降低，容易导致 GC 频繁。</li></ul><p><strong>热点优化</strong></p><p>如何降低本地缓存的使用量？</p><ul><li>因为火爆的直播间会占据整个平台大部分的流量，可以只针对火爆的直播间开启本地缓存。</li><li>通过路由控制同一个直播间的请求分发到固定的几台机器，例如一致性 Hash 算法。通过减少读服务机器上的直播间数量，达到降低本地缓存使用量的目的。</li></ul><p>上述方法可以有效地解决问题，但是不能解决流量不均衡的问题。不同直播间分配的机器资源不是拍脑袋定的，需要有理论依据，<code>可以根据直播间的一些数据指标进行动态分配机器资源。</code></p><ul><li>增加对直播间数据指标的统计，如单机 QPS、集群 QPS、单机直播间在线数等。</li><li>关于自适应的<a href="https://cloud.tencent.com/product/clb?from_column=20065&from=20065">负载均衡</a>又是一个可以深挖的话题，在这里我们讨论几个常用的方案，有可能结合起来使用效果更好。<ul><li>分桶：不同 QPS 的范围段划分为不同的桶，根据桶范围的不同分配的机器数量也是不同的。</li><li>最大最小公平分配：根据直播间的 QPS 划分资源需求的权重比例，根据总机器的数量和权重比例来分配机器数量。</li><li>启发式算法：遗传算法、蚁群算法等。</li></ul></li></ul><p><strong>客户端<strong><strong>长连接</strong></strong>推送</strong></p><p>为了保障客户端消息的推送性能和实时性，长连接基本是必备的，最新的消息可以直接采用长连接实时推送。</p><ul><li>Push Server 从 Redis 中获取用户和直播间的订阅关系以及长连接信息。</li><li>连接代理只负责与客户端保持长连接。</li><li>海量的消息推送需要批量压缩。</li></ul><p><strong>弹幕回放</strong></p><p>增加一组专门用于回放的 Redis 集群，同时增加回放的本地缓存，其余设计与上述方案保持一致。</p><p>主要讨论了以下几个点：</p><ul><li>读写分离的架构设计</li><li>通过缓存优化读性能</li><li>长连接的方案设计以及客户端的消息推送</li></ul><h1 id="消息队列，两条消息不同topic-不同时间到达，将两条消息关联起来，如何实现"><a href="#消息队列，两条消息不同topic-不同时间到达，将两条消息关联起来，如何实现" class="headerlink" title="消息队列，两条消息不同topic,不同时间到达，将两条消息关联起来，如何实现"></a>消息队列，两条消息不同topic,不同时间到达，将两条消息关联起来，如何实现</h1><ol><li>消息ID与关联ID:</li></ol><ul><li>当发送第一条消息时，生成一个唯一的关联ID(Correlation ID)。</li><li>将这个关联ID作为消息的属性或头部与第一条消息一起发送。</li><li>当需要发送第二条消息时，使用相同的关联D。</li><li>在消息消费者端，当接收到消息时，检查关联性，并尝试将其与之前接收到的消息进行匹配。</li></ul><ol><li>外部存储：</li></ol><ul><li>使用数据库或缓存系统（如Redis)作为外部存储来跟踪消息。</li><li>当第一条消息到达时，将其关键信息（如消息D、时间戳等）存储在外部存储中，并使用一个唯一的键（例如基于消息的某个属性）进行索引。</li><li>当第二条消息到达时，检查其是否包含与第一条消息相关联的属性。如果包含，则从外部存储中检索第一条消息的信息，并进行关联。</li></ul><ol><li>延迟队列或定时任务：</li></ol><ul><li>如果第二条消息总是在第一条消息之后的一个可预测的时间窗口内到达，可以使用延迟队列或定时任务来处理。</li><li>当第一条消息到达时，将其存储在某个临时位置（如数据库、内存队列等）。</li><li>设置一个定时任务或延迟队列，等待一段时间后检查是否有与第一条消息相关的第二条消息。</li><li>如果找到第二条消息，则将它们关联起来。</li></ul><ol><li>消息队列的高级功能：</li></ol><ul><li>一些消息队列系统（如RabbitMQ、Apache Kafka等）提供了死信队列、消息重试等高级功能，可以帮助处理这种情况。</li><li>例如，在RabbitMQ中，可以使用消息的TTL(Time-To-Live)和死信队列来处理超时未处理的消息</li><li>在Apache Kafka中，可以使用流处理工具（如Kafka Streams或Flink)来处理跨多个topic的消息关联。</li></ul><ol><li>应用程序级别的关联：</li></ol><ul><li>在应用程序级别实现消息关联逻辑。这意味着当应用程序消费消息时，它会维护一个内部状态或数据结构来跟踪和关联不同topic的消息。</li><li>这需要应用程序能够处理可能的并发和状态管理问题。</li></ul><h1 id="一个表在不添加字段，不改动表结构的情况下，怎么增加新的属性"><a href="#一个表在不添加字段，不改动表结构的情况下，怎么增加新的属性" class="headerlink" title="一个表在不添加字段，不改动表结构的情况下，怎么增加新的属性"></a>一个表在不添加字段，不改动表结构的情况下，怎么增加新的属性</h1><p>在Java后端开发中，如果需要在不添加字段和不改动表结构的情况下为一个表增加新的属性，可以考虑以下几种策略：</p><p>\1. <strong>使用JSON字段</strong>：</p><p>   如果数据库表中已经有一个JSON类型的字段，可以在该字段中添加新的属性。Java后端可以通过解析和修改JSON数据来实现。</p><p>\2. 使用视图（View）：</p><p>   在数据库中创建一个视图，该视图基于原表，并添加了需要的新属性（可能是通过计算得到的）。Java后端查询视图而非原表。</p><p>\3. 使用缓存：</p><p>   在应用程序中使用缓存（如Redis）来存储额外的属性。每次表中的数据被访问或修改时，应用程序逻辑负责更新缓存中的属性。</p><p>\4. 使用中间件或服务：</p><p>   创建一个中间件或服务，它在数据访问层和业务逻辑层之间工作，负责在不改变数据库表结构的情况下添加额外的属性。</p><p>\5. 使用应用程序逻辑：</p><p>   在Java应用程序中添加逻辑来处理新的属性。例如，可以根据现有的数据计算新的属性值，或者从其他数据源获取这些值。</p><p>\6. 使用数据库触发器（如果适用）：</p><p>   如果数据库支持，可以创建触发器来自动填充额外的属性到另一个表或缓存中。但这通常需要对数据库结构有所改动。</p><p>\7. 使用数据库函数：</p><p>   利用数据库的函数功能，在查询时动态计算新的属性值。</p><p>\8. 使用外部数据存储：</p><p>   将新的属性存储在外部系统（如NoSQL数据库、搜索引擎等），通过应用程序逻辑来同步和查询这些数据。</p><p>\9. 使用数据库扩展（如果数据库支持）：</p><p>   某些数据库支持通过插件或扩展来添加新的功能，这可能允许在不改变表结构的情况下添加属性。</p><p>\10. 使用ORM框架的特性：</p><p>​    如果使用ORM框架（如Hibernate），可以利用框架提供的特性来映射额外的属性，例如通过关联对象或动态映射。</p><h1 id="设计一个累充奖励系统"><a href="#设计一个累充奖励系统" class="headerlink" title="设计一个累充奖励系统"></a>设计一个累充奖励系统</h1><p>一、系统架构设计</p><p>1.功能性需求</p><ul><li>用户充值记录：记录用户充值金额和时间。</li><li>奖励规则配置：设置不同充值金额对应的奖励。</li><li>奖励发放：根据用户的充值记录，自动发放奖励。</li></ul><p>二、数据库设计</p><p>1.数据表设计</p><p>用户表(user):存储用户信息，如用户D、用户名等。</p><p>充值记录表(recharge_record砂：存储用户的充值信息，如用户ID、充值金额、充值时间等。</p><p>奖励规则表(reward_ru1e:存储奖励规则，如充值金额阈值、对应奖励等。</p><p>奖励发放记录表(reward_record):存储奖励发放记录，如用户ID、奖励内容、</p><p>发放时间等</p><p>2.索引设计</p><p>在recharge_.record表的user_id和recharge._time字段上建立索引，提高查询效率</p><p>在reward_ru1e表的充值金额阈值字段上建立索引，方便根据充值金额查找对应的奖励。</p><p>3.关联关系</p><p>通过用户lD,recharge_.recordi和reward_recor表可以与user表进行关联。</p><p>通过奖励规侧则lD,reward_record表可以与reward_rule表进行关联。</p><ol><li><strong>数据库性能优化</strong>：<ol><li>定期优化查询语句，避免复杂的联表查询。</li><li>使用分页查询，避免一次性加载大量数据。</li></ol></li><li><strong>读写分离</strong>：<ol><li>将读操作和写操作分离到不同的数据库服务器。</li></ol></li><li><strong>分库分表</strong>：<ol><li>根据业务需求进行垂直或水平分库分表。</li></ol></li><li><strong>数据缓存</strong>：<ol><li>对频繁访问且不常变更的数据使用缓存策略。</li></ol></li><li><strong>异步处理</strong>：<ol><li>对于非实时性要求的操作，如奖励发放，可以采用异步处理。</li></ol></li><li><strong>数据备份与恢复</strong>：<ol><li>定期备份数据库，确保数据安全。</li></ol></li><li><strong>高可用性</strong>：<ol><li>通过主从复制、集群等方式提高数据库的可用性。</li></ol></li><li><strong>监控与告警</strong>：<ol><li>实施数据库性能监控，设置阈值告警。</li></ol></li><li><strong>数据一致性</strong>：<ol><li>使用事务管理确保数据操作的原子性、一致性、隔离性和持久性。</li></ol></li></ol><h1 id="百万级别以上的数据是怎么删除的"><a href="#百万级别以上的数据是怎么删除的" class="headerlink" title="百万级别以上的数据是怎么删除的"></a>百万级别以上的数据是怎么删除的</h1><p>当需要删除百万级的数据时，为了提高删除速度和减少对数据库性能的影响，可以采取以下一些优化技巧。</p><p><strong>使用批量删除</strong></p><p>为了减少数据库的IO开销，可以将删除操作分批进行。例如，将百万级数据分为一千个批次，每个批次删除一千行数据，可以使用循环语句结合LIMIT子句来实现。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> unique_checks<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> foreign_key_checks<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">WHILE row_count <span class="operator">&gt;</span> <span class="number">0</span> DO</span><br><span class="line">    <span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">condition</span> LIMIT <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">SET</span> row_count <span class="operator">=</span> ROW_COUNT();</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> autocommit<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> unique_checks<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> foreign_key_checks<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们关闭了自动提交（autocommit）、唯一键检查（unique_checks）和外键检查（foreign_key_checks）来优化删除过程。同时，采用循环的方式，每次删除一千行数据，并在每次删除后提交事务，直到所有的数据都被删除完。</p><p><strong>禁止触发器和索引</strong></p><p>删除大规模数据时，触发器和索引的维护可能会导致性能下降。为了提高删除速度，可以暂时禁止触发器和索引的维护，删除完成后再重新启用。可以使用以下语句来禁止和启用触发器和索引的维护。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 禁止触发器</span></span><br><span class="line"><span class="keyword">SET</span> session trigger_definer<span class="operator">=</span>&quot;DEFINER=your_definer_name@localhost&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 禁止索引维护</span></span><br><span class="line"><span class="keyword">SET</span> session sql_log_bin<span class="operator">=</span><span class="number">0</span>; </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name DISABLE KEYS;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 启用索引维护</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name ENABLE KEYS;</span><br><span class="line"><span class="keyword">SET</span> session sql_log_bin<span class="operator">=</span><span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 启用触发器</span></span><br><span class="line"><span class="keyword">SET</span> session trigger_definer<span class="operator">=</span>&quot;&quot;;</span><br></pre></td></tr></table></figure><p><strong>使用分区表</strong></p><p>对于分区表来说，删除数据只需删除相应分区即可，这样就避免了扫描整个表的操作，提高了删除速度。可以使用以下语句删除分区表中的数据。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">PARTITION</span> partition_name;</span><br></pre></td></tr></table></figure><p>需要注意的是，使用分区表需要提前设计好分区策略，合理设置分区数量和范围，以便更好地支持删除操作。</p><p><strong>其他优化技巧</strong></p><ul><li>如果删除的数据涉及外键约束，可以先禁用外键约束再进行删除操作，以避免约束检查的开销。</li><li>使用合适的索引，能够加快删除操作的速度。</li><li>选择非繁忙时段进行删除操作，以避免对正常业务操作的影响。</li></ul><h1 id="多人调用请求，如果某一个人的请求发生了错误，如何具体定位到哪个人的调用出现了错误"><a href="#多人调用请求，如果某一个人的请求发生了错误，如何具体定位到哪个人的调用出现了错误" class="headerlink" title="多人调用请求，如果某一个人的请求发生了错误，如何具体定位到哪个人的调用出现了错误"></a>多人调用请求，如果某一个人的请求发生了错误，如何具体定位到哪个人的调用出现了错误</h1><ol><li><strong>请求跟踪ID</strong>：为每个请求生成一个唯一的跟踪ID（Trace ID），并将其存储在日志中。这样，即使在分布式系统中，也能追踪到请求的完整路径。</li><li><strong>用户会话标识</strong>：使用用户会话标识（如Session ID或JWT Token）来关联请求和用户。确保每个请求都包含这个标识，并在日志中记录。</li><li><strong>日志记录</strong>：使用日志框架（如Log4j、SLF4J等）记录详细的请求日志。日志应包括时间戳、请求ID、用户会话标识、请求的URL、方法、IP地址、错误信息等。</li><li><strong>异常捕获</strong>：在代码中使用try-catch块捕获异常，并记录异常信息。确保异常信息中包含足够的上下文，以便于问题定位。</li><li><strong>错误码和消息</strong>：为不同的错误类型定义错误码和错误消息，这样在日志中可以快速识别错误类型。</li><li>**中间件&#x2F;**<strong>拦截器</strong>：使用中间件或拦截器来处理请求和响应，记录每个请求的开始和结束时间，以及任何异常。</li><li><strong>分布式****跟踪</strong>：如果系统是分布式的，可以使用分布式跟踪系统（如Zipkin、Jaeger等）来跟踪请求在各个服务之间的流动。</li><li><strong>性能监控</strong>：使用性能监控工具（如New Relic、Datadog等）来监控服务的性能和健康状态。</li><li><strong>错误报告工具</strong>：集成错误报告工具（如Sentry、Rollbar等），它们可以捕获异常并提供详细的错误报告。</li><li><strong>审计日志</strong>：对于敏感操作，记录审计日志，包括操作人、操作时间、操作内容等信息。</li><li><strong>用户反馈</strong>：允许用户提供反馈，这可以作为定位问题的辅助手段。</li><li><strong>测试和验证</strong>：通过自动化测试（单元测试、集成测试等）来验证代码的正确性，减少错误发生的概率。</li><li><strong>代码审查</strong>：定期进行代码审查，以发现潜在的错误和性能问题。</li><li><strong>文档化</strong>：确保所有的错误处理和日志记录策略都有文档记录，以便团队成员理解和遵循</li></ol><h1 id="支付系统该如何设计"><a href="#支付系统该如何设计" class="headerlink" title="支付系统该如何设计"></a>支付系统该如何设计</h1><h2 id="支付系统总览"><a href="#支付系统总览" class="headerlink" title="支付系统总览"></a><strong>支付系统总览</strong></h2><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=Mjk4ZTk0YzM2YzRmMTFlYWU5OGQzZTgxMDA1ZWFmZjZfRzl1RGU2NUs4Rm5Ia1lXcXJVM3d6cGMxbUxsUjRmeU9fVG9rZW46Vlk4TGJTWmZPb2R0YkZ4N21IMWNUSVFHbmxmXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h2 id="核心系统解析"><a href="#核心系统解析" class="headerlink" title="核心系统解析"></a><strong>核心系统解析</strong></h2><h3 id="交易核心"><a href="#交易核心" class="headerlink" title="交易核心"></a><strong>交易核心</strong></h3><p>交易核心把公司的业务系统和底层支付关联起来，让业务系统专注于业务，不必关心底层支付。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MmEwNWY2ZGFiMzE2MjZmM2M0ZTFhNDQ1NGU4NmYzYzFfQlFiR1JkOEU5QWE2b1ZpZGRxQUI0dVQ2WlNRN2hjalNfVG9rZW46VlNncmJMTHFxb1ZzV3R4TlI4R2NwcDdNblNnXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p><strong>基础交易类型抽象</strong></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTgxZmRiYWJmZmUzMTVlYmE5MzhlNDJiZjA0NzkyNGRfZHBZenNyVlRmVWJSZ2xDN0JJQm43ZHRldkI0dzhUZUtfVG9rZW46S1BSd2JEdkh2b1VLNmx4YllpMGNib0lobmRlXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p><strong>多表聚合 &amp; 订单关联</strong></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YTIxZWU3MDc0NmYyZWNlOWYxMTQ1Y2M4NTllN2E3NzRfQWZwNDA1ZjhaSXdQUUp4bTRHS21EdndUU2NnTEtSaTJfVG9rZW46RENLSGJOWjNjb0FWT0d4bGl4NmNHRmV1blJoXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h3 id="支付核心"><a href="#支付核心" class="headerlink" title="支付核心"></a><strong>支付核心</strong></h3><p>支付核心主要负责将多种支付类型进行抽象，变成<code>充值</code>、<code>提现</code>、<code>退款</code>、<code>转账</code>四种支付形态。同时，还要负责集成多种支付工具，对支付指令进行编排等等。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2M2YzIxYTAxYjZjN2NiNDBlMzU5ZmJkZDBhNjEzYmFfbHVKVWN5RXFqUk1uSmQ0Z0t2YzFnUnk2Tld6TDNrcnBfVG9rZW46UWplVmJDOUZQbzliaHV4c2RncGNhNDBabkZiXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p><strong>支付行为编排</strong></p><p>其目的，是实现<code>插件式开发</code>、<code>支付规则可配置</code>的 灵活开发方式</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MDJjYTAxMzliYTExNzc1NDJiMGI5NjAxNmM0YWEzOWRfdEdwSkh1NWtzWm9naEtKdTFseVZCYktDNkRIbWNDclhfVG9rZW46RnFOYWJuZnpMbzNRMTl4Y2RheWNzM0xMbnZiXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p><strong>异常处理</strong></p><p>异常处理包括了 重复支付、部分支付、金额不一致、其他异常等异常场景。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWRhNTM4NmUzYWU0MTkyNjYyMDAzYjEyY2EzNWE4ZGFfUG5hNExqVnpoNVNGZWJzRW9KSFc0V0N2dFlFUlFKWUFfVG9rZW46Uzl3TGJ6TnF0b2VYY3B4UmZKUmM2TzFBbkdnXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h3 id="渠道网关"><a href="#渠道网关" class="headerlink" title="渠道网关"></a><strong>渠道网关</strong></h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YWY2NjM2NzNjMWFlNzVmOWU2ZmQ1NmNhMGRhMGQxYmRfU2lRN2x6em14c0NrVmRDOTY1Ym01QXZtb1ZLZDhNUkhfVG9rZW46Rk55d2JqQXM0b21MQ2Z4M1l6cGNNUW53bmtnXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h3 id="资金核算"><a href="#资金核算" class="headerlink" title="资金核算"></a><strong>资金核算</strong></h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MGVjODQxOWViNjdkYTc4ZjhkMmExNWY4ZDk0NWZlYTdfdUpPUnZaSGpZUE1sdEdSeWdDMTcyYjlkMkRvSVpjSXpfVG9rZW46TWhJeGJNYTVBbzBuak14QVJWMWN3QlZQbmRjXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a><strong>服务治理</strong></h2><h3 id="平台统一上下文"><a href="#平台统一上下文" class="headerlink" title="平台统一上下文"></a><strong>平台统一上下文</strong></h3><p>通过确定系统边界、业务建模拆分之后，整个支付平台被拆分几十个服务，而如何保障在服务间流转业务信息不被丢失，是我们需要考虑的问题。平台统一上下文的要素信息（唯一业务标识码），在整个支付平台链路中全程传递，被用来解决这个问题。</p><h3 id="数据一致性治理"><a href="#数据一致性治理" class="headerlink" title="数据一致性治理"></a><strong>数据一致性治理</strong></h3><p>大型的支付公司，内部都有非常严格和完备的数据一致性方案，比如采用业务侵入性非常大的分布式事务等，以牺牲开发效率来提升数据的稳定，是非常有必要的。而业务公司，如果不采用分布式事务又有哪些应对策略呢？</p><h4 id="CAS-校验"><a href="#CAS-校验" class="headerlink" title="CAS 校验"></a><strong>CAS 校验</strong></h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjYzZjk1NDU3NTlmZTQ0ZjVhMTQ3MWNmMzEzZWRlZGVfYmttaWxWcVZRbkpOcklONUlHQUVldDJyWmtOT05xUjRfVG9rZW46V1JOb2JCV1V3b2RHQXh4ZHR5RGM1ZFprbm1iXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h4 id="幂等-异常补偿"><a href="#幂等-异常补偿" class="headerlink" title="幂等 &amp; 异常补偿"></a><strong>幂等 &amp; 异常补偿</strong></h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MjA4NTk4MTY2YWUzZDMxNjcxZmY4Njc3NDRkZmQ4NWJfb2tOdEVvUFFTWlBRVzh1VlZ6MWI2QXVqM0VZTHZDWGdfVG9rZW46RjU2MGJSUFRCb3MxM3J4ZWdKM2MyTW5tblRiXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h4 id="对账"><a href="#对账" class="headerlink" title="对账"></a><strong>对账</strong></h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTNiZjg0NjhhYTEyNWFkNzFiMDc2ZWQ2MDQ3ZWJhMzlfaHlTOFJ2MllJdWw3S3pCOTg3U2JjYzdPdzl0YXpEZ0dfVG9rZW46Q2RnbGJHWndOb0ZuYVJ4b014c2NoSmlMbnhiXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h4 id="准实时对账"><a href="#准实时对账" class="headerlink" title="准实时对账"></a><strong>准实时对账</strong></h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjQ4ZGVlYWNkNTI4NzkxMDUxMzUzODE3NTlmNjNhNzlfbkNyWFJ1dFJlNWR2eEg1eXRxUVRKM0FWY2pDUnltTU1fVG9rZW46R2hIemJaaUNFbzlnVzJ4UjJnOGMyMDFKbjRkXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h3 id="DB-拆分"><a href="#DB-拆分" class="headerlink" title="DB 拆分"></a><strong>DB 拆分</strong></h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTBjYmI2ZmRiYWM3MGVjNGQ4YTNkNzhlOWQ0MTM0YTRfdnJMQUtkc0NlWE5YSHBaU29odm43c1NWMEhDU01PdjdfVG9rZW46SFlpSWJXNDZsb0kyUUx4ZkFkUGNIT1gzbkFnXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h3 id="异步化"><a href="#异步化" class="headerlink" title="异步化"></a><strong>异步化</strong></h3><p>支付是整个交易链路的核心环节，那么，怎么兼顾支付系统的稳定性和执行效率呢？是异步化。</p><h4 id="消息异步化"><a href="#消息异步化" class="headerlink" title="消息异步化"></a><strong>消息异步化</strong></h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MGEyMzZmNGU0ZjAzYzkzNDkzZDBiYmEzMTVmOTU3MDJfNkJUS3ZMQUJ4ak9OQWNKWEd4TnNDc2gzZjAxNW1RMHRfVG9rZW46QXNkeWJGOTVRb3UyaTB4bFdVeGNPUjhHbmdoXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h4 id="外部支付调用异步化"><a href="#外部支付调用异步化" class="headerlink" title="外部支付调用异步化"></a><strong>外部支付调用异步化</strong></h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OWEwODQxNjZkYzNhM2FlZDhjNjg3YWMxODA1MDc2M2RfQnduWDFPdGlWZUg3QTZySFlXVmgzNG5SV0xwUzM0UlNfVG9rZW46SEQxWWI5VzdSb1ZuNm54TVBDZGNxUng0bkxJXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p>这种同步调用的情况下，由于需要跨外部网络，响应的 RT 会非常长，可能会出现跨秒的情况。由于是同步调用，会阻塞整个支付链路。一旦 RT 很长且 QPS 比较大的情况下，服务会整体 hold 住，甚至会出现拒绝服务的情况。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=M2VhMjVkYmYzZmY4MTgyNWIwY2QxMDQ0YzdmOGVjYWFfa3dYRkNnWFFETmluaG1XMmkxejR4ZUltcmpDZFlaZ3BfVG9rZW46UmxGT2JTU2JLb1VsTnR4Y2FmN2NiVXhvblVoXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p>因此，可以拆分获取凭证的操作，通过独立网关渠道前置服务，将获取的方式异步化，从前置网关获取内部凭证，然后由前置网关去异步调用第三方。</p><h4 id="异步并行化"><a href="#异步并行化" class="headerlink" title="异步并行化"></a><strong>异步并行化</strong></h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjYzNzU4ZGVlNTAwYjZhMjkwN2UyODA0YTA1NmY1YmJfSTRiTHRLM2JxSlNicUh1MTU2Umc1ZkxKYUdZQ0VuNzBfVG9rZW46UWN2ZmJ2ZTU2b0RKQmx4anA3aGNHUEpTbmxkXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h4 id="资金核算异步化"><a href="#资金核算异步化" class="headerlink" title="资金核算异步化"></a><strong>资金核算异步化</strong></h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NTkxZTkwZDlkMjg4YzgzMzIxYjE3ZmZlYzhmMjk5MDBfOGtNV2hZUjJBalVTcVR1enprZnhkRG9wR2FvNHRpTHBfVG9rZW46VklaUmJDWlRrb0hoQWF4YldxOWNSdmlxbktoXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h4 id="热点账户账务单独处理"><a href="#热点账户账务单独处理" class="headerlink" title="热点账户账务单独处理"></a><strong>热点账户账务单独处理</strong></h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NGUzYmVlNjJmNWNiNzVhYWY3ODk0YmZkYmNhMzM2MmRfWEswa3RkTnFNZTh2dktVZTNZY3BZQ05Memh4OUdsb09fVG9rZW46QlZ4U2I3R21Fb0JIY1V4Q21tZmNDS1lNbnViXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h4 id="记账事务切分"><a href="#记账事务切分" class="headerlink" title="记账事务切分"></a><strong>记账事务切分</strong></h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NjMwMDk1OGFlNTc3ZDg0ODhiZjliNzQ3ZGM0MjEyYjdfMVlMZFF0UXVZWmgyOWU4aGtwMW54T1dIQlhZSE1CMVBfVG9rZW46TGVzemIxYTBBbzh4Q0d4ZnZUZmM4cGwxblZjXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h1 id="Redis中存储的value-50MB会出现什么问题-该如何解决"><a href="#Redis中存储的value-50MB会出现什么问题-该如何解决" class="headerlink" title="Redis中存储的value&gt;50MB会出现什么问题?该如何解决"></a>Redis中存储的value&gt;50MB会出现什么问题?该如何解决</h1><ol><li>内存消耗过多：Redis是一个内存数据库，大value会占用大量的内存空间，可能导致内存迅速耗尽，影响其他key-value对的存储和性能。</li><li>网络传输效率下降：当需要通过网络传输大value时，会占用更多的网络带宽和传输时间，可能号致网络延迟或拥堵。</li><li>性能下降：读取、写入或操作大value需要更多的CPU时间和内存资源，可能导致Redis的响应延迟和整体性能下降。</li><li>持久化问题：如果启用了Redis的持久化（如RDB或AOF),大value可能导致特久化操作变慢，甚至可能因磁盘空间不足而失败。</li><li>数据安全问题：在某些情况下，如果Redis实例崩渍，大value可能无法完整恢复，从而导致数据丢失或损坏。</li></ol><p>解决方案：</p><ol><li>数据拆分：将大value:拆分成多个小value进行存储。例如，可以将一个大对象拆分成多个字段或子对象，分别作为不同的key进行存储。</li><li>使用适当的数据结构：根据数据的特性选择合适的Redis数据结构，如Hash、List、Set或Sorted Set,以便更有效地存储和检索数据。</li><li>外部存储与Redisi配合：对于非常大的数据，可以考虑使用外部存储系统（如分布式文件系统、对象存储或数据库）来存储实际的数据内容，并在Redis中仅保存指向这些数据的引用或标识符。</li><li>监控与报警：设置内存使用阈值，并监控Redis实例的内存使用情况。当内存使用接近阈值时，发报警机制，以便及时采取措施避免内存耗尽。</li><li>优化持久化策略：根据实际情况调整RDB或AOF的持久化配置，如调整持久化频率、使用增量持久化等方式来减少持久化对大value的影响。</li><li>备份与恢复策略：定期备份Redis数据，并制定完善的恢复策略，以便在出现数据丢失或损坏时能够迅速恢复。</li></ol><h1 id="设计注册中心，心跳机制如何维护和考虑设计"><a href="#设计注册中心，心跳机制如何维护和考虑设计" class="headerlink" title="设计注册中心，心跳机制如何维护和考虑设计"></a>设计注册中心，心跳机制如何维护和考虑设计</h1><p>需要考虑的点：</p><p>服务注册 注册表结构设计 服务发现 服务订阅 服务推送 健康检查 集群同步：设计到数据同步，数据同步我们有哪些协议 raft 、distro、ZAB</p><p>选型</p><p>注册中心作为一个服务注册和发现的服务，必须是<strong>高可用</strong>的，所以应该是<strong>AP****模型</strong>；</p><p>1、注册中心提供节点信息的存储与扩展，使用mysql持久化，redis做缓存</p><p>2、提供权重设置，分组设置，可区分核心应用和非核心应用调用不同的分组，互不干扰</p><p>3、基于netty通过tcp协议，提供者和消费者与注册中心保持长连接</p><p>4、注册中心集群节点间可采用gossip协议维护集群节点的自动发现、转移和心跳</p><p>我们需要解决如下几个问题：</p><ul><li>服务如何注册</li><li>consumer如何知道provider</li><li>服务注册中心如何高可用</li><li>服务上下线，消费端如何动态感知</li></ul><p>服务注册</p><p>服务列表保存通常有三种方式：本地内存、数据库、第三方缓存系统注册上去后，consumer需要服务地址的时候，就可以用相应key去注册中心获取对应的服务列表。</p><p>同一个服务注册中心，我们可以注册多个服务，比如用户服务、商品服务、订单服务…</p><p>服务消费</p><p>consumer端通过key获取指定的服务地址列表。</p><p>简单来说，我们就是<strong>引用了</strong>一个第三方的服务来存放我们的服务提供者列表。并且以key-value的形式存储，key我们可以理解为服务名称，value就是服务实例列表。</p><p>注册中心高可用</p><p>高可用无非就是做<strong>集群</strong>，我们可以对注册中心部署多个节点。在消费端consumer只需要知道一个服务注册中心<strong>集群地址</strong><code>cluster-url</code>即可。</p><p>动态感知服务上下线</p><p>consumer拿到服务列表后，会把服务列表保存起来，保存到<strong>本地缓存里</strong>。</p><p>consumer通过一定的<strong>负载均衡算法</strong>，选择出一个地址，最后发起远程的调用。</p><p>如果我们的服务节点挂掉一个了，怎么办？</p><p>此时，服务注册中心的服务列表还是之前的列表，如果consumer调用到过掉的节点上，那岂不是会出问题呀。</p><p>所以，我们的服务注册中心需要知道哪个服务节点挂了，然后从对应服务列表里删除。</p><p>有种办法叫做心跳检测heartBeat，即就是服务注册中心，每隔一定时间去监测一下provider，如果监测到某个服务挂了，那就把对应服务地址从服务列表中删除。</p><p>可是不对呀，此时consumer端本地列表里还有过掉的服务地址，怎么办呢？</p><p>或者是，在增加一个新的服务节点</p><p>对于服务注册中心来说，就是服务列表里增加一个服务地址。</p><p>但是在消费端存在同样的问题，就是服务注册中心的服务列表和consumer端的服务列表不一样了。</p><p>如何让consumer端也动态感知呢？</p><p>其实很简单，此时，我们得思维换一下，因为consumer的服务列表是来自于服务注册中心，我们就可以把consumer理解为消费端，服务注册中心理解为服务端。此时，consumer端就可以去服务端（服务注册中心）拉取provider服务列表。</p><p>通常有两种方案：push和pull</p><p>push：服务注册中心主动推送服务列表给consumer。</p><p>pull：consumer主动从注册中心拉取服务列表。</p><p>不管是push还是pull，都会存在consumer和服务注册中心的<strong>通信管道</strong>。如果他们之间断开了，那就无法获取服务列表了。</p><p>还有就是服务注册中心<strong>知道consumer的地址</strong></p><p>我们的网络通信，必然会存在<strong>监听</strong>的动作。</p><p>如果服务注册中心要push到consumer，此时他们之间需要建立一个会话，所以，在服务注册中心会维护一个<strong>会话管理</strong>的模块。还有一种方式就是consumer提供一个**<code>API</code>**，这个<code>API</code>给服务注册中心进行回调。</p><p>push有个不好点，那就是服务注册中心需要维护大量的会话，而且还需要对每个会话维持一个心跳，以便知晓这些会话状态，得确保这些consumer能收到数据，</p><p>另外就是pull，pull其实就相对push就简单多了。pull和我们前面说的心跳机制是类似的，consumer端启动定时任务，每个多久拉取服务注册中心的服务列表。pull也不需要去维护大量的会话，我只需要每隔多久调用接口拉取服务列表即可。但是这里还是会存在一个问题，因为是定时去拉取，所以会存在一定的数据延迟，比如consumer刚刚拉取服务列表，但就在拉取结束的后，某个服务provider挂了，consumer就要等下次拉取才知道对应服务provider挂了。</p><p>还有一种方式long-pull，也叫<strong>长****轮询</strong>，是上面两种方案的优化方案，consumer发起拉取请求时，先把这个请求hold住，当服务注册中心有发生变化后，consumer端能立马感知。</p><p>通过上面的服务注册、服务消费、注册中心高可用以及动态感知服务的上下线，这就是我们去实现一个服务注册中心的通用模型。</p><h1 id="单核CPU，什么时候单线程任务比多线程任务更快"><a href="#单核CPU，什么时候单线程任务比多线程任务更快" class="headerlink" title="单核CPU，什么时候单线程任务比多线程任务更快"></a>单核CPU，什么时候单线程任务比多线程任务更快</h1><ol><li><strong>上下文切换开销</strong>：多线程任务需要在不同的线程之间进行上下文切换，这会产生一定的开销。如果任务是单线程的，就不需要进行上下文切换，可以减少这部分开销。</li><li><strong>线程管理开销</strong>：操作系统需要管理多个线程，包括调度、同步和通信等，这会产生额外的开销。单线程任务则不需要这些管理开销。</li><li><strong>任务性质</strong>：如果任务是计算密集型的，并且可以很好地利用CPU的计算资源，那么单线程可能比多线程更快，因为多线程需要额外的时间来处理线程间的同步和通信。</li><li><strong>I&#x2F;O****密集型任务</strong>：对于I&#x2F;O密集型任务，多线程可以提高性能，因为线程可以在等待I&#x2F;O操作完成时让其他线程运行。但如果I&#x2F;O操作非常快速或者任务主要是计算密集型的，那么单线程可能更高效。</li><li><strong>线程数量</strong>：如果线程数量超过了CPU的核心数，那么额外的线程将不会带来性能上的提升，反而可能因为线程竞争和上下文切换而导致性能下降。</li><li><strong>编程复杂性</strong>：编写和维护多线程程序通常比单线程程序要复杂得多。如果多线程程序没有正确地设计和优化，可能会导致性能问题，甚至比单线程版本更慢。</li><li><strong>锁和同步机制</strong>：多线程程序中使用的锁和同步机制可能会成为性能瓶颈。如果锁竞争严重，或者锁的使用不当，可能会导致线程阻塞，从而降低性能。</li><li><strong>任务的<strong><strong>并行</strong></strong>性</strong>：如果任务本身的并行性不高，即任务的各个部分不能很好地同时进行，那么多线程可能不会带来太大的性能提升。</li></ol><h1 id="第三方的接口没有访问到（支付），返回的过程没收到，怎么办"><a href="#第三方的接口没有访问到（支付），返回的过程没收到，怎么办" class="headerlink" title="第三方的接口没有访问到（支付），返回的过程没收到，怎么办"></a>第三方的接口没有访问到（支付），返回的过程没收到，怎么办</h1><p><strong>接口访问不到</strong></p><p>在执行第三方接口调用任务时，如果遇到程序响应迟滞直至超时，或者直接抛出诸如<code>Connection refused</code>、<code>Host is unreachable</code>、<code>SocketTimeoutException</code>之类的网络异常情况，这明确指示了无法成功建立起与目标服务器的通信连接。产生此问题的根源可能源自于多种因素，其中包括但不限于网络状况不佳、服务器尚未启动、域名解析错误或接口地址有误等。</p><p>为应对这类问题，首要步骤是自查本地网络环境是否正常。一旦确定自身网络并无故障，可行的操作之一是运用<code>ping</code>命令对目标域名进行探测，以验证域名能否被正确解析并得到响应。若域名无法解析，则可能表明对方服务器DNS配置存在问题；即使域名可以解析，但如果<code>ping</code>测试结果显示响应异常或超时，说明目标服务端存在潜在故障。在这种情况下，及时与对方的技术团队取得联系，共享诊断信息，共同协作进行问题排查是一种有效的解决策略。</p><p>此外，我们调用第三方接口还有可能遇到以下问题：</p><p><strong>接口突然没有返回数据&#x2F;数据异常</strong></p><p>原本正常的接口突然开始返回空数据，或者是返回的数据结构与预期不符，比如缺少必要的字段、数据格式错误、数据内容无效等，导致客户端无法正常解析和使用。</p><p>面对这类接口突然无响应或无法返回数据的问题，首先，我们需要从源头着手，全面核查请求参数和认证凭证的有效性。这包括仔细审查发送至接口的请求数据是否完整准确，以及确保使用的Token、Key等身份认证信息处于有效状态。同时，必须密切关注接口供应商是否有未提前公告的变更，如API版本升级、接口废弃等情况。</p><p>在代码实现层面上，为了能快速响应这类异常，我们应当对关键数据字段设置严格的监控与预警机制。例如，可以植入手动埋点并通过企业通讯工具（如钉钉消息、电子邮件提醒）实现即时告警。一旦监测到核心数据未能如期返回，系统应能立即发出警报，使开发人员能够在第一时间获知并处理此类问题，以防止其对整体业务流程造成干扰或经济损失。</p><p>以一个实际应用场景为例，当我们在上游系统中使用订单号向下游WMS系统查询出入库订单详情时，若发现特定订单号未能返回预期的订单信息，那么通过预先设定的监控和告警系统，我们将在第一时间接收到警告信息。在此基础上，应迅速与第三方系统的技术支持团队取得联系，查明原因并解决问题。同时，对于这类无法匹配的数据，应在业务流程中设立防护机制，及时拦截处理，以免对核心业务造成负面影响。</p><p><strong>接口超时&#x2F;异常，不稳定</strong></p><p>由于网络抖动，或者第三方系统不稳定，部署，服务器负载不均、并发访问量过大等等问题，可能会导致调用接口时花费的时间超出预期设定的超时时间，从而引发<code>TimeoutException</code>；或者接收到HTTP状态码表明出现异常，如<code>500 Internal Server Error</code>、<code>404 Not Found</code>等。这种坑是我们平常最容易遇见的也是最头疼的所在，因此需要我们给予足够的重视。</p><p>对于这类异常，首先我们在调用接口时设置合理的超时时间，我们以使用<code>Retrofit2</code>调用<code>http</code>接口为例，设置其请求超时时间以及读取超时时间：</p><p><strong>接口变更，版本迭代兼容性</strong></p><p>第三方系统对API进行版本升级或服务调整属于常见现象，这种情况下，原有的接口可能面临无法继续使用的问题，或者返回的数据结构、格式可能发生变动，部分接口随着版本升级可能存在不向下兼容的情况，调用旧版接口在新版环境下可能失效。针对此类状况，最佳实践是始终保持对服务提供商通告的关注，一旦得知有关更新信息，应迅速作出响应，及时调整并更新调用接口的方式。在代码层面，有必要预先设计并实现一套接口版本管理和兼容性处理机制，以确保无论接口如何演变，系统都能够平滑地适应和处理。</p><p>接口变更时，采用接口参数动态化是一种有效的应对策略，其核心理念是让客户端调用接口时具备更强的灵活性和适应性，特别是在接口新增、删除或修改参数的情况下，比如采取Map，JSON接受参数（当然不是很推荐。。。。）。</p><p>并且，对接口进行严密的异常监测同样至关重要，通过实时监控接口调用的异常状况，能够在问题发生的第一时间发现并上报。及时与第三方系统的技术支持团队沟通协调，并采取相应的补救措施，能够最大限度地减少接口变动对业务连续性的影响，确保系统稳定高效运行。</p><p><strong>API限制</strong></p><p>在一定时间段内频繁调用接口，然后突然所有请求都开始失败，返回的错误提示可能是调用频率过高、超出配额等。这是由于大多数第三方API为了防止滥用，会对调用次数、频次或流量进行限制。我们应密切关注接口文档中的调用限制说明，并在代码中采取限流措施，如设置合适的请求间隔、使用令牌桶算法或漏桶算法控制请求速度。当然也要做好接口监控告警策略。</p><p><strong>错误码定义混乱，字段结构不一致</strong></p><p>我们常常会遇到接口文档与实际错误码定义、字段结构不一致的问题，例如文档中标明错误码400代表参数错误，但实际上可能收到的是404错误响应；又或者返回的数据结构与文档描述不相吻合，这使得我们难以精准识别并恰当处理结果。针对此类问题，应当采取以下策略：</p><p>首先，构建自定义错误处理机制，创建专门的错误处理类，对所有可能出现的错误码进行统一且明确的处理。这样，无论接口返回何种错误码，都能确保有一套标准的逻辑进行响应和记录。</p><p>其次，针对那些与文档描述不符或者含义模糊不清的错误码和字段，应及时与第三方系统的技术团队展开沟通交流，明确其真实含义和用途。这样的互动有助于确保接口对接的精确性，避免因对错误码或字段理解不准确而引发的系统内部错误。</p><p>对于接口文档与实际不符的情况，一方面要通过定制化的错误处理机制增强系统的容错性与一致性，另一方面要强化与第三方系统的沟通协作，确保对接接口的清晰性和准确性，从而有效避免潜在问题对自身系统产生的不良影响。</p><p><strong>返回的<strong><strong>数据格式</strong></strong>不统一</strong></p><p>对于同一个系统，接口返回的数据格式在不同场景下可能有所差异，例如有的时候返回JSON对象，有的时候却是字符串或其他格式，例如xml等。</p><p>针对这类问题，我们需要编写包容性较强的解析逻辑，确保在任何情况下都能准确解构并处理返回数据。创建多个数据模型类对应不同格式的数据，根据接口返回的内容决定使用哪个模型类进行反序列化。针对不同的数据格式编写适配器，确保数据能统一转换为应用程序可处理的格式。</p><h1 id="如何在SpringBoot启动时执行特定代码"><a href="#如何在SpringBoot启动时执行特定代码" class="headerlink" title="如何在SpringBoot启动时执行特定代码"></a>如何在SpringBoot启动时执行特定代码</h1><ol><li><strong>监听ApplicationContext事件</strong>：通过实现<code>ApplicationListener&lt;ContextRefreshedEvent&gt;</code>接口，监听<code>ContextRefreshedEvent</code>事件，可在Spring容器初始化完成后执行初始化逻辑。这种方式适用于需要在所有Bean加载完毕后进行全局性初始化操作的场景。</li><li><strong>实现CommandLineRunner接口</strong>：Spring Boot启动后，会自动调用实现了<code>CommandLineRunner</code>接口的Bean的<code>run</code>方法，该方法可以处理命令行参数并执行启动时的特定操作。适用于需要根据命令行参数执行初始化逻辑或进行启动后一次性任务的情况。</li><li><strong>实现ApplicationRunner接口</strong>：与<code>CommandLineRunner</code>类似，<code>ApplicationRunner</code>也在Spring Boot启动后执行其<code>run</code>方法，但其参数为<code>ApplicationArguments</code>，提供了更强大的命令行参数解析功能。适合处理键值对形式的命令行参数并据此执行初始化任务。</li><li><strong>使用@PostConstruct注解</strong>：在Bean的方法上添加<code>@PostConstruct</code>注解，Spring会在该Bean的所有依赖注入完成后调用该方法进行初始化。这种方法用于单个Bean初始化完成后的特定逻辑，增强了代码的模块化和可维护性。</li><li><strong>@Bean注解中指定初始化方法</strong>：通过<code>@Bean</code>注解中的<code>initMethod</code>属性指定Bean的初始化方法，该方法在Bean实例化并完成注入后由Spring容器调用。这种方法适用于需要对特定Bean进行精细化初始化管理的场景。</li><li><strong>实现InitializingBean接口</strong>：Bean实现<code>InitializingBean</code>接口并重写<code>afterPropertiesSet</code>方法，也能实现在依赖注入完成后执行初始化逻辑。虽然传统但不如使用<code>@PostConstruct</code>注解优雅，且增加了类的耦合度。</li><li><strong>使用@EventListener注解</strong>：通过监听<code>ApplicationReadyEvent</code>等事件，可以在Spring Boot应用启动并准备就绪后执行初始化任务。这种方式延迟执行，适用于在所有Bean初始化完毕且应用已经完全启动后才需要进行的操作。</li></ol><h1 id="金额到底是用Long还是BigDecimal？"><a href="#金额到底是用Long还是BigDecimal？" class="headerlink" title="金额到底是用Long还是BigDecimal？"></a>金额到底是用Long还是BigDecimal？</h1><p><strong>排除<strong><strong>float</strong></strong>和double</strong></p><p>当然，对于金额，首先我们要排除的就是float和double。它们不适合用于精确的金融计算，因为<code>float</code>和<code>double</code>是基于IEEE 754标准的浮点数表示，它们无法精确地表示所有的十进制小数。这会导致在进行财务计算时出现舍入误差，这些误差可能会累积并导致不可预测的结果。</p><p><strong>选择Long</strong></p><p><code>Long</code>类型在Java中用于存储64位整数。它的主要优点是速度快，因为整数运算在CPU层面是非常高效的。另外，<code>Long</code>类型也占用较少的内存，并且整数类型(<code>BIGINT</code>)在数据库中占用较少的存储空间。</p><p>但是<code>Long</code>类型在处理金额时有几个明显的缺点：</p><ol><li><strong>精度问题</strong>：<code>Long</code>只能存储整数，无法直接表示小数。使用<code>Long</code>来表示以分为单位的金额（例如，100表示1元），此时就会失去小数的精度。即使使用某种方式来表示小数（例如，乘以100或10000），也会遇到舍入误差的问题。并且这种计算方式也会增加计算的复杂度。</li><li><strong>浮点数****问题</strong>：虽然这不是直接使用<code>Long</code>的问题，但如果你尝试将<code>Long</code>与浮点数（如<code>double</code>或<code>float</code>）进行转换以进行计算（比如汇率计算等），还是会遇到浮点数精度问题，这可能导致在财务计算中出现不可接受的误差。</li></ol><p>在阿里巴巴的开发手册中建议使用Long。</p><p>但是在一些金融系统当中，对小数位要求比较高的，比如精确到小数点后6位，那么我们使用Long进行存储，每次在计算时都要除以或者乘以1000000，那么计算的开销就很大了。</p><p>并且，如果在需求确认时，我们无法知道金额要求的小数位，那我们使用Long也是不行的，我们并不知道需要乘以或者除以多少个0。</p><p><strong>选择BigDecimal</strong></p><p><code>BigDecimal</code>是Java提供的一个类，用于任意精度的算术运算。它的主要优点是提供了高精度的计算，这对于金融和货币计算来说是非常重要的。<code>BigDecimal</code>可以表示任意大小的正数、负数或零，并可以精确控制舍入行为。并且在数据库中存储时也有对应的类型进行匹配，比如MySQL的<code>DECIMAL</code>类型提供了精确的数值存储，可以匹配<code>BigDecimal</code>的精度。</p><p>但是<code>BigDecimal</code>也有一些缺点：</p><ol><li><strong>性能</strong>：与<code>Long</code>相比，<code>BigDecimal</code>的性能较差。因为它的运算需要更多的内存和CPU时间。</li><li><strong>复杂性</strong>：使用<code>BigDecimal</code>进行运算比使用<code>Long</code>或基本数据类型更复杂。你需要考虑舍入模式、精度等因素。</li><li>在数据库中需要更多的存储空间来存储小数部分。</li></ol><p>而在Mysql的开发手册中，建议金额需要进行小数位计算时，存储要使用Decimal，否则我们要将金额乘以对应小数位的倍数变成BIGINT进行存储。</p><p>总结</p><p>基于上述对<code>Long</code>和<code>BigDecimal</code>的优缺点分析，我们可以得出以下结论：</p><p>在金额计算层面，即代码实现中，推荐使用<code>BigDecimal</code>进行所有与金额相关的计算。<code>BigDecimal</code>提供了高精度的数值运算，能够确保金额计算的精确性，避免了因浮点数精度问题导致的财务误差。使用<code>BigDecimal</code>可以简化代码逻辑，减少因处理精度问题而引入的复杂性。</p><p>而在数据库存储方面，我们需要根据具体需求进行权衡。如果业务需求已经明确金额只需精确到分（如某些国家&#x2F;地区的货币最小单位为分），并且我们确信不会涉及到需要更高精度的小数计算，那么可以使用<code>Long</code>类型进行存储，将金额转换为最小货币单位（如分）进行存储。这样可以节省存储空间并提高查询性能。</p><p>但是如果业务需求中金额的小数位数不确定，或者可能涉及多位小数的计算（如国际货币交易等），那么最好使用<code>DECIMAL</code>或<code>NUMERIC</code>类型进行存储。这些类型提供了精确的数值存储，可以确保数据库中的数据与应用程序中的<code>BigDecimal</code>对象保持一致，避免数据转换过程中可能引入的精度损失。</p><h1 id="记录日志功能的实现–AOP"><a href="#记录日志功能的实现–AOP" class="headerlink" title="记录日志功能的实现–AOP"></a>记录日志功能的实现–AOP</h1><p><strong>记录日志的意义：</strong></p><p>后台管理系统记录操作日志的意义非常重要，主要体现在以下几个方面：</p><p>1、安全性：操作日志可以记录管理员操作行为，以此来监控和防止管理员滥用权限或进行其他不当操作。如果后台管理系统没有记录操作日志，那么一旦出现不当操作，就无法对其进行追踪和定位，造成不可估量的安全风险。</p><p>2、追溯性：操作日志可以帮助管理员及时发现问题，并可以通过日志进行快速定位和处理。例如某个用户投诉自己的订单异常，管理员可以直接通过查询该订单的操作日志，找到问题所在并进行修改或解决。</p><p>因此，后台管理系统记录操作日志，对于维护系统的安全稳定性、保障客户数据的完整性和隐私性、提高系统及时响应和处理能力等方面具有重要意义，是保障企业正常运营和客户满意度的重要手段。</p><p><strong>日志数据表结构：</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_oper_log` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;日志主键&#x27;</span>,</span><br><span class="line">  `title` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;模块标题&#x27;</span>,</span><br><span class="line">  `business_type` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;业务类型（0其它 1新增 2修改 3删除）&#x27;</span>,</span><br><span class="line">  `<span class="keyword">method</span>` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;方法名称&#x27;</span>,</span><br><span class="line">  `request_method` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;请求方式&#x27;</span>,</span><br><span class="line">  `operator_type` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;操作类别（0其它 1后台用户 2手机端用户）&#x27;</span>,</span><br><span class="line">  `oper_name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;操作人员&#x27;</span>,</span><br><span class="line">  `dept_name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;部门名称&#x27;</span>,</span><br><span class="line">  `oper_url` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;请求URL&#x27;</span>,</span><br><span class="line">  `oper_ip` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;主机地址&#x27;</span>,</span><br><span class="line">  `oper_param` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;请求参数&#x27;</span>,</span><br><span class="line">  `json_result` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;返回参数&#x27;</span>,</span><br><span class="line">  `status` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;操作状态（0正常 1异常）&#x27;</span>,</span><br><span class="line">  `error_msg` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;错误消息&#x27;</span>,</span><br><span class="line">  `oper_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `is_deleted` tinyint <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;删除标记（0:不可用 1:可用）&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">67</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 COMMENT<span class="operator">=</span><span class="string">&#x27;操作日志记录&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>AOP记录日志的主要优点包括：</strong></p><p>1、低侵入性：AOP记录日志不需要修改原有的业务逻辑代码，只需要新增一个切面即可。</p><p>2、统一管理：通过AOP记录日志可以将各个模块中需要记录日志的部分进行统一管理，降低了代码重复度，提高了代码可维护性和可扩展性。</p><p>3、提升效率：通过引入AOP记录日志，可以避免手动编写日志记录代码，减少了开发人员的工作量，提升了开发效率。</p><p>4、安全性：通过AOP记录日志，可以收集系统的操作日志，帮助管理员及时发现问题并进行调整，从而提高系统的安全性。</p><p><strong>AOP记录日志的整体思想</strong>：</p><p>1、基于自定义注解来确定切入点【优势：可以通过自定义注解携带一些变化的参数，比如模块名称】</p><p>2、基于环绕通知来完成日志记录</p><h2 id="切面类环境搭建"><a href="#切面类环境搭建" class="headerlink" title="切面类环境搭建"></a><strong>切面类环境搭建</strong></h2><p>新建记录日志模块，模块中引入依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">      &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="自定义Log注解"><a href="#自定义Log注解" class="headerlink" title="自定义Log注解"></a><strong>自定义Log注解</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Log &#123;                <span class="comment">// 自定义操作日志记录注解</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">title</span><span class="params">()</span> ;                                                                <span class="comment">// 模块名称</span></span><br><span class="line">    <span class="keyword">public</span> OperatorType <span class="title function_">operatorType</span><span class="params">()</span> <span class="keyword">default</span> OperatorType.MANAGE;        <span class="comment">// 操作人类别</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">businessType</span><span class="params">()</span> ;     <span class="comment">// 业务类型（0其它 1新增 2修改 3删除）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSaveRequestData</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;   <span class="comment">// 是否保存请求的参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSaveResponseData</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;  <span class="comment">// 是否保存响应的参数</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>OperatorType</strong></p><p>操作人枚举类定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OperatorType</span> &#123;                <span class="comment">// 操作人类别</span></span><br><span class="line">    OTHER,                <span class="comment">// 其他</span></span><br><span class="line">    MANAGE,                <span class="comment">// 后台用户</span></span><br><span class="line">    MOBILE                <span class="comment">// 手机端用户</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LogAspect"><a href="#LogAspect" class="headerlink" title="LogAspect"></a><strong>LogAspect</strong></h2><p>定义一个切面类，并且在该切面类中提供一个环绕通知方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;            <span class="comment">// 环绕通知切面类定义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncOperLogService asyncOperLogService ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(value = &quot;@annotation(sysLog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doAroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint , Log sysLog)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建前置参数</span></span><br><span class="line">        <span class="type">SysOperLog</span> <span class="variable">sysOperLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SysOperLog</span>() ;</span><br><span class="line"></span><br><span class="line">        LogUtil.beforeHandleLog(sysLog , joinPoint , sysOperLog) ;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            proceed = joinPoint.proceed();</span><br><span class="line">            <span class="comment">// 执行业务方法</span></span><br><span class="line">            LogUtil.afterHandlLog(sysLog , proceed , sysOperLog , <span class="number">0</span> , <span class="literal">null</span>) ;</span><br><span class="line">            <span class="comment">// 构建响应结果参数</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;                                 <span class="comment">// 代码执行进入到catch中，</span></span><br><span class="line">            <span class="comment">// 业务方法执行产生异常</span></span><br><span class="line">            e.printStackTrace();                                <span class="comment">// 打印异常信息</span></span><br><span class="line">            LogUtil.afterHandlLog(sysLog , proceed , sysOperLog , <span class="number">1</span> , e.getMessage()) ;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存日志数据</span></span><br><span class="line">        asyncOperLogService.saveSysOperLog(sysOperLog);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回执行结果</span></span><br><span class="line">        <span class="keyword">return</span> proceed ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EnableLogAspect"><a href="#EnableLogAspect" class="headerlink" title="EnableLogAspect"></a><strong>EnableLogAspect</strong></h2><p>想让LogAspect这个切面类在其他的业务服务中进行使用，那么就需要该切面类纳入到Spring容器中。Spring Boot默认会扫描和启动类所在包相同包中的bean以及子包中的bean。而LogAspect切面类不满足扫描条件，因此无法直接在业务服务中进行使用。那么此时可以通过自定义注解进行实现，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(value = LogAspect.class)</span>            <span class="comment">// 通过Import注解导入日志切面类到Spring容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableLogAspect &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SysOperLog"><a href="#SysOperLog" class="headerlink" title="SysOperLog"></a><strong>SysOperLog</strong></h2><p>定义一个与日志数据库表相对应的实体类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SysOperLog</span> <span class="keyword">extends</span> <span class="title class_">BaseEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String title;                                        <span class="comment">// 模块标题</span></span><br><span class="line">        <span class="keyword">private</span> String method;                                        <span class="comment">// 方法名称</span></span><br><span class="line">        <span class="keyword">private</span> String requestMethod;                        <span class="comment">// 请求方式</span></span><br><span class="line">        <span class="keyword">private</span> String operatorType;                        <span class="comment">// 操作类别（0其它 1后台用户 2手机端用户）</span></span><br><span class="line">    <span class="keyword">private</span> Integer businessType ;                        <span class="comment">// 业务类型（0其它 1新增 2修改 3删除）</span></span><br><span class="line">        <span class="keyword">private</span> String operName;                                <span class="comment">// 操作人员</span></span><br><span class="line">        <span class="keyword">private</span> String operUrl;                                        <span class="comment">// 请求URL</span></span><br><span class="line">        <span class="keyword">private</span> String operIp;                                        <span class="comment">// 主机地址</span></span><br><span class="line">        <span class="keyword">private</span> String operParam;                                <span class="comment">// 请求参数</span></span><br><span class="line">        <span class="keyword">private</span> String jsonResult;                                <span class="comment">// 返回参数</span></span><br><span class="line">        <span class="keyword">private</span> Integer status;                                        <span class="comment">// 操作状态（0正常 1异常）</span></span><br><span class="line">        <span class="keyword">private</span> String errorMsg;                                <span class="comment">// 错误消息</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LogAspect-1"><a href="#LogAspect-1" class="headerlink" title="LogAspect"></a><strong>LogAspect</strong></h2><p>添加工具类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作执行之后调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">afterHandlLog</span><span class="params">(Log sysLog, Object proceed,</span></span><br><span class="line"><span class="params">                                     SysOperLog sysOperLog, <span class="type">int</span> status ,</span></span><br><span class="line"><span class="params">                                     String errorMsg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sysLog.isSaveResponseData()) &#123;</span><br><span class="line">            sysOperLog.setJsonResult(JSON.toJSONString(proceed));</span><br><span class="line">        &#125;</span><br><span class="line">        sysOperLog.setStatus(status);</span><br><span class="line">        sysOperLog.setErrorMsg(errorMsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作执行之前调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">beforeHandleLog</span><span class="params">(Log sysLog,</span></span><br><span class="line"><span class="params">                                       ProceedingJoinPoint joinPoint,</span></span><br><span class="line"><span class="params">                                       SysOperLog sysOperLog)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置操作模块名称</span></span><br><span class="line">        sysOperLog.setTitle(sysLog.title());</span><br><span class="line">        sysOperLog.setOperatorType(sysLog.operatorType().name());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取目标方法信息</span></span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">methodSignature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature() ;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> methodSignature.getMethod();</span><br><span class="line">        sysOperLog.setMethod(method.getDeclaringClass().getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求相关参数</span></span><br><span class="line">        <span class="type">ServletRequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> (ServletRequestAttributes)</span><br><span class="line">                RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> requestAttributes.getRequest();</span><br><span class="line">        sysOperLog.setRequestMethod(request.getMethod());</span><br><span class="line">        sysOperLog.setOperUrl(request.getRequestURI());</span><br><span class="line">        sysOperLog.setOperIp(request.getRemoteAddr());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置请求参数</span></span><br><span class="line">        <span class="keyword">if</span>(sysLog.isSaveRequestData()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">requestMethod</span> <span class="operator">=</span> sysOperLog.getRequestMethod();</span><br><span class="line">            <span class="keyword">if</span> (HttpMethod.PUT.name().equals(requestMethod) || HttpMethod.POST.name().equals(requestMethod)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">params</span> <span class="operator">=</span> Arrays.toString(joinPoint.getArgs());</span><br><span class="line">                sysOperLog.setOperParam(params);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sysOperLog.setOperName(AuthContextUtil.get().getUserName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在模块中定义保存日志数据的service接口，然后在具体的业务服务中给出实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AsyncOperLogService</span> &#123;                        <span class="comment">// 保存日志数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">saveSysOperLog</span><span class="params">(SysOperLog sysOperLog)</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncOperLogServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AsyncOperLogService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SysOperLogMapper sysOperLogMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>      <span class="comment">// 异步执行保存日志操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveSysOperLog</span><span class="params">(SysOperLog sysOperLog)</span> &#123;</span><br><span class="line">        sysOperLogMapper.insert(sysOperLog);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：要想通过异步线程执行saveSysOperLog方法，那么此时就需要在启动类上添加**@EnableAsync**注解。</p><p>SysOperLogMapper持久层接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SysOperLogMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(SysOperLog sysOperLog)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SysOperLogMapper-xml"><a href="#SysOperLogMapper-xml" class="headerlink" title="SysOperLogMapper.xml"></a><strong>SysOperLogMapper.xml</strong></h2><ul><li>在SysOperLogMapper.xml映射文件中添加如下的SQL语句：</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.lcp.lcp.mapper.SysOperLogMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> &gt;</span></span><br><span class="line">        insert into sys_oper_log (</span><br><span class="line">            id,</span><br><span class="line">            title,</span><br><span class="line">            method,</span><br><span class="line">            request_method,</span><br><span class="line">            operator_type,</span><br><span class="line">            oper_name,</span><br><span class="line">            oper_url,</span><br><span class="line">            oper_ip,</span><br><span class="line">            oper_param,</span><br><span class="line">            json_result,</span><br><span class="line">            status,</span><br><span class="line">            error_msg</span><br><span class="line">        ) values (</span><br><span class="line">                     #&#123;id&#125;,</span><br><span class="line">                     #&#123;title&#125;,</span><br><span class="line">                     #&#123;method&#125;,</span><br><span class="line">                     #&#123;requestMethod&#125;,</span><br><span class="line">                     #&#123;operatorType&#125;,</span><br><span class="line">                     #&#123;operName&#125;,</span><br><span class="line">                     #&#123;operUrl&#125;,</span><br><span class="line">                     #&#123;operIp&#125;,</span><br><span class="line">                     #&#123;operParam&#125;,</span><br><span class="line">                     #&#123;jsonResult&#125;,</span><br><span class="line">                     #&#123;status&#125;,</span><br><span class="line">                     #&#123;errorMsg&#125;</span><br><span class="line">                 )</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="事务失效"><a href="#事务失效" class="headerlink" title="事务失效"></a>事务失效</h2><p>当我们自定义了切面类以后，如果不注意异常的处理，那么此时就会出现事务失效的情况。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Log(title = &quot;角色菜单模块&quot; , businessType = 2 )</span>                </span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAssign</span><span class="params">(AssginMenuDto assginMenuDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据角色的id删除其所对应的菜单数据</span></span><br><span class="line">    sysRoleMenuMapper.deleteByRoleId(assginMenuDto.getRoleId());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span> ;                <span class="comment">// 手动抛出异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取菜单的id</span></span><br><span class="line">    List&lt;Map&lt;String, Number&gt;&gt; menuInfo = assginMenuDto.getMenuIdList();</span><br><span class="line">    <span class="keyword">if</span>(menuInfo != <span class="literal">null</span> &amp;&amp; menuInfo.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sysRoleMenuMapper.doAssign(assginMenuDto) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：不加@Log注解事务可以进行回滚，但是加上该注解以后事务就会失效。</p><p><strong>问题分析</strong></p><p>Spring的事务控制是通过aop进行实现的，在框架底层会存在一个事务切面类，当业务方法产生异常以后，事务切面类感知到异常以后事务进行回滚。</p><p>当系统中存在多个切面类的时候，Spring框架会按照**@Order<strong>注解的值对切面进行排序，@Order的值越小优先级越高，@Order的值越大优先级越低。优先级越高的切面类越优先执行，当我们没有给切面类指定排序值的时候，我们自定义的切面类的优先级和aop切面类的优先级相同，那么此时</strong>事务切面类的优先级要高于自定义切面类**，那么切面类的执行顺序如下所示：</p><p>当在自定义切面类中对异常进行了捕获，没有将异常进行抛出，那么此时事务切面类是感知不到异常的存在，因此事务失效。</p><p><strong>问题解决</strong></p><p>解决方案一：使用@Order注解提高自定义切面类的优先级</p><p>解决方案二：在自定义切面类的catch中进行异常的抛出</p><h1 id="数据库数据批量导入es"><a href="#数据库数据批量导入es" class="headerlink" title="数据库数据批量导入es"></a>数据库数据批量导入es</h1><p>当时想的是如果项目上线的时候，肯定要把数据库中的中药材数据全部导入到es索引库中，为了以防万一，如果数据量很大，一次性导入肯定会发生OOM,所以当时我就想到可以使用线程池的方式导入，利用CountDownLatch来控制，就能避免一次性加载过多，防止内存溢出</p><p>具体流程我画成了流程图:</p><p>暂时无法在飞书文档外展示此内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApMedicineServiceImpl</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ApMedicineMapper apMedicineMapper;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestHighLevelclient client;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ARTICLE_ES_INDEX</span> <span class="operator">=</span><span class="string">&quot;app_info_article&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> PAGE_SIZE=<span class="number">2000</span>;</span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">importAll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//总条数</span></span><br><span class="line">       <span class="type">int</span> count apMedicineMapper.selectCount();</span><br><span class="line">        <span class="comment">//总页数</span></span><br><span class="line">       <span class="type">int</span> totalPagesize <span class="type">count</span> <span class="variable">PAGE_SIZE</span> <span class="operator">=</span><span class="number">0</span> count/PAGE_SIZE count/PAGE_SIZE +<span class="number">1</span>;</span><br><span class="line">       <span class="comment">//开始执行时间</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span>System.currentTimeMillis();</span><br><span class="line">       <span class="comment">//一共有多少页，就创建多少个CountDownLatch的计数</span></span><br><span class="line">       <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(totalPagesize);</span><br><span class="line">       <span class="type">int</span> fromIndex;</span><br><span class="line">       List&lt;SearchMedicineVo&gt; medicineList =<span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;totalPagesize;i++)&#123;</span><br><span class="line">           <span class="comment">//起始分页条数</span></span><br><span class="line">            fromIndex= i*PAGE_SIZE;</span><br><span class="line">           <span class="comment">//查询文章</span></span><br><span class="line">            medicineList= apMedicineMapper.LoadMedicineList(fromIndex,PAGE_SIZE);</span><br><span class="line">           <span class="comment">//创建线程，做批量插入es数据操作</span></span><br><span class="line">            <span class="type">TaskThread</span> <span class="variable">taskThread</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">TaskThread</span>(medicineList,countDownLatch);</span><br><span class="line">           <span class="comment">//执行线程</span></span><br><span class="line">            executorService.execute(taskThread);</span><br><span class="line">&#125;</span><br><span class="line">           <span class="comment">//调用await()方法，用来等待计数归零</span></span><br><span class="line">           countDownLatch.await();</span><br><span class="line">       </span><br><span class="line">           <span class="type">Long</span> <span class="variable">endTime</span> <span class="operator">=</span>System.currentTimeMillis();</span><br><span class="line">           log.info(<span class="string">&quot;es索引数据批量导入共：&#123;&#125;条，共消耗时间：&#123;&#125;秒&quot;</span>，count,(endTime-startTime)/<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TaskThread</span> implementst Runnable&#123;</span><br><span class="line">            List&lt;SearchMedicineVo&gt; medicineList;</span><br><span class="line">            CountDownLatch cdl;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">TaskThread</span><span class="params">(List&lt;SearchMedicineVo&gt; medicineList,CountDownLatch cdl)</span>&#123;</span><br><span class="line">               <span class="built_in">this</span>.medicineList =medicineList;</span><br><span class="line">               <span class="built_in">this</span>.cdl=cdl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">               <span class="comment">//批量导入</span></span><br><span class="line">               BulkRequest bulkRequest <span class="keyword">new</span> <span class="title class_">BulkRequest</span>(ARTICLE_ES_INDEX);</span><br><span class="line">               <span class="keyword">for</span> (SearchMedicineVo searchMedicineVo medicineList)&#123;</span><br><span class="line">                    bulkRequest.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>().id(searchMedicinevo.getId().tostring())</span><br><span class="line">                                   source(JSON.toJSONString(searchMedicineVo),XContentType.JSON));</span><br><span class="line">               &#125;</span><br><span class="line">                <span class="comment">//发送请求，批量添加数据到s索引库中</span></span><br><span class="line">                client.bulk(bulkRequest,Requestoptions.DEFAULT);</span><br><span class="line">               <span class="comment">//让计数减</span></span><br><span class="line">                cdl.countDown();</span><br><span class="line">            &#125;   </span><br><span class="line">         &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络学习总结</title>
      <link href="/2024/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2024/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>此专栏可以说是计算机相关专业最重要的，那就是计算机网络，无论考研还是就业，它都是我们最重要的，所以我把我从学习<a href="https://www.bilibili.com/video/BV1c4411d7jb/?spm_id_from=333.999.0.0">湖科大教书匠</a>的计算机网络进行总结的笔记也上传上来了，未来如果学到没有总结到的，也会继续更新。</p><p>这几篇老文章都是我之前用飞书云文档写的，因转换格式问题，本文之前已写完的文档图片太多了，不想一一转化了，大家可以访问我的飞书云文档来查看这些图片–<a href="https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e,%E4%B8%8D%E8%BF%87%E5%90%8E%E7%BB%AD%E8%A1%A5%E5%85%85%E7%9A%84%E9%83%BD%E4%BC%9A%E6%9C%89%E5%9B%BE%E7%89%87">https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e,不过后续补充的都会有图片</a></p><h1 id="（一）计算机网络概述"><a href="#（一）计算机网络概述" class="headerlink" title="（一）计算机网络概述"></a>（一）计算机网络概述</h1><h2 id="1-计算机网络在信息时代的作用"><a href="#1-计算机网络在信息时代的作用" class="headerlink" title="1. 计算机网络在信息时代的作用"></a>1. 计算机网络在信息时代的作用</h2><ul><li>计算机网络已由一种通信基础设施发展成为一种重要的信息服务基础设施。</li><li>计算机网络已经像水、电、煤气这些基础设施一样，成为我们生活中不可或缺的一部分。</li></ul><h2 id="2-因特网概述"><a href="#2-因特网概述" class="headerlink" title="2. 因特网概述"></a>2. 因特网概述</h2><h3 id="2-1-网络、互连网-互联网-和因特网"><a href="#2-1-网络、互连网-互联网-和因特网" class="headerlink" title="2.1 网络、互连网(互联网)和因特网"></a>2.1 网络、互连网(互联网)和因特网</h3><ol><li>网络(Network)由若干结点(Node)和连接这些结点的链路(Link)组成。</li><li>多个网络还可以通过路由器互连起来，这样就构成了一个覆盖范围更大的网络，即互联网（或互连网)因此，互联网是“网络的网络(Netwrok of Networks) “。</li><li>因特网(Internet)是世界上最大的互连网络（用户数以亿计，互连的网络数以百万计)。</li><li>internet与lnternet的区别 internet(互联网或互连网) 是一个通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议可以是任意的。 Internet(因特网) 则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用TCP&#x2F;IP协议族作为通信的规则，其前身是美国的 ARPANET。</li></ol><h3 id="2-2-因特网发展的三个阶段"><a href="#2-2-因特网发展的三个阶段" class="headerlink" title="2.2 因特网发展的三个阶段"></a>2.2 因特网发展的三个阶段</h3><h4 id="1-从单个网络ARPANET向互联网发展"><a href="#1-从单个网络ARPANET向互联网发展" class="headerlink" title="1. 从单个网络ARPANET向互联网发展"></a>1. 从单个网络ARPANET向互联网发展</h4><ul><li>1969年，第一个分组交换网 ARPANET;</li><li>70年代中期，研究多种网络之间的互连;</li><li>1983年,TCP&#x2F;IP协议成为ARPANET的标准协议(因特网诞生时间)</li></ul><h4 id="2-逐步建成三级结构的因特网"><a href="#2-逐步建成三级结构的因特网" class="headerlink" title="2. 逐步建成三级结构的因特网"></a>2. 逐步建成三级结构的因特网</h4><ul><li>1985年，NSF围绕六个大型计算机中心建设NSFNET（主干网、地区网和校园网）;</li><li>1990年，ARPANET任务完成，正式关闭;</li><li>1991年，美国政府将因特网主干网交给私人公司经营，并开始对接入因特网的单位收费;</li></ul><h4 id="3-多层次ISP结构的因特网"><a href="#3-多层次ISP结构的因特网" class="headerlink" title="3. 多层次ISP结构的因特网"></a>3. 多层次ISP结构的因特网</h4><ul><li>1993年，NSFNET逐渐被若干个商用因特网主干网替代;政府机构不再负责因特网运营，让各种因特网服务提供者ISP来运营。</li><li>1994年，万维网wwW技术促使因特网迅猛发展;</li><li>1995年，NSFNET停止运作，因特网彻底商业化。</li></ul><blockquote><p>ISP: 因特网服务提供者ISP（Internet Service Provider）</p></blockquote><h3 id="2-3-因特网的标准化工作"><a href="#2-3-因特网的标准化工作" class="headerlink" title="2.3 因特网的标准化工作"></a>2.3 因特网的标准化工作</h3><ol><li>因特网的标准化工作对因特网的发展起到了非常重要的作用。</li><li>因特网在制定其标准上的一个很大的特点是面向公众。<ol><li>因特网所有的RFC(Request For Comments)技术文档都可从因特网上免费下载;(<a href="http://www.ietf.org/rfc.html">http://www.ietf.org/rfc.html</a>)</li><li>任何人都可以随时用电子邮件发表对某个文档的意见或建议。</li></ol></li><li>因特网协会ISOC是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用。<ol><li>因特网体系结构委员会IAB，负责管理因特网有关协议的开发;</li><li>因特网工程部IETF，负责研究中短期工程问题，主要针对协议的开发和标准化;</li><li>因特网研究部IRTF，从事理论方面的研究和开发一些需要长期考虑的问题。</li></ol></li><li>制订因特网的正式标准要经过以下4个阶段:<ol><li>因特网草案(在这个阶段还不是RFC文档)</li><li>建议标准 (从这个阶段开始就成为RFC文档)</li><li>草案标准 (目前已取消)</li><li>因特网标准</li></ol></li></ol><h3 id="2-4-因特网组成"><a href="#2-4-因特网组成" class="headerlink" title="2.4 因特网组成"></a>2.4 因特网组成</h3><p>因特网由边缘部分和核心部分组成。</p><h4 id="1-边缘部分"><a href="#1-边缘部分" class="headerlink" title="1. 边缘部分"></a>1. 边缘部分</h4><p>由所有连接在因特网上的 主机 组成。这部分是 用户直接 使用的，用来进行 通信 （传送数据、音频或视频）和 资源共享</p><h4 id="2-核心部分"><a href="#2-核心部分" class="headerlink" title="2. 核心部分"></a>2. 核心部分</h4><p>由 大量网络 和连接这些网络的 路由器 组成。这部分是 为边缘部分提供服务 的(提供连通性和交换)</p><h2 id="3-三种交换方式"><a href="#3-三种交换方式" class="headerlink" title="3. 三种交换方式"></a>3. 三种交换方式</h2><ul><li>电路交换（Circuit Switching）</li><li>分组交换（Packet Switching）</li><li>报文交换（Message Switching）</li></ul><h3 id="3-1-电路交换"><a href="#3-1-电路交换" class="headerlink" title="3.1 电路交换"></a>3.1 电路交换</h3><p>电话交换机接通电话线的方式称为电路交换;</p><p>从通信资源的分配角度来看，交换(Switching）就是按照某种方式动态地分配传输线路的资源;</p><p>电路交换的三个步骤：</p><ol><li>建立连接（分配通信资源)</li><li>通话（一直占用通信资源)</li><li>释放连接（归还通信资源)</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OTk5NTdjNWU1YmI2M2QxYmY4NDhkZWFkYWQyMDdiOGVfWTdid0U1RTdQZkhIdWdNNUpHN3Mwc1Zud0luWFZEdE1fVG9rZW46TEFYbWJ6R3VDb05OVHp4ZnNZZWNMS1NZbk9nXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><blockquote><p>当使用电路交换来传送计算机数据时, 其线路的传输效率往往很低。</p></blockquote><h3 id="3-2-分组交换"><a href="#3-2-分组交换" class="headerlink" title="3.2 分组交换"></a>3.2 分组交换</h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ODZkMDA3ZmNjNWJiNmVkZGI1YWJkNzU2ODE3ZTI3YTBfQ3dMRWRENFN1T0dmdzJoT1VDckx0N3htc0wySjh1YXNfVG9rZW46UDNhVWJ0TURrbzhjeTF4dktxbWNUWDEybnFmXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h3 id="3-3-报文交换"><a href="#3-3-报文交换" class="headerlink" title="3.3 报文交换"></a>3.3 报文交换</h3><p>报文交换对报文的大小没有限制，这就要求结点有较大的缓存空间。报文交换主要用于早期的电报通信网，现在较少使用。通常被较先进的分组交换方式所替代。</p><h3 id="3-4-三种方式对比"><a href="#3-4-三种方式对比" class="headerlink" title="3.4 三种方式对比"></a>3.4 三种方式对比</h3><h2 id="4-计算机网络的定义和分类"><a href="#4-计算机网络的定义和分类" class="headerlink" title="4. 计算机网络的定义和分类"></a>4. 计算机网络的定义和分类</h2><h3 id="4-1-计算机网络的定义"><a href="#4-1-计算机网络的定义" class="headerlink" title="4.1 计算机网络的定义"></a>4.1 计算机网络的定义</h3><ul><li>计算机网络的精确定义并未统一</li><li>计算机网络的最简单的定义是: 一些 互相连接 的、自治 的计算机的 集合。<ul><li>互连 是指计算机之间可以通过有线或无线的方式进行数据通信</li><li>自治 是指独立的计算机，它有自己的硬件和软件，可以单独运行使用</li><li>集合 是指至少需要两台计算机</li></ul></li><li>计算机网络的较好的定义 是: 计算机网络主要是由一些 通用的、可编程的硬件互连 而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号)。这些可编程的硬件能够用来 传送多种不同类型的数据，并能 支持广泛的和日益增长的应用。 该定义表明：<ul><li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。</li><li>计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用)</li></ul></li></ul><blockquote><p>以下系统并不是一个计算机网络。 因为图示终端机只是具有显示和输入设备的终端，不是自治的计算机。因此，这只是一个运行分时系统的大型机系统。</p></blockquote><h3 id="4-2-计算机网络的分类"><a href="#4-2-计算机网络的分类" class="headerlink" title="4.2 计算机网络的分类"></a>4.2 计算机网络的分类</h3><ol><li>按照交换技术分类<ol><li>电路交换网络</li><li>报文交换电路</li><li>分组交换电路</li></ol></li><li>按使用者分类<ol><li>公用网</li><li>专用网</li></ol></li><li>按照传输介质分类<ol><li>有线网</li><li>无线网</li></ol></li><li>按覆盖范围分类<ol><li>广域网 WAN</li><li>城域网 MAN</li><li>局域网 LAN</li><li>个域网 PAN</li></ol></li><li>按拓扑结构分类<ol><li>总线型网络</li><li>星型网络</li><li>环型网络</li><li>网状型网络</li></ol></li></ol><h2 id="5-计算机网络的性能指标"><a href="#5-计算机网络的性能指标" class="headerlink" title="5. 计算机网络的性能指标"></a>5. 计算机网络的性能指标</h2><h3 id="5-1-常用性能指标"><a href="#5-1-常用性能指标" class="headerlink" title="5.1 常用性能指标"></a>5.1 常用性能指标</h3><p>性能指标可以从不同的方面来度量计算机网络的性能。 常用的计算机网络的性能指标有以下8个:</p><ul><li>速率</li><li>带宽</li><li>吞吐量</li><li>时延</li><li>时延带宽积</li><li>往返时间</li><li>利用率</li><li>丢包率</li></ul><h3 id="5-2-速率"><a href="#5-2-速率" class="headerlink" title="5.2 速率"></a>5.2 速率</h3><h4 id="1-比特"><a href="#1-比特" class="headerlink" title="1. 比特"></a>1. 比特</h4><p>计算机中 数据量的单位，也是信息论中信息量的单位。一个比特就是二进制数字中的一个 <code>1</code> 或 <code>0</code>。</p><p>常用数据量单位:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 bit = 1 Byte  </span><br><span class="line">KB = 2^10B  </span><br><span class="line">MB = K·KB = 2^10·2^10 B = 2^20 B  </span><br><span class="line">GB = K·MB = 2^10·2^20 B = 2^30 B  </span><br><span class="line">TB = K·GB = 2^10·2^30 B = 2^40 B  Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><h4 id="2-速率"><a href="#2-速率" class="headerlink" title="2. 速率"></a>2. 速率</h4><p>连接在计算机网络上的主机在数字信道上传送比特的速率，也称为 比特率 或 数据率。</p><p>常用数据单位：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bit/s (b/s，bps)  </span><br><span class="line">kb/s = 10^3 b/s (bps)    </span><br><span class="line">Mb/s = k·kb/s = 10^3·10^3 bls = 10^6 b/s (bps)   </span><br><span class="line">Gb/s = k·Mb/s = 10^3·10^6 b/s = 10 b/s (bps)    </span><br><span class="line">Tb/s = k·Gb/s = 10^3·10^9 b/s = 10^2 b/s (bps)Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>例1∶有一个待发送的数据块，大小为100 MB，网卡的发送速率为100 Mbps，则网卡发送完该数据块需要多长时间?</p><p>𝑇&#x3D;100𝑀𝐵100𝑀𝑏&#x2F;𝑠&#x3D;𝑀𝐵𝑀𝑏&#x2F;𝑠&#x3D;220𝐵106𝑏&#x2F;𝑠&#x3D;220⋅8𝑏106𝑏&#x2F;𝑠&#x3D;8.388608𝑠T&#x3D;100Mb&#x2F;s100MB&#x3D;Mb&#x2F;sMB&#x3D;106b&#x2F;s220B&#x3D;106b&#x2F;s220⋅8b&#x3D;8.388608s</p><h3 id="5-3-带宽"><a href="#5-3-带宽" class="headerlink" title="5.3 带宽"></a>5.3 带宽</h3><p>带宽在模拟信号系统中的意义：信号所包含的各种不同频率成分所占据的频率范围。</p><p>带宽在计算机网络中的意义：用来表示网络的通信线路所能传送数据的能力，因此网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的 “最高数据率”。</p><p>单位：b&#x2F;s, (kb&#x2F;s, Mb&#x2F;s, Gb&#x2F;s, Tb&#x2F;s)</p><p>其实,“带宽”的这两种表述之间有着密切的联系。一条通信线路的“频带宽度”越宽,其所传输数据的“最高数据率”也越高。</p><h3 id="5-4-吞吐量"><a href="#5-4-吞吐量" class="headerlink" title="5.4 吞吐量"></a>5.4 吞吐量</h3><ul><li>吞吐量表示在单位时间内 通过某个网络(或信道、接口)的数据量。</li><li>吞吐量被经常用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。</li><li>吞吐量受 网络的带宽或额定速率 的限制。</li></ul><h3 id="5-5-时延"><a href="#5-5-时延" class="headerlink" title="5.5 时延"></a>5.5 时延</h3><p>网络时延 &#x3D; 发送时延 + 传播时延 + 处理时延</p><h4 id="1-发送时延"><a href="#1-发送时延" class="headerlink" title="1. 发送时延"></a>1. 发送时延</h4><p>发送时延(s) &#x3D; 分组长度(b) &#x2F; 发送速率(b&#x2F;s)</p><p>发送速率受 网卡的发送速率 、信道带宽、接口速率 影响。</p><h4 id="2-传播时延"><a href="#2-传播时延" class="headerlink" title="2. 传播时延"></a>2. 传播时延</h4><p>传播时延(s) &#x3D; 信道长度(m) &#x2F; 电磁波传播速率(m&#x2F;s)</p><p>电磁波在 自由空间 的传播速率 𝑣&#x3D;3×108𝑚&#x2F;𝑠v&#x3D;3×108m&#x2F;s</p><p>在铜线中：𝑣&#x3D;2.3×108𝑚&#x2F;𝑠v&#x3D;2.3×108m&#x2F;s</p><p>在光纤中：𝑣&#x3D;2.0×108𝑚&#x2F;𝑠v&#x3D;2.0×108m&#x2F;s</p><p>要计算传播时延，先确定传播媒体。</p><h4 id="3-处理时延"><a href="#3-处理时延" class="headerlink" title="3. 处理时延"></a>3. 处理时延</h4><p>不方便计算。</p><blockquote><p>发送时延占主导还是传播时延占主导，要根据具体例子实际分析。</p></blockquote><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MzVkMWI1ZmIyOTc3NmQ4NDg4MGU2M2VhYWY5NThhMTBfdVd3aEpHbjRPVzdMTkhHT3FLMTRGWlRSS05tSkx0TVRfVG9rZW46VkMxZWJidnRyb1J1STl4TFBad2NScTBtbnN1XzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h3 id="5-6-时延带宽积"><a href="#5-6-时延带宽积" class="headerlink" title="5.6 时延带宽积"></a>5.6 时延带宽积</h3><p>时延带宽积 &#x3D; 传播时延 * 带宽</p><ul><li>若发送端连续发送数据，则在所发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个比特</li><li>链路的时延带宽积又称为 以比特为单位的链路长度。</li></ul><h3 id="5-7-往返时间RTT"><a href="#5-7-往返时间RTT" class="headerlink" title="5.7 往返时间RTT"></a>5.7 往返时间RTT</h3><ul><li>从发送端发送信息开始，到发送端接收到来自接受端发送的确认信息，称为往返时间RTT。</li><li>在许多情况下，因特网上的信息不仅仅单方向传输，而是双向交互</li><li>我们有时很需要知道双向交互一次所需的时间;</li><li>因此，往返时间 RTT(Round-Trip Time)也是一个重要的性能指标。</li></ul><h3 id="5-8-利用率"><a href="#5-8-利用率" class="headerlink" title="5.8 利用率"></a>5.8 利用率</h3><p>利用率分类为 信道利用率 和 网络利用率</p><ul><li>信道利用率：用来表示某信道有百分之几的时间是被利用的（有数据通过)</li><li>网络利用率：全网络的信道利用率的加权平均</li></ul><p>根据排队论，当某信道的利用率增大时，该信道引起的时延也会迅速增加。</p><p>如果令：</p><ul><li>𝐷0D0：网络空闲时延</li><li>𝐷D：网络当前时延</li><li>𝑈U：利用率</li></ul><p>那么则有下列关系：</p><p>𝐷&#x3D;𝐷01−𝑈D&#x3D;1−UD0</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NzBlN2Q0OTU4MjU1ODM5MTI2ZWU4YzE2YWQ1OTNjMWFfYjBoNmszRWc4MkxmbEU5NEwwZHhseko3bk14elNCVGhfVG9rZW46VUtPYWJIV21PbzVhTlV4RmhDU2N6MG05bmNkXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><ul><li>当网络的利用率达到50%时，时延就要加倍</li><li>当网络的利用率超过50%时，时延急剧增大</li><li>当网络的利用率接近100%时，时延就趋于无穷大</li><li>因此，一些拥有较大主干网的ISP通常会控制它们的信道利用率不超过50%。如果超过了，就要准备扩容，增大线路的带宽</li></ul><p>也不能使信道利用率太低，这会使宝贵的通信资源被白白浪费。应该使用一些机制，可以根据情况动态调整输入到网络中的通信量，使网络利用率保持在合理范围内。</p><h3 id="5-9-丢包率"><a href="#5-9-丢包率" class="headerlink" title="5.9 丢包率"></a>5.9 丢包率</h3><ol><li>丢包率即分组丢失率，是指在一定的时间范围内，传输过程中 丢失的分组数量与总分组数量的比率。</li><li>丢包率具体可分为接口丢包率、结点丢包率、链路丢包率、路径丢包率、网络丢包率等。</li><li>丢包率是 网络运维人员 非常关心的一个网络性能指标，但对于普通用户来说往往并不关心这个指标，因为他们通常意识不到网络丢包。</li><li>分组丢失主要有两种情况:<ol><li>分组在传输过程中出现 误码，被结点丢弃;</li><li>分组到达一台队列已满的分组交换机时被丢弃;</li><li>在通信量较大时就可能造成 网络拥塞。</li></ol></li><li>因此，丢包率反映了网络的拥塞情况:<ol><li>无拥塞时路径丢包率为0</li><li>轻度拥塞时路径丢包率为1%~4%</li><li>严重拥塞时路径丢包率为5%~15%</li></ol></li></ol><h2 id="6-计算机网络体系结构"><a href="#6-计算机网络体系结构" class="headerlink" title="6. 计算机网络体系结构"></a>6. 计算机网络体系结构</h2><h3 id="6-1-常见的计算机网络体系结构"><a href="#6-1-常见的计算机网络体系结构" class="headerlink" title="6.1 常见的计算机网络体系结构"></a>6.1 常见的计算机网络体系结构</h3><ul><li>常见网络体系结构–&gt;OSI体系结构</li><li>常见网络体系结构–&gt;TCP&#x2F;IP体系结构</li><li>OSI体系结构–&gt;五层协议结构</li><li>TCP&#x2F;IP体系结构–&gt;五层协议结构</li></ul><h4 id="1-OSI体系结构"><a href="#1-OSI体系结构" class="headerlink" title="1. OSI体系结构"></a>1. OSI体系结构</h4><p>法律上的国际标准时 OSI 七层体系结构，但由于专家却反实际经验、分层过于复杂、指定周期长、层次划分不合理等原因，并没有投入实际引用。</p><h4 id="2-TCP-IP体系结构"><a href="#2-TCP-IP体系结构" class="headerlink" title="2. TCP&#x2F;IP体系结构"></a>2. TCP&#x2F;IP体系结构</h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWMzMmEyZTlkY2NhYzA1ZmE3NTE3NzBiN2E4OTM0ZGFfUk81UWtidVlIaEd3QVhKb1l0Tlc3VEVBR0liZHc4RjJfVG9rZW46TnBKWGJsQ3N6b0RVNjR4ZHYyVWNhemhDbkliXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h4 id="3-五层协议体系结构"><a href="#3-五层协议体系结构" class="headerlink" title="3. 五层协议体系结构"></a>3. 五层协议体系结构</h4><p>结合了 OSI 和 TCP&#x2F;IP 的特点，一般用于学习。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NzAyZWQ2MmJhOTllNmJiOGY3N2JhMTRiYjBlZjc1ZGJfUjA2VHdvQnVUUXo0NVFVUUhyblhKY2djU0lQaVZNazZfVG9rZW46WUM5S2Jjcklob3k1emt4VnB6bWNWRnU5bjJjXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h3 id="6-2-计算机网络体系结构分层的必要性"><a href="#6-2-计算机网络体系结构分层的必要性" class="headerlink" title="6.2 计算机网络体系结构分层的必要性"></a>6.2 计算机网络体系结构分层的必要性</h3><ul><li>计算机网络是个非常复杂的系统。早在最初的ARPANET设计时就提出了分层的设计理念。</li><li>“分层” 可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理。</li></ul><p>下面按照由简单到复杂的顺序，来看看实现计算机网络要面临哪些主要的问题，以及如何将这些问题划分到相应的层次，层层处理。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OTY0NDZlMzNjMmRkZWZiMTg1NzA0ODE2MDgyZDViM2Jfczl6ZWFuaFlKODVtN0NGS2s3NWc0OWJYaUpUeUxNNGVfVG9rZW46WGRpaGJIMVVZbzNzMUp4NlV0d2NJa1lTbjZmXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h3 id="6-3-计算机网络体系结构分层思想举例"><a href="#6-3-计算机网络体系结构分层思想举例" class="headerlink" title="6.3 计算机网络体系结构分层思想举例"></a>6.3 计算机网络体系结构分层思想举例</h3><h3 id="6-4-计算机网络体系结构中的专用术语"><a href="#6-4-计算机网络体系结构中的专用术语" class="headerlink" title="6.4 计算机网络体系结构中的专用术语"></a>6.4 计算机网络体系结构中的专用术语</h3><h4 id="1-实体"><a href="#1-实体" class="headerlink" title="1. 实体"></a>1. 实体</h4><p>实体：任何可发送或接受信息的 硬件 或 软件进程。</p><p>对等实体：收发双方 相同层次中的实体。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NTMzYmZlZjc5NjUyOTQzMGE1NWRmYWFjOWI5ZWJhYjRfUmJnRmtDNExmSXVFUzc5RGZRbHdWeVJHcVdBY0V0UHpfVG9rZW46WFZNWGJITHF1b3lJZUx4TmVuN2NpdGJMbkxkXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h4 id="2-协议"><a href="#2-协议" class="headerlink" title="2. 协议"></a>2. 协议</h4><p>协议：控制两个对等实体进行逻辑通信的规则的集合。协议的三要素：语法、语义、同步</p><ul><li>语法：定义所交换信息的格式</li><li>语义：定义收发双方所要完成的操作</li><li>同步：定义收发双方的时序关系</li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=Mjg0Y2MxM2M1MDQzMWRmNmYxYWQ4ZWMyNzRlNTVmNmNfU0M1dVFDb0hrR0hOQURhNEc4T0NCV25QSmdIaE9BT1pfVG9rZW46QWtTcGJna3hsbzNCUGp4NXdEYmMzaDFMbkloXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><ul><li>在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务。</li><li>要实现本层协议，还需要使用下面一层所提供的服务。</li><li>协议是“水平的”，服务是“垂直的”。</li><li>实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议。也就是说，下面的协议对上面的实体是 “透明” 的。</li></ul><h4 id="3-服务"><a href="#3-服务" class="headerlink" title="3. 服务"></a>3. 服务</h4><ul><li>服务访问点：在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型。<ul><li>数据链路层的服务访问点为帧的“类型”字段。</li><li>网络层的服务访问点为IP数据报首部中的“协议字段”。</li><li>运输层的服务访问点为“端口号”。</li></ul></li><li>服务原语：上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语。</li><li>协议数据单元PDU：对等层次之间传送的数据包称为该层的协议数据单元。</li><li>服务数据单元SDU：同一系统内，层与层之间交换的数据包称为服务数据单元。</li><li>多个SDU可以合成为一个PDU，一个SDU也可划分为几个PDU。</li></ul><ol><li><h2 id="总时延计算"><a href="#总时延计算" class="headerlink" title="总时延计算"></a>总时延计算</h2></li></ol><p>假设:分组等长，各链路长度相同、带宽也相同，忽略路由器的处理时延。</p><p>若有 𝑛n 个分组，𝑚m 段链路，则总时延计算公式为：</p><p>总时延 &#x3D; n个分组的发送时延 + 1 个分组的发送时延 * (m-1) + 1段链路的传播时延 * m</p><p>设：</p><ul><li>总时延：𝑇T</li><li>一个分组的发送时延：𝑡0t0</li><li>一段链路的传播时延：𝑡𝑠ts</li></ul><p>则有：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">𝑇=𝑛×𝑡<span class="number">0</span>+(𝑚−<span class="number">1</span>)×𝑡<span class="number">0</span>+𝑚×𝑡𝑠T=n×t0+(m−<span class="number">1</span>)×t0+m×ts</span><br></pre></td></tr></table></figure><ol><li><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2></li><li><p>在OSI参考模型中，自下而上第一个提供端到端服务的层次是B</p></li></ol><p>A.数据链路层</p><p>B.传输层</p><p>C.会话层</p><p>D.应用层</p><ol><li>下列选项中，不属于网络体系结构所描述的内容是C</li></ol><p>A.网络的层次</p><p>B.每一层使用的协议</p><p>C.协议的内部实现细节</p><p>D.每一层必须完成的功能</p><ol><li>TCP&#x2F;IP参考模型的网络层提供的是A</li></ol><p>A.无连接不可靠的数据报服务</p><p>B.无连接可靠的数据报服务</p><p>C.有连接不可靠的虚电路服务</p><p>D.有连接可靠的虚电路服务</p><ol><li>在TCP&#x2F;IP体系结构中，直接为CMP提供服务的协议是B</li></ol><p>A.PPP</p><p>B.IP</p><p>C.UDP</p><p>D.TCP</p><ol><li>在OSI参考模型中，下列功能需由应用层的相邻层实现的是B</li></ol><p>A.对话管理</p><p>B.数据格式转换</p><p>C.路由选择</p><p>D.可靠数据传输</p><ol><li>在OSI参考模型中，直接为会话层提供服务的是C</li></ol><p>A.应用层</p><p>B.表示层</p><p>C.传输层</p><p>D.网络层</p><ol><li>通过POP3协议接收邮件时，使用的传输层服务类型是D</li></ol><p>A.无连接不可靠的数据传输服务</p><p>B.无连接可靠的数据传输服务</p><p>C.有连接不可靠的数据传输服务</p><p>D.有连接可靠的数据传输服务</p><ol><li>在OSI参考模型中，R1、Switch、Hub实现的最高功能层分别是C</li></ol><p>A.2、2、1</p><p>B.2、2、2</p><p>C.3、2、1</p><p>D.3、2、2</p><ol><li>假设OSI参考模型的应用层欲发送400B的数据（无拆分），除物理层和应用层之</li></ol><p>外，其他各层在封装PDU时均引入20B的额外开销，则应用层数据传输效率约为A</p><p>A.80%</p><p>B.83%</p><p>C.87%</p><p>D.91%</p><ol><li>下列TCP&#x2F;IP应用层协议中，可以使用传输层无连接服务的是B</li></ol><p>A.FTP</p><p>B.DNS</p><p>C.SMTP</p><p>D.HTTP</p><h1 id="（二）物理层"><a href="#（二）物理层" class="headerlink" title="（二）物理层"></a>（二）物理层</h1><h2 id="1-物理层基本概念"><a href="#1-物理层基本概念" class="headerlink" title="1. 物理层基本概念"></a>1. 物理层基本概念</h2><ul><li>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。</li><li>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么。</li><li>物理层协议的主要任务：机械特性、电气特性、功能特性、过程特性</li><li>传输媒体不属于任何一层，如果一定要分类，则属于物理层</li><li>传输媒体<ul><li>导引型传输媒体<ul><li>同轴电缆</li><li>双绞线</li><li>光纤</li></ul></li><li>非导引型传输媒体：微波通信</li></ul></li></ul><h2 id="2-物理层下面的传输媒体"><a href="#2-物理层下面的传输媒体" class="headerlink" title="2. 物理层下面的传输媒体"></a>2. 物理层下面的传输媒体</h2><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NzdjNTIzYTY5MzFkOTBlNGI4MDdlNDZmZDMyZmIzNDZfTmV3bklSckRHNE1YNVpyOUZicWc3NmRTZ29ydGFHMEFfVG9rZW46TWE5NmJ4MllGb0w1SDR4NHVXQWNSamc2blBoXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><p>双绞线绞合的作用：</p><ol><li>抵御部分来自外界的电磁干扰</li><li>减少相邻导线的电磁干扰</li></ol><ul><li>目前的家用以太网,最低应选用超5类(5E)双绞线</li><li>屏蔽双绞线比非屏蔽双绞线只有更好的抗干扰性能,但价格也更贵。|</li></ul><p>微波传播特性</p><ol><li>直线传播，可以穿透电离层</li><li>地面100米发生塔，最大视距LOS传输距离为100公里</li><li>地球同步卫星</li><li>低轨道卫星</li></ol><h2 id="3-传输方式"><a href="#3-传输方式" class="headerlink" title="3. 传输方式"></a>3. 传输方式</h2><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NWQxZGYyNjQ5ZTg0M2JhMGNlYmI2ZmJjOGVkZWIwZmZfdm1zMjlJWjNtWlFodFdTMTdPejJvMlpsN0xxSWU2aUVfVG9rZW46UmpnSmJFOFRXb1hheFZ4VDJ6SmM2ZmdPbjBjXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h4 id="1-串行传输与并行传输"><a href="#1-串行传输与并行传输" class="headerlink" title="1. 串行传输与并行传输"></a>1. 串行传输与并行传输</h4><ol><li>串行传输 串行传输是指数据是一个比特一个比特依次发送的，只需要一条传输链路。</li><li>并行传输 并行传输是指一次发送n个比特而不是一个比特，为此。在发送端和接收端之间需要有n条传输线路。</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NThlNTRjMDhlNWVlZDQ5YTY0ODk5MDQxYWQwNDZiNTRfWktkUGJZbzBFbVNZNzY4Ynd5cExGUFk3dW5BeU9PUjhfVG9rZW46UkRzc2JjTzBSb0xDc2Z4Q0I2eGNOblRubnJkXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h4 id="2-同步传输和异步传输"><a href="#2-同步传输和异步传输" class="headerlink" title="2. 同步传输和异步传输"></a>2. 同步传输和异步传输</h4><ol><li>同步传输 收发双方时钟同步的方法<ol><li>外同步: 在收发双方之间添加一条单独的时钟信号线</li><li>内同步: 发送端将时钟同步信号编码到发送数据中一起传输（例如曼彻斯特编码)</li></ol></li><li>异步传输<ol><li>字节之间异步（字节之间的时间间隔不固定)</li><li>字节中的每个比特仍然要同步(各比特的持续时间是相同的)</li></ol></li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NTk3M2NiOWJjNjM0MjM5YmZlMWJkN2ZiMjMwNDZkZDRfQTdWUzJyRHJ1bnVvVkpDSE1EUXB2QXJJaTYxdDJxeXFfVG9rZW46TDJsVmJ6U0h3b2xUbFd4V2kwNWNNZmpObmpiXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h4 id="3-单工、半双工、全双工通信"><a href="#3-单工、半双工、全双工通信" class="headerlink" title="3. 单工、半双工、全双工通信"></a>3. 单工、半双工、全双工通信</h4><ol><li>单工：一方向另一方传递信息</li><li>半双工：双方互相传递信息，但是不能同时传递</li><li>全双工：双方可同时互相传递信息</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OTM5M2EwM2IyZjMzNGFjYWY3Y2NkMzA5ZDNmNjQ0YzRfaUZtSmF3eHVXT2ExczRLeEdIUHc2NkR4U2hFTGVoTWJfVG9rZW46U05obWJoOTVlb1VyQlN4OFVqdWNQbjcwbk1iXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h2 id="4-编码与调制"><a href="#4-编码与调制" class="headerlink" title="4. 编码与调制"></a>4. 编码与调制</h2><h3 id="4-1-编码与调制"><a href="#4-1-编码与调制" class="headerlink" title="4.1 编码与调制"></a>4.1 编码与调制</h3><h3 id="4-2-码元"><a href="#4-2-码元" class="headerlink" title="4.2 码元"></a>4.2 码元</h3><p>码元：在使用时间域的波形表示数字信号时,代表不同 离散数值的基本波形。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NjEwM2JhYjE1NTJjMGE0YTdmZTI3NWI5ZTVjNjBlMDJfZU93dml3dnU2bTgzVXFPaHhoMTA3eWg5SGRYcnpJc2RfVG9rZW46UGlFU2Izd3FKb00xQkV4S3FOZGMxM2VQbmtmXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h3 id="4-3-传输媒体与信道的关系"><a href="#4-3-传输媒体与信道的关系" class="headerlink" title="4.3 传输媒体与信道的关系"></a>4.3 传输媒体与信道的关系</h3><p>传输媒体不等同于信道，对于单工通信，传输媒体只有一条 发送信道或者接收信道；对于半双工和全双工传输，则包含两条信道；如果使用 信道复用 技术，则可以包含多条信道。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NzUzNzE3NWJmYjg2MTIzYWE1ODYwNjFjNTlhMGFhZmZfaUlQT2R0WHlSMkNFdGFIMjF2bzE1Nmowb29qMnoxV1VfVG9rZW46VTFXUGJpMnpUb0k5aEp4d1I4UmN0NmtIbmhnXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h3 id="4-4-信道复用技术"><a href="#4-4-信道复用技术" class="headerlink" title="4.4 信道复用技术"></a>4.4 信道复用技术</h3><h3 id="4-5-常用编码"><a href="#4-5-常用编码" class="headerlink" title="4.5 常用编码"></a>4.5 常用编码</h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OGU1Y2FkZmMyZGIwNmY3ODQ5OGIyM2NlM2U4YzM5MDNfS2FySGF5cEhhdFlFQkNxMzl1THpZcVRMMWRvNnFmNWlfVG9rZW46TE5OOWJLR0hDb3I3RHV4eDZDZmMxQ0x3bnhjXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h3 id="4-6-基本调制方法"><a href="#4-6-基本调制方法" class="headerlink" title="4.6 基本调制方法"></a>4.6 基本调制方法</h3><p>基本调制方法：调幅、调频、调相</p><h3 id="4-7-混合调制"><a href="#4-7-混合调制" class="headerlink" title="4.7 混合调制"></a>4.7 混合调制</h3><p>正交振幅调制：通常情况下，相位和振幅可以结合起来一起调制，称为正交振幅调制 QAM。</p><h3 id="4-8-混合调制举例：正交振幅调制"><a href="#4-8-混合调制举例：正交振幅调制" class="headerlink" title="4.8 混合调制举例：正交振幅调制"></a>4.8 混合调制举例：正交振幅调制</h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NTIxY2U0Y2EwMDVkM2FjY2U4OWI5NmM5YTZjMjE3MTZfYzFtOVBWYlBsamo0cndaMTVaTElmWk1ITzZHcVFtWHdfVG9rZW46V3hJamJ3V0Zub3E0clV4RkF2RWN3SFhibldlXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h2 id="5-信道的极限容量"><a href="#5-信道的极限容量" class="headerlink" title="5. 信道的极限容量"></a>5. 信道的极限容量</h2><h3 id="5-1-信号失真"><a href="#5-1-信号失真" class="headerlink" title="5.1 信号失真"></a>5.1 信号失真</h3><p>信号在通过信道时，会产生失真现象。</p><p>信号通过通信质量较好的信道时，失真不严重，可以识别；但信号通过通信质量较差的信道时，失真严重，无法识别。</p><p>影响失真的因素：码元传输速率、信号传输距离、噪声干扰、传输媒体质量等</p><h3 id="5-2-奈氏准则"><a href="#5-2-奈氏准则" class="headerlink" title="5.2 奈氏准则"></a>5.2 奈氏准则</h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWJhOTNkMGFiNDIxOTk5NWE1YmFkNzI1YmVlZmJiZTZfcUVNQm1PM0hjdlNFUDA2UlQza1padmhvRHNjNzNiMjdfVG9rZW46STFyZmJ0R3BQb3l5U1N4QlE5VGNYZGd5bkhmXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><p>奈氏准则计算公式</p><p>理想低通信道下极限数据传输速率</p><p>𝐶&#x3D;2𝑊log⁡2𝑉C&#x3D;2Wlog2V</p><p>其中，C是数据传输速率（bit&#x2F;s），W是信道带宽（Hz），V是信号状态数（可调制的不同波形的数量）</p><h3 id="5-3-香农公式"><a href="#5-3-香农公式" class="headerlink" title="5.3 香农公式"></a>5.3 香农公式</h3><h3 id="5-4-数据传输速率公式"><a href="#5-4-数据传输速率公式" class="headerlink" title="5.4 数据传输速率公式"></a>5.4 数据传输速率公式</h3><p>数据传输速率(比特&#x2F;秒) &#x3D; 波特率(码元传输速率，码元&#x2F;秒) * 每个码元携带的信息量(比特&#x2F;码元)</p><h3 id="5-5-奈氏准则与香农公式的意义"><a href="#5-5-奈氏准则与香农公式的意义" class="headerlink" title="5.5 奈氏准则与香农公式的意义"></a>5.5 奈氏准则与香农公式的意义</h3><h2 id="6-习题课"><a href="#6-习题课" class="headerlink" title="6. 习题课"></a>6. 习题课</h2><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ODUwZGU5ZjUzMTRlNjgxM2VlMDBhZGU3MzJjMzc0ZjFfdGpiVjVHZXkwM09pRDVZTXZPMkJpVWN3aVNaS2NmWlhfVG9rZW46WkJNcGJjWTN5b21xS1Z4WGJFbWNjNUpJbk9nXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><p>解答：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NGY1ZGQ1YWM0NGIxYjRmYTMzOWY4Yjg4NzIwOGRlNmJfdkpScFdwdnoydm41NFhUeFNhZ1h2Q3UyQW02OTcyTTZfVG9rZW46RGJqcGJyem9Sb2RUTXV4UW1odGNONzNWbnhkXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWM4YzZkYzZhNWVhNzIxODA2MDNlNTkwOGNiOGUyZDZfN1Zrc0tmZEVGZzgwaEhrSGdGYnhvaWlCdTVHcWtyNElfVG9rZW46WWNiN2JHblVGbzhibGt4M3UyN2N6OHJIbkdnXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><p>解析</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NjAxMWU3ODIzN2FkNmI2ZTI3Zjc1NDUwYzkwNjkwNmRfcFZRUlkwWFNTVEhZd21jcTRNSmRpVzB4dVdFNU1yZjNfVG9rZW46Q2RWYWJYWUU2b1NValB4dVl2cmNpUXEybmNjXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h1 id="（三）数据链路层"><a href="#（三）数据链路层" class="headerlink" title="（三）数据链路层"></a>（三）数据链路层</h1><h2 id="1-数据链路层概述"><a href="#1-数据链路层概述" class="headerlink" title="1. 数据链路层概述"></a>1. 数据链路层概述</h2><h3 id="1-1-数据链路层在网络体系结构中的地位"><a href="#1-1-数据链路层在网络体系结构中的地位" class="headerlink" title="1.1 数据链路层在网络体系结构中的地位"></a>1.1 数据链路层在网络体系结构中的地位</h3><p>数据链路层上传输的数据包称为帧。</p><h3 id="1-2-使用点对点信道的数据链路层"><a href="#1-2-使用点对点信道的数据链路层" class="headerlink" title="1.2 使用点对点信道的数据链路层"></a>1.2 使用点对点信道的数据链路层</h3><blockquote><p>数据链路层的三个重要问题</p></blockquote><h4 id="1-封装成帧"><a href="#1-封装成帧" class="headerlink" title="1. 封装成帧"></a>1. 封装成帧</h4><p>封装成帧：数据链路层给网络层交付的协议数据单元添加 帧头和帧尾 的操作。称为封装成帧。</p><p>目的：为了在链路上 以帧为单元 来传送数据，也就是 为了实现数据链路层本身的功能。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGVjYzVjYThhYzM4ZDBiMWQ4MTQ2YTkxOWY1NjM3MmVfaWlXZkw2d0ZFNnBTeXBSd1dRQjVoSXoxOXVCMzlPc0RfVG9rZW46Sld5MmJPOVAxbzNseUN4MG5IMWNzQjFMbk1nXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h4 id="2-差错检测"><a href="#2-差错检测" class="headerlink" title="2. 差错检测"></a>2. 差错检测</h4><p>接收方主机收到帧后，通过检错码和检错算法，就可以判断出帧在传输过程中是否出现了了误码。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YWNhNjc3NGRlNjA0NjRjZDU3MTQ2Mjc0ZWMzYzU1NDlfcXFOeFpBWFRBN1c5NGFwV0J6YlhUY1FCSFdueGo0VG1fVG9rZW46QWZXSGJGVzNQb3l2bTl4YTNEOGNUWFdPbkFnXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h4 id="3-可靠传输"><a href="#3-可靠传输" class="headerlink" title="3. 可靠传输"></a>3. 可靠传输</h4><p>接受方主机收到有误码的帧后，不会接受，将其丢弃。</p><p>如果数据链路层向其上层提供的是不可靠服务，丢弃就丢弃了，不会有更多措施。</p><p>如果数据链路层向其上层提供的是 可靠服务，就还需要其他措施，确保接收方主机回以重新收到被丢弃的这个帧的确副本。</p><blockquote><p>以上都是使用 点对点 信道的数据链路层来举例的。</p></blockquote><h3 id="1-3-使用广播信道的数据链路层"><a href="#1-3-使用广播信道的数据链路层" class="headerlink" title="1.3 使用广播信道的数据链路层"></a>1.3 使用广播信道的数据链路层</h3><ul><li>共享式以太网的媒体接入控制协议CSMA&#x2F;CD</li><li>802.11局域网的媒体接入控制协议CSMA&#x2F;CA</li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MWFhZWE5OTRjMjdiOTUzYmRiN2JjODJhNTA4MTY0MjBfMXBVcnFHTElYTXEySWpVQ213Y0FucHFZOHZ0U1lmWVJfVG9rZW46UHUzZ2JVTm9Wb0ZTSUZ4ZnJEcWNQVEtVbm9oXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h3 id="1-4-数据链路层的互联设备"><a href="#1-4-数据链路层的互联设备" class="headerlink" title="1.4 数据链路层的互联设备"></a>1.4 数据链路层的互联设备</h3><ul><li>网桥和交换机的工作原理</li><li>集线器（物理层互连设备)与交换机的区别</li></ul><h2 id="2-封装成帧"><a href="#2-封装成帧" class="headerlink" title="2. 封装成帧"></a>2. 封装成帧</h2><h3 id="2-1-封装成帧"><a href="#2-1-封装成帧" class="headerlink" title="2.1 封装成帧"></a>2.1 封装成帧</h3><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧。</p><ul><li>帧头和帧尾中包含有重要的控制信息。</li><li>帧头和帧尾的作用之一就是帧定界。</li></ul><p>1）PPP帧的帧头和帧尾各有一个标志字节，作用是帧定界。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDFkYjBjMmJmODhlMWY0N2FkOTg3OTIzMzQyZDQxNzJfcjQzSXg3RXZZNFNhMkRvZGdnV3hobGwxUkJnM0JjRWlfVG9rZW46RlpVN2JCWFY4b3hpbVJ4c2NONWNlcGZjblVnXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><p>2）并不是每一种数据链路层协议的帧都包含帧定界标志。 例如，以太网MAC帧。而且以太网V2的MAC帧还有帧间间隔，规定为 96 比特时间。</p><h3 id="2-2-透明传输"><a href="#2-2-透明传输" class="headerlink" title="2.2 透明传输"></a>2.2 透明传输</h3><p>透明传输：是指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样。</p><p>例题</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MTJjYTcwMzZiMjI4NTY4ODE1YzMxZDE4Y2M4NDA3ZjRfeG5DV0ExTDdFdlVCVDBkOWs5b2tiQkFZTVZMZTg4dE1fVG9rZW46Vnl3d2J3SkVsb0xxUTd4UTlUOWNzVnNybnpoXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h3 id="2-3-提高帧传输效率"><a href="#2-3-提高帧传输效率" class="headerlink" title="2.3 提高帧传输效率"></a>2.3 提高帧传输效率</h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2I2YWViZjZhZjI0NmY4ZDQ3NTI0ZDY3ZGIyZDMzZGVfRFZnNG1QVmVrUXcwb0lUdEhiZUw5ak4zd0h1M0thWGNfVG9rZW46VUEycWJORkMwb2hucDB4TmtDTWMzRmhrbldjXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h2 id="3-差错检测"><a href="#3-差错检测" class="headerlink" title="3. 差错检测"></a>3. 差错检测</h2><h3 id="3-1-差错检测"><a href="#3-1-差错检测" class="headerlink" title="3.1 差错检测"></a>3.1 差错检测</h3><ul><li>比特差错：实际的通信链路都不是理想的，比特在传输过程中可能会产生差错: 1可能会变成0,而0也可能变成1。这称为比特差错。</li><li>误码率BER：在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率BER(Bit Error Rate)</li><li>差错检测码FCS：使用差错检测码来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一。</li></ul><h3 id="3-2-奇偶校验"><a href="#3-2-奇偶校验" class="headerlink" title="3.2 奇偶校验"></a>3.2 奇偶校验</h3><ul><li>奇&#x2F;偶校验：在待发送的数据后面 添加1位奇偶校验位，使整个数据（包括所添加的校验位在内)中 “1”的个数 为奇数(奇校验)或偶数（偶校验)。</li><li>如果有 奇数个位发生误码，则奇偶性发生变化，可以检查出误码</li><li>如果有 偶数个位发生误码，则奇偶性不发生变化，不能检查出误码（漏检)</li></ul><blockquote><p>奇偶校验法的漏检率较高，数据链路层一般不采用这种方法。</p></blockquote><h3 id="3-3-循环冗余检验"><a href="#3-3-循环冗余检验" class="headerlink" title="3.3 循环冗余检验"></a>3.3 循环冗余检验</h3><h4 id="1-循环冗余检验-CRC-Cyclic-Redundancy-Check"><a href="#1-循环冗余检验-CRC-Cyclic-Redundancy-Check" class="headerlink" title="1. 循环冗余检验:CRC(Cyclic Redundancy Check)"></a>1. 循环冗余检验:CRC(Cyclic Redundancy Check)</h4><p>1）CRC</p><p>2）生成多项式</p><h4 id="2-举例"><a href="#2-举例" class="headerlink" title="2. 举例"></a>2. 举例</h4><p>1）发送方处理</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTYyOWU5YTdlMmUyMWJkZGI4NjZmMjc3M2U1ODQyN2RfV2pBaEpMVHE3SkNMemRZWHp3NHlaV3JqaWk5bGU0cXlfVG9rZW46TG9reWJTYllFb3FhYkV4ZEhmS2NjbFY0bmcxXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><p>2）接收方处理</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NDBjOTY1MmI1YTdjZTg5YjdkOGI5NTNiZDNlNmIzMzRfb29oTHlCUTQxQld3NURiUmZ2WjV3bHpMN2lyWklCRVFfVG9rZW46WDJDSGJ1cFkxb2F0c3R4REh4OGNNclpZbmZjXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h3 id="3-4-本节总结"><a href="#3-4-本节总结" class="headerlink" title="3.4 本节总结"></a>3.4 本节总结</h3><h2 id="4-可靠传输"><a href="#4-可靠传输" class="headerlink" title="4. 可靠传输"></a>4. 可靠传输</h2><h3 id="4-1-可靠传输的基本概念"><a href="#4-1-可靠传输的基本概念" class="headerlink" title="4.1 可靠传输的基本概念"></a>4.1 可靠传输的基本概念</h3><ul><li>使用 差错检测技术 （例如循环冗余校验CRC)，接收方的数据链路层就可检测出帧在传输过程中是否产生了 误码 （比特错误)。</li><li>数据链路层向上层提供的服务类型<ul><li>不可靠传输服务: 仅仅丢弃有误码的帧 ，其他什么也不做;</li><li>可靠传输服务: 想办法实现 发送端发送什么，接收端就收到什么。</li></ul></li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OTExYzYxN2VlYjQzNmU0MThjZDkzOGJiOWZiOGMzYTBfR1k0aDc1TWlqUzliM0N5QTVHR2VGMU5NVzBwc2d0TVRfVG9rZW46QTJocmJ3M3NXbzZEbFV4TFhmbWM0Y09nbjZjXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><ul><li>一般情况下，有线链路 的误码率比较低，为了减小开销，并 不要求数据链路层向上提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理。</li><li>无线链路 易受干扰，误码率比较高，因此 要求数据链路层 必须向上层提供 可靠传输服务。</li><li>比特差错 只是传输差错中的一种。</li><li>从整个计算机网络体系结构来看，传输差错还包括分组丢失、分组失序 以及 分组重复。</li><li>分组丢失、分组失序以及分组重复这些传输差错，一般不会出现在数据链路层，而会出现在其上层。</li><li>可靠传输服务并不仅局限于数据链路层，其他各层均可选择实现可靠传输。</li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ODE1ZGQ2NWZiOTAwYThhMzQzMDU0ZDQ0NGQ0ZWIwYThfZzJIUTV6T3RXWmhKN2ZMMlZaVE5WT0NmQ0tZa2M2UUFfVG9rZW46SWxDUGJtcWROb05RYmN4aDIyWWNZN2lNbkZiXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><ul><li>可靠传输的实现比较复杂，开销也比较大，是否使用可靠传输取决于应用需求。</li></ul><h3 id="4-2-三种可靠传输实现机制"><a href="#4-2-三种可靠传输实现机制" class="headerlink" title="4.2 三种可靠传输实现机制"></a>4.2 三种可靠传输实现机制</h3><p>下面介绍可靠传输的三种实现机制：</p><p>停止等待协议SW、回退N帧协议GBN、选择重传协议SR</p><ul><li>这三种可靠传输实现机制的基本原理并不仅限于数据链路层,可以应用到计算机网络体系结构的各层协议中。</li><li>在学习时,不要把思维局限在数据链路层,而应放眼于整个网络体系结构。</li></ul><h3 id="4-3-（一）停止-等待协议"><a href="#4-3-（一）停止-等待协议" class="headerlink" title="4.3 （一）停止-等待协议"></a>4.3 （一）停止-等待协议</h3><h4 id="1-停止-等待协议"><a href="#1-停止-等待协议" class="headerlink" title="1. 停止-等待协议"></a>1. 停止-等待协议</h4><p>停止-等待协议：SW（Stop and Wait）：发送方每发送一个分组，就停止发送并等待接收方的确认分组。当收到接收方的确认分组后，才能发送下一个数据分组，如此反复进行。</p><ul><li>DATA：发送分组</li><li>ACK：确认接受分组</li><li>NAK：未接受，否定应答分组</li></ul><h4 id="2-超时重传机制"><a href="#2-超时重传机制" class="headerlink" title="2. 超时重传机制"></a>2. 超时重传机制</h4><h4 id="3-避免分组重复"><a href="#3-避免分组重复" class="headerlink" title="3. 避免分组重复"></a>3. 避免分组重复</h4><p>分组重复：接收方发送的 ACK 数据包丢失，发送方启动超时重传机制，发送重复分组。</p><p>解决机制：为 避免分组重复这种传输错误，必须给 每个分组带上序号。对于停止-等待协议，由于每发送一个数据分组就停止等待,只要保证每发送一个新的数据分组，其发送序号与上次发送的数据分组的序号不同就可以了，因此用 一个比特来编号就够了。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OWU2YzEzMGVlYzc4OWIxNmY0OGZhM2JhYzVhNTU4OWVfYk1VVlJCQUliaU50Z1g0R2d4Q25ESnpoa0Z4bkp6QnlfVG9rZW46Wlg4b2JMZW5jb1lTdmF4M1h0VmNpRFJEbk1oXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h4 id="4-确认分组ACK迟到：确认分组也需要编号"><a href="#4-确认分组ACK迟到：确认分组也需要编号" class="headerlink" title="4. 确认分组ACK迟到：确认分组也需要编号"></a>4. 确认分组ACK迟到：确认分组也需要编号</h4><blockquote><p>对于PPP信道的数据链路层实现停止-等待协议，往返时间固定，不需要给确认分组编号。</p></blockquote><h4 id="5-停止-等待协议的注意事项"><a href="#5-停止-等待协议的注意事项" class="headerlink" title="5. 停止-等待协议的注意事项"></a>5. 停止-等待协议的注意事项</h4><ul><li>接收端检测到数据分组有误码时，将其 丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方尽早重传，也 可给发送方发送NAK分组</li><li>为了让接收方能够判断所收到的数据分组是否是重复的，需要给 数据分组编号。由于停止-等待协议的停等特性，只需1个比特编号就够了，即编号0和1.</li><li>为了让发送方能够判断所收到的ACK分组是否是重复的，需要 给ACK分组编号，所用比特数量与数据分组编号所用比特数量一样。</li><li>点对点信道的数据链路层一般不会出现ACK分组迟到的情况，因此 在数据链路层实现停止-等待协议可以不用给ACK分组编号。</li><li>超时计时器设置的重传时间应仔细选择。一般可将重传时间选为 略大于“从发送方到接收方的平均往返时间”。<ul><li>在数据链路层点对点的往返时间比较确定，重传时间比较好设定。</li><li>然而在运输层，由于端到端往返时间非常不确定，设置合适的重传时间有时并不容易</li></ul></li></ul><h4 id="6-停止-等待协议的信道利用率"><a href="#6-停止-等待协议的信道利用率" class="headerlink" title="6. 停止-等待协议的信道利用率"></a>6. 停止-等待协议的信道利用率</h4><ul><li>𝑇𝐷TD：数组分组的发送时延</li><li>𝑇𝐴TA：接收方主机的处理时延</li><li>𝑅𝑇𝑇RTT：往返时延</li></ul><p>则 停止-等待协议的信道利用率计算公式 𝑈U 为：</p><p>𝑈&#x3D;𝑇𝐷𝑇𝑑+𝑅𝑇𝑇+𝑇𝐴U&#x3D;Td+RTT+TATD</p><p>计算举例</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MTkyYmEzYzU0ZmEyOWI5MTM1NzQ5ZDFiNTcyYjVhZjVfVUZYZzZVV2tBcXBRbk5LdnBoT015UGFDZlVFNjNtd09fVG9rZW46Uk9LWWJQRXRGb3JXa1F4ZzdSUGN6U0F5bmRlXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><ul><li>当往返时延RTT远大于数据帧发送时延Tp时（例如使用卫星链路)，信道利用率非常低。若出现重传，则对于传送有用的数据信息来说，信道利用率还要降低</li><li>为了克服停止-等待协议信道利用率很低的缺点，就产生了另外两种协议，即 后退N帧协议GBN和选择重传协议SR</li></ul><p>例题</p><h3 id="4-4-（二）回退N帧协议GBN"><a href="#4-4-（二）回退N帧协议GBN" class="headerlink" title="4.4 （二）回退N帧协议GBN"></a>4.4 （二）回退N帧协议GBN</h3><h4 id="1-停止-等待协议SW的缺点及优化"><a href="#1-停止-等待协议SW的缺点及优化" class="headerlink" title="1. 停止-等待协议SW的缺点及优化"></a>1. 停止-等待协议SW的缺点及优化</h4><ul><li>缺点：停止-等待协议SW的信道利用率很低，若出现超时重传，利用率更低。</li><li>优化：采用流水线传输可以提高信道利用率。</li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2MyODcwNDU3ZWUwNGMyZWQ0NjE5ODNiMDdiMzA1NjhfT3hyb1ZMeGl2Z3haN1FWU1VHMTQxdFpFRXJMWTF4SFhfVG9rZW46SEhZaWJSSHZFbzJtbEx4ek1MUGNxTzBFbnRjXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h4 id="2-回退N帧协议"><a href="#2-回退N帧协议" class="headerlink" title="2. 回退N帧协议"></a>2. 回退N帧协议</h4><p>在流水线传输的基础上，利用发送窗口限制发送方可连续发送数据分组的个数。</p><ol><li>使用3个比特给分组编序号，0−70−7</li><li>发送窗口的尺寸 𝑊𝑇WT 取值：1&lt;𝑊𝑇&lt;&#x3D;23−11&lt;WT&lt;&#x3D;23−1，本例取 𝑊𝑇&#x3D;5WT&#x3D;5</li><li>接收窗口𝑊𝑅WR的取值：𝑊𝑅&#x3D;1WR&#x3D;1</li></ol><blockquote><p>当 𝑊𝑇&#x3D;1WT&#x3D;1 为停止-等待协议SW。</p></blockquote><h5 id="（1）无差错情况"><a href="#（1）无差错情况" class="headerlink" title="（1）无差错情况"></a>（1）无差错情况</h5><p>无差错情况：正常发送与接受，无误码或丢失等情况。</p><h5 id="（2）累计确认"><a href="#（2）累计确认" class="headerlink" title="（2）累计确认"></a>（2）累计确认</h5><p>累计确认：接收方不一定要对收到的数据分组逐个发送确认，而是可以在收到几个数据分组后（由具体实现决定)对 按序到达的最后一个数据分组发送确认。𝐴𝐶𝐾𝑛ACKn表示序号为n及以前的所有数据分组都已正确接收。</p><blockquote><p>即使 AKC1丢失了，也有ACK4来确认，发送方也可能不必重传。</p></blockquote><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YWZlMTdmNGEzMDk3YmQzZjY1YzljNmQ3MWJhNzhiMGNfM1N4SmJ4dGxkSGZMd2t2VUdKSWNxWjF3d2F0bnEwTlBfVG9rZW46SnlabGJKT09Yb3lySXR4WTdOMGNzdVlQbk1iXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><ul><li>累计确认的优点：减少接收方的开销、减少对网络资源的占用。</li><li>累计确认的缺点：不能向发送方及时发送接收方正确接受数据分组的信息。</li></ul><h5 id="（3）有差错情况"><a href="#（3）有差错情况" class="headerlink" title="（3）有差错情况"></a>（3）有差错情况</h5><ul><li>在本例中。尽管序号为6,7,0,1的数据分组正确到达接收方，但由于5号数据分组误码不被接受，它们也“受到牵连”而不被接受。发送方还要重传这些数据分组，这就是所谓的 Go-back-N (回退N帧)</li><li>可见，当通信线路质量不好时，回退N帧协议的信道利用率并不比停止-等待协议高。</li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MjA0MjUyZDhlMDQxZThkNGRhNTE0MzMyMTRiZWQ5YWRfMjBJSUlnS1pnWkZLMDBrT0JRSEU1eTNNZlNubWVnYzZfVG9rZW46TW5kb2I4MVpObzVSSmN4blVpNWNkWXFablhBXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h5 id="（4）𝑊𝑇WT超过其上限7"><a href="#（4）𝑊𝑇WT超过其上限7" class="headerlink" title="（4）𝑊𝑇WT超过其上限7"></a>（4）𝑊𝑇WT超过其上限7</h5><p>若𝑊𝑇WT超过取值范围，例如𝑊𝑇&#x3D;8WT&#x3D;8，会出现什么情况?</p><blockquote><p>如果是失败重传，序号为0-7；如果是发送新的分组，序号也为0-7。就无法分辨新旧数据分组了。</p></blockquote><h4 id="3-回退N帧协议总结"><a href="#3-回退N帧协议总结" class="headerlink" title="3. 回退N帧协议总结"></a>3. 回退N帧协议总结</h4><ul><li>回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种连续ARQ协议。</li><li>在协议的工作过程中发送窗回和接收窗口不断向前滑动,因此这类协议叉称为滑动窗回协议。</li><li>由于回退N帧协议的特性,当通信线路质量不好时,其信道利用率并不比停止-等待协议高。</li></ul><p>例题</p><h3 id="4-5-（三）选择重传协议SR"><a href="#4-5-（三）选择重传协议SR" class="headerlink" title="4.5 （三）选择重传协议SR"></a>4.5 （三）选择重传协议SR</h3><h4 id="1-由GBN过渡到SR"><a href="#1-由GBN过渡到SR" class="headerlink" title="1. 由GBN过渡到SR"></a>1. 由GBN过渡到SR</h4><ul><li>回退N帧协议 的接收窗口尺寸 𝑊𝑅WR只能等于1，因此 接收方只能按序接收正确到达的数据分组。</li><li>一个数据分组的误码就会导致其后续多个数据分组不能被接收方按序接收而丢弃(尽管它们无乱序和误码)。这必然会造成发送方对这些数据分组的超时重传，显然这是对通信资源的极大浪费。</li><li>为了进一步提高性能，可设法只重传出现误码的数据分组。因此，接收窗口的尺寸 𝑊𝑅WR不应再等于1(而应大于1)，以便接收方先收下失序到达但无误码并且序号落在接收窗口内的那些数据分组，等到所缺分组收齐后再一并送交上层。这就是 选择重传协议。</li></ul><p>注意</p><p>选择重传协议为了使发送方仅重传出现差错的分组，接收方 不能采用累计确认，而需要对每个正确接收到的数据分组进行 逐一确认。</p><h4 id="2-选择重传协议SR"><a href="#2-选择重传协议SR" class="headerlink" title="2. 选择重传协议SR"></a>2. 选择重传协议SR</h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MjUwOWU0ZTY1OTQ2Mjg4NzI4NWQxYTUxMDQzYzkxZTZfWlFMeUpxenVVQ1pyc1h1MFJGdHFLYlRKZXE1WDZEUjFfVG9rZW46U0lRbWJSVnhZb3VuN1F4V0VBdGNxVXNSbm5jXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h5 id="1）选择重传协议发送窗口与接收窗口应满足的条件"><a href="#1）选择重传协议发送窗口与接收窗口应满足的条件" class="headerlink" title="1）选择重传协议发送窗口与接收窗口应满足的条件"></a>1）选择重传协议发送窗口与接收窗口应满足的条件</h5><h5 id="2）若发送窗口取值超过限制"><a href="#2）若发送窗口取值超过限制" class="headerlink" title="2）若发送窗口取值超过限制"></a>2）若发送窗口取值超过限制</h5><p>如果发送窗口和接收窗口超过了取值范围，就会使 接收方无法区分新、旧数据分组，进而出现 分组重复 这种差错。</p><h4 id="3-SR协议总结"><a href="#3-SR协议总结" class="headerlink" title="3. SR协议总结"></a>3. SR协议总结</h4><p>例题</p><blockquote><p>【2011年题35】数据链路层采用选择重传协议（SR）传输数据，发送方已发送了0~3号数据帧，现已收到1号帧的确认，而0、2号帧依次超时，则此时需要重传的帧数是 A.1 B.2 C.3 D.4</p></blockquote><p>解析</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OTFhYmZhZDM5Y2VjMzhmYTZkNTVhMTA5MmRkYjBhMDJfNkZZc2JmZkZYNWIwTlRaUjlKMmttTjdhcGpISk5UT2ZfVG9rZW46SnZPdGJ0THkwb2Viemp4SDdQR2NXaEh4bmVsXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h2 id="5-点对点协议PPP"><a href="#5-点对点协议PPP" class="headerlink" title="5. 点对点协议PPP"></a>5. 点对点协议PPP</h2><h3 id="5-1-PPP协议的组成"><a href="#5-1-PPP协议的组成" class="headerlink" title="5.1 PPP协议的组成"></a>5.1 PPP协议的组成</h3><ul><li>点对点协议PPP（Point-to-Point Protocol）是目前使用最广泛的 点对点数据链路层协议。</li><li>PPPoE：Point-to-Point Protocol over Ethernet</li><li>PPP协议是因特网工程任务组IETF在1992年制定的。经过1993年和1994年的修订，现在的PPP协议已成为因特网的正式标准[RFC1661，RFC1662]。</li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YzI3NzE2NDQwMTI2ODcwYjY0OWEyMjcyZjdmMzY3OGVfSFM2TWRXamozS2FKQ1NPZnVmNjhJRk5LRFRiYVdadm5fVG9rZW46WmJSbWJ2WUNCb0FteE94VGZaQmNkR2NkbkFsXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><ul><li>PPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成:<ul><li>对各种协议数据报的封装方法（封装成帧)</li><li>链路控制协议LCP：用于建立、配置以及测试数据链路的连接</li><li>一套网络控制协议NCPs：其中的每一个协议支持不同的网络层协议</li></ul></li></ul><h3 id="5-2-点对点协议PPP的帧格式"><a href="#5-2-点对点协议PPP的帧格式" class="headerlink" title="5.2 点对点协议PPP的帧格式"></a>5.2 点对点协议PPP的帧格式</h3><h3 id="5-3-点对点协议PPP透明传输"><a href="#5-3-点对点协议PPP透明传输" class="headerlink" title="5.3 点对点协议PPP透明传输"></a>5.3 点对点协议PPP透明传输</h3><p>点多点协议PPP实现透明传输的两种方法：</p><ul><li>面向字节的异步链路采用插入转义字符的字节填充法</li><li>面向比特的同步链路采用插入比特 0 的比特填充法</li></ul><h4 id="1-字节填充法"><a href="#1-字节填充法" class="headerlink" title="1. 字节填充法"></a>1. 字节填充法</h4><h4 id="2-比特填充法"><a href="#2-比特填充法" class="headerlink" title="2. 比特填充法"></a>2. 比特填充法</h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NDkyMTg1MTQ4MDliMTJkMzRkOWFlM2EyNWYyNzgzOTZfVFh4end1R2hnY055ZUowcktTbHlIcGRORElsc1k5NHRfVG9rZW46QzBTZGJETGJXb3hqcVJ4QU15R2NnU1NrbjRlXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h3 id="5-4-差错检测"><a href="#5-4-差错检测" class="headerlink" title="5.4 差错检测"></a>5.4 差错检测</h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OTY0Njk5MjM2Nzg0MTgzMGEwZmI3YzM0YzE4MTQ4ZmNfaWU2ZDAzZVRSaERIcmZvRWQ1TWRVQ1FISEtiVGdqUHBfVG9rZW46RnBSMmJWUFVTb2g0TWd4aHNwZmNpSE9pbmhjXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h3 id="5-5-工作状态"><a href="#5-5-工作状态" class="headerlink" title="5.5 工作状态"></a>5.5 工作状态</h3><h2 id="6-媒体接入控制"><a href="#6-媒体接入控制" class="headerlink" title="6. 媒体接入控制"></a>6. 媒体接入控制</h2><h3 id="6-1-媒体接入控制基本概念"><a href="#6-1-媒体接入控制基本概念" class="headerlink" title="6.1 媒体接入控制基本概念"></a>6.1 媒体接入控制基本概念</h3><p>共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即 媒体接入控制MAC(Medium Access Control)。</p><h3 id="6-2-媒体接入技术分类"><a href="#6-2-媒体接入技术分类" class="headerlink" title="6.2 媒体接入技术分类"></a>6.2 媒体接入技术分类</h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NmYxMmRkNzc1ODdhNjAyYzg1OWNlY2FlNTUzNDJhYWVfeGFaYzV4N0lhWUFoS0hFTm1TTmdyUE5PMUdlTzIyUFhfVG9rZW46V0cyZWJRNWNBbzNMRXR4ZWJCTWNCTldYbnBlXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><blockquote><p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术。</p></blockquote><h3 id="6-3-媒体接入控制：静态划分信道"><a href="#6-3-媒体接入控制：静态划分信道" class="headerlink" title="6.3 媒体接入控制：静态划分信道"></a>6.3 媒体接入控制：静态划分信道</h3><h4 id="信道复用"><a href="#信道复用" class="headerlink" title="信道复用"></a>信道复用</h4><ul><li>复用(Multiplexing）是通信技术中的一个重要概念。复用就是通过一条物理线路同时传输多路用户的信号。</li><li>当网络中传输媒体的传输容量大于多条单一信道传输的总通信量时，可利用复用技术在一条物理线路上建立多条通信信道来充分利用传输媒体的带宽。</li><li>分类：频分复用、时分复用、波分复用、码分复用</li></ul><h4 id="1-频分复用-FDM"><a href="#1-频分复用-FDM" class="headerlink" title="1. 频分复用 FDM"></a>1. 频分复用 FDM</h4><p>频分复用的所有用户 同时占用不同的频带资源 并行通信。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MGEzNDJhZjM0ZDJmNmJkMjJjMzNjN2I2MjFiZWE3ZWNfVmM0cWZPSjkwVDlEeWQ4cFp4U01Vd0sxYlJLS0U1M3pfVG9rZW46WFFQV2IwZkVobzQ0eHF4MDFzV2NVaFNibnVlXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h4 id="2-时分复用-TDM"><a href="#2-时分复用-TDM" class="headerlink" title="2. 时分复用 TDM"></a>2. 时分复用 TDM</h4><p>时分复用的所有用户在 不同的时间占用同样的频带宽度 。</p><h4 id="3-波分复用-WDM"><a href="#3-波分复用-WDM" class="headerlink" title="3. 波分复用 WDM"></a>3. 波分复用 WDM</h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NWZiZTVhNDNjNzllNDY3M2JjM2JkN2M3MTc2ZGIzNzJfMzlkcTZ6YXFLcUpONFBIMllvUzFPNVlXdGZPNkM4MDRfVG9rZW46WFcyWWJ4eW5xb0ZHZ0d4enZwVmNLOHhobkFkXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h4 id="4-码分复用-CDM"><a href="#4-码分复用-CDM" class="headerlink" title="4. 码分复用 CDM"></a>4. 码分复用 CDM</h4><h5 id="（1）CDM-基本概念（理解、了解）"><a href="#（1）CDM-基本概念（理解、了解）" class="headerlink" title="（1）CDM 基本概念（理解、了解）"></a>（1）CDM 基本概念（理解、了解）</h5><ul><li>码分复用 CDM 是另一种共享信道的方法。实际上，由于该技术主要用于多址接入，人们更常用 的名词是 码分多址CDMA(Code Division Multiple Access)。</li><li>同理，频分复用 FDM 和时分复用 TDM 同样可用于多址接入，相应的名词是频分多址 FDMA (Frequency Division Multiple Access)和时分多址TDMA(Time Division Multiple</li><li>本课程中，我们不严格区分复用与多址的概念。可简单理解如下:<ul><li>复用是将单一媒体的频带资源划分成很多子信道，这些子信道之间相互独立，互不干扰。从 媒体的整体频带资源上看，每个子信道只占用该媒体频带资源的一-部分。</li><li>多址(更确切地应该称为多点接入)处理的是动态分配信道给用户。这在用户仅仅暂时性地占用信道 的应用中是必须的，而所有的移动通信系统基本上都属于这种情况。相反,在信道永久性地分配给用 户的应用中，多址是不需要的(对于无线广播或电视广播站就是这样)。</li><li>某种程度上，FDMA、TDMA、CDMA可以分别看成是FDM、TDM、CDM的应用。</li></ul></li><li>与 FDM 和 TDM 不同，CDM的每一个用户可以在 同样的时间使用同样的频带进行通信。</li><li>由于 各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。</li><li>CDM 最初是用于军事通信的，因为这种系统所发送的信号有很强的抗干扰能力，其频谱类似于 白噪声,不易被敌人发现。</li><li>随着技术的进步，CDMA设备的价格和体积都大幅度下降，因而现在已广泛用于民用的移动通信中</li></ul><h5 id="（2）码片（理解、应用）"><a href="#（2）码片（理解、应用）" class="headerlink" title="（2）码片（理解、应用）"></a>（2）码片（理解、应用）</h5><ul><li>在CDMA中，每一个比特时间再划分为m个短的间隔，称为码片(Chip)。通常m&#x3D;64或128。 为了简单起见，在后续的举例中，我们 假设m为8。</li></ul><blockquote><ul><li>注意：1个比特时间是指发送1个比特所花费的时间。</li></ul></blockquote><ul><li>使用CDMA的每一个站被指派一个唯一的 m bit 码片序列(Chip Sequence)。<ul><li>一个站如果 要发送比特1,则发送它 自己的m bit码片序列</li><li>个站如果要 发送比特0，则发送它 自己的m bit码片序列的二进制反码</li></ul></li><li>码片序列的挑选 原则 如下:<ul><li>分配给每个站的码片序列必须 各不相同，实际常采用伪随机码序列。</li><li>分配给每个站的码片序列必须 相互正交(规格化内积为0)</li></ul></li><li>计算公式如下<ul><li>令向量 S 表示站 S 的码片序列，令向量 T 表示其他任何站的码片序列</li><li>两个不同站 S 和 T 的码片序列正交，就是向量 S 和 T 的规格化内积为 0</li></ul></li></ul><h5 id="（3）码片的应用举例"><a href="#（3）码片的应用举例" class="headerlink" title="（3）码片的应用举例"></a>（3）码片的应用举例</h5><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NWNmYTEzMzhiMDBkYzc1OTIxMWE0YzEwZWE2ZGI5MDFfelhYMnFsTDRDSGhveTg1Vzk0YlZ5STVQb2tUY3B6eGdfVG9rZW46UERUUWI0ckpyb2xTcnJ4Zm1yemNWUHFtbkdlXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWU3OWMwYTJhYTNhYjQyMTZhOGJmNzZmMTJmYzUzYTVfYWVsak1uRk5CUktmZzJTY0d2aHlhTXVSY0VmY1E4TGhfVG9rZW46R0VvMmJ6VlAwb1R0OXl4R2tucmMwbklXbnllXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><p>解析</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ODJlZThmMmQwNDk4YWY0MTUzYzc5NThjZDEyZTYzYmJfQVBOVHVUSFFwYk9ZSE1TdXVWdEtwd1NvRFVwbkxJbTRfVG9rZW46WWN4M2I0Q2Zib1hEc3Z4UkZtc2NwMUN1bmNoXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><p>其他选项类似计算。（A发送1；B发送0；C未发送；D发送1）</p><p>解答</p><h3 id="6-4-随机接入：CSMA-CD-协议"><a href="#6-4-随机接入：CSMA-CD-协议" class="headerlink" title="6.4 随机接入：CSMA&#x2F;CD 协议"></a>6.4 随机接入：CSMA&#x2F;CD 协议</h3><h4 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h4><p>对于使用广播信道的总线型以太网，就会出现各种 碰撞（冲突）现象。 </p><h4 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h4><p>媒体接入控制-动态接入控制-随机接入方式：</p><p>CSMA&#x2F;CD 协议</p><p>（载波监听多址接入&#x2F;碰撞检测）</p><p>（Carrier Sense Multiple Access&#x2F;Collision Detection）</p><p>（1）多址接入（MA）：多个站连接在一条总线上，竞争使用</p><p>（2）载波监听（CS）：每一个站在发送帧之前先要检测一下总线上是否有其他站点在发送帧（“先听后说”）</p><ul><li>若检测到 总线空闲 96 比特时间，则发送这个帧</li><li>若检测到总线忙，则继续检测并等待总线转为 空闲 96 比特时间，然后发送这个帧。</li></ul><p>（3）碰撞检测（CD）：每一个正在发送帧的站边发送 边检测碰撞（“边说边听”）</p><p>一旦发现总线，上出现碰撞，则立即停止发送，退避一段随机时间后再次发送(“一旦冲突，立即停说，等待时机，重新再说” ）。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YmRiNzhiZWY1MGRhNjNhNjI0Yjg4YzkxMzRmMzNkYzlfMFF3UTI2ZkEyN290TWF2cFI3SzJXNUVQNmM1VkVGRndfVG9rZW46WXFwMmI0N0FOb0d3YTh4ZDNUY2NjQlowbnpnXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><p>（4）强化碰撞</p><p>以太网还采取一种叫做 强化碰撞 的措施。当发送帧的站点一旦检测到碰撞，除了 立即停止发送帧 外，还要再继续发送32比特或48比特的 人为干扰信号(Jamming Signal) ，以便有 足够多的碰撞信号 使所有站点 都能检测出碰撞。</p><h4 id="3-争用期（碰撞窗口）"><a href="#3-争用期（碰撞窗口）" class="headerlink" title="3. 争用期（碰撞窗口）"></a>3. 争用期（碰撞窗口）</h4><p>注意：</p><ul><li>𝜏τ：以太网单程端到端传播时延。</li><li>𝛿δ：B站发送数据 到 B站检测到碰撞 所经历的一段时间。</li><li>𝑡t：纵轴向下，时间的正向进行。</li><li>电磁波在 1𝑘𝑚1km 电缆传播时延约等于 5𝜇5μs</li><li>主机 最多 经过 2𝜏2τ（即δ→0）的时长就可检测到本次发送是否遭受了碰撞</li><li>因此，以太网的端到端往返传播时延 2𝜏2τ 称为 争用期 或 碰撞窗口</li><li>经过争用期这段时间还 没有检测到碰撞，才能 肯定这次发送不会发生碰撞</li><li>每一个主机在自己发送帧之后的一小段时间内，存在着遭遇碰撞的可能性。这一小段时间是不确定的。它取决于另一个发送帧的主机到本主机的距离，但不会超过总线的端到端往返传播时延，即一个争用期时间。</li><li>显然，在以太网中发送帧的主机越多，端到端往返传播时延越大，发生碰撞的概率就越大。因此，共享式以太网不能连接太多的主机，使用的总线也不能太长。 10Mb&#x2F;s以太网把争用期定为 512 比特发送时间，即 51 .2μs,因此其总线长度不能超过 5120m，但考虑到其他一些因素，如信号衰减等，以太网规定总线长度不能超过 2500m。</li></ul><h4 id="4-最小帧长"><a href="#4-最小帧长" class="headerlink" title="4. 最小帧长"></a>4. 最小帧长</h4><p>A站 发送一个帧 完毕后，不再针对该帧进行碰撞检测，不知道已发送完毕的帧是否遭遇碰撞，不进行重传。而这时候C站 检测到信道空闲时间 96 bit，发送帧，将 产生碰撞。</p><p>显然，以太网的帧长不能太短！</p><ul><li>以太网规定最小帧长为64字节，即512比特（512比特时间即为争用期）<ul><li>如果要发送的数据非常少，那么必须加入一些填充字节,使帧长不小于64字节。</li></ul></li><li>以太网的 最小帧长确保了主机可在帧发送完成之前就检测到该帧的发送过程中是否遭遇了碰撞<ul><li>如果在争用期（共发送64字节）没有检测到碰撞,那么后续发送的数据就一定不会发生碰撞;</li><li>如果在争用期内检测到碰撞，就立即中止发送，这时已经发送出去的数据一定小于64字节，因此 凡长度小于64字节的帧都是由于碰撞而异常中止的无效帧。</li></ul></li></ul><p>最小帧长计算公式</p><p>最小帧长 &#x3D; 争用期 * 数据传输速率</p><h4 id="5-最大帧长"><a href="#5-最大帧长" class="headerlink" title="5. 最大帧长"></a>5. 最大帧长</h4><h4 id="6-截断二进制指数退避算法"><a href="#6-截断二进制指数退避算法" class="headerlink" title="6. 截断二进制指数退避算法"></a>6. 截断二进制指数退避算法</h4><h4 id="7-信道利用率"><a href="#7-信道利用率" class="headerlink" title="7. 信道利用率"></a>7. 信道利用率</h4><h5 id="（1）一般信道利用率"><a href="#（1）一般信道利用率" class="headerlink" title="（1）一般信道利用率"></a>（1）一般信道利用率</h5><h5 id="（2）极限信道利用率"><a href="#（2）极限信道利用率" class="headerlink" title="（2）极限信道利用率"></a>（2）极限信道利用率</h5><p>发送一帧所用时间为 𝑇0+𝜏T0+τ，帧本身发送时间为 𝑇0T0，则信道利用率计算公式如下</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MjZjZGU1MmYwMjM0YjYwNTFjZGZjNGI0NTJkYjdjM2NfMTN2UTNYczZnQkVNWnJlVTJJemtxaFdxNnRSMm9HSGtfVG9rZW46VG9IYmJNTGhhbzVWSll4ZENHTmNCemlpbnFlXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><h4 id="8-帧发送-接收流程"><a href="#8-帧发送-接收流程" class="headerlink" title="8. 帧发送&#x2F;接收流程"></a>8. 帧发送&#x2F;接收流程</h4><h5 id="（1）帧发送流程"><a href="#（1）帧发送流程" class="headerlink" title="（1）帧发送流程"></a>（1）帧发送流程</h5><h5 id="（2）帧接收流程"><a href="#（2）帧接收流程" class="headerlink" title="（2）帧接收流程"></a>（2）帧接收流程</h5><h4 id="9-测试题"><a href="#9-测试题" class="headerlink" title="9. 测试题"></a>9. 测试题</h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OTdhNDY3YjNjOTMxODFkNTcwZGYyMzdmN2RmNjQ5MDlfUmxPemVzek53ZHJSMkl1OUlJY2VXb2tQbTJJY2VXUGdfVG9rZW46SThvc2JHZnZRb29YdW14ZHZpMWN5aWxZbkVjXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><p>解析</p><p>（1）最短时间： </p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MDViZWJhNDRmZjUzMTRjYThhNDNiZDc2OTU5OTY4NTlfd1JSbkcxaDBNWkRCQTdkSHhYNjhhalpqME5tbXZyQkdfVG9rZW46WXlIQ2JsSTV6b3ZTc3V4RDN4QmNRcXBxblJlXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><p> （2）最长时间： </p><blockquote><p>CSMA&#x2F;CD协议曾经用于各种总线结构以太网和双绞线以太网的早期版本中。现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA&#x2F;CD协议。</p></blockquote><h2 id="7-MAC-地址"><a href="#7-MAC-地址" class="headerlink" title="7. MAC 地址"></a>7. MAC 地址</h2><h3 id="7-1-MAC-地址"><a href="#7-1-MAC-地址" class="headerlink" title="7.1 MAC 地址"></a>7.1 MAC 地址</h3><p>MAC 地址是以太网的 MAC 子层所使用的地址，属于数据链路层。</p><ul><li>对于点对点信道的数据链路层不需要地址。</li><li>使用广播信道的数据链路层则需要使用 MAC 地址。</li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OGUyNDIzM2M3MTBhYzcxMzdkYTA1NGJmZTY5MTk5MjVfeFcycXVQZHZvYnRjdkpFb1dsM2VFMzVGSmdrUFVjYUFfVG9rZW46TFB4NWJBRVZyb2g1REp4RG5EUGNDR0FhbkpjXzE3MTk4MTIzMTk6MTcxOTgxNTkxOV9WNA" alt="img"></p><ul><li>当多个主机连接在同一个广播信道上,要想实现两个主机之间的通信，则每个主机都必须有一个唯- -的标识， 即一个数据链路层地址;</li><li>在每个主机发送的 帧中必须携带标识发送主机和接收主机的地址。由于这类地址是用于媒体接入控制 MAC(Media Access Control)，因此这类地址被称为 MAC地址 -MAC 地址一般被固化在网卡(网络适配器)的电可擦可编程只读存储器EEPROM中，因此MAC地址也 被称为 硬件地址<ul><li>MAC 地址有时也被称为 物理地址。请注意：这并不意味着MAC地址属于网络体系结构中的物理层！</li></ul></li><li>般情况下，用户主机会包含两个网络适配器：有线局域网适配器(有线网卡)和无线局域网适配器(无线 网卡)。每个网络适配器都有一个全球唯一的 MAC 地址。 而交换机和路由器往往拥有更多的网络接口，所以 会拥有更多的MAC地址。综上所述，严格来说，MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识。</li></ul><h3 id="7-2-IEEE-802局域网的MAC地址格式"><a href="#7-2-IEEE-802局域网的MAC地址格式" class="headerlink" title="7.2 IEEE 802局域网的MAC地址格式"></a>7.2 IEEE 802局域网的MAC地址格式</h3><p>IEEE 802 局域网 MAC 地址格式：（共 6 字节，48位）</p><p>前 3 位字节（OUI） + 后 3 位（扩展标识符）</p><p>第 1 位字节的低位为 1、3、5、7、9、B、D，则为多播地址，48 位全为 1 时，则为广播地址。</p><p>提问：EU1-48地址空间会耗尽吗？</p><p>答：对于使用EUI-48空间的应用程序，IEEE的目标寿命为100年(直到2080)，但是鼓励采用EUI-64作为替代。</p><h3 id="7-3-IEEE-802-局域网-MAC-地址发送顺序"><a href="#7-3-IEEE-802-局域网-MAC-地址发送顺序" class="headerlink" title="7.3 IEEE 802 局域网 MAC 地址发送顺序"></a>7.3 IEEE 802 局域网 MAC 地址发送顺序</h3><h3 id="7-4-单播-多播-广播地址举例"><a href="#7-4-单播-多播-广播地址举例" class="headerlink" title="7.4 单播&#x2F;多播&#x2F;广播地址举例"></a>7.4 单播&#x2F;多播&#x2F;广播地址举例</h3><h4 id="（1）单播地址"><a href="#（1）单播地址" class="headerlink" title="（1）单播地址"></a>（1）单播地址</h4><p>主机B将本主机地址填入单播帧源地址，主机C地址填入目的地址，形成该单播帧。</p><h4 id="（2）广播地址"><a href="#（2）广播地址" class="headerlink" title="（2）广播地址"></a>（2）广播地址</h4><p>主机B将本机地址填入源地址，将 <code>FF-FF-FF-FF-FF-FF</code> 广播地址填入目的地址，构成广播帧。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OGIyZTMzYTdhMzZjOWI2MDRlNDNjYTM1NjQwNTQ3MGJfR0s4blV4UnVjSnBXV2t1YkZTRWh3SHRTeG5NSTlTbnlfVG9rZW46Q2drb2J1NmU4b0laR2R4clFVa2NNRGlHbmtSXzE3MTk4MTIzMjA6MTcxOTgxNTkyMF9WNA" alt="img"></p><h4 id="（3）多播地址"><a href="#（3）多播地址" class="headerlink" title="（3）多播地址"></a>（3）多播地址</h4><p>主机A发送含有多播地址的多播帧，其他主机根据自己的多播组列表，判断是否接收帧。</p><h2 id="8-IP-地址"><a href="#8-IP-地址" class="headerlink" title="8. IP 地址"></a>8. IP 地址</h2><blockquote><p>由于MAC地址、IP地址、ARP协议三者联系紧密，故提前一起讲述。</p></blockquote><h3 id="8-1-初识-IP-地址"><a href="#8-1-初识-IP-地址" class="headerlink" title="8.1 初识 IP 地址"></a>8.1 初识 IP 地址</h3><ul><li>IP地址是因特网（Internet）上的 主机和路由器 所使用的地址， 用于标识两部分信息:<ul><li>网络编号：标识因特网上数以百万计的网络</li><li>主机编号：标识同一网络上不同主机（或路由器各接口）</li></ul></li><li>很显然， 之前介绍的MAC地址不具备区分不同网络的功能<ul><li>如果只是一个单独的网络，不接入因特网，可以只使用MAC地址（这不是一般用户的应用方式）</li><li>如果主机所在的网络要接入因特网，则IP地址和MAC地址都需要使用。</li></ul></li></ul><h3 id="8-1-从网络体系结构看IP地址与MAC地址"><a href="#8-1-从网络体系结构看IP地址与MAC地址" class="headerlink" title="8.1 从网络体系结构看IP地址与MAC地址"></a>8.1 从网络体系结构看IP地址与MAC地址</h3><p>IP 地址属于网络层，MAC 地址属于数据链路层。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjgwNWYzNWUzZmMwNmEzOWNhNWZiZDZmYTE2MWZhMDNfazB5dWpCYlR6ajF0aE82Q2lwNjJudldlZldvYjhkSnZfVG9rZW46V0hUd2J0bXpQb29nM294T25aNWN6WDdCbnRnXzE3MTk4MTIzMjA6MTcxOTgxNTkyMF9WNA" alt="img"></p><h3 id="8-2-数据包转发过程中IP地址与MAC地址的变化情况"><a href="#8-2-数据包转发过程中IP地址与MAC地址的变化情况" class="headerlink" title="8.2 数据包转发过程中IP地址与MAC地址的变化情况"></a>8.2 数据包转发过程中IP地址与MAC地址的变化情况</h3><ul><li>数据包转发过程中源IP地址和目的IP地址保持不变</li><li>数据包转发过程中源MAC地址和目的MAC地址逐个链路(或逐个网络)改变。</li></ul><p>暂且这么认为：H1知道应该把数据包传给R1，由R1帮其把数据包转发出去。H1知道R1相应接口的IP地址为IP3，但不知道其对应的MAC地址是什么!</p><h3 id="8-3-测试题"><a href="#8-3-测试题" class="headerlink" title="8.3 测试题"></a>8.3 测试题</h3><h2 id="9-ARP-地址转移协议"><a href="#9-ARP-地址转移协议" class="headerlink" title="9. ARP 地址转移协议"></a>9. ARP 地址转移协议</h2><h3 id="9-1-介绍"><a href="#9-1-介绍" class="headerlink" title="9.1 介绍"></a>9.1 介绍</h3><ul><li>高速缓存表</li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YWVhNWE0N2U1ZjNjZDI3ZWRlZWRjZDY5MGYzNTA3MGRfWGtBRzJxM2hMT2d6SFBlSEJ3R3lZSE5BNE1iQmJmMWJfVG9rZW46Tmtob2J0NmNFb2liZHp4Q0xNaWMxUHNHbnJkXzE3MTk4MTIzMjA6MTcxOTgxNTkyMF9WNA" alt="img"></p><ul><li>ARP 协议：由 IP 地址获取 MAC 地址的一种协议。</li></ul><h3 id="9-2-ARP：地址解析协议原理"><a href="#9-2-ARP：地址解析协议原理" class="headerlink" title="9.2 ARP：地址解析协议原理"></a>9.2 ARP：地址解析协议原理</h3><p>B 发送带有广播 MAC 地址广播帧，以获取指定 IP 地址的固化 MAC 地址。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YWY2MDgxZWZhY2U0ZTRkYmVjMTg5N2IzZmU2MjY3ZGFfV0hCWXVXZ1VBNVJ0Y1I3TzJIOEJYRXFwRlF3QmdFZEZfVG9rZW46U2J1bmJKbTdTb1l1OWZ4SGlJVWNmdk9Ebm1oXzE3MTk4MTIzMjA6MTcxOTgxNTkyMF9WNA" alt="img"></p><h3 id="9-3-高速缓存表分类"><a href="#9-3-高速缓存表分类" class="headerlink" title="9.3 高速缓存表分类"></a>9.3 高速缓存表分类</h3><ul><li>动态：自动获取，生命周期默认为两分钟;</li><li>静态：手工设置，不同操作系统下的生命周期不同，例如系统重启后不存在或系统重启后依然有效。</li></ul><p>ARP 协议只在同一段链路间使用。</p><h2 id="10-集线器和交换机的区别"><a href="#10-集线器和交换机的区别" class="headerlink" title="10. 集线器和交换机的区别"></a>10. 集线器和交换机的区别</h2><h3 id="10-1-早期总线型以太网"><a href="#10-1-早期总线型以太网" class="headerlink" title="10.1 早期总线型以太网"></a>10.1 早期总线型以太网</h3><p>传统以太网是使用 粗同轴电缆的总线以太网，后面转变为较为便宜的 细同轴电缆。最后 淘汰，被双绞线代替。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGQzYzQ2ODdlYTQyYjYzM2FhNGJiZTdlMjAzZjhjOWNfb0tBaXZHY1dYWGNiZ3ROb2Q1UWJBTkVsWTBHQTBsdmlfVG9rZW46RkNXemJYM2V5b2wyR2x4aFphMmNsQmNHbnRmXzE3MTk4MTIzMjA6MTcxOTgxNTkyMF9WNA" alt="img"></p><h3 id="10-2-使用双绞线和集线器HUB的星型以太网"><a href="#10-2-使用双绞线和集线器HUB的星型以太网" class="headerlink" title="10.2 使用双绞线和集线器HUB的星型以太网"></a>10.2 使用双绞线和集线器HUB的星型以太网</h3><ul><li>使用集线器的以太网在 逻辑上仍是一个总线网，各站共享总线资源，使用的还是CSMA&#x2F;CD协议</li><li>集线器只工作在物理层，它的每个接口仅简单地转发比特，不进行碰撞检测（由各站的网卡检测）</li><li>集线器一般都有少量的容错能力和网络管理功能。例如，若网络中某个网卡出了故障，不停地发送帧。此时，集线器可以检测到这个问题，在内部断开与出故障网卡的连线，使整个以太网仍然能正常工作。</li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NDFhM2Y3YzUwOGIwYTI3ZjhjMjE1ZjdkY2NkNTg1ZjRfQ2h1ckNWWERsQVdtM3hZZTVYa0pGMXhpSUpFRkdQTUVfVG9rZW46S0lSSGI2d1Jkb20zaGh4WlZ0Q2NGMUlWbjhjXzE3MTk4MTIzMjA6MTcxOTgxNTkyMF9WNA" alt="img"></p><h3 id="10-3-使用集线器HUB在物理层扩展以太网"><a href="#10-3-使用集线器HUB在物理层扩展以太网" class="headerlink" title="10.3 使用集线器HUB在物理层扩展以太网"></a>10.3 使用集线器HUB在物理层扩展以太网</h3><p>如图，在局域网扩展以前，三个小局域网 各自是一个广播域，也各自成 一个碰撞域。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MzhiY2E4NDAxMGVmZDhmNjMyODkyMDQ0OWYyNTU5MzlfUU53ZnNmY3BGbDdsV1o3YmpldFl3NWRjV2ZZOFZNZnBfVG9rZW46SDJzWmJoSU1Eb3hGbkh4dFVMWGNTNWdkbmZiXzE3MTk4MTIzMjA6MTcxOTgxNTkyMF9WNA" alt="img"></p><p>通过一个“主干”集线器将三个系互连，成为一个更大的以太网。新的以太网还是一个 更大的广播域，也是一个 更大的碰撞域。</p><h3 id="10-4-以太网交换机"><a href="#10-4-以太网交换机" class="headerlink" title="10.4 以太网交换机"></a>10.4 以太网交换机</h3><p>前提：① 忽略ARP过程 ②假设交换机的帧交换表已“学习好了”</p><ul><li>以太网交换机 通常都有多个接口。每个接口都可以直接与一台主机或另一个以太网交换机相连。一般都工作在 全双工方式。</li><li>以太网交换机具有并行性，能 同时连通多对接口，使多对主机能同时通信，无碰撞（不使用CSMA&#x2F;CD协议）。</li><li>以太网交换机- -般都具有多种速率的接口，例如: 10Mb&#x2F;s、100Mb&#x2F;s、 1Gb&#x2F;s、 10Gb&#x2F;s接口的多种组合。</li><li>以太网交换机 工作在数据链路层（也包括物理层）， 它收到帧后，在帧交换表中 查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧。</li><li>以太网交换机使一种即插即用设备，其内部的 帧交换表 是通过 自学习算法 自动地逐渐建立起来的。</li><li>帧的两种转发方式:<ul><li>存储转发</li><li>直通交换：采用基于硬件的交叉矩阵（交换时延非常小，但不检查帧是否有差错）</li></ul></li></ul><h3 id="10-5-集线器和交换机的区别"><a href="#10-5-集线器和交换机的区别" class="headerlink" title="10.5 集线器和交换机的区别"></a>10.5 集线器和交换机的区别</h3><h4 id="（1）单播（一个）"><a href="#（1）单播（一个）" class="headerlink" title="（1）单播（一个）"></a>（1）单播（一个）</h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MDQyMjA3ZjMzZjc2YjY3ZWExZGU2ZDlmMzBkNjJmMjlfQWx2WndUbmxibHNXVm1vTWFKNktaZk1SS3dUek1MVldfVG9rZW46UmdDVWI0d0xzbzJ5dTF4MEdUQWNRMDFRbldlXzE3MTk4MTIzMjA6MTcxOTgxNTkyMF9WNA" alt="img"></p><h4 id="（2）广播"><a href="#（2）广播" class="headerlink" title="（2）广播"></a>（2）广播</h4><h4 id="（3）单播（两个）"><a href="#（3）单播（两个）" class="headerlink" title="（3）单播（两个）"></a>（3）单播（两个）</h4><p>两个同时进行的单播，对于集线器，会发生碰撞。而对于交换机，则不会产生碰撞。</p><h3 id="10-6-集线器与交换机对比"><a href="#10-6-集线器与交换机对比" class="headerlink" title="10.6 集线器与交换机对比"></a>10.6 集线器与交换机对比</h3><ul><li>相同点，集线器和交换机 都扩大了广播域</li><li>不同点，集线器扩大了碰撞域（冲突域），而交换机没有扩大碰撞域</li></ul><h4 id="（1）集线器HUB"><a href="#（1）集线器HUB" class="headerlink" title="（1）集线器HUB"></a>（1）集线器HUB</h4><ul><li>早期 以太网的互连设备</li><li>工作在OSI体系结构的 物理层</li><li>对接收到的信号进行 放大、转发</li><li>使用集线器作为互连设备的以太网仍然 属于共享总线式以太网。集线器互连起来的所有主机共享总线带宽，属于同一个碰撞域和广播域。</li><li>目前，集线器已 被淘汰。</li></ul><h4 id="（2）交换机SWITCH"><a href="#（2）交换机SWITCH" class="headerlink" title="（2）交换机SWITCH"></a>（2）交换机SWITCH</h4><ul><li>目前 以太网中使用最广泛的互连设备</li><li>工作在OSI体系结构的 数据链路层（也包括物理层）</li><li>根据 MAC地址 对帧进行转发</li><li>使用交换机作为互连设备的以太网，称为 交换式以太网。交换机可以根据MAC地址 过滤 帧，即隔离碰撞域。</li><li>交换机的 每个接口是一个独立的碰撞域</li><li>交换机 隔离碰撞域 但 不隔离广播域(VLAN除外）</li></ul><h2 id="11-以太网交换机自学习和转发帧的过程"><a href="#11-以太网交换机自学习和转发帧的过程" class="headerlink" title="11. 以太网交换机自学习和转发帧的过程"></a>11. 以太网交换机自学习和转发帧的过程</h2><p>前提</p><p>假设各主机知道网络中其他各主机的MAC地址（无需进行ARP）</p><ul><li>以太网交换机工作在 数据链路层（也包括物理层）</li><li>以太网交换机收到帧后，在帧交换表中查找 帧的目的MAC地址所对应的接口号，然后通过该接口转发帧。</li><li>以太网交换机是一种即插即用设备，刚上电启动时其内部的帧交换表是空的。随着网络中各主机间的通信，以太网交换机 通过自学习算法自动逐渐建立起帧交换表。</li></ul><p>具体过程</p><ol><li>收到帧后进行 登记。登记的内容为帧的源MAC地址及进入交换机的 接口号</li><li>根据 帧的目的MAC地址 和交换机的 帧交换表 对帧进行 转发，有以下三种情况：<ol><li>明确转发：交换机知道应当从哪个(或哪些)接口转发该帧（单播,多播,广播）</li><li>盲目转发：交换机不知道 应当从哪个端口转发帧，只能将其通过除进入交换机的接口外的其他所有接口转发（也称为泛洪）。</li><li>明确丢弃：交换机知道不应该转发该帧，将其丢弃。</li></ol></li></ol><p>注意</p><p>每条记录都有自己的 有效时间，到期自动删除！这是因为 MAC地址与交换机接口的对应关系并不是永久性的！</p><p>具体可能原因如下：</p><ol><li>交换机的接口改接了另一台主机</li><li>主机更换了网卡</li></ol><h2 id="12-以太网交换机的生成树协议STP"><a href="#12-以太网交换机的生成树协议STP" class="headerlink" title="12. 以太网交换机的生成树协议STP"></a>12. 以太网交换机的生成树协议STP</h2><h3 id="12-1-背景"><a href="#12-1-背景" class="headerlink" title="12.1 背景"></a>12.1 背景</h3><h3 id="12-2-生成树协议STP"><a href="#12-2-生成树协议STP" class="headerlink" title="12.2 生成树协议STP"></a>12.2 生成树协议STP</h3><h2 id="13-虚拟局域网VLAN"><a href="#13-虚拟局域网VLAN" class="headerlink" title="13. 虚拟局域网VLAN"></a>13. 虚拟局域网VLAN</h2><h3 id="13-1-虚拟局域网概述"><a href="#13-1-虚拟局域网概述" class="headerlink" title="13.1 虚拟局域网概述"></a>13.1 虚拟局域网概述</h3><p>广播风暴会浪费网络资源和各主机的CPU资源！</p><p>但是 网络中会频繁出现广播信息，于是就需要划分广播域。</p><p>一种方法是使用 路由器，路由器工作在 网络层，默认情况下不对广播数据包进行转发。</p><p>但是路由器的成本太高，因此 虚拟局域网VLAN技术 应运而生。</p><p>虚拟局域网VLAN（Virtual Local Area Network）是一种将局域网内的 设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求。</p><h3 id="13-2-虚拟局域网的实现机制"><a href="#13-2-虚拟局域网的实现机制" class="headerlink" title="13.2 虚拟局域网的实现机制"></a>13.2 虚拟局域网的实现机制</h3><h4 id="IEEE-802-1Q帧"><a href="#IEEE-802-1Q帧" class="headerlink" title="IEEE 802.1Q帧"></a>IEEE 802.1Q帧</h4><ul><li>IEEE 802.1Q帧（也称Dot One Q帧）对以太网的MAC帧格式进行了扩展，插入了 4字节的VLAN标记。<ul><li>以太网V2的MAC帧（最大长度1518字节）</li><li>插入VLAN标记后的802.1Q帧（最大长度1522字节）</li></ul></li><li>VLAN标记的 最后12比特称为 VLAN标识符VID，它唯一地标志了以太网帧属于哪一一个VLAN。<ul><li>VID的取值范围是0 ~ 4095（0 ~ 212−1212−1）</li><li>0和4095都不用来表示VLAN，因此用于表示VLAN的 VID的有效取值范围是 1~4094。</li></ul></li><li>802.1Q帧是由交换机来处理的，而不是用户主机来处理的。<ul><li>当交换机收到 普通的以太网帧时， 会将其插入4字节的VLAN标记转变为802.1Q帧，简称 “打标签”。</li><li>当交换机 转发802.1Q帧时， 可能会删除其4字节VLAN标记转变为普通以太网帧，简称 “去标签”</li></ul></li></ul><h4 id="交换机的端口类型"><a href="#交换机的端口类型" class="headerlink" title="交换机的端口类型"></a>交换机的端口类型</h4><ul><li>交换机的端口类型有以下三种:<ul><li>Access</li><li>Trunk</li><li>Hybrid</li></ul></li><li>交换机各端口的缺省VLAN ID<ul><li>在思科交换机上称为 Native VLAN，即本征VLAN。</li><li>在华为交换机.称为 Port VLAN ID，即端口VLAN ID，简记为PVID。</li></ul></li></ul><h5 id="（1）Access-端口"><a href="#（1）Access-端口" class="headerlink" title="（1）Access 端口"></a>（1）Access 端口</h5><ul><li>Accss端口一-般用于 连接用户计算机</li><li>Access端口只能属于一个VLAN</li><li>Access端口的 PVID值与端口所属VLAN的ID相同（默认为1）</li><li>Access端口接收处理方法: 一般只接受“未打标签”的普通以太网MAC帧。 根据接收帧的端口的PVID给帧 “打标签”，即插入4字节VLAN标记字段，字段中的 VID取值与端口的PVID取值相等。</li><li>Access端口发送处理方法： 若帧中的VID与端口的PVID相等，则 “去标签” 并转发该帧；否则不转发。</li></ul><h5 id="（2）Trunk-端口"><a href="#（2）Trunk-端口" class="headerlink" title="（2）Trunk 端口"></a>（2）Trunk 端口</h5><ul><li>Trunk端口- -般 用于交换机之间或交换机与路由器之间的互连</li><li>Trunk端口可以属于多个VLAN</li><li>用户可以设置Trunk端口的PVID值。默认情况下，Trunk端口的PVID值为1。</li><li>Trunk端口发送处理方法：<ul><li>对 VID等于PVID的帧，“去标签” 再转发</li><li>对 VID不等于PVID的帧，直接转发</li></ul></li><li>Trunk端口接收处理方法：<ul><li>接收 “未打标签” 的帧，根据接收帧的端口的PVID给帧 “打标签”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等。</li><li>接收 “已打标签” 的帧</li></ul></li></ul><h1 id="（四）网络层"><a href="#（四）网络层" class="headerlink" title="（四）网络层"></a>（四）网络层</h1><h2 id="1-网络层概述"><a href="#1-网络层概述" class="headerlink" title="1. 网络层概述"></a>1. 网络层概述</h2><ul><li>网络层的主要任务是实现 网络互连，进而 实现数据包在各网络之间的传输。</li><li>TCP&#x2F;IP参考模型的网络层提供的是 无连接不可靠的数据报服务</li><li>要实现网络层任务，需要解决以下主要问题:<ul><li>网络层向运输层提供怎样的服务（“可靠传输” 还是 “不可靠传输”）</li><li>网络层寻址问题</li><li>路由选择问题</li></ul></li><li>因特网（Internet）是目前全世界用户数量最多的互联网，它使用 TCP&#x2F;IP协议栈。</li><li>由于TCP&#x2F;IP协议栈的网络层使用 网际协议IP，它是整个协议栈的核心协议，因此在TCP&#x2F;IP协议栈中网络层常称为 网际层。</li><li>综上所述，我们通过学习TCP&#x2F;IP协议栈的网际层来学习网络层的理论知识和实践技术。</li></ul><h2 id="2-网络层提供的两种服务"><a href="#2-网络层提供的两种服务" class="headerlink" title="2. 网络层提供的两种服务"></a>2. 网络层提供的两种服务</h2><h3 id="2-1-面向连接的虚电路服务"><a href="#2-1-面向连接的虚电路服务" class="headerlink" title="2.1 面向连接的虚电路服务"></a>2.1 面向连接的虚电路服务</h3><ul><li>可靠通信由网络来保证</li><li>必须建立 网络层的连接虚电路VC(Virtual Circuit）</li><li>通信双方 沿着已建立的虚电路发送分组</li><li>目的主机的地址仅在连接建立阶段使用，之后 每个分组的首部只需携带一条虚电路的编号（构成虚电路的每一段链路都有一个虚电路编号）。</li><li>这种通信方式如果再使用可靠传输的网络协议，就可使所发送的分组最终正确到达接收方（无差错按序到达、不丢失、不重复）</li><li>通信结束后，需要释放之前所建立的虚电路。</li><li>很多广域分组交换网都使用面向连接的虚电路服务。 例如，曾经的X.25和逐渐过时的帧中继FR、异步传输模式ATM等。</li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MmEwZWMyODAzMDAxMDJjM2U0M2ZlMmYwMzRlYjQyYjZfZjNDM0dyQTdhT1VVU1paS1l2UlVDZm5hUWZNS0FFUkdfVG9rZW46WVQ2SWJGMmprb2owZFJ4ZFBlc2NKUmFabmRjXzE3MTk4MTIzMjA6MTcxOTgxNTkyMF9WNA" alt="img"></p><h3 id="2-2-无连接的数据报服务"><a href="#2-2-无连接的数据报服务" class="headerlink" title="2.2 无连接的数据报服务"></a>2.2 无连接的数据报服务</h3><ul><li>可靠通信应当由用户主机来保证</li><li>不需要建立网络层连接</li><li>每个分组可走不同的路径</li><li>每个分组的 首部必须携带目的主机的完整地址</li><li>这种通信方式所传送的 分组可能误码、丢失、重复和失序。</li><li>由于 网络本身不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价 格低廉（与电信网的交换机相比较）。</li><li>因特网采用了这种设计思想，也就是 将复杂的网络处理功能置于因特网的边缘（用户主机和其内部的运输层），而将相对简单的尽最大努力的分组交付功能置于因特网核心。</li></ul><h3 id="2-3-虚电路服务和数据报服务的对比"><a href="#2-3-虚电路服务和数据报服务的对比" class="headerlink" title="2.3 虚电路服务和数据报服务的对比"></a>2.3 虚电路服务和数据报服务的对比</h3><h2 id="3-IPv4地址及其应用"><a href="#3-IPv4地址及其应用" class="headerlink" title="3. IPv4地址及其应用"></a>3. IPv4地址及其应用</h2><h3 id="3-1-IPv4地址概述"><a href="#3-1-IPv4地址概述" class="headerlink" title="3.1 IPv4地址概述"></a>3.1 IPv4地址概述</h3><ul><li>在TCP&#x2F;IP体系中，IP地址是一个最基本的概念，我们必须把它弄清楚。</li><li>IPv4地址 就是给因特网（Internet）上的 每一台主机（或路由器）的每一个接口分配一个在全世界范围内是 唯一的32比特的标识符。</li><li>IP地址由因特网名字和数字分配机构ICANN(Internet Corporation for Assigned Names and Numbers)进行分配。<ul><li>我国用户可向亚太网络信息中心APNIC(Asia Pacific Network Information Center)申请IP地址， 需要缴费。</li><li>2011年2月3日，互联网号码分配管理局IANA（由ICANN行使职能）宣布，IPv4地址已经分配完毕。</li><li>我国在2014至201 5年也逐步停止了向新用户和应用分配IPv4地址。同时全面开展商用部署IPv6。</li></ul></li><li>IPv4地址的编址方法经历了如下三个历史阶段:</li><li>32比特的IPv4地址不方便阅读、记录以及输入等,因此IPv4地址采用 点分十进制表示方法以方便用户使用。</li></ul><h3 id="3-2-分类编址的IPv4地址"><a href="#3-2-分类编址的IPv4地址" class="headerlink" title="3.2 分类编址的IPv4地址"></a>3.2 分类编址的IPv4地址</h3><p>分类的IPv4地址共分为 5 类：A类地址、B类地址、C类地址、D类地址、E类地址。</p><p>注意：</p><ul><li>只有A类、B类和C类地址可分配给网络中的 主机或路由器的各接口</li><li>主机号为 “全0” 的地址是网络地址，不能分配给主机或路由器的各接口</li><li>主机号为 “全1” 的地址是广播地址，不能分配给主机或路由器的各接口</li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MjQxMGFjMWUxMDkwMGZkMzg0ZDdmMzdhMGRkOGEyMmFfY0RMd1drTHNSWk9wWnZ6UWVTN1ZycDRESE9IRkdrcGFfVG9rZW46VUhIUGJ3VVdOb3ZodnV4N1llbmN6Y0dZbkFlXzE3MTk4MTIzMjA6MTcxOTgxNTkyMF9WNA" alt="img"></p><h4 id="（1）A类地址"><a href="#（1）A类地址" class="headerlink" title="（1）A类地址"></a>（1）A类地址</h4><ul><li>最小网络号 0，保留不指派</li><li>第一个可指派的网络号为 1，网络地址为 1.0.0.0</li><li>最大网络号 127，作为本地环回测试地址，不指派<ul><li>最小的本地环回测试地址为 127.0.0.1</li><li>最大的本地环回测试地址为 127.255.255.254</li></ul></li><li>最后一个可指派的网络号为 126，网络地址为 126.0.0.0</li><li>可指派的网络数量为 28−1&#x3D;12628−1&#x3D;126（减2的原因是除去最小网络号0和最大网络号127）</li><li>每个网络中可分配的IP地址数量为 224−2&#x3D;16777214224−2&#x3D;16777214（减2的原因是除去主机号为全 0 的网络地址和全 1 的广播地址）</li></ul><h4 id="（2）B类地址"><a href="#（2）B类地址" class="headerlink" title="（2）B类地址"></a>（2）B类地址</h4><ul><li>最小网络号也是第一个可指派的网络号 128.0 网络地址为 128.0.0.0</li><li>最大网络号也是最后一一个可指派的网络号 191.255 网络地址为 191.255.0.0</li><li>可指派的网络数量为 216−2&#x3D;16384216−2&#x3D;16384</li><li>每个网络中可分配的IP地址数量为 216−2&#x3D;65534216−2&#x3D;65534（减2的原因是除去主机号为全 0 的网络地址和全1的广播地址）</li></ul><h4 id="（3）C类地址"><a href="#（3）C类地址" class="headerlink" title="（3）C类地址"></a>（3）C类地址</h4><ul><li>最小网络号也是第一个可指派的网络号 192.0.0 网络地址为 192.0.0.0</li><li>最大网络号也是最后一一个可指派的网络号 223.255.255 网络地址为 223.255.255.0</li><li>可指派的网络数量为 224−3&#x3D;2097152224−3&#x3D;2097152</li><li>每个网络中可分配的IP地址数量为 28−2&#x3D;25428−2&#x3D;254（减2的原因是除去主机号为全 0 的网络地址和全 1 的广播地址）</li></ul><h4 id="（4）一般不使用的特殊IP地址"><a href="#（4）一般不使用的特殊IP地址" class="headerlink" title="（4）一般不使用的特殊IP地址"></a>（4）一般不使用的特殊IP地址</h4><h5 id="一、"><a href="#一、" class="headerlink" title="一、"></a><a href="https://docs.mphy.top/#/C-Network/ch04?id=%E4%B8%80%E3%80%81">一、</a></h5><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MmU4ZmNmM2Y2YWQ4ZjdlNWFlZjY3OGZjMzRmMzkzYTZfS0dtUEZsYzdkMmFSa1dmTGwxd0VtU1h0UmVMQkZBd21fVG9rZW46RXlqUGJaZk5EbzR6SHR4MUllc2N2aURybkVjXzE3MTk4MTIzMjA6MTcxOTgxNTkyMF9WNA" alt="img"></p><h5 id="解答"><a href="#解答" class="headerlink" title="解答"></a><a href="https://docs.mphy.top/#/C-Network/ch04?id=%E8%A7%A3%E7%AD%94">解答</a></h5><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NjFmM2FkNmVmMjNiZGY2ODI0YjMwM2NkYTk1MzM0ZmFfMFhrRVVnZjdwVVlkOWxGZDUzNnVjQU5SVnpZWWlqNUtfVG9rZW46SnhPdWJOQ0JYb0lqTld4WVB3V2NsakRIbnFmXzE3MTk4MTIzMjA6MTcxOTgxNTkyMF9WNA" alt="img"></p><h3 id="3-3-划分子网的IPv4地址"><a href="#3-3-划分子网的IPv4地址" class="headerlink" title="3.3 划分子网的IPv4地址"></a>3.3 划分子网的IPv4地址</h3><h3 id="3-4-无分类编址的IPv4地址"><a href="#3-4-无分类编址的IPv4地址" class="headerlink" title="3.4 无分类编址的IPv4地址"></a>3.4 无分类编址的IPv4地址</h3><h3 id="3-5-IPv4地址的应用规划"><a href="#3-5-IPv4地址的应用规划" class="headerlink" title="3.5 IPv4地址的应用规划"></a>3.5 IPv4地址的应用规划</h3><h4 id="1）应用规划"><a href="#1）应用规划" class="headerlink" title="1）应用规划"></a>1）应用规划</h4><p>应用规划：给定一个IPv4地址块，将其划分为几个更小的地址块，并将这些地址块分给互联网中的不同网络，进而给各位网络的主机和路由器接口分配IPv4地址。</p><p>解决方法：</p><ul><li>方法一：定长子网掩码（FLSM，Fixed Length Subnet Mask）<ul><li>使用同一个子网掩码来划分子网</li><li>每个子网所分配的IP地址数量相同，造成IP地址浪费</li></ul></li><li>方法二：变长子网掩码（VLSM，Variable Length Subnet Mask）<ul><li>使用不同的子网掩码来划分子网</li><li>每个子网所分配的IP地址数量可以不同，尽可能减少对IP地址的浪费</li></ul></li></ul><h4 id="2）定长子网掩码划分"><a href="#2）定长子网掩码划分" class="headerlink" title="2）定长子网掩码划分"></a>2）定长子网掩码划分</h4><p>先确定每个子网中需要分配的IP地址的数量，向给定的网络地址（假如是C类网）中的主机号借 𝑛n 位来表示子网号，若需要划分 𝑚m 个子网，则要满足： 2𝑛&gt;&#x3D;𝑚2n&gt;&#x3D;m ，且 28−𝑛&gt;&#x3D;28−n&gt;&#x3D; 每个子网IP地址总需求量</p><h4 id="3）变长子网掩码划分"><a href="#3）变长子网掩码划分" class="headerlink" title="3）变长子网掩码划分"></a>3）变长子网掩码划分</h4><ol><li>先确定每个子网中需要分配的IP地址的数量 𝑥x（包括网络地址，广播地址，可分配地址），然后由此确定每个子网的主机号位数 𝑛n，满足 2𝑛&#x3D;𝑥2n&#x3D;x，再由此得出网络前缀的位数 𝑦&#x3D;32−𝑛y&#x3D;32−n。</li><li>然后得到每个子网的地址块形式：&#x2F;𝑦&#x2F;y 和地址数量：2𝑛2n。</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NTc0MzJiM2JlNTQ3Y2ViMWIzNDQ1NmFlNDMwNDVjN2VfWlpvVEZPRmVEYWpFdnRGaTdUazZLWHBhUUFXOTVXUzBfVG9rZW46Q29sM2JySmtqbzRickx4WVFoQWN4cWZabmlmXzE3MTk4MTIzMjA6MTcxOTgxNTkyMF9WNA" alt="img"></p><ol><li>列出所给地址块的全部地址，在该地址块中给网络待划分的子网分配子块，分配原则是“每个子块的起点位置不能随意选取，只能选取 “块大小整数倍的地址作为起点”。建议先给大的子块分配。</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDA5ZGQzNjg0NWY4ZTA4MjQ3NDJhZjZjYzljOTJjNTFfeXpWU08yUXRwQ1ZqaGpxeUdyNTRvVFhiRjRteEJmdmtfVG9rZW46UTVnUWJKN3lobzBNam94WlpZT2NCNzVsbmxnXzE3MTk4MTIzMjA6MTcxOTgxNTkyMF9WNA" alt="img"></p><h2 id="4-IP数据报的发送和转发过程"><a href="#4-IP数据报的发送和转发过程" class="headerlink" title="4. IP数据报的发送和转发过程"></a>4. IP数据报的发送和转发过程</h2><ul><li>主机发送IP数据报 判断目的主机是否与自己在同一个网络（判断方法请参看本节课相关示例）<ul><li>若在同一个网络，则属于直接交付</li><li>若不在同一个网络，则属于间接交付，传输给主机所在网络的默认网关（路由器），由默认网关帮忙转发</li></ul></li><li>路由器转发IP数据报<ul><li>检查IP数据报首部是否出错：<ol><li>若出错，则直接丢弃该IP数据报并通告源主机</li><li>若没有出错，则进行转发</li></ol></li><li>根据IP数据报的目的地址在路由表中查找匹配的条目（查找方法请参看本节课相关示例）：<ol><li>若找到匹配的条目，则转发给条目中指示的下一跳</li><li>若找不到，则丢弃该IP数据报并通告源主机</li></ol></li></ul></li><li>中继器 和 集线器 工作在物理层，既不隔离冲突域也不隔离广播域。</li><li>网桥 和 交换机（多端口网桥）工作在数据链路层，可以隔离冲突域，不能隔离广播域。</li><li>路由器 工作在网络层，既隔离冲突域，也隔离广播域。</li></ul><h2 id="5-静态路由配置及其可能产生的路由环路问题"><a href="#5-静态路由配置及其可能产生的路由环路问题" class="headerlink" title="5. 静态路由配置及其可能产生的路由环路问题"></a>5. 静态路由配置及其可能产生的路由环路问题</h2><ul><li>静态路由配置错误导致 路由环路</li><li>TTL：为了防止IP数据报在路由环路中永久兜圈，在IP数据报首部设有 生存时间TTL字段。IP数据报进入路由器后，TTL字段的值减1。若TTL的值不等于0，则被路由器转发，否则被丢弃。</li><li>静态路由配置 是指用户或网络管理员使用路由器的相关命令给路由器 人工配置路由表。<ul><li>这种人工配置方式简单、开销小。但不能及时适应网络状态(流量、拓扑等)的变化。</li><li>一般只在小规模网络中采用。</li></ul></li><li>使用静态路由配置可能出现以下导致产生 路由环路的错误<ul><li>配置错误</li><li>聚合了不存在的网络</li><li>网络故障</li></ul></li><li>路由条目的类型<ul><li>直连网络</li><li>静态路由（人工配置）</li><li>动态路由（路由选择协议）</li></ul></li><li>特殊的静态路由条目<ul><li>默认路由（目的网络为0.0.0.0, 地址掩码为0.0.0.0）</li><li>特定主机路由（目的网络为特定主机的IP地址，地址掩码为255.255.255.255）</li><li>黑洞路由（下一跳为 <code>null0</code>）</li></ul></li><li>路由表中几种静态路由<ul><li>自动得出的直连网络：目的网络为与接口直连的网络地址，下一跳为直连的接口。</li><li>人工配置的默认路由：目的网络为 <code>0.0.0.0/0</code>，子网掩码为 <code>255.255.255.255</code>，下一跳为指定的网络。</li><li>特定主机路由：目的网络为特定主机的IP地址，子网掩码为 <code>255.255.255.255</code></li><li>黑洞路由：为了解决因聚合了不存在的网络而导致路由环路的问题，目的网络为不存在的网络地址，下一跳为 <code>null0</code></li></ul></li></ul><h2 id="6-路由选择协议"><a href="#6-路由选择协议" class="headerlink" title="6. 路由选择协议"></a>6. 路由选择协议</h2><h3 id="6-1-路由选择协议概述"><a href="#6-1-路由选择协议概述" class="headerlink" title="6.1 路由选择协议概述"></a>6.1 路由选择协议概述</h3><h4 id="1）路由选择分类"><a href="#1）路由选择分类" class="headerlink" title="1）路由选择分类"></a>1）路由选择分类</h4><ul><li>静态路由选择<ul><li>由人工配置的网络路由、默认路由、特定主机路由、黑洞路由等都属于静态路由。</li><li>这种人工配置方式简单、开销小。 但是 不能及时适应网络状态（流量、拓扑等）的变化。</li><li>一般只在 小规模网络 中采用。</li></ul></li><li>动态路由选择<ul><li>路由器通过路由选择协议 自动获取路由信息。</li><li>比较复杂、开销比较大。 能较好的适应网络状态的变化。</li><li>适用于 大规模网络</li></ul></li></ul><h4 id="2）因特网所采用的路由选择协议的主要特点"><a href="#2）因特网所采用的路由选择协议的主要特点" class="headerlink" title="2）因特网所采用的路由选择协议的主要特点"></a>2）因特网所采用的路由选择协议的主要特点</h4><ul><li>动态路由选择，较好的适应网络状态变化</li><li>路由器之间交换路由信息</li><li>将整个因特网划分为许多较小的自治系统AS</li></ul><h4 id="3）因特网采用分层次的路由选择协议"><a href="#3）因特网采用分层次的路由选择协议" class="headerlink" title="3）因特网采用分层次的路由选择协议"></a>3）因特网采用分层次的路由选择协议</h4><ul><li>自治系统AS内部的路由选择称为 域内路由选择，自治系统之间的路由选择称为 域间路由选择。</li><li>域内路由选择使用的是一类 内部网关协议IGP（Inner Gateway Protocol），域间路由选择使用的协议是一类 外部网关协议EGP（Edge Gateway Protocl）。</li></ul><blockquote><p>说明，“网关” 和 “路由”这两个名字和互换，即内部路由协议IRP。</p></blockquote><ul><li>不同自治系统使用的内部网关协议IGP不影响其他自治系统的IGP。（可以使用RIP或OSPF等等）</li></ul><h4 id="4）常见网关协议"><a href="#4）常见网关协议" class="headerlink" title="4）常见网关协议"></a>4）常见网关协议</h4><h4 id="5）路由器的基本结构"><a href="#5）路由器的基本结构" class="headerlink" title="5）路由器的基本结构"></a>5）路由器的基本结构</h4><ul><li>路由器是一种具有多个输入端口和输出端口的专用计算机，其任务是 转发分组。</li><li>路由器结构可分为两大部分<ul><li>路由选择部分</li><li>分组转发部分</li></ul></li><li>路由选择部分的核心构件是 路由选择处理机，其任务是通过路由选择协议周期性的与其他路由器进行路由信息的交互，来 更新路由表。</li><li>分组转发部分由三部分构成<ul><li>交换结构</li><li>一组输入端口</li><li>一组输出端口</li></ul></li><li>路由器还具有输入缓冲区、输出缓冲区，来缓存已经处理但未发送的分组。</li><li>路由表一般仅包含 从目的网络到下一跳的映射</li><li>路由表需要对网络拓扑变化的计算最优化</li><li>转发表是从路由表得出的</li><li>转发表的结构应当使查找过程最优化</li></ul><blockquote><p>一般不严格区分路由表和转发表。</p></blockquote><h3 id="6-2-路由信息协议RIP的基本工作原理"><a href="#6-2-路由信息协议RIP的基本工作原理" class="headerlink" title="6.2 路由信息协议RIP的基本工作原理"></a>6.2 路由信息协议RIP的基本工作原理</h3><ul><li>路由信息协议RIP（Routing Information Protocol）是内部网关协议IGP中最先得到广泛使用的协议之一，其相关标准文档为RFC 1058。</li><li>RIP要求自治系统AS内的每- -个路由器都要维护从它自己到AS内其他每-一个网络的距离记录。这是一组距离，称为 “距离向量D-V(Distance-Vector)”。</li><li>RIP使用 跳数（Hop Count）作为度量（Metric）来衡量到达目的网络的距离。<ul><li>路由器到直连网络的距离定义为1。</li><li>路由器到非直连网络的距离定义为所经过的路由器数加1。</li><li>允许一条路径最多只能包含15个路由器。 “距离”等于16时相当于不可达。因此，RIP只适用于小型互联网。</li></ul></li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=Yzc2YzZiZDJjZTYzZjA1OTk5ZDIzZGMzYzU1ZDE2ZjNfZkhvRzhNdVhLaEdQT3hiRnY4QVJpQ3NqdkxUOXBUb2VfVG9rZW46TlUxMmJaZzNib010dUR4bG9uMWNpYWlQbk9lXzE3MTk4MTIzMjA6MTcxOTgxNTkyMF9WNA" alt="img"></p><ul><li>RIP认为 好的路由 就是 “距离短” 的路由，也就是 所通过路由器数量最少的路由。</li><li>当到达同一目的网络有多条 “距离相等” 的路由时，可以进行 等价负载均衡。</li><li>RIP包含以下三个要点:<ul><li>和谁交换信息：仅和相邻路由器交换信息</li><li>交换什么信息：自己的路由表</li><li>何时交换信息：周期性交换（例如每30秒）</li></ul></li><li>RIP的基本工作过程<ul><li>路由器刚开始工作时，只知道自己到直连网络的距离为1。</li><li>每个路由器仅和相邻路由器周期性地交换并更新路由信息。</li><li>若干次交换和更新后，每个路由器都知道到达本AS内各网络的最短距离和下- -跳地址,称为收敛。</li></ul></li><li>RIP的路由条目的更新规则<ul><li>发现了新的网络，添加</li><li>到达目的网络，相同下一跳，最新消息，更新</li><li>到达目的网络，不同下一跳，新路由优势，更新</li><li>到达目的网络,不同下一跳，新路由劣势，不更新</li><li>到达目的网络,不同下一跳,等价负载均衡</li></ul></li><li>RIP存在 “坏消息传播得慢” 的问题 “坏消息传播得慢” 又称为 路由环路或距离无穷计数问题，这是 距离向量算法的一个固有问题。 可以采取多种措施 减少 出现该问题的概率或减小该问题带来的危害。<ul><li>限制最大路径距离为15（16表示不可达）</li><li>当路由表发生变化时就立即发送更新报文（即 “触发更新”），而不仅是周期性发送</li><li>让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送（即 “水平分割”）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机专业必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机专业必备 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试中的算法-总结</title>
      <link href="/2024/07/01/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95-%E6%80%BB%E7%BB%93/"/>
      <url>/2024/07/01/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95-%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>开设这个专栏主要是在面试中算法避免一些踩坑，首先，经过我本人亲自实践+网上各位大佬总结:</p><p>当我们刷算法题的时候，比如力扣、牛客这些网站，很多的题目只需要我们写出函数体（核心代码），平台就可以自动帮助我们补齐输入输出，进行调试，但，在笔试和面试中，往往需要自己写出可以运行的完整代码（ACM模式），这个时候，需要我们去了解一下自己所使用的语言下的输入输出如何去设计。</p><p>这几篇老文章都是我之前用飞书云文档写的，因转换格式问题，之前已写完的文档图片太多了，不想一一转化了，大家可以访问我的飞书云文档来查看这些图片–<a href="https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e">https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e</a></p><h2 id="核心代码模式与ACM模式"><a href="#核心代码模式与ACM模式" class="headerlink" title="核心代码模式与ACM模式"></a>核心代码模式与ACM模式</h2><p>当我们刷算法题的时候，比如力扣、牛客这些网站，很多的题目只需要我们写出函数体（核心代码），平台就可以自动帮助我们补齐输入输出，进行调试，但，在笔试和面试中，往往需要自己写出可以运行的完整代码（ACM模式），这个时候，需要我们去了解一下自己所使用的语言下的输入输出如何去设计。</p><p>首先给出几个注意事项：</p><p>1.笔试平台用的比较多的，比如牛客，赛码，可以提前去熟悉熟悉上面的操作。</p><p>2.有些笔试，需要自己写输入输出，有些，则不需要，但我们必须要把输入输出搞懂，这样就不怕是什么类型的笔试了，而且输入输出本身是不难的，学习一下就可以完全掌握。最好不要出现，算法题的核心思路会写，卡在了输入输出上，这样就很难受了。</p><p>3.有些笔试，还会让大伙自己设计测试用例，这个平时练习的时候也可以注意一下，主要核心的思想就是测试用例设计的几个原则。</p><p>4.不仅仅是笔试，有些面试，也会要求你写输入输出和测试用例。</p><h2 id="面试手撕代码的几种形式"><a href="#面试手撕代码的几种形式" class="headerlink" title="面试手撕代码的几种形式"></a>面试手撕代码的几种形式</h2><p>1.平台类</p><p>去面试官给定的平台上去面试，上面可以编写代码，调试和运行，这些平台有的写好了函数框架，有的是白板，需要自己写全部内容</p><p>2.自己的IDE</p><p>面试官要求候选人打开自己的ide，并共享桌面进行编写，这种肯定是要自己写全输入输出了</p><p>3.要求补齐测试用例</p><p>有些面试官，比如微软的面试官，可能会让你写完代码后，自己设计尽可能全面的测试用例，对你编写的代码进行测试。</p><h2 id="java处理输入输出"><a href="#java处理输入输出" class="headerlink" title="java处理输入输出"></a>java处理输入输出</h2><p>然后我是javaer，所以就给出java的acm模式处理输入输出的方式:</p><p>因为我之前参加算法比赛中，一般都是对时间卡的比较严格，所以都是用java的快读快写，但是笔试或者面试中手撕，一般不会要求那么严格，或者测试用例比较少，所以我么们直接使用Scanner就完全够用了</p><h3 id="情况1-全都是数字的输入，每行数字个数不定"><a href="#情况1-全都是数字的输入，每行数字个数不定" class="headerlink" title="情况1: 全都是数字的输入，每行数字个数不定"></a><strong>情况1: 全都是数字的输入，每行数字个数不定</strong></h3><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022127280.png" alt="image (4)" style="zoom:50%;" /><h3 id="情况2-每行第一个数字为确定的数字n，后面跟着n个数字"><a href="#情况2-每行第一个数字为确定的数字n，后面跟着n个数字" class="headerlink" title="情况2:每行第一个数字为确定的数字n，后面跟着n个数字"></a><strong>情况2:每行第一个数字为确定的数字n，后面跟着n个数字</strong></h3><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022127127.png" alt="image" style="zoom:50%;" /><h3 id="情况3-每行确定有n个数字的情况"><a href="#情况3-每行确定有n个数字的情况" class="headerlink" title="情况3: 每行确定有n个数字的情况"></a><strong>情况3: 每行确定有n个数字的情况</strong></h3><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022051417.png" alt="af53e94f-b92f-4994-9728-d7d91195b5db" style="zoom: 50%;" /><h3 id="情况4-第一行是一个数字n-第二行是n个字符串"><a href="#情况4-第一行是一个数字n-第二行是n个字符串" class="headerlink" title="情况4: 第一行是一个数字n, 第二行是n个字符串"></a><strong>情况4: 第一行是一个数字n, 第二行是n个字符串</strong></h3><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022052740.png" alt="cd792bb5-5f16-4379-b318-bcb270f57043" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022127888.png" alt="image (1)" style="zoom:50%;" /><h3 id="避坑点"><a href="#避坑点" class="headerlink" title="避坑点"></a>避坑点</h3><ul><li><strong>全局只能new出一个Scanner对象，如果有多个，会出现不可预见的问题！</strong></li><li>关于next() 函数、nextInt()函数、nextLine()函数：</li></ul><p>​        <strong>nextInt():</strong> 只读取整数类型数据， nextInt()在读取完输入后把光标放在读取数据的同一行，该数据的后面。</p><p>​        <strong>next():</strong> 只读取到空格，不能读取被空格分开的两个单词（也就是不能读取空格），并且在读取完后把光标放在读取数据的同一行，该数据的后面。（同上）</p><p>​        <strong>nextLine():</strong> 读取整行的数据包括单词间的空格，到回车结束（也就是从开始读一整行包括回车），读取结束后，光标放在下一行开头。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>不论是acm模式，还是核心代码模式，面试官考察的还是算法能力，要提高算法能力，说再多也没用，练就有效，像leetcode,牛客，洛谷，都是非常好的刷题网站，如果是零基础，并且要用java去应对笔试，我推荐去b站上搜索左程云老师，先入门，再刷题，每天坚持，无问西东。</p><h2 id="我将记录手撕题目"><a href="#我将记录手撕题目" class="headerlink" title="我将记录手撕题目:"></a>我将记录手撕题目:</h2><h3 id="写一个快速排序"><a href="#写一个快速排序" class="headerlink" title="写一个快速排序"></a>写一个快速排序</h3><p><a href="https://leetcode.cn/problems/sort-an-array/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 随机快速排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 随机这一下，常数时间比较大</span></span><br><span class="line">        <span class="comment">// 但只有这一下随机，才能在概率上把快速排序的时间复杂度收敛到O(n * logn)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> arr[l + (<span class="type">int</span>) (Math.random() * (r - l + <span class="number">1</span>))];</span><br><span class="line">        partition(arr, l, r, x);</span><br><span class="line">        <span class="comment">// 为了防止底层的递归过程覆盖全局变量</span></span><br><span class="line">        <span class="comment">// 这里用临时变量记录first、last</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> last;</span><br><span class="line">        quickSort(arr, l, left - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, right + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 荷兰国旗问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> first, last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已知arr[l....r]范围上一定有x这个值</span></span><br><span class="line"><span class="comment">// 划分数组 &lt;x放左边，==x放中间，&gt;x放右边</span></span><br><span class="line"><span class="comment">// 把全局变量first, last，更新成==x区域的左右边界</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        first = l;</span><br><span class="line">        last = r;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= last) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] == x) &#123;</span><br><span class="line">                        i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; x) &#123;</span><br><span class="line">                        swap(arr, first++, i++);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        swap(arr, i, last--);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求最长递增子序列"><a href="#求最长递增子序列" class="headerlink" title="求最长递增子序列"></a>求最长递增子序列</h3><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">                <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">                <span class="comment">// len表示ends数组目前的有效区长度</span></span><br><span class="line">                <span class="comment">// ends[0...len-1]是有效区，有效区内的数字一定严格升序</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, find; i &lt; n; i++) &#123;</span><br><span class="line">                        find = bs1(ends, len, nums[i]);</span><br><span class="line">                        <span class="keyword">if</span> (find == -<span class="number">1</span>) &#123;</span><br><span class="line">                                ends[len++] = nums[i];</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                ends[find] = nums[i];</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// &quot;最长递增子序列&quot;使用如下二分搜索 :</span></span><br><span class="line">        <span class="comment">// ends[0...len-1]是严格升序的，找到&gt;=num的最左位置</span></span><br><span class="line">        <span class="comment">// 如果不存在返回-1</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bs1</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> len, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = len - <span class="number">1</span>, m, ans = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                        m = (l + r) / <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> (ends[m] &gt;= num) &#123;</span><br><span class="line">                                ans = m;</span><br><span class="line">                                r = m - <span class="number">1</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                l = m + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果求最长不下降子序列，那么使用如下的二分搜索 :</span></span><br><span class="line">        <span class="comment">// ends[0...len-1]是不降序的</span></span><br><span class="line">        <span class="comment">// 在其中找到&gt;num的最左位置，如果不存在返回-1</span></span><br><span class="line">        <span class="comment">// 如果求最长不下降子序列，就在lengthOfLIS中把bs1方法换成bs2方法</span></span><br><span class="line">        <span class="comment">// 已经用对数器验证了，是正确的</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bs2</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> len, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = len - <span class="number">1</span>, m, ans = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                        m = (l + r) / <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> (ends[m] &gt; num) &#123;</span><br><span class="line">                                ans = m;</span><br><span class="line">                                r = m - <span class="number">1</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                l = m + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br></pre></td></tr></table></figure><h3 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h3><p><a href="https://leetcode.cn/problems/lru-cache/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">class</span> <span class="title class_">DoubleNode</span> &#123;</span><br><span class="line">                        <span class="keyword">public</span> <span class="type">int</span> key;</span><br><span class="line">                        <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">                        <span class="keyword">public</span> DoubleNode last;</span><br><span class="line">                        <span class="keyword">public</span> DoubleNode next;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">public</span> <span class="title function_">DoubleNode</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">                                key = k;</span><br><span class="line">                                val = v;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">class</span> <span class="title class_">DoubleList</span> &#123;</span><br><span class="line">                        <span class="keyword">private</span> DoubleNode head;</span><br><span class="line">                        <span class="keyword">private</span> DoubleNode tail;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">public</span> <span class="title function_">DoubleList</span><span class="params">()</span> &#123;</span><br><span class="line">                                head = <span class="literal">null</span>;</span><br><span class="line">                                tail = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(DoubleNode newNode)</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (newNode == <span class="literal">null</span>) &#123;</span><br><span class="line">                                        <span class="keyword">return</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">                                        head = newNode;</span><br><span class="line">                                        tail = newNode;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        tail.next = newNode;</span><br><span class="line">                                        newNode.last = tail;</span><br><span class="line">                                        tail = newNode;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveNodeToTail</span><span class="params">(DoubleNode node)</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (tail == node) &#123;</span><br><span class="line">                                        <span class="keyword">return</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (head == node) &#123;</span><br><span class="line">                                        head = node.next;</span><br><span class="line">                                        head.last = <span class="literal">null</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        node.last.next = node.next;</span><br><span class="line">                                        node.next.last = node.last;</span><br><span class="line">                                &#125;</span><br><span class="line">                                node.last = tail;</span><br><span class="line">                                node.next = <span class="literal">null</span>;</span><br><span class="line">                                tail.next = node;</span><br><span class="line">                                tail = node;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">public</span> DoubleNode <span class="title function_">removeHead</span><span class="params">()</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">                                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="type">DoubleNode</span> <span class="variable">ans</span> <span class="operator">=</span> head;</span><br><span class="line">                                <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">                                        head = <span class="literal">null</span>;</span><br><span class="line">                                        tail = <span class="literal">null</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        head = ans.next;</span><br><span class="line">                                        ans.next = <span class="literal">null</span>;</span><br><span class="line">                                        head.last = <span class="literal">null</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">return</span> ans;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">private</span> HashMap&lt;Integer, DoubleNode&gt; keyNodeMap;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">private</span> DoubleList nodeList;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">                        keyNodeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                        nodeList = <span class="keyword">new</span> <span class="title class_">DoubleList</span>();</span><br><span class="line">                        capacity = cap;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (keyNodeMap.containsKey(key)) &#123;</span><br><span class="line">                                <span class="type">DoubleNode</span> <span class="variable">ans</span> <span class="operator">=</span> keyNodeMap.get(key);</span><br><span class="line">                                nodeList.moveNodeToTail(ans);</span><br><span class="line">                                <span class="keyword">return</span> ans.val;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (keyNodeMap.containsKey(key)) &#123;</span><br><span class="line">                                <span class="type">DoubleNode</span> <span class="variable">node</span> <span class="operator">=</span> keyNodeMap.get(key);</span><br><span class="line">                                node.val = value;</span><br><span class="line">                                nodeList.moveNodeToTail(node);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (keyNodeMap.size() == capacity) &#123;</span><br><span class="line">                                        keyNodeMap.remove(nodeList.removeHead().key);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="type">DoubleNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleNode</span>(key, value);</span><br><span class="line">                                keyNodeMap.put(key, newNode);</span><br><span class="line">                                nodeList.addNode(newNode);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>一般要求递归和迭代都要写出来</p><p><a href="https://leetcode.cn/problems/reverse-linked-list/description/">链接</a></p><p>迭代：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">     ListNode next=<span class="literal">null</span>;</span><br><span class="line">     ListNode pre=<span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">         next=head.next;</span><br><span class="line">         head.next=pre;</span><br><span class="line">         pre=head;</span><br><span class="line">         head=next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> pre;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>递归：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> recur(head, <span class="literal">null</span>);    <span class="comment">// 调用递归并返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">recur</span><span class="params">(ListNode cur, ListNode pre)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> pre; <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> recur(cur.next, cur);  <span class="comment">// 递归后继节点</span></span><br><span class="line">    cur.next = pre;              <span class="comment">// 修改节点引用指向</span></span><br><span class="line">    <span class="keyword">return</span> res;                  <span class="comment">// 返回反转链表的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><p>经典滑动窗口</p><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> n=s.length;</span><br><span class="line">        <span class="type">int</span>[] last=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">        Arrays.fill(last,-<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>,r=<span class="number">0</span>; r&lt;n; r++) &#123;</span><br><span class="line">            l=Math.max(l,last[s[r]]+<span class="number">1</span>);<span class="comment">//如果s[r]之前没出现过，那么l就还是l，如果出现过，则l就变成新的位置</span></span><br><span class="line">            ans=Math.max(ans,r-l+<span class="number">1</span>);</span><br><span class="line">            last[s[r]]=r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h3><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        ListNode start=head;</span><br><span class="line">        ListNode end=teamEnd(start,k);</span><br><span class="line">        <span class="keyword">if</span>(end==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head=end;</span><br><span class="line">        reverse(start,end);</span><br><span class="line">        ListNode lastTeamEnd=start;</span><br><span class="line">        <span class="keyword">while</span>(lastTeamEnd.next!=<span class="literal">null</span>) &#123;</span><br><span class="line">            start=lastTeamEnd.next;</span><br><span class="line">            end=teamEnd(start,k);</span><br><span class="line">            <span class="keyword">if</span>(end==<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            reverse(start,end);</span><br><span class="line">            lastTeamEnd.next=end;</span><br><span class="line">            lastTeamEnd=start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(ListNode s, ListNode e)</span> &#123;</span><br><span class="line">           <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">           e=e.next;</span><br><span class="line">           ListNode pre=<span class="literal">null</span>,cur=s,next=<span class="literal">null</span>;</span><br><span class="line">           <span class="keyword">while</span> (cur != e) &#123;</span><br><span class="line">               next = cur.next;</span><br><span class="line">               cur.next = pre;</span><br><span class="line">               pre = cur;</span><br><span class="line">               cur = next;</span><br><span class="line">           &#125;</span><br><span class="line">           s.next = e;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> ListNode <span class="title function_">teamEnd</span><span class="params">(ListNode s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">           <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">           <span class="keyword">while</span> (--k!=<span class="number">0</span>&amp;&amp;s!=<span class="literal">null</span>) &#123;</span><br><span class="line">               s=s.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> s;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h3><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">链接</a></p><p>要实现O(n)的算法，实际上就是写一个快排。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 随机这一下，常数时间比较大</span></span><br><span class="line">               <span class="comment">// 但只有这一下随机，才能在概率上把快速排序的时间复杂度收敛到O(n * logn)</span></span><br><span class="line">               <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> arr[l + (<span class="type">int</span>) (Math.random() * (r - l + <span class="number">1</span>))];</span><br><span class="line">               partition(arr, l, r, x);</span><br><span class="line">               <span class="comment">// 为了防止底层的递归过程覆盖全局变量</span></span><br><span class="line">               <span class="comment">// 这里用临时变量记录first、last</span></span><br><span class="line">               <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> first;</span><br><span class="line">               <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> last;</span><br><span class="line">               quickSort(arr, l, left - <span class="number">1</span>);</span><br><span class="line">               quickSort(arr, right + <span class="number">1</span>, r);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 荷兰国旗问题</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> first, last;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 已知arr[l....r]范围上一定有x这个值</span></span><br><span class="line">       <span class="comment">// 划分数组 &lt;x放左边，==x放中间，&gt;x放右边</span></span><br><span class="line">       <span class="comment">// 把全局变量first, last，更新成==x区域的左右边界</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">               first = l;</span><br><span class="line">               last = r;</span><br><span class="line">               <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">               <span class="keyword">while</span> (i &lt;= last) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (arr[i] == x) &#123;</span><br><span class="line">                               i++;</span><br><span class="line">                       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; x) &#123;</span><br><span class="line">                               swap(arr, first++, i++);</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               swap(arr, i, last--);</span><br><span class="line">                       &#125;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">               arr[i] = arr[j];</span><br><span class="line">               arr[j] = tmp;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">       quickSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> nums[nums.length-k];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p><a href="https://leetcode.cn/problems/3sum/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n=nums.length;</span><br><span class="line">    Arrays.sort(nums);  <span class="comment">//一定得排序那么一下</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> first=<span class="number">0</span>;first&lt;n;first++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(first&gt;<span class="number">0</span>&amp;&amp;nums[first]==nums[first-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> third=n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> target=-nums[first];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> second=first+<span class="number">1</span>;second&lt;n;second++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(second&gt;first+<span class="number">1</span>&amp;&amp;nums[second]==nums[second-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(second&lt;third&amp;&amp;nums[second]+nums[third]&gt;target)&#123;</span><br><span class="line">                --third;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(second==third)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[second]+nums[third]==target)&#123;</span><br><span class="line">                List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                list.add(nums[first]);</span><br><span class="line">                list.add(nums[second]);</span><br><span class="line">                list.add(nums[third]);</span><br><span class="line">                ans.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode head1, ListNode head2)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (head1 == <span class="literal">null</span> || head2 == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> head1 == <span class="literal">null</span> ? head2 : head1;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> head1.val &lt;= head2.val ? head1 : head2;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">h1</span> <span class="operator">=</span> head.next;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">h2</span> <span class="operator">=</span> head == head1 ? head2 : head1;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="keyword">while</span> (h1 != <span class="literal">null</span> &amp;&amp; h2 != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (h1.val &lt;= h2.val) &#123;</span><br><span class="line">               pre.next = h1;</span><br><span class="line">               h1 = h1.next;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               pre.next = h2;</span><br><span class="line">               h2 = h2.next;</span><br><span class="line">           &#125;</span><br><span class="line">           pre = pre.next;</span><br><span class="line">       &#125;</span><br><span class="line">       pre.next = h1 != <span class="literal">null</span> ? h1 : h2;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="排序数组"><a href="#排序数组" class="headerlink" title="排序数组"></a>排序数组</h3><p><a href="https://leetcode.cn/problems/sort-an-array/description/">链表</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> first, last;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">       <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">           quickSort(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> nums;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[l + (<span class="type">int</span>) (Math.random() * (r - l + <span class="number">1</span>))];</span><br><span class="line">       partition(nums, l, r,x);</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> first;</span><br><span class="line">       <span class="type">int</span> right=last;</span><br><span class="line">       quickSort(nums,l,left-<span class="number">1</span>);</span><br><span class="line">       quickSort(nums,right+<span class="number">1</span>,r);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">       first=l;</span><br><span class="line">       last=r;</span><br><span class="line">       <span class="type">int</span> i=l;</span><br><span class="line">       <span class="keyword">while</span>(i&lt;=last)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i]==x)&#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&lt;x)&#123;</span><br><span class="line">               swap(nums,first++,i++);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               swap(nums,i,last--);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">       <span class="type">int</span> temp=nums[i];</span><br><span class="line">       nums[i]=nums[j];</span><br><span class="line">       nums[j]=temp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h3><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + (end -start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//后半部分有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[end])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[end])&#123;</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span>(nums[mid] &gt; target &amp;&amp; target &gt;= nums[start])&#123;</span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="合并K个排序数组"><a href="#合并K个排序数组" class="headerlink" title="合并K个排序数组"></a>合并K个排序数组</h3><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a.val - b.val);</span><br><span class="line">            <span class="keyword">for</span> (ListNode head : lists)</span><br><span class="line">                <span class="keyword">if</span> (head != <span class="literal">null</span>)</span><br><span class="line">                    pq.offer(head);</span><br><span class="line"></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(); <span class="comment">// 哨兵节点，作为合并后链表头节点的前一个节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">            <span class="keyword">while</span> (!pq.isEmpty()) &#123; <span class="comment">// 循环直到堆为空</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll(); <span class="comment">// 剩余节点中的最小节点</span></span><br><span class="line">                <span class="keyword">if</span> (node.next != <span class="literal">null</span>) <span class="comment">// 下一个节点不为空</span></span><br><span class="line">                    pq.offer(node.next); <span class="comment">// 下一个节点有可能是最小节点，入堆</span></span><br><span class="line">                cur.next = node; <span class="comment">// 合并到新链表中</span></span><br><span class="line">                cur = cur.next; <span class="comment">// 准备合并下一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dummy.next; <span class="comment">// 哨兵节点的下一个节点就是新链表的头节点</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="反转链表-1"><a href="#反转链表-1" class="headerlink" title="反转链表||"></a>反转链表||</h3><p><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">      <span class="comment">// 设置 dummyNode 是这一类问题的一般做法</span></span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">      dummyNode.next = head;</span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">          pre = pre.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">      ListNode next;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">          next = cur.next;</span><br><span class="line">          cur.next = next.next;</span><br><span class="line">          next.next = pre.next;</span><br><span class="line">          pre.next = next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">2001</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode[] queue = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[MAXN];</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> l, r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        l = r = <span class="number">0</span>;</span><br><span class="line">        queue[r++] = root;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r - l;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue[r++] = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue[r++] = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(list);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">   <span class="type">int</span> len=s.length();</span><br><span class="line">   <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">   <span class="type">boolean</span>[][] dp=<span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=len-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;len;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==s.charAt(j)&amp;&amp;(j-i&lt;=<span class="number">1</span>||dp[i+<span class="number">1</span>][j-<span class="number">1</span>]))&#123;</span><br><span class="line">            dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(j-i&gt;res)&#123;</span><br><span class="line">                res=j-i;</span><br><span class="line">                left=i;</span><br><span class="line">                right=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(left,right+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相似题目–<a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">最长回文子序列</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq2</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">return</span> f(s, <span class="number">0</span>, n - <span class="number">1</span>, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">char</span>[] s, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>[][] dp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">                <span class="keyword">return</span> s[l] == s[r] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[l][r] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> dp[l][r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans;</span><br><span class="line">        <span class="keyword">if</span> (s[l] == s[r]) &#123;</span><br><span class="line">                ans = <span class="number">2</span> + f(s, l + <span class="number">1</span>, r - <span class="number">1</span>, dp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = Math.max(f(s, l + <span class="number">1</span>, r, dp), f(s, l, r - <span class="number">1</span>, dp));</span><br><span class="line">        &#125;</span><br><span class="line">        dp[l][r] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的锯齿形层序遍历"><a href="#二叉树的锯齿形层序遍历" class="headerlink" title="二叉树的锯齿形层序遍历"></a>二叉树的锯齿形层序遍历</h3><p><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> MAXN=<span class="number">2001</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode[] queue=<span class="keyword">new</span> <span class="title class_">TreeNode</span>[MAXN];</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> l,r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root!=<span class="literal">null</span>) &#123;</span><br><span class="line">        l=r=<span class="number">0</span>;</span><br><span class="line">        queue[r++]=root;</span><br><span class="line">        <span class="type">boolean</span> reverse=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">            <span class="type">int</span> size=r-l;</span><br><span class="line">            ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> reverse?r-<span class="number">1</span>:l,k=<span class="number">0</span>;k &lt; size; i += reverse?-<span class="number">1</span>:<span class="number">1</span>, k++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue[i];</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue[r++] = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue[r++] = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(list);</span><br><span class="line">            reverse = !reverse;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h3><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(root==<span class="literal">null</span>||p==root||q==root)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">      &#125;</span><br><span class="line">      TreeNode left= lowestCommonAncestor(root.left,p,q);</span><br><span class="line">      TreeNode right=  lowestCommonAncestor(root.right,p,q);</span><br><span class="line">      <span class="keyword">if</span>(left!=<span class="literal">null</span>&amp;&amp;right!=<span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">      <span class="keyword">if</span>(left==<span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">      <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h3><p><a href="https://leetcode.cn/problems/maximum-subarray/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> ans=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            dp[i]=Math.max(dp[i-<span class="number">1</span>]+nums[i],nums[i]);</span><br><span class="line">            ans=Math.max(dp[i],ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h3><p><a href="https://leetcode.cn/problems/reorder-list/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">      <span class="comment">// 快慢指针找到链表中点</span></span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">      <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">          slow = slow.next;</span><br><span class="line">          fast = fast.next.next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// cur 指向右半部分链表</span></span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> slow.next;</span><br><span class="line">      slow.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 反转右半部分链表</span></span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> cur.next;</span><br><span class="line">          cur.next = pre;</span><br><span class="line">          pre = cur;</span><br><span class="line">          cur = t;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = head;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 此时 cur, pre 分别指向链表左右两半的第一个节点</span></span><br><span class="line">      <span class="comment">// 合并</span></span><br><span class="line">      <span class="keyword">while</span> (pre != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> pre.next;</span><br><span class="line">          pre.next = cur.next;</span><br><span class="line">          cur.next = pre;</span><br><span class="line">          cur = pre.next;</span><br><span class="line">          pre = t;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode h1, ListNode h2)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(h1==<span class="literal">null</span>||h2==<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> diff=<span class="number">0</span>;</span><br><span class="line">   ListNode a=h1;</span><br><span class="line">   ListNode b=h2;</span><br><span class="line">   <span class="keyword">while</span>(a.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">    a=a.next;</span><br><span class="line">    diff++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(b.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">    b=b.next;</span><br><span class="line">    diff--;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(diff&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">    a=h1;</span><br><span class="line">    b=h2;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    a=h2;</span><br><span class="line">    b=h1;</span><br><span class="line">   &#125;</span><br><span class="line">   diff=Math.abs(diff);</span><br><span class="line">   <span class="keyword">while</span>(diff--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    a=a.next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line">    a=a.next;</span><br><span class="line">    b=b.next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h3><p><a href="https://leetcode.cn/problems/spiral-matrix/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计矩阵从外向内的层数，如果矩阵非空，那么它的层数至少为1层</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> (Math.min(m, n)+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//从外部向内部遍历，逐层打印数据</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; count) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n-i; j++) &#123;</span><br><span class="line">            list.add(matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; m-i; j++) &#123;</span><br><span class="line">            list.add(matrix[j][(n-<span class="number">1</span>)-i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (n-<span class="number">1</span>)-(i+<span class="number">1</span>); j &gt;= i &amp;&amp; (m-<span class="number">1</span>-i） != i; j--) &#123;</span><br><span class="line">            list.add(matrix[(m-<span class="number">1</span>)-i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (m-<span class="number">1</span>)-(i+<span class="number">1</span>); j &gt;= i+<span class="number">1</span> &amp;&amp; (n-<span class="number">1</span>-i) != i; j--) &#123;</span><br><span class="line">            list.add(matrix[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h3><p><a href="https://leetcode.cn/problems/trapping-rain-water/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>,r=nums.length-<span class="number">2</span>,lmax=nums[<span class="number">0</span>],rmax=nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lmax&lt;=rmax)&#123;</span><br><span class="line">                ans+=Math.max(<span class="number">0</span>,lmax-nums[l]);</span><br><span class="line">                lmax=Math.max(lmax,nums[l++]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans+=Math.max(<span class="number">0</span>,rmax-nums[r]);</span><br><span class="line">                rmax=Math.max(rmax,nums[r--]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h3><p><a href="https://leetcode.cn/problems/number-of-islands/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">       <span class="type">int</span> n=grid.length;</span><br><span class="line">       <span class="type">int</span> m=grid[<span class="number">0</span>].length;</span><br><span class="line">       <span class="type">int</span> island=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">               island++;</span><br><span class="line">               dfs(grid,i,j,n,m);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> island;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid,<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> n,<span class="type">int</span> m)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=n||j&lt;<span class="number">0</span>||j&gt;=m||grid[i][j]!=<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       grid[i][j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">       dfs(grid,i+<span class="number">1</span>,j,n,m);</span><br><span class="line">       dfs(grid,i-<span class="number">1</span>,j,n,m);</span><br><span class="line">       dfs(grid,i,j+<span class="number">1</span>,n,m);</span><br><span class="line">       dfs(grid,i,j-<span class="number">1</span>,n,m);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p><a href="https://leetcode.cn/problems/linked-list-cycle/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">      ListNode slow=head;</span><br><span class="line">      ListNode fast=head;</span><br><span class="line">      <span class="keyword">while</span>(fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">       slow=slow.next;</span><br><span class="line">       fast=fast.next.next;</span><br><span class="line">       <span class="keyword">if</span>(slow==fast)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, min = prices[<span class="number">0</span>]; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="comment">// min : 0...i范围上的最小值</span></span><br><span class="line">        min = Math.min(min, prices[i]);</span><br><span class="line">        ans = Math.max(ans, prices[i] - min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p><a href="https://leetcode.cn/problems/permutations/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       f(nums,<span class="number">0</span>,ans);</span><br><span class="line">       <span class="keyword">return</span> ans; </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,List&lt;List&lt;Integer&gt;&gt; ans)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(i==nums.length)&#123;</span><br><span class="line">           List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">               list.add(nums[j]);</span><br><span class="line">           &#125;</span><br><span class="line">           ans.add(list);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123;</span><br><span class="line">               swap(nums,i,j);</span><br><span class="line">               f(nums, i+<span class="number">1</span>, ans);</span><br><span class="line">               swap(nums,i,j);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">       <span class="type">int</span> temp=nums[i];</span><br><span class="line">       nums[i]=nums[j];</span><br><span class="line">       nums[j]=temp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">                <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">                <span class="comment">// len表示ends数组目前的有效区长度</span></span><br><span class="line">                <span class="comment">// ends[0...len-1]是有效区，有效区内的数字一定严格升序</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, find; i &lt; n; i++) &#123;</span><br><span class="line">                        find = bs(ends, len, nums[i]);</span><br><span class="line">                        <span class="keyword">if</span> (find == -<span class="number">1</span>) &#123;</span><br><span class="line">                                ends[len++] = nums[i];</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                ends[find] = nums[i];</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// &quot;最长递增子序列&quot;使用如下二分搜索 :</span></span><br><span class="line">        <span class="comment">// ends[0...len-1]是严格升序的，找到&gt;=num的最左位置</span></span><br><span class="line">        <span class="comment">// 如果不存在返回-1</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bs</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> len, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = len - <span class="number">1</span>, m, ans = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                        m = l+(r-l) / <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> (ends[m] &gt;= num) &#123;</span><br><span class="line">                                ans = m;</span><br><span class="line">                                r = m - <span class="number">1</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                l = m + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p><a href="https://leetcode.cn/problems/two-sum/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h3><p><a href="https://leetcode.cn/problems/merge-sorted-array/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m + n - <span class="number">1</span>;</span><br><span class="line">       m--;</span><br><span class="line">       n--;</span><br><span class="line">       <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (m &lt; <span class="number">0</span> || nums2[n] &gt; nums1[m]) &#123;</span><br><span class="line">               nums1[i--] = nums2[n--];</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               nums1[i--] = nums1[m--];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="删除排序链表中的重复元素II"><a href="#删除排序链表中的重复元素II" class="headerlink" title="删除排序链表中的重复元素II"></a>删除排序链表中的重复元素II</h3><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> head;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">     <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">     <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (cur.next.val == cur.next.next.val) &#123;</span><br><span class="line">             <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">             <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == x) &#123;</span><br><span class="line">                 cur.next = cur.next.next;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             cur = cur.next;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> dummy.next;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h3><p><a href="https://leetcode.cn/problems/valid-parentheses/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       Deque&lt;Character&gt; stack=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">           <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">           <span class="keyword">if</span> (c==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">               stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">               stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">               stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!stack.isEmpty()&amp;&amp;c==stack.peek())&#123;</span><br><span class="line">                   stack.pop();</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a>字符串相加</h3><p><a href="https://leetcode.cn/problems/add-strings/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">       <span class="type">StringBuffer</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">       <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> x + y + add;</span><br><span class="line">           ans.append(result % <span class="number">10</span>);</span><br><span class="line">           add = result / <span class="number">10</span>;</span><br><span class="line">           i--;</span><br><span class="line">           j--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 计算完以后的答案需要翻转过来</span></span><br><span class="line">       ans.reverse();</span><br><span class="line">       <span class="keyword">return</span> ans.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h3><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">           <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">           <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">               fast = fast.next.next;</span><br><span class="line">               slow = slow.next;</span><br><span class="line">               <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           fast = head;</span><br><span class="line">           <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">               slow = slow.next;</span><br><span class="line">               fast = fast.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> fast;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><p><a href="https://leetcode.cn/problems/merge-intervals/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals)&#123;</span><br><span class="line">        Arrays.sort(intervals,(a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] interval:intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span>(res.size()==<span class="number">0</span>||interval[<span class="number">0</span>]&gt;res.get(res.size()-<span class="number">1</span>)[<span class="number">1</span>]) &#123;</span><br><span class="line">                res.add(interval);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res.get(res.size()-<span class="number">1</span>)[<span class="number">1</span>]=Math.max(res.get(res.size()-<span class="number">1</span>)[<span class="number">1</span>],interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>只要我还再刷题，持续更新</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈利用AOP实现记录日志功能</title>
      <link href="/2024/07/01/%E6%B5%85%E8%B0%88%E5%88%A9%E7%94%A8AOP%E5%AE%9E%E7%8E%B0%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD/"/>
      <url>/2024/07/01/%E6%B5%85%E8%B0%88%E5%88%A9%E7%94%A8AOP%E5%AE%9E%E7%8E%B0%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="1-记录日志"><a href="#1-记录日志" class="headerlink" title="1 记录日志"></a>1 记录日志</h1><p>记录日志：记录业务人员的操作日志【删除数据、修改数据、新增操作…】</p><h2 id="1-1-记录日志的意义"><a href="#1-1-记录日志的意义" class="headerlink" title="1.1 记录日志的意义"></a>1.1 记录日志的意义</h2><p>后台管理系统记录操作日志的意义非常重要，主要体现在以下几个方面：</p><p>1、安全性：操作日志可以记录管理员操作行为，以此来监控和防止管理员滥用权限或进行其他不当操作。如果后台管理系统没有记录操作日志，那么一旦出现不当操作，就无法对其进行追踪和定位，造成不可估量的安全风险。</p><p>2、追溯性：操作日志可以帮助管理员及时发现问题，并可以通过日志进行快速定位和处理。例如某个用户投诉自己的订单异常，管理员可以直接通过查询该订单的操作日志，找到问题所在并进行修改或解决。</p><p>因此，后台管理系统记录操作日志，对于维护系统的安全稳定性、保障客户数据的完整性和隐私性、提高系统及时响应和处理能力等方面具有重要意义，是保障企业正常运营和客户满意度的重要手段。</p><h2 id="1-2-日志数据表结构"><a href="#1-2-日志数据表结构" class="headerlink" title="1.2 日志数据表结构"></a>1.2 日志数据表结构</h2><p>记录操作日志的表结构如下所示：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_oper_log` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;日志主键&#x27;</span>,</span><br><span class="line">  `title` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;模块标题&#x27;</span>,</span><br><span class="line">  `business_type` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;业务类型（0其它 1新增 2修改 3删除）&#x27;</span>,</span><br><span class="line">  `<span class="keyword">method</span>` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;方法名称&#x27;</span>,</span><br><span class="line">  `request_method` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;请求方式&#x27;</span>,</span><br><span class="line">  `operator_type` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;操作类别（0其它 1后台用户 2手机端用户）&#x27;</span>,</span><br><span class="line">  `oper_name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;操作人员&#x27;</span>,</span><br><span class="line">  `dept_name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;部门名称&#x27;</span>,</span><br><span class="line">  `oper_url` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;请求URL&#x27;</span>,</span><br><span class="line">  `oper_ip` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;主机地址&#x27;</span>,</span><br><span class="line">  `oper_param` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;请求参数&#x27;</span>,</span><br><span class="line">  `json_result` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;返回参数&#x27;</span>,</span><br><span class="line">  `status` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;操作状态（0正常 1异常）&#x27;</span>,</span><br><span class="line">  `error_msg` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;错误消息&#x27;</span>,</span><br><span class="line">  `oper_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `is_deleted` tinyint <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;删除标记（0:不可用 1:可用）&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">67</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 COMMENT<span class="operator">=</span><span class="string">&#x27;操作日志记录&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="1-3-记录日志思想"><a href="#1-3-记录日志思想" class="headerlink" title="1.3 记录日志思想"></a>1.3 记录日志思想</h2><p><strong>原始做法的伪代码实现</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">( <span class="meta">@RequestBody</span> Brand brand)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建SysOperLog对象封装操作日志的相关参数</span></span><br><span class="line">    <span class="type">SysOperLog</span> <span class="variable">sysOperLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SysOperLog</span>() ;</span><br><span class="line">    sysOperLog.setTitle(<span class="string">&quot;品牌管理&quot;</span>)</span><br><span class="line">    sysOperLog.setBusinessType(<span class="string">&quot;新增品牌&quot;</span>)</span><br><span class="line">    sysOperLog.setMethod(<span class="string">&quot;com.atguigu.spzx.product.controller.BrandController.save()&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//执行业务操作</span></span><br><span class="line">    brandService.save(brand);</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> Result.build(<span class="literal">null</span> , ResultCodeEnum.SUCCESS) ; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将响应结果设置到SysOperLog对象中</span></span><br><span class="line">    sysOperLog.setJsonResult(JSON.toJsonString(result)) ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存日志数据</span></span><br><span class="line">    sysOperLogService.save(sysOperLog) ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;updateById&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">updateById</span><span class="params">( <span class="meta">@RequestBody</span> Brand brand)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建SysOperLog对象封装操作日志的相关参数</span></span><br><span class="line">    <span class="type">SysOperLog</span> <span class="variable">sysOperLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SysOperLog</span>() ;</span><br><span class="line">    sysOperLog.setTitle(<span class="string">&quot;品牌管理&quot;</span>)</span><br><span class="line">    sysOperLog.setBusinessType(<span class="string">&quot;修改品牌&quot;</span>)</span><br><span class="line">    sysOperLog.setMethod(<span class="string">&quot;com.atguigu.spzx.product.controller.BrandController.updateById()&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//执行业务操作</span></span><br><span class="line">    brandService.updateById(brand);</span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> Result.build(<span class="literal">null</span> , ResultCodeEnum.SUCCESS) ; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将响应结果设置到SysOperLog对象中</span></span><br><span class="line">    sysOperLog.setJsonResult(JSON.toJsonString(result)) ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存日志数据</span></span><br><span class="line">    sysOperLogService.save(sysOperLog) ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方式存在的弊端：</p><p>1、需要更改每一个业务接口，不符合开闭原则(对修改关闭对扩展开放)</p><p>2、在每一个业务接口中都需要添加记录日志的代码，影响开发效率</p><p>3、业务接口中添加记录日志的代码非常类似，每一个业务接口中都编写一次代码复用性较差</p><p><strong>AOP记录日志</strong></p><p>AOP记录日志的主要优点包括：</p><p>1、低侵入性：AOP记录日志不需要修改原有的业务逻辑代码，只需要新增一个切面即可。</p><p>2、统一管理：通过AOP记录日志可以将各个模块中需要记录日志的部分进行统一管理，降低了代码重复度，提高了代码可维护性和可扩展性。</p><p>3、提升效率：通过引入AOP记录日志，可以避免手动编写日志记录代码，减少了开发人员的工作量，提升了开发效率。</p><p>4、安全性：通过AOP记录日志，可以收集系统的操作日志，帮助管理员及时发现问题并进行调整，从而提高系统的安全性。</p><p><strong>AOP记录日志的整体思想</strong>：</p><p>1、基于自定义注解来确定切入点【优势：可以通过自定义注解携带一些变化的参数，比如模块名称】</p><p>2、基于环绕通知来完成日志记录</p><h2 id="1-4-切面类环境搭建"><a href="#1-4-切面类环境搭建" class="headerlink" title="1.4 切面类环境搭建"></a>1.4 切面类环境搭建</h2><h3 id="1-4-1-日志模块创建"><a href="#1-4-1-日志模块创建" class="headerlink" title="1.4.1 日志模块创建"></a>1.4.1 日志模块创建</h3><p>具体步骤：</p><p>1、在common模块下创建一个独立的记录日志的模块【common-log】</p><p>2、在该模块下加入如下的依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-2-自定义Log注解"><a href="#1-4-2-自定义Log注解" class="headerlink" title="1.4.2 自定义Log注解"></a>1.4.2 自定义Log注解</h3><p>自定义Log注解，如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Log &#123;                <span class="comment">// 自定义操作日志记录注解</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">title</span><span class="params">()</span> ;                                                                <span class="comment">// 模块名称</span></span><br><span class="line">    <span class="keyword">public</span> OperatorType <span class="title function_">operatorType</span><span class="params">()</span> <span class="keyword">default</span> OperatorType.MANAGE;        <span class="comment">// 操作人类别</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">businessType</span><span class="params">()</span> ;     <span class="comment">// 业务类型（0其它 1新增 2修改 3删除）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSaveRequestData</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;   <span class="comment">// 是否保存请求的参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSaveResponseData</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;  <span class="comment">// 是否保存响应的参数</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-3-OperatorType"><a href="#1-4-3-OperatorType" class="headerlink" title="1.4.3 OperatorType"></a>1.4.3 OperatorType</h3><p>操作人枚举类定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OperatorType</span> &#123;                <span class="comment">// 操作人类别</span></span><br><span class="line">    OTHER,                <span class="comment">// 其他</span></span><br><span class="line">    MANAGE,                <span class="comment">// 后台用户</span></span><br><span class="line">    MOBILE                <span class="comment">// 手机端用户</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-4-LogAspect"><a href="#1-4-4-LogAspect" class="headerlink" title="1.4.4 LogAspect"></a>1.4.4 LogAspect</h3><p>定义一个切面类，并且在该切面类中提供一个环绕通知方法，代码如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;            <span class="comment">// 环绕通知切面类定义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(value = &quot;@annotation(sysLog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doAroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint , Log sysLog)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> sysLog.title();</span><br><span class="line">        log.info(<span class="string">&quot;LogAspect...doAroundAdvice方法执行了&quot;</span>+title);</span><br><span class="line">        System.out.println(<span class="string">&quot;LogAspect...doAroundAdvice方法执行了&quot;</span>+title);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            proceed = joinPoint.proceed();              <span class="comment">// 执行业务方法</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;                         <span class="comment">// 代码执行进入到catch中，业务方法执行产生异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proceed ;                                <span class="comment">// 返回执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-5-EnableLogAspect"><a href="#1-4-5-EnableLogAspect" class="headerlink" title="1.4.5 EnableLogAspect"></a>1.4.5 EnableLogAspect</h3><p>想让LogAspect这个切面类在其他的业务服务中进行使用，那么就需要该切面类纳入到Spring容器中。Spring Boot默认会扫描和启动类所在包相同包中的bean以及子包中的bean。而LogAspect切面类不满足扫描条件，因此无法直接在业务服务中进行使用。那么此时可以通过自定义注解进行实现，</p><p>代码如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(value = LogAspect.class)</span>            <span class="comment">// 通过Import注解导入日志切面类到Spring容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableLogAspect &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在ManagerApplication服务的启动类上添加**@EnableLogAspect**注解</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableLogAspect</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(value = &#123;UserAuthProperties.class, MinioProperties.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManagerApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ManagerApplication.class , args) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-保存日志数据"><a href="#1-5-保存日志数据" class="headerlink" title="1.5 保存日志数据"></a>1.5 保存日志数据</h2><p>更改LogAspect切面类代码完成日志数据数据的保存。</p><h3 id="1-5-1-SysOperLog"><a href="#1-5-1-SysOperLog" class="headerlink" title="1.5.1 SysOperLog"></a>1.5.1 SysOperLog</h3><p>定义一个与日志数据库表相对应的实体类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SysOperLog</span> <span class="keyword">extends</span> <span class="title class_">BaseEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String title;                                        <span class="comment">// 模块标题</span></span><br><span class="line">        <span class="keyword">private</span> String method;                                        <span class="comment">// 方法名称</span></span><br><span class="line">        <span class="keyword">private</span> String requestMethod;                        <span class="comment">// 请求方式</span></span><br><span class="line">        <span class="keyword">private</span> String operatorType;                        <span class="comment">// 操作类别（0其它 1后台用户 2手机端用户）</span></span><br><span class="line">    <span class="keyword">private</span> Integer businessType ;                        <span class="comment">// 业务类型（0其它 1新增 2修改 3删除）</span></span><br><span class="line">        <span class="keyword">private</span> String operName;                                <span class="comment">// 操作人员</span></span><br><span class="line">        <span class="keyword">private</span> String operUrl;                                        <span class="comment">// 请求URL</span></span><br><span class="line">        <span class="keyword">private</span> String operIp;                                        <span class="comment">// 主机地址</span></span><br><span class="line">        <span class="keyword">private</span> String operParam;                                <span class="comment">// 请求参数</span></span><br><span class="line">        <span class="keyword">private</span> String jsonResult;                                <span class="comment">// 返回参数</span></span><br><span class="line">        <span class="keyword">private</span> Integer status;                                        <span class="comment">// 操作状态（0正常 1异常）</span></span><br><span class="line">        <span class="keyword">private</span> String errorMsg;                                <span class="comment">// 错误消息</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-2-LogAspect"><a href="#1-5-2-LogAspect" class="headerlink" title="1.5.2 LogAspect"></a>1.5.2 LogAspect</h3><ul><li>common-log添加工具类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作执行之后调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">afterHandlLog</span><span class="params">(Log sysLog, Object proceed,</span></span><br><span class="line"><span class="params">                                     SysOperLog sysOperLog, <span class="type">int</span> status ,</span></span><br><span class="line"><span class="params">                                     String errorMsg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sysLog.isSaveResponseData()) &#123;</span><br><span class="line">            sysOperLog.setJsonResult(JSON.toJSONString(proceed));</span><br><span class="line">        &#125;</span><br><span class="line">        sysOperLog.setStatus(status);</span><br><span class="line">        sysOperLog.setErrorMsg(errorMsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作执行之前调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">beforeHandleLog</span><span class="params">(Log sysLog,</span></span><br><span class="line"><span class="params">                                       ProceedingJoinPoint joinPoint,</span></span><br><span class="line"><span class="params">                                       SysOperLog sysOperLog)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置操作模块名称</span></span><br><span class="line">        sysOperLog.setTitle(sysLog.title());</span><br><span class="line">        sysOperLog.setOperatorType(sysLog.operatorType().name());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取目标方法信息</span></span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">methodSignature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature() ;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> methodSignature.getMethod();</span><br><span class="line">        sysOperLog.setMethod(method.getDeclaringClass().getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求相关参数</span></span><br><span class="line">        <span class="type">ServletRequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> (ServletRequestAttributes)</span><br><span class="line">                RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> requestAttributes.getRequest();</span><br><span class="line">        sysOperLog.setRequestMethod(request.getMethod());</span><br><span class="line">        sysOperLog.setOperUrl(request.getRequestURI());</span><br><span class="line">        sysOperLog.setOperIp(request.getRemoteAddr());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置请求参数</span></span><br><span class="line">        <span class="keyword">if</span>(sysLog.isSaveRequestData()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">requestMethod</span> <span class="operator">=</span> sysOperLog.getRequestMethod();</span><br><span class="line">            <span class="keyword">if</span> (HttpMethod.PUT.name().equals(requestMethod) || HttpMethod.POST.name().equals(requestMethod)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">params</span> <span class="operator">=</span> Arrays.toString(joinPoint.getArgs());</span><br><span class="line">                sysOperLog.setOperParam(params);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sysOperLog.setOperName(AuthContextUtil.get().getUserName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>日志切面类代码修改，如下所示：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;            <span class="comment">// 环绕通知切面类定义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncOperLogService asyncOperLogService ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(value = &quot;@annotation(sysLog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doAroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint , Log sysLog)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建前置参数</span></span><br><span class="line">        <span class="type">SysOperLog</span> <span class="variable">sysOperLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SysOperLog</span>() ;</span><br><span class="line"></span><br><span class="line">        LogUtil.beforeHandleLog(sysLog , joinPoint , sysOperLog) ;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            proceed = joinPoint.proceed();</span><br><span class="line">            <span class="comment">// 执行业务方法</span></span><br><span class="line">            LogUtil.afterHandlLog(sysLog , proceed , sysOperLog , <span class="number">0</span> , <span class="literal">null</span>) ;</span><br><span class="line">            <span class="comment">// 构建响应结果参数</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;                                 <span class="comment">// 代码执行进入到catch中，</span></span><br><span class="line">            <span class="comment">// 业务方法执行产生异常</span></span><br><span class="line">            e.printStackTrace();                                <span class="comment">// 打印异常信息</span></span><br><span class="line">            LogUtil.afterHandlLog(sysLog , proceed , sysOperLog , <span class="number">1</span> , e.getMessage()) ;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="comment">// 保存日志数据</span></span><br><span class="line">         asyncOperLogService.saveSysOperLog(sysOperLog);</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回执行结果</span></span><br><span class="line">        <span class="keyword">return</span> proceed ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-3-AsyncOperLogService"><a href="#1-5-3-AsyncOperLogService" class="headerlink" title="1.5.3 AsyncOperLogService"></a>1.5.3 AsyncOperLogService</h3><p>在common-log模块中定义保存日志数据的service接口，然后在具体的业务服务中给出实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AsyncOperLogService</span> &#123;                        <span class="comment">// 保存日志数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">saveSysOperLog</span><span class="params">(SysOperLog sysOperLog)</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncOperLogServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AsyncOperLogService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SysOperLogMapper sysOperLogMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>      <span class="comment">// 异步执行保存日志操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveSysOperLog</span><span class="params">(SysOperLog sysOperLog)</span> &#123;</span><br><span class="line">        sysOperLogMapper.insert(sysOperLog);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：要想通过异步线程执行saveSysOperLog方法，那么此时就需要在启动类上添加**@EnableAsync**注解。</p><h3 id="1-5-4-SysOperLogMapper"><a href="#1-5-4-SysOperLogMapper" class="headerlink" title="1.5.4 SysOperLogMapper"></a>1.5.4 SysOperLogMapper</h3><p>SysOperLogMapper持久层接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SysOperLogMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(SysOperLog sysOperLog)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-5-SysOperLogMapper-xml"><a href="#1-5-5-SysOperLogMapper-xml" class="headerlink" title="1.5.5 SysOperLogMapper.xml"></a>1.5.5 SysOperLogMapper.xml</h3><ul><li>在SysOperLogMapper.xml映射文件中添加如下的SQL语句：</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.atguigu.spzx.mapper.SysOperLogMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> &gt;</span></span><br><span class="line">        insert into sys_oper_log (</span><br><span class="line">            id,</span><br><span class="line">            title,</span><br><span class="line">            method,</span><br><span class="line">            request_method,</span><br><span class="line">            operator_type,</span><br><span class="line">            oper_name,</span><br><span class="line">            oper_url,</span><br><span class="line">            oper_ip,</span><br><span class="line">            oper_param,</span><br><span class="line">            json_result,</span><br><span class="line">            status,</span><br><span class="line">            error_msg</span><br><span class="line">        ) values (</span><br><span class="line">                     #&#123;id&#125;,</span><br><span class="line">                     #&#123;title&#125;,</span><br><span class="line">                     #&#123;method&#125;,</span><br><span class="line">                     #&#123;requestMethod&#125;,</span><br><span class="line">                     #&#123;operatorType&#125;,</span><br><span class="line">                     #&#123;operName&#125;,</span><br><span class="line">                     #&#123;operUrl&#125;,</span><br><span class="line">                     #&#123;operIp&#125;,</span><br><span class="line">                     #&#123;operParam&#125;,</span><br><span class="line">                     #&#123;jsonResult&#125;,</span><br><span class="line">                     #&#123;status&#125;,</span><br><span class="line">                     #&#123;errorMsg&#125;</span><br><span class="line">                 )</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-5-6-测试"><a href="#1-5-6-测试" class="headerlink" title="1.5.6 测试"></a>1.5.6 测试</h3><ul><li>在需要添加操作日志的接口方法上添加**@Log**注解进行测试。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Log(title = &quot;品牌列表&quot;,businessType = 0,operatorType = OperatorType.MANAGE)</span></span><br><span class="line"><span class="comment">//品牌列表（分页）</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;page&#125;/&#123;limit&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">list</span><span class="params">(<span class="meta">@PathVariable</span> Integer page,</span></span><br><span class="line"><span class="params">                   <span class="meta">@PathVariable</span> Integer limit)</span> &#123;</span><br><span class="line">    PageInfo&lt;Brand&gt; pageInfo = brandService.list(page,limit);</span><br><span class="line">    <span class="keyword">return</span> Result.build(pageInfo,ResultCodeEnum.SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-6-事务失效"><a href="#1-6-事务失效" class="headerlink" title="1.6 事务失效"></a>1.6 事务失效</h2><p>当我们自定义了切面类以后，如果不注意异常的处理，那么此时就会出现事务失效的情况。</p><h3 id="1-6-1-事务失效演示"><a href="#1-6-1-事务失效演示" class="headerlink" title="1.6.1 事务失效演示"></a>1.6.1 事务失效演示</h3><p>以给角色分配菜单的代码为例，演示事务失效的问题，代码如下所示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Log(title = &quot;角色菜单模块&quot; , businessType = 2 )</span>                </span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAssign</span><span class="params">(AssginMenuDto assginMenuDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据角色的id删除其所对应的菜单数据</span></span><br><span class="line">    sysRoleMenuMapper.deleteByRoleId(assginMenuDto.getRoleId());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span> ;                <span class="comment">// 手动抛出异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取菜单的id</span></span><br><span class="line">    List&lt;Map&lt;String, Number&gt;&gt; menuInfo = assginMenuDto.getMenuIdList();</span><br><span class="line">    <span class="keyword">if</span>(menuInfo != <span class="literal">null</span> &amp;&amp; menuInfo.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sysRoleMenuMapper.doAssign(assginMenuDto) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：不加@Log注解事务可以进行回滚，但是加上该注解以后事务就会失效。</p><h3 id="1-6-2-问题分析"><a href="#1-6-2-问题分析" class="headerlink" title="1.6.2 问题分析"></a>1.6.2 问题分析</h3><p>Spring的事务控制是通过aop进行实现的，在框架底层会存在一个事务切面类，当业务方法产生异常以后，事务切面类感知到异常以后事务进行回滚。</p><p>当系统中存在多个切面类的时候，Spring框架会按照**@Order<strong>注解的值对切面进行排序，@Order的值越小优先级越高，@Order的值越大优先级越低。优先级越高的切面类越优先执行，当我们没有给切面类指定排序值的时候，我们自定义的切面类的优先级和aop切面类的优先级相同，那么此时</strong>事务切面类的优先级要高于自定义切面类**，那么切面类的执行顺序如下所示：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NWMzN2Y2OGZkZmI3ZmVmNzdmNTI1MDA3MDE3MmFjNWVfQlJ5RVRIZ1hRNlpITmtVQzlUcVRnQmhVcXloMEpvVGhfVG9rZW46RURobmJsVElvb25DSWh4clowY2NQbHZZbnFjXzE3MTk4MTIwMDM6MTcxOTgxNTYwM19WNA" alt="img"></p><p>当在自定义切面类中对异常进行了捕获，没有将异常进行抛出，那么此时事务切面类是感知不到异常的存在，因此事务失效。</p><h3 id="1-6-3-问题解决"><a href="#1-6-3-问题解决" class="headerlink" title="1.6.3 问题解决"></a>1.6.3 问题解决</h3><p>解决方案一：使用@Order注解提高自定义切面类的优先级</p><p>解决方案二：在自定义切面类的catch中进行异常的抛出</p><p><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022057111.png" alt="551201a3-9a70-4d83-8e24-490627ab2dbc"></p>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux知识点</title>
      <link href="/2024/07/01/Linux%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2024/07/01/Linux%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>Linux对于程序员来说是至关重要的一个操作系统，在此记录一下，以后多回顾</p><p>这几篇老文章都是我之前用飞书云文档写的，因转换格式问题，本文之前已写完的文档图片太多了，不想一一转化了，大家可以访问我的飞书云文档来查看这些图片–<a href="https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e,%E4%B8%8D%E8%BF%87%E5%90%8E%E7%BB%AD%E8%A1%A5%E5%85%85%E7%9A%84%E9%83%BD%E4%BC%9A%E6%9C%89%E5%9B%BE%E7%89%87">https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e,不过后续补充的都会有图片</a></p><h1 id="Linux知识点"><a href="#Linux知识点" class="headerlink" title="Linux知识点"></a>Linux知识点</h1><h2 id="VM的安装"><a href="#VM的安装" class="headerlink" title="VM的安装"></a>VM的安装</h2><p>安装完成检查网络适配器是否正常配置，通过快捷键:win+r输入ncpa.cpl回车即可打开</p><h2 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h2><p>Linux的目录结构是一个树型结构<br>Windows系统可以拥有多个盘符，如C盘、D盘、E盘<br>Linux没有盘符这个概念，只有一个根目录&#x2F;，所有文件都在它下面</p><h2 id="Linux的路径描述方式"><a href="#Linux的路径描述方式" class="headerlink" title="Linux的路径描述方式"></a>Linux的路径描述方式</h2><p>在Linux系统中，路径之间的层级关系，使用：&#x2F;来表示<br>在Windows:系统中，路径之间的层级关系，使用：\来表示</p><h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><p>无论是什么命令，用于什么用途，在Liux中，命令有其通用的格式：<br>command [-options] [parameter]<br>command:     命令本身<br>-options:     [可选 非必填]命令的一些选项，可以通过选项控制命令的行为细节<br>parameter:   [可选，非必填]命令的参数，多数用于命令的指向目标等</p><h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><p>ls命令的作用是列出目录下的内容，语法细节如下：<br>ls [-a-1-h] [Linux路径]<br>-a-l-h是可选的选项<br>Linux路径是此命令可选的参数<br>当不使用选项和参数，直接使用S命令本体，表示：以平铺形式，列出当前工作目录下的内容</p><h4 id="HOME目录"><a href="#HOME目录" class="headerlink" title="HOME目录"></a>HOME目录</h4><p>每个Linux操作用户在Linux系统的个人账户目录，路径在：&#x2F;home&#x2F;用户名</p><h4 id="ls命令的叁数和选项"><a href="#ls命令的叁数和选项" class="headerlink" title="ls命令的叁数和选项"></a>ls命令的叁数和选项</h4><p>如下语法，S命令是可以使用选项的<br>ls [-a-1-h] [Linux路径]<br>-a选项，表示：all的意思，即列出全部文件（包含隐藏的文件&#x2F;文件夹)      以.开头的，表示是Linux系统的隐藏文件&#x2F;文件夹（只要以.开头,就能自动隐藏).只有通过-a选项，才能看到这些隐藏的文件&#x2F;文件夹</p><p>-l  选项，表示：以列表（竖向排列）的形式展示内容，并展示更多信息</p><p>语法中的选项是可以组合使用的，比如学习的-和-l可以组合应用。</p><p>ls -l -a<br>ls -la<br>ls -al</p><p>-h表示以易于阅读的形式，列出文件大小，如K、M、G<br>-h选项必须要搭配-l一起使用</p><h3 id="cd切换工作目录"><a href="#cd切换工作目录" class="headerlink" title="cd切换工作目录"></a>cd切换工作目录</h3><p>我们可以通过cd命令，更改当前所在的工作目录。<br>cd命令来自英文：Change Directory<br>语法：cd [Linux路径]<br>Cd命令无需选项，只有参数，表示要切换到哪个目录下<br>Cd命令直接执行，不写参数，表示回到用户的HOME目录</p><h3 id="pwd查看当前工作目录"><a href="#pwd查看当前工作目录" class="headerlink" title="pwd查看当前工作目录"></a>pwd查看当前工作目录</h3><p>通过ls来验证当前的工作目录，其实是不恰当的。<br>我们可以通过pwd命令，来查看当前所在的工作目录。<br>pwd命令来自：Print Work Directory<br>语法：pwd<br>·pWd命令，无选项，无参数，直接输入pWd即可</p><h3 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h3><p>绝对路径：以根目录为起点描述路径的一种写法，路径描述以&#x2F;开头<br>相对路径：以当前目录为起点，描述路径的一种写法，路径描述无需以&#x2F;开头</p><p>cd &#x2F;home&#x2F;itheima&#x2F;Desktop       绝对路径写法</p><p>cd Desktop          相对路径写法</p><h3 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符"></a>特殊路径符</h3><p>特殊路径符：<br>  . 表示当前目暴，比如cd&#x2F;Desktop表示切换到当前目录下的Desktop目录内，和cd Desktop效果一致<br>  ..  表示上一级目录，比如：cd.…即可切换到上一级目录，cd.&#x2F;.切换到上二级的目录<br>  ~  表示HOME目录，比如：cd<del>即可切换到HOME目录或cd</del>&#x2F;Desktop,切换到HOME内的Desktop目录</p><h3 id="mkdir创建目录"><a href="#mkdir创建目录" class="headerlink" title="mkdir创建目录"></a>mkdir创建目录</h3><p>mkdir来自英文：Make Directory<br>语法：mkdir [-p] Linux路径<br>,参数必填，表示Liux路径，即要创建的文件夹的路径，相对路径或绝对路径均可<br>-p选项可选，表示自动创建不存在的父目录，适用于创建连续多层级的目录</p><p>如果想要一次性创建多个层级的目录会报错，因为上级目录itcast和good并不存在，所以无法创建666目录<br>可以通过-p选项，将一整个链条都创建完成。</p><p>注意：创建文件夹需要修改权限，请确保操作均在HOME目录内，不要在HOME外操作<br>涉及到权限问题，HOME外无法成功<br>后续我们会讲解权限管控的知识</p><h3 id="清屏"><a href="#清屏" class="headerlink" title="清屏"></a>清屏</h3><p>ctrl+L 或者 输入clear</p><h3 id="touch创建文件"><a href="#touch创建文件" class="headerlink" title="touch创建文件"></a>touch创建文件</h3><p>可以通过touch命令创建文件<br>语法：<br>touch  Linux路径<br>touch命令无选项，参数必填，表示要创建的文件路径，相对、绝对、特殊路径符均可以使用</p><h3 id="cat命令查看文件内容"><a href="#cat命令查看文件内容" class="headerlink" title="cat命令查看文件内容"></a>cat命令查看文件内容</h3><p>有了文件后，我们可以通过cat命令查看文件的内容。<br>不过，现在我们还未学习编辑器，无法向文件内编辑内容，所以，暂时，我们先通过图形化<br>在图形化中，手动向文件内添加内容，以测试cat命令</p><h3 id="more命令查看文件内容"><a href="#more命令查看文件内容" class="headerlink" title="more命令查看文件内容"></a>more命令查看文件内容</h3><p>more命令同样可以查看文件内容，同cat不同的是：<br>cat是直接将内容全部显示出来<br>more支持翻页，如果文件内容过多，可以一页页的展示<br>语法：more Linux路径<br>同样没有选项，只有必填参数，参数表示：被查看的文件路径，相对、绝对、特殊路径符都可以使用</p><p>在查看的过程中，通过空格翻页<br>通过q退出查看</p><h3 id="cp命令复制文件夹"><a href="#cp命令复制文件夹" class="headerlink" title="cp命令复制文件夹"></a>cp命令复制文件夹</h3><p>cp命令可以用于复制文件文件夹，cp命令来自英文单词：copy<br>语法：cp [-r] 参数1 参数2<br>·-r选项，可选，用于复制文件夹使用，表示递归<br>·参数1，Linux路径，表示被复制的文件或文件夹<br>·参数2，Linux路径，表示要复制去的地方</p><h3 id="mv-移动文件或者文件夹"><a href="#mv-移动文件或者文件夹" class="headerlink" title="mv 移动文件或者文件夹"></a>mv 移动文件或者文件夹</h3><p>mv命令可以用于移动文件\文件夹，mv命令来自英文单词：move<br>语法：mv 参数1 参数2<br>参数1，Linux路径，表示被移动的文件或文件夹<br>参数2，Linux路径，表示要移动去的地方，如果目标不存在，则进行改名，确保目标存在</p><h3 id="rm命令可用于删除文件、文件夹"><a href="#rm命令可用于删除文件、文件夹" class="headerlink" title="rm命令可用于删除文件、文件夹"></a>rm命令可用于删除文件、文件夹</h3><p>rm命令来自英文单词：remove<br>语法：rm[-r-f] 参数1 参数2…参数N<br>·同cp命令一样，-选项用于删除文件夹<br>·-f表示force,强制删除（不会弹出提示确认信息)<br>       ·普通用户删除内容不会弹出提示，只有Oot管理员用户删除内容会有提示<br>       ·所以一般普通用户用不到-f选项<br>·参数1、参数2、、参数N表示要删除的文件或文件夹路径，按照空格隔开</p><p>r命令支持通配符<em>，用来做模糊匹配<br>·符号</em>表示通配符，即匹配任意内容（包含空），示例：<br>·test*,表示匹配任何以test开头的内容<br>·* test,表示匹配任何以test结尾的内容<br><em>test</em>,表示匹配任何包含test的内容</p><h3 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h3><p>我们在前面学习的Liu命令，其实它们的本体就是一个个的二进制可执行程序。<br>和Windows系统中的.exe文件，是一个意思。<br>我们可以通过whch命令，查看所使用的一系列命令的程序文件存放在哪里<br>语法：which要查找的命令</p><h3 id="find命令–按文件名查找文件"><a href="#find命令–按文件名查找文件" class="headerlink" title="find命令–按文件名查找文件"></a>find命令–按文件名查找文件</h3><p>find起始路径-name”被查找文件名”</p><p>为了确保后续演示，拥有最大的权限，可以在整个系统完成搜索<br>我们可以切换到oot用户以获得管理员权限<br>执行命令：<br>su -root<br>输入密码：123456（和你普通用户的密码一样)</p><p>​       <em>用来做模糊匹配<br>·符号</em>表示通配符，即匹配任意内容（包含空），示例：<br>·test*,表示匹配任何以test开头的内容<br>·* test,表示匹配任何以test结尾的内容<br><em>test</em>,表示匹配任何包含test的内容</p><h3 id="find命令-按文件大小查找文件"><a href="#find命令-按文件大小查找文件" class="headerlink" title="find命令-按文件大小查找文件"></a>find命令-按文件大小查找文件</h3><p>语法：find起始路径 -size +&#x2F;-n[kMG]<br>·+、-表示大于和小于<br>n表示大小数字<br>kMG表示大小单位，服小写字母)表示kb,M表示MB,G表示GB</p><h3 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h3><p>可以通过grep命令，从文件中通过关键字过滤文件行。<br>语法：grep[-n] 关键字 文件路径<br>选项-n,可选，表示在结果中显示匹配的行的行号。<br>参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用” ”将关键字包围起来<br>参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口</p><h3 id="WC命令做数量统计"><a href="#WC命令做数量统计" class="headerlink" title="WC命令做数量统计"></a>WC命令做数量统计</h3><p>可以通过WC命令统计文件的行数、单词数量等<br>语法：wc[-c -m -1 -w]文件路径<br>,选项，-c,统计bytes数量<br>·选项，-m,统计字符数量<br>·选项，-l,统计行数<br>选项，-W,统计单词数量<br>·参数，文件路径，被统计的文件，可作为内容输入端口</p><h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符  |"></a>管道符  |</h3><p>将管道符左边命令的结果，作为右边命令的输入</p><h3 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h3><p>可以使用echo命令在命令行内输出指定内容<br>语法：echo输出的内容<br>·无需选项，只有一个参数，表示要输出的内容，复杂内容可以用””包围                                                                               带有空格或等特殊符号，建议使用双引号包围</p><p>被&#96;包围的内容，会被作为命令执行。而非普通字符</p><h3 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h3><p>我们再来学习两个特殊符号，重定向符：&gt;和&gt;&gt;</p><p>,&gt;,将左侧命令的结果，覆盖写入到符号右侧指定的文件中</p><p>,&gt;&gt;,将左侧命令的结果，追加写入到符号右侧指定的文件中</p><h3 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h3><p>使用tail命令，可以查看文件尾部内容，跟踪文件的最新更改，语法如下：<br>tailf-f -num]  Linux路径<br>·参数，Linux路径，表示被跟踪的文件路径<br>·选项，-f,表示持续跟踪<br>选项，-num,表示，查看尾部多少行，不填默认10行</p><h2 id="vi-vim编辑器"><a href="#vi-vim编辑器" class="headerlink" title="vi \ vim编辑器"></a>vi \ vim编辑器</h2><p>vi \ vim是visual interfacel的简称，是Linux中最经典的文本编辑器<br>同图形化界面中的文本编辑器一样，ⅵ是命令行下对文本文件进行编辑的绝佳选择。<br>vim是vi的加强版本，兼容vi的所有指令，不仅能编辑文本，而且还具有shll程序编辑的功能，可以不同颜色的字<br>体来辨别语法的正确性，极大方便了程序的设计和编辑性。</p><h3 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h3><h4 id="1命令模式-Command-mode"><a href="#1命令模式-Command-mode" class="headerlink" title="1命令模式(Command mode)"></a>1命令模式(Command mode)</h4><p>命令模式下，所敲的按键编辑器都理解为命令，以命令驱动执行不同的功能       此模型下，不能自由进行文本编辑。</p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240302142238874.png" alt="image-20240302142238874"></p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240302142537876.png" alt="image-20240302142537876"></p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240302142638197.png" alt="image-20240302142638197"></p><h4 id="2输入模式-Insert-mode"><a href="#2输入模式-Insert-mode" class="headerlink" title="2输入模式(Insert mode)"></a>2输入模式(Insert mode)</h4><p>按 i 键进入，按esc退回到命令模式</p><p>也就是所谓的编辑模式、插入模式。<br>此模式下，可以对文件内容进行自由编辑。</p><h4 id="3底线命令模式-Last-line-mode"><a href="#3底线命令模式-Last-line-mode" class="headerlink" title="3底线命令模式(Last line mode)"></a>3底线命令模式(Last line mode)</h4><p>（要先退回到命令模式）按 : 进入 ，输入wq保存并退出</p><p>以：开始，通常用于文件的保存、退出。</p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240302144143925.png" alt="image-20240302144143925"></p><h2 id="root用户"><a href="#root用户" class="headerlink" title="root用户"></a>root用户</h2><p>在前面，我们接触过su命令切换到root账户。<br>Su命令就是用于账户切换的系统命令，其来源英文单词：Switch User<br>语法：su  [-] [用户名]<br>·-符号是可选的，表示是否在切换用户后加载环境变量（后续讲解），建议带上<br>参数：用户名，表示要切换的用户，用户名也可以省略，省略表示切换到root<br>·切换用户后，可以通过exit命令退回上一个用户，也可以使用快捷键：ctrl+d<br>使用普通用户，切换到其它用户需要输入密码，如切换到root用户<br>使用root用户切换到其它用户，无需密码，可以直接切换</p><h3 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h3><p>在我们得知root密码的时候，可以通过su命令切换oot得到最大权限<br>但是我们不建议长期使用oot用户，避免带来系统损坏。</p><p>我们可以使用udd命令，为普通的命令授权，临时以root身份执行。<br>语法：<br>sudo     其它命令<br>在其它命令之前，带上sudo,即可为这一条命令临时赋予root授权<br>但是并不是所有的用户，都有权利使用sudo,我们需要为普通用户配置sudo认证</p><p>为普通用户配置sudo认证</p><p>切换到root用户，执行visudo命令，会自动通过vi编辑器打开：&#x2F;etc&#x2F;sudoers<br>在文件的最后添加：</p><p>用户名         ALL&#x3D;(ALL)           NOPASSWD:ALL</p><p>其中最后的NOPASSWD:ALL表示使用sudo命令，无需输入密码</p><h2 id="用户、用户组"><a href="#用户、用户组" class="headerlink" title="用户、用户组"></a>用户、用户组</h2><p>Linux系统中可以：<br>配置多个用户<br>配置多个用户组<br>用户可以加入多个用户组中</p><p>Linux中关于权限的管控级别有2个级别，分别是：<br>针对用户的权限控制<br>针对用户组的权限控制<br>比如，针对某文件，可以控制用户的权限<br>也可以控制用户组的权限。<br>所以，我们需要学习在LiuX中进行用户、用户组管理的基础命令，为后面学习权限控制打下基础。</p><p>创建用户组<br>groupadd用户组名</p><p>删除用户组<br>groupdel用户组名</p><p>·创建用户<br>useradd[-g-d]用户名<br>·选项：-g指定用户的组，不指定，会创建同名组并自动加入，指定-g需要组已经存在，如已存在同名组，必须使用g<br>·选项：-d指定用户HOME路径，不指定，HOME目录默认在：&#x2F;home&#x2F;用户名</p><p>删除用户<br>userdel[-rl用户名<br>·选项：-r,删除用户的HOME目录，不使用-r,删除用户时，HOME目录保留<br>·查看用户所属组</p><p>id[用户名]<br>·参数：用户名，被查看的用户，如果不提供则查看自身</p><p>,修改用户所属组<br>usermod-aG用户组    用户名</p><p>getent 查看当前系统有哪些用户</p><h2 id="查看权限控制信息"><a href="#查看权限控制信息" class="headerlink" title="查看权限控制信息"></a>查看权限控制信息</h2><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240302153954274.png" alt="image-20240302153954274"></p><h2 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h2><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240302154434021.png" alt="image-20240302154434021"></p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240302154913315.png" alt="image-20240302154913315" style="zoom: 80%;" /><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240302161602269.png" alt="image-20240302161602269"></p><h1 id="Linux快捷键"><a href="#Linux快捷键" class="headerlink" title="Linux快捷键"></a>Linux快捷键</h1><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240302163132849.png" alt="image-20240302163132849"></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240302163819049.png" alt="image-20240302163819049"></p><h1 id="systemctl命令"><a href="#systemctl命令" class="headerlink" title="systemctl命令"></a>systemctl命令</h1><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303154900848.png" alt="image-20240303154900848"></p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303155600796.png" alt="image-20240303155600796"></p><h1 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h1><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303155716395.png" alt="image-20240303155716395"></p><h1 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h1><h2 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h2><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303160530689.png" alt="image-20240303160530689"></p><h2 id="修改时区"><a href="#修改时区" class="headerlink" title="修改时区"></a>修改时区</h2><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303161106180.png" alt="image-20240303161106180"></p><h2 id="自动校准"><a href="#自动校准" class="headerlink" title="自动校准"></a>自动校准</h2><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303161138631.png" alt="image-20240303161138631"></p><h1 id="Ip地址，主机名"><a href="#Ip地址，主机名" class="headerlink" title="Ip地址，主机名"></a>Ip地址，主机名</h1><p>ifconfig命令查看本机ip</p><p>特殊ip地址</p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303161529779.png" alt="image-20240303161529779"></p><p>主机名</p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303162132681.png" alt="image-20240303162132681"></p><p>域名解析</p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303162339022.png" alt="image-20240303162339022"></p><h1 id="虚拟机配置固定Ip地址"><a href="#虚拟机配置固定Ip地址" class="headerlink" title="虚拟机配置固定Ip地址"></a>虚拟机配置固定Ip地址</h1><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303163001723.png" alt="image-20240303163001723"></p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303163117793.png" alt="image-20240303163117793"></p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303163314978.png" alt="image-20240303163314978"></p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303163335898.png" alt="image-20240303163335898"></p><h1 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h1><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303163944242.png" alt="image-20240303163944242"></p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303164200085.png" alt="image-20240303164200085"></p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303164334183.png" alt="image-20240303164334183"></p><h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303165038289.png" alt="image-20240303165038289"></p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303165052002.png" alt="image-20240303165052002"></p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303165206531.png" alt="image-20240303165206531"></p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303165305320.png" alt="image-20240303165305320"></p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303170337169.png" alt="image-20240303170337169"></p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303170500618.png" alt="image-20240303170500618"></p><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303171258546.png" alt="image-20240303171258546"></p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303171725769.png" alt="image-20240303171725769"></p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303184412298.png" alt="image-20240303184412298"></p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303184748256.png" alt="image-20240303184748256"></p><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303185110855.png" alt="image-20240303185110855"></p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303185146660.png" alt="image-20240303185146660"></p><p>自行设置环境变量<img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303185400130.png" alt="image-20240303185400130"></p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303185821076.png" alt="image-20240303185821076"></p><h1 id="上传和下载"><a href="#上传和下载" class="headerlink" title="上传和下载"></a>上传和下载</h1><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303190415567.png" alt="image-20240303190415567"></p><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303190553437.png" alt="image-20240303190553437"></p><h1 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h1><p><img src="C:\Users\28168\AppData\Roaming\Typora\typora-user-images\image-20240303191535571.png" alt="image-20240303191535571"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机专业必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机专业必备 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>minio的使用</title>
      <link href="/2024/07/01/minio%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/07/01/minio%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Minio使用"><a href="#Minio使用" class="headerlink" title="Minio使用"></a>Minio使用</h2><h3 id="Minio介绍"><a href="#Minio介绍" class="headerlink" title="Minio介绍"></a>Minio介绍</h3><ul><li>目前可用于文件存储的网络服务选择也有不少，比如阿里云OSS、七牛云、腾讯云等等，可是收费都有点小贵。为了节约成本，很多公司使用MinIO做为文件服务器。</li></ul><p>这几篇老文章都是我之前用飞书云文档写的，因转换格式问题，本文之前已写完的文档图片太多了，不想一一转化了，大家可以访问我的飞书云文档来查看这些图片–<a href="https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e,%E4%B8%8D%E8%BF%87%E5%90%8E%E7%BB%AD%E8%A1%A5%E5%85%85%E7%9A%84%E9%83%BD%E4%BC%9A%E6%9C%89%E5%9B%BE%E7%89%87">https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e,不过后续补充的都会有图片</a></p><p>官网：<a href="https://www.minio.org.cn/">https://www.minio.org.cn/</a></p><ul><li>MinIO是一个开源的分布式对象存储服务器，支持S3协议并且可以在多节点上实现数据的高可用和容错。它采用Go语言开发，拥有轻量级、高性能、易部署等特点，并且可以自由选择底层存储介质。它基于Apache License 开源协议，兼容Amazon S3云存储接口。适合存储非结构化数据，如图片，音频，视频，日志等。</li><li>MinIO的主要特点包括：</li></ul><p>1、高性能：MinIO基于GO语言编写，具有高速、轻量级、高并发等性能特点，还支持多线程和缓存等机制进行优化，可以快速地处理大规模数据。</p><p>2、安装部署简单：MinIO只需要执行这几行命令便可轻松搞定，也大大降低了学习和维护成本。</p><p>3、操作简单，自带管理界面：MinIO在服务端安装后就自带了UI界面，可谓开箱即用。</p><p>4、性能优秀，读写速度快：MinIO号称是世界上速度最快的对象存储服务器，读对象的速度能达到183 GB&#x2F;s，写对象的速度能达到171 GB&#x2F;s。</p><p>5、支持云原生容器化部署：MinIO提供了与K8s、ETCD、Docker等容器化技术深度集成方案，可以说MinIO就是为云环境而生的。</p><p>6、提供多语言SDK的支持：MinIO提供了绝大部分主流开发语言的SDK以及文档，比如Java、Python、Golang、JS、.NET等等。</p><p>7、兼容亚马逊S3 API：亚马逊云的 S3 API（接口协议） 是在全球范围内达到共识的对象存储的协议，是全世界认可的对象存储标准。而MinIO是采用S3兼容协议的产品之一。</p><ul><li><strong>S3协议</strong>是Amazon Web Services (AWS) 提供的对象存储服务（Simple Storage Service）的API协议。它是一种 RESTful风格的Web服务接口，使用HTTP&#x2F;HTTPS协议进行通信，支持多种编程语言和操作系统，并实现了数据的可靠存储、高扩展性以及良好的可用性。</li></ul><h3 id="Minio安装"><a href="#Minio安装" class="headerlink" title="Minio安装"></a>Minio安装</h3><p>官网地址：<a href="https://www.minio.org.cn/docs/cn/minio/container/index.html">https://www.minio.org.cn/docs/cn/minio/container/index.html</a></p><h4 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h4><p>1、下载Minio安装文件</p><ul><li>地址：<a href="https://dl.min.io/server/minio/release/">https://dl.min.io/server/minio/release/</a></li></ul><p>2、进入到Monio所在目录，启动Minio</p><ul><li>启动命令： minio.exe server 数据文件目录</li></ul><p><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022059753.png" alt="output"></p><ul><li>访问控制台</li></ul><p><a href="http://127.0.0.1:57132/login">http://127.0.0.1:57132/login</a></p><p><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022059777.png" alt="output (1)"></p><h4 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h4><p>具体命令：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拉取镜像</span></span><br><span class="line">docker pull quay.io/minio/minio</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建数据存储目录</span></span><br><span class="line">mkdir -p ~/minio/data</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建minio</span></span><br><span class="line">docker run \</span><br><span class="line">   -p <span class="number">9001</span>:<span class="number">9000</span> \</span><br><span class="line">   -p <span class="number">9090</span>:<span class="number">9090</span> \</span><br><span class="line">   --name minio \</span><br><span class="line">   -v ~/minio/data:/data \</span><br><span class="line">   -e <span class="string">&quot;MINIO_ROOT_USER=admin&quot;</span> \</span><br><span class="line">   -e <span class="string">&quot;MINIO_ROOT_PASSWORD=admin123456&quot;</span> \</span><br><span class="line">   -d \</span><br><span class="line">   quay.io/minio/minio server /data --console-address <span class="string">&quot;:9090&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Minio入门"><a href="#Minio入门" class="headerlink" title="Minio入门"></a>Minio入门</h3><p>本章节会给大家介绍一下如何通过Java客户端操作Minio，可以参考官网地址。</p><p>官网地址：<a href="https://min.io/docs/minio/linux/developers/java/minio-java.html">https://min.io/docs/minio/linux/developers/java/minio-java.html</a></p><p>具体步骤：</p><p>1、加入如下依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- common-util模块中加入如下依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.minio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>minio<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、示例代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建一个Minio的客户端对象</span></span><br><span class="line">        <span class="type">MinioClient</span> <span class="variable">minioClient</span> <span class="operator">=</span> MinioClient.builder()</span><br><span class="line">                .endpoint(<span class="string">&quot;http://127.0.0.1:9000&quot;</span>)</span><br><span class="line">                .credentials(<span class="string">&quot;minioadmin&quot;</span>, <span class="string">&quot;minioadmin&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> minioClient.bucketExists(BucketExistsArgs.builder().bucket(<span class="string">&quot;spzx-bucket&quot;</span>).build());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不存在，那么此时就创建一个新的桶</span></span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">            minioClient.makeBucket(MakeBucketArgs.builder().bucket(<span class="string">&quot;spzx-bucket&quot;</span>).build());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果存在打印信息</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Bucket &#x27;spzx-bucket&#x27; already exists.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D://01.jpg&quot;</span>) ;</span><br><span class="line">        <span class="type">PutObjectArgs</span> <span class="variable">putObjectArgs</span> <span class="operator">=</span> PutObjectArgs.builder()</span><br><span class="line">                .bucket(<span class="string">&quot;spzx-bucket&quot;</span>)</span><br><span class="line">                .stream(fis, fis.available(), -<span class="number">1</span>)</span><br><span class="line">                .object(<span class="string">&quot;01.jpg&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        minioClient.putObject(putObjectArgs) ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建fileUrl</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileUrl</span> <span class="operator">=</span> <span class="string">&quot;http://127.0.0.1:9000/spzx-bucket/01.jpg&quot;</span> ;</span><br><span class="line">        System.out.println(fileUrl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：设置minio的中该桶的访问权限为public，如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022100585.png" alt="ca21db2e-e2ef-4c4a-872e-e7165fd4d5fe"></p><p><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022100577.png" alt="03bceb44-d9af-4fae-a00e-5b53cee9b54e"></p><h2 id="上传文件接口"><a href="#上传文件接口" class="headerlink" title="上传文件接口"></a>上传文件接口</h2><h3 id="FileUploadController"><a href="#FileUploadController" class="headerlink" title="FileUploadController"></a>FileUploadController</h3><p>上传文件的表现层代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/admin/system&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> FileUploadService fileUploadService ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/fileUpload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;String&gt; <span class="title function_">fileUploadService</span><span class="params">(<span class="meta">@RequestParam(value = &quot;file&quot;)</span> MultipartFile multipartFile)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">fileUrl</span> <span class="operator">=</span> fileUploadService.fileUpload(multipartFile) ;</span><br><span class="line">        <span class="keyword">return</span> Result.build(fileUrl , ResultCodeEnum.SUCCESS) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FileUploadService"><a href="#FileUploadService" class="headerlink" title="FileUploadService"></a>FileUploadService</h3><p>上传文件的业务层代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileUploadServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">FileUploadService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MinioProperties minioProperties ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fileUpload</span><span class="params">(MultipartFile multipartFile)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个Minio的客户端对象</span></span><br><span class="line">            <span class="type">MinioClient</span> <span class="variable">minioClient</span> <span class="operator">=</span> MinioClient.builder()</span><br><span class="line">                    .endpoint(minioProperties.getEndpointUrl())</span><br><span class="line">                    .credentials(minioProperties.getAccessKey(), minioProperties.getSecreKey())</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断桶是否存在</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> minioClient.bucketExists(BucketExistsArgs.builder().bucket(minioProperties.getBucketName()).build());</span><br><span class="line">            <span class="keyword">if</span> (!found) &#123;       <span class="comment">// 如果不存在，那么此时就创建一个新的桶</span></span><br><span class="line">                minioClient.makeBucket(MakeBucketArgs.builder().bucket(minioProperties.getBucketName()).build());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 如果存在打印信息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Bucket &#x27;spzx-bucket&#x27; already exists.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置存储对象名称</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">dateDir</span> <span class="operator">=</span> DateUtil.format(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&quot;yyyyMMdd&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="comment">//20230801/443e1e772bef482c95be28704bec58a901.jpg</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> dateDir+<span class="string">&quot;/&quot;</span>+uuid+multipartFile.getOriginalFilename();</span><br><span class="line">            System.out.println(fileName);</span><br><span class="line"></span><br><span class="line">            <span class="type">PutObjectArgs</span> <span class="variable">putObjectArgs</span> <span class="operator">=</span> PutObjectArgs.builder()</span><br><span class="line">                    .bucket(minioProperties.getBucketName())</span><br><span class="line">                    .stream(multipartFile.getInputStream(), multipartFile.getSize(), -<span class="number">1</span>)</span><br><span class="line">                    .object(fileName)</span><br><span class="line">                    .build();</span><br><span class="line">            minioClient.putObject(putObjectArgs) ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> minioProperties.getEndpointUrl() + <span class="string">&quot;/&quot;</span> + minioProperties.getBucketName() + <span class="string">&quot;/&quot;</span> + fileName ;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MinioProperties"><a href="#MinioProperties" class="headerlink" title="MinioProperties"></a>MinioProperties</h3><p>将构建MinioClient所对应的参数定义到配置文件中，然后通过该实体类封装该配置文件中的内容。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;spzx.minio&quot;)</span> <span class="comment">//读取节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinioProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String endpointUrl;</span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line">    <span class="keyword">private</span> String secreKey;</span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置文件内容"><a href="#配置文件内容" class="headerlink" title="配置文件内容"></a>配置文件内容</h3><p>在配置文件中添加Minio的相关配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义配置</span></span><br><span class="line"><span class="attr">spzx:</span></span><br><span class="line">  <span class="attr">minio:</span></span><br><span class="line">    <span class="attr">endpointUrl:</span> <span class="string">http://127.0.0.1:9000</span></span><br><span class="line">    <span class="attr">accessKey:</span> <span class="string">minioadmin</span></span><br><span class="line">    <span class="attr">secreKey:</span> <span class="string">minioadmin</span></span><br><span class="line">    <span class="attr">bucketName:</span> <span class="string">spzx-bucket</span></span><br></pre></td></tr></table></figure><h2 id="前端对接"><a href="#前端对接" class="headerlink" title="前端对接"></a>前端对接</h2><p>修改sysUser.vue上传图片的页面代码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-upload</span><br><span class="line">           class=&quot;avatar-uploader&quot;</span><br><span class="line">           action=&quot;http://localhost:8501/admin/system/fileUpload&quot;</span><br><span class="line">           :show-file-list=&quot;false&quot;</span><br><span class="line">           :on-success=&quot;handleAvatarSuccess&quot;</span><br><span class="line">           :headers=&quot;headers&quot;</span><br><span class="line">&gt;</span><br><span class="line">    </span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; useApp &#125; from &#x27;@/pinia/modules/app&#x27;</span><br><span class="line"></span><br><span class="line">const headers = &#123;</span><br><span class="line">  token: useApp().authorization.token     // 从pinia中获取token，在进行文件上传的时候将token设置到请求头中</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 图像上传成功以后的事件处理函数</span><br><span class="line">const handleAvatarSuccess = (response, uploadFile) =&gt; &#123;</span><br><span class="line">    sysUser.value.avatar = response.data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 应用 </tag>
            
            <tag> minio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录学习Spring源码</title>
      <link href="/2024/07/01/%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0Spring%E6%BA%90%E7%A0%81/"/>
      <url>/2024/07/01/%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0Spring%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>因为Spring源码这个东西实在是太难学了，学了忘，忘了学，反反复复，还有很多晦涩难懂的东西，甚至现在我感觉仍然是入门，只能说是把每节课学到的东西给记录一下，将来能多次回顾。笔记参考视频-黑马程序员</p><p>这几篇老文章都是我之前用飞书云文档写的，因转换格式问题，本文之前已写完的文档图片太多了，不想一一转化了，大家可以访问我的飞书云文档来查看这些图片–<a href="https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e,%E4%B8%8D%E8%BF%87%E5%90%8E%E7%BB%AD%E8%A1%A5%E5%85%85%E7%9A%84%E9%83%BD%E4%BC%9A%E6%9C%89%E5%9B%BE%E7%89%87">https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e,不过后续补充的都会有图片</a></p><h1 id="容器接口"><a href="#容器接口" class="headerlink" title="容器接口"></a>容器接口</h1><p>以 SpringBoot 的启动类为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A01Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(A01Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 run() 方法是有返回值的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(Application.class, args);</span><br></pre></td></tr></table></figure><p>ConfigurableApplicationContext</p><p>  ConfigurableApplicationContext 接口继承了 ApplicationContext 接口，而 ApplicationContext 接口又间接地继承了 BeanFactory 接口，除此之外还继承了其他很多接口，相当于对 BeanFactory 进行了拓展。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTQ5ZDU4ZDNhNWY4Y2IxYWE4NmRiNzBjYzRhMDU3NWZfYXBEcEREbFM1cEhra0F5WnpwT0dFU2MwYTl1V2l2NGRfVG9rZW46VXpLMmI5Nk1Qb3gxRkx4QlpoWmNxaDNUbmdlXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><h2 id="1-1-BeanFactory介绍"><a href="#1-1-BeanFactory介绍" class="headerlink" title="1.1 BeanFactory介绍"></a>1.1 BeanFactory介绍</h2><ol><li>它是 ApplicationContext 的父接口</li><li>它才是 Spring 的核心容器，主要的 ApplicationContext 实现组合了它的功能，也就是说，BeanFactory 是 ApplicationContext 中的一个成员变量。</li><li>常用的 context.getBean(“xxx”) 方法，其实是调用了 BeanFactory 的 getBean() 方法。</li></ol><h2 id="1-2-BeanFactory-作用"><a href="#1-2-BeanFactory-作用" class="headerlink" title="1.2  BeanFactory 作用"></a>1.2  BeanFactory 作用</h2><p>IDEA中查看BeanFactory的相关方法</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ODMzMTJhZjdlODM3ZTkxMmM4ZWEzNzcyYjFiZDIwNTJfRnNGeHBTZmVyNzNNVDF5QmZoaDVUNDZlRm1OUHhyS0NfVG9rZW46SUpRMGJwZnVsb2RLNTN4U3RadmN1WTB1bndoXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p> 通过这些方法定义可知，BeanFactory 表面上只有 getBean() 方法，但实际上 Spring 中的控制反转、基本的依赖注入、乃至 Bean 的生命周期中的各个功能都是由它的实现类提供。</p><h2 id="1-3DefaultListableBeanFactory"><a href="#1-3DefaultListableBeanFactory" class="headerlink" title="1.3DefaultListableBeanFactory"></a>1.3DefaultListableBeanFactory</h2><h3 id="1-3-1DefaultListableBeanFactory简单介绍"><a href="#1-3-1DefaultListableBeanFactory简单介绍" class="headerlink" title="1.3.1DefaultListableBeanFactory简单介绍"></a>1.3.1DefaultListableBeanFactory简单介绍</h3><ol><li>DefaultListableBeanFactory 实现了 BeanFactory 接口，它能管理 Spring 中所有的 Bean，当然也包含 Spring 容器中的那些单例对象。</li><li>DefaultListableBeanFactory 还继承了DefaultSingletonBeanRegistry 类，这个类就是用来管理 Spring 容器中的单例对象。</li></ol><h3 id="1-3-2源码分析"><a href="#1-3-2源码分析" class="headerlink" title="1.3.2源码分析"></a>1.3.2源码分析</h3><p>进入DefaultSingletonBeanRegistry它有一个 Map 类型的成员变量 singletonObjects</p><p>Map 的 key 就是 Bean 的名字，而 value 是对应的 Bean，即单例对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure><p>演示</p><p>现有如下两个 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Component1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Component2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写程序查看 singletonObjects 中是否存在这两个 Bean 的信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A01Application</span> &#123;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A01Application.class, args);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">singletonObjects</span> <span class="operator">=</span> DefaultSingletonBeanRegistry.class.getDeclaredField(<span class="string">&quot;singletonObjects&quot;</span>);</span><br><span class="line">        singletonObjects.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getBeanFactory();</span><br><span class="line">        Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) singletonObjects.get(beanFactory);</span><br><span class="line">        map.entrySet().stream().filter(e -&gt; e.getKey().startsWith(<span class="string">&quot;component&quot;</span>))</span><br><span class="line">            .forEach(e -&gt; System.out.println(e.getKey() + <span class="string">&quot;=&quot;</span> + e.getValue()));</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">component1=indi.lcp.bean.a01.Component1@25a5c7db</span><br><span class="line">component2=indi.lcp.bean.a01.Component2@4d27d9d</span><br></pre></td></tr></table></figure><h2 id="1-4ApplicationContext"><a href="#1-4ApplicationContext" class="headerlink" title="1.4ApplicationContext"></a>1.4ApplicationContext</h2><p>附一张ConfigurableApplicationContext的继承类图</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YmEzOThmN2Q5NDlhYTFmYzkyMWVmNzE0OTVmNTI1NWRfbndPUnlDcWN5RFM4MDRFeW9yeHE1QlB2WjQyMjJOUjNfVG9rZW46WE5IdWJwcFJ2b0tJWFN4MUpjeWNzanVEbm9lXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>可以看出ApplicationContext 除了继承 BeanFactory 外，还继承了：</p><ul><li>MessageSource：使其具备处理国际化资源的能力</li><li>ResourcePatternResolver：使其具备使用通配符进行资源匹配的能力</li><li>EnvironmentCapable：使其具备读取 Spring 环境信息、配置文件信息的能力</li><li>ApplicationEventPublisher：使其具备发布事件的能力</li></ul><p>依次深入看一下这四个类</p><h3 id="1-4-1MessageSource"><a href="#1-4-1MessageSource" class="headerlink" title="1.4.1MessageSource"></a>1.4.1MessageSource</h3><p> 在 SpringBoot 项目的 resources 目录下创建 messages.properties、messages_en.properties、messages_zh_CN.properties、messages_zh_TW.properties 四个国际化文件，除 messages.properties 外，其余三个文件内容如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lcp=Li congpu</span><br><span class="line">lcp=李从浦</span><br><span class="line">lcp=李從浦</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A01Application.class, args);</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    System.out.println(context.getMessage(<span class="string">&quot;thanks&quot;</span>, <span class="literal">null</span>, Locale.ENGLISH));</span><br><span class="line">    System.out.println(context.getMessage(<span class="string">&quot;thanks&quot;</span>, <span class="literal">null</span>, Locale.SIMPLIFIED_CHINESE));</span><br><span class="line">    System.out.println(context.getMessage(<span class="string">&quot;thanks&quot;</span>, <span class="literal">null</span>, Locale.TRADITIONAL_CHINESE));</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Li congpu</span><br><span class="line">李从浦</span><br><span class="line">李從浦</span><br></pre></td></tr></table></figure><h3 id="1-4-2ResourcePatternResolver"><a href="#1-4-2ResourcePatternResolver" class="headerlink" title="1.4.2ResourcePatternResolver"></a>1.4.2ResourcePatternResolver</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A01Application.class, args);</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    Resource[] resources = context.getResources(<span class="string">&quot;classpath:application.properties&quot;</span>);</span><br><span class="line">    Assert.isTrue(resources.length &gt; <span class="number">0</span>, <span class="string">&quot;加载类路径下的 application.properties 文件失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 classpath* 可以加载 jar 里类路径下的 resource</span></span><br><span class="line">    resources = context.getResources(<span class="string">&quot;classpath*:META-INF/spring.factories&quot;</span>);</span><br><span class="line">    Assert.isTrue(resources.length &gt; <span class="number">0</span>, <span class="string">&quot;加载类路径下的 META-INF/spring.factories 文件失败&quot;</span>);</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-3EnvironmentCapable"><a href="#1-4-3EnvironmentCapable" class="headerlink" title="1.4.3EnvironmentCapable"></a>1.4.3EnvironmentCapable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A01Application.class, args);</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    System.out.println(context.getEnvironment().getProperty(<span class="string">&quot;java_home&quot;</span>));</span><br><span class="line">    System.out.println(context.getEnvironment().getProperty(<span class="string">&quot;properties.name&quot;</span>));</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java_home 是从环境变量中读取，properties.name 则是从 application.yml 配置文件中读取。</p><h3 id="1-4-4ApplicationEventPublisher"><a href="#1-4-4ApplicationEventPublisher" class="headerlink" title="1.4.4ApplicationEventPublisher"></a>1.4.4ApplicationEventPublisher</h3><p>定义事件类 UserRegisteredEvent：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegisteredEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6319117283222183184L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserRegisteredEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 Component1 作为发送事件的 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Component1</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;事件&quot;</span>);</span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> <span class="title class_">UserRegisteredEvent</span>(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 Component2 作为事件监听器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Component2</span> &#123;</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aaa</span><span class="params">(UserRegisteredEvent event)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, event);</span><br><span class="line">        log.debug(<span class="string">&quot;监听到事件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main() 方法中使用 Component1 发送事件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A01Application.class, args);</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    context.getBean(Component1.class).register();</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.bean.a01.Component1      - 事件 </span><br><span class="line">indi.lcp.bean.a01.Component2      - indi.lcp.bean.a01.UserRegisteredEvent[source=indi.lcp.bean.a01.Component1@25a5c7db] </span><br><span class="line">indi.lcp.bean.a01.Component2      - 监听到事件 </span><br></pre></td></tr></table></figure><h1 id="容器实现"><a href="#容器实现" class="headerlink" title="容器实现"></a>容器实现</h1><h2 id="2-1-BeanFactory-的实现"><a href="#2-1-BeanFactory-的实现" class="headerlink" title="2.1 BeanFactory 的实现"></a>2.1 BeanFactory 的实现</h2><p>有如下类，尝试将 Config 添加到 Bean 工厂中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;构造 Bean1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">getBean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bean2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean2</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;构造 Bean2()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要使用到 BeanFactory 的一个实现类： DefaultListableBeanFactory。有了 Bean 工厂，还需要定义 Bean，之后再把定义的 Bean 注册到工厂即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">    <span class="comment">// bean 的定义（class，scope，初始化，销毁）</span></span><br><span class="line">    <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(Config.class)</span><br><span class="line">            .setScope(<span class="string">&quot;singleton&quot;</span>)</span><br><span class="line">            .getBeanDefinition();</span><br><span class="line">    beanFactory.registerBeanDefinition(<span class="string">&quot;config&quot;</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有 config</span></span><br><span class="line">    Arrays.stream(beanFactory.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">config</span><br></pre></td></tr></table></figure><p>现在 Bean 工厂中 有且仅有一个 名为 config 的 Bean。</p><ul><li>解析配置类</li></ul><p>根据对 @Configuration 和 @Bean 两个注解的认识可知，Bean 工厂中应该还存在 bean1 和 bean2，那为什么现在没有呢？</p><p>很明显是现在的 BeanFactory 缺少了解析 @Configuration 和 @Bean 两个注解的能力。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="comment">// 给 BeanFactory 添加一些常用的后置处理器</span></span><br><span class="line">    AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory);</span><br><span class="line">    Arrays.stream(beanFactory.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据打印出的信息，可以看到有一个名为 org.springframework.context.annotation.internalConfigurationAnnotationProcessor 的 Bean，根据其所含的 ConfigurationAnnotationProcessor 字样，可以知道这个 Bean 就是用来处理 @Configuration 和 @Bean 注解的，将配置类中定义的 Bean 信息补充到 BeanFactory 中。</p><p>那为什么在 Bean 工厂中依旧没有 bean1 和 bean2 呢？</p><p>现在仅仅是将处理器添加到了 Bean 工厂，还没有使用处理器。</p><p>使用处理器很简单，先获取到处理器，然后再使用即可。像internalConfigurationAnnotationProcessor 这样的 Bean，都有一个共同的类型，名为 BeanFactoryPostProcessor，因此可以：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="comment">// 使用后置处理器</span></span><br><span class="line">    <span class="comment">// BeanFactoryPostProcessor 补充了一些 Bean 的定义</span></span><br><span class="line">    beanFactory.getBeansOfType(BeanFactoryPostProcessor.class).values().forEach(i -&gt; i.postProcessBeanFactory(beanFactory));</span><br><span class="line">    Arrays.stream(beanFactory.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">config</span><br><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">bean1</span><br><span class="line">bean2</span><br></pre></td></tr></table></figure><ul><li>依赖注入</li></ul><p>bean1 和 bean2 已经被添加到 Bean 工厂中，尝试获取 bean1 中的 bean2，查看 bean2 是否成功注入到 bean1 中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    System.out.println(beanFactory.getBean(Bean1.class).getBean2());</span><br><span class="line">&#125;</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure><p>bean2 没有成功被注入到 bean1 中。</p><p>在先前添加到 BeanFactory 中的后置处理器里，有名为 internalAutowiredAnnotationProcessor 和 internalCommonAnnotationProcessor 的两个后置处理器。前者用于解析 @Autowired 注解，后者用于解析 @Resource 注解，它们都有一个共同的类型 BeanPostProcessor，因此可以：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    System.out.println(<span class="string">&quot;---------------------------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">// Bean 后置处理器，对 Bean 的生命周期的各个阶段提供拓展，例如 @AutoWired @Resource...</span></span><br><span class="line">    beanFactory.getBeansOfType(BeanPostProcessor.class).values().forEach(beanFactory::addBeanPostProcessor);</span><br><span class="line">    System.out.println(beanFactory.getBean(Bean1.class).getBean2());</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------</span><br><span class="line">[main] DEBUG indi.lcp.bean.a02.TestBeanFactory$Bean1 - 构造 Bean1()</span><br><span class="line">[main] DEBUG indi.lcp.bean.a02.TestBeanFactory$Bean2 - 构造 Bean2()</span><br><span class="line">indi.lcp.bean.a02.TestBeanFactory$Bean2@6ee12bac</span><br></pre></td></tr></table></figure><p>建立 BeanPostProcessor 和 BeanFactory 的关系后，bean2 被成功注入到 bean1 中了。</p><p>除此之外还可以发现：当需要使用 Bean 时，Bean 才会被创建，即按需加载。那有没有什么办法预先就初始化好单例对象呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预先初始化单例对象（完成依赖注入和初始化流程）  懒汉变饿汉</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">    System.out.println(<span class="string">&quot;---------------------------------------------&quot;</span>);</span><br><span class="line">    beanFactory.getBeansOfType(BeanPostProcessor.class).values().forEach(beanFactory::addBeanPostProcessor);</span><br><span class="line">    System.out.println(beanFactory.getBean(Bean1.class).getBean2());</span><br><span class="line">&#125;</span><br><span class="line">[main] DEBUG indi.lcp.bean.a02.TestBeanFactory$Bean1 - 构造 Bean1()</span><br><span class="line">[main] DEBUG indi.lcp.bean.a02.TestBeanFactory$Bean2 - 构造 Bean2()</span><br><span class="line">----------------------------------------</span><br><span class="line">indi.lcp.bean.a02.TestBeanFactory$Bean2@6ee12bac</span><br></pre></td></tr></table></figure><p><strong>学到了什么-&gt;BeanFactory 不会做的事 ：</strong></p><ul><li><p>主动调用 BeanFactory 后置处理器；</p></li><li><p>主动添加 Bean 后置处理器；</p></li><li><p>主动初始化单例对象；</p></li><li><p>解析 ${} 和 #{}</p></li><li><p><strong>扩展：后置处理器的排序</strong></p></li></ul><p>在最初给出的类信息中进行补充：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean3 <span class="title function_">bean3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean3</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean4 <span class="title function_">bean4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean4</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean3</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean3</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;构造 Bean3()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean4</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean4</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;构造 Bean4()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Resource(name = &quot;bean4&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Inter bean3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Inter <span class="title function_">getInter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bean3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向 Bean 工厂中添加了 bean3 和 bean4，并且计划在 bean1 中注入 Inter 类型的 Bean。</p><p>现在 Bean 工厂中 Inter 类型的 Bean 有两个，分别是 bean3、bean4，那么会注入哪一个呢？</p><p>如果只使用 @Autowired，首先会按照类型注入，如果同种类型的 Bean 有多个，再按照变量名称注入，如果再注入失败，就报错；如果只使用 @Resource，也会采取与 @Autowired 一样的注入策略，只不过 @Resource 注解还可以指定需要注入 Bean 的 id（使用 name 属性进行指定），如果指定了需要注入 Bean 的 id，就直接按照指定的 id 进行注入，如果失败就报错。</p><p>那如果即使用 @Autowired 又使用 @Resource(name &#x3D; “bean4”) 呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    System.out.println(beanFactory.getBean(Bean1.class).getInter());</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a02.TestBeanFactory$Bean3@<span class="number">8e0379d</span></span><br></pre></td></tr></table></figure><p>根据打印的结果可知，@Autowired 先生效了，这是因为 internalAutowiredAnnotationProcessor 排在 internalCommonAnnotationProcessor 之前。可以查看它们的先后关系</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    beanFactory.getBeansOfType(BeanPostProcessor.class).values().forEach(i -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt; &quot;</span> + i);</span><br><span class="line">        beanFactory.addBeanPostProcessor(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor@6385cb26</span><br><span class="line">org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@<span class="number">38364841</span></span><br></pre></td></tr></table></figure></blockquote><p>也可以改变它们的顺序，然后再查看注入的是 bean3 还是 bean4：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    beanFactory.getBeansOfType(BeanPostProcessor.class).values().stream()</span><br><span class="line">        .sorted(Objects.requireNonNull(beanFactory.getDependencyComparator()))</span><br><span class="line">        .forEach(i -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt; &quot;</span> + i);</span><br><span class="line">            beanFactory.addBeanPostProcessor(i);</span><br><span class="line">        &#125;);</span><br><span class="line">    System.out.println(beanFactory.getBean(Bean1.class).getInter());</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt;&gt; org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@6385cb26</span><br><span class="line">&gt;&gt;&gt;&gt; org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor@<span class="number">38364841</span></span><br><span class="line">indi.lcp.bean.a02.TestBeanFactory$Bean4@52e677af</span><br></pre></td></tr></table></figure><p>改变 BeanPostProcessor 的先后顺序后，@Resource(name &#x3D; “bean4”) 生效了，成功注入了 bean4。</p><p>为什么使用 beanFactory.getDependencyComparator() 后就改变了 BeanPostProcessor 的先后顺序呢？</p><p>在调用的 AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory); 方法源码中有：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerAnnotationConfigProcessors</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    registerAnnotationConfigProcessors(registry, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">registerAnnotationConfigProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">    BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">    <span class="keyword">if</span> (beanFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">            <span class="comment">// 设置比较器</span></span><br><span class="line">            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">            beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置的 AnnotationAwareOrderComparator 比较器会根据设置的 order 信息进行比较。</p><p>AutowiredAnnotationBeanPostProcessor 设置的 order 是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">order</span> <span class="operator">=</span> Ordered.LOWEST_PRECEDENCE - <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>CommonAnnotationBeanPostProcessor 设置的 order 是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CommonAnnotationBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">    setOrder(Ordered.LOWEST_PRECEDENCE - <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值越小，优先级越大，就排在更前面，因此当设置了 AnnotationAwareOrderComparator 比较器后，CommonAnnotationBeanPostProcessor 排在更前面，@Resource 就先生效。</p><h2 id="2-2-ApplicationContext-的实现"><a href="#2-2-ApplicationContext-的实现" class="headerlink" title="2.2 ApplicationContext 的实现"></a>2.2 ApplicationContext 的实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lcp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/12/23 23:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A02Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">        <span class="meta">@Getter</span></span><br><span class="line">        <span class="meta">@Setter</span></span><br><span class="line">        <span class="keyword">private</span> Bean1 bean1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-1-ClassPathXmlApplicationContext"><a href="#2-2-1-ClassPathXmlApplicationContext" class="headerlink" title="2.2.1 ClassPathXmlApplicationContext"></a>2.2.1 ClassPathXmlApplicationContext</h3><p>较为经典的容器，基于 classpath 下的 xml 格式的配置文件来创建。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;indi.lcp.bean.a02.A02Application.Bean1&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;indi.lcp.bean.a02.A02Application.Bean2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bean1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line">private static void testClassPathXmlApplicationContext() &#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;b01.xml&quot;);</span><br><span class="line">    Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">    System.out.println(context.getBean(Bean2.class).getBean1());</span><br><span class="line">&#125;</span><br><span class="line">bean1</span><br><span class="line">bean2</span><br><span class="line">indi.lcp.bean.a02.A02Application$Bean1@2db7a79b</span><br></pre></td></tr></table></figure><h3 id="2-2-2-FileSystemXmlApplicationContext"><a href="#2-2-2-FileSystemXmlApplicationContext" class="headerlink" title="2.2.2 FileSystemXmlApplicationContext"></a>2.2.2 FileSystemXmlApplicationContext</h3><p>与 ClassPathXmlApplicationContext 相比，FileSystemXmlApplicationContext 是基于磁盘路径下 xml 格式的配置文件来创建。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testFileSystemXmlApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 使用相对路径时，以模块为起点（IDEA 中需要设置 Working directory），也支持绝对路径</span></span><br><span class="line">    <span class="type">FileSystemXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;bean\\src\\main\\resources\\b01.xml&quot;</span>);</span><br><span class="line">    Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">    System.out.println(context.getBean(Bean2.class).getBean1());</span><br><span class="line">&#125;</span><br><span class="line">bean1</span><br><span class="line">bean2</span><br><span class="line">indi.lcp.bean.a02.A02Application$Bean1@2db7a79b</span><br></pre></td></tr></table></figure><ul><li><strong>从XML 文件中读取 Bean 的定义</strong></li></ul><p>ClassPathXmlApplicationContext 和 FileSystemXmlApplicationContext 都依赖于从 XML 文件中读取 Bean 的信息，而这都利用了 XmlBeanDefinitionReader 进行读取。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testXmlBeanDefinitionReader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;读取之前...&quot;</span>);</span><br><span class="line">        Arrays.stream(beanFactory.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;读取之后...&quot;</span>);</span><br><span class="line">        <span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line"><span class="comment">//        reader.loadBeanDefinitions(new ClassPathResource(&quot;b01.xml&quot;));</span></span><br><span class="line">        reader.loadBeanDefinitions(<span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(<span class="string">&quot;bean\\src\\main\\resources\\b01.xml&quot;</span>));</span><br><span class="line">        Arrays.stream(beanFactory.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">读取之前...</span><br><span class="line">读取之后...</span><br><span class="line">bean1</span><br><span class="line">bean2</span><br></pre></td></tr></table></figure><h3 id="2-2-3-AnnotationConfigApplicationContext"><a href="#2-2-3-AnnotationConfigApplicationContext" class="headerlink" title="2.2.3 AnnotationConfigApplicationContext"></a>2.2.3 AnnotationConfigApplicationContext</h3><p>基于 Java 配置类来创建。首先定义配置类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">(Bean1 bean1)</span> &#123;</span><br><span class="line">        <span class="type">Bean2</span> <span class="variable">bean2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">        bean2.setBean1(bean1);</span><br><span class="line">        <span class="keyword">return</span> bean2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Config.class);</span><br><span class="line">    Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">    System.out.println(context.getBean(Bean2.class).getBean1());</span><br><span class="line">&#125;</span><br><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">a02Application.Config</span><br><span class="line">bean1</span><br><span class="line">bean2</span><br><span class="line">indi.lcp.bean.a02.A02Application$Bean1@1f0f1111</span><br></pre></td></tr></table></figure><p>与前面两种基于 XML 创建 ApplicationContext 的方式相比，使用 AnnotationConfigApplicationContext 后，使得容器中多了一些后置处理器相关的 Bean。</p><p>如果要在先前的两种方式中也添加上这些 Bean，可以在 XML 进行配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;indi.lcp.bean.a02.A02Application.Bean1&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;indi.lcp.bean.a02.A02Application.Bean2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bean1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  添加后置处理器  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-4-AnnotationConfigServletWebServerApplicationContext"><a href="#2-2-4-AnnotationConfigServletWebServerApplicationContext" class="headerlink" title="2.2.4 AnnotationConfigServletWebServerApplicationContext"></a>2.2.4 AnnotationConfigServletWebServerApplicationContext</h3><p>基于 Java 配置类来创建，用于 web 环境。首先定义配置类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 提供内嵌的 Web 容器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 添加前控制器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">registrationBean</span><span class="params">(DispatcherServlet dispatcherServlet)</span> &#123;</span><br><span class="line">        <span class="comment">// 将 DispatcherServlet 注册到 Tomcat 服务器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 bean 以 &#x27;/&#x27; 开头，将 &#x27;/&#x27; 后的 bean 的名称作为访问路径</span></span><br><span class="line">    <span class="meta">@Bean(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Controller <span class="title function_">controller1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 添加控制器，用于展示</span></span><br><span class="line">        <span class="keyword">return</span> (request, response) -&gt; &#123;</span><br><span class="line">            response.getWriter().println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAnnotationConfigServletWebServerApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigServletWebServerApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>(WebConfig.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，在浏览器中访问 <a href="http://localhost:8080/hello">http://localhost:8080/hello</a> 路径则会显示出 hello 字样</p><h2 id="2-3-BeanFactory-接口体系"><a href="#2-3-BeanFactory-接口体系" class="headerlink" title="2.3 BeanFactory 接口体系"></a>2.3 BeanFactory 接口体系</h2><p>BeanFactory 其实就是 Spring IoC 容器，它本身是一个接口，提供了一系列获取 Bean 的方式。</p><p>基于它也有众多子接口：</p><ul><li>ListableBeanFactory：提供获取 Bean 集合的能力，比如一个接口可能有多个实现，通过该接口下的方法就能获取某种类型的所有 Bean；</li><li>HierarchicalBeanFactory：Hierarchical 意为“层次化”，通常表示一种具有层级结构的概念或组织方式，这种层次化结构可以通过父子关系来表示对象之间的关联，比如树、图、文件系统、组织架构等。根据该接口下的方法可知，能够获取到父容器，说明 BeanFactory 有父子容器概念；</li><li>AutowireCapableBeanFactory：提供了创建 Bean、自动装配 Bean、属性填充、Bean 初始化、依赖注入等能力，比如 @Autowired 注解的底层实现就依赖于该接口的 resolveDependency() 方法；</li><li>ConfigurableBeanFactory：该接口并未直接继承至 BeanFactory，而是继承了 HierarchicalBeanFactory。Configurable 意为“可配置的”，就是说该接口用于对 BeanFactory 进行一些配置，比如设置类型转换器。</li></ul><h2 id="2-4-读取-BeanDefinition"><a href="#2-4-读取-BeanDefinition" class="headerlink" title="2.4 读取 BeanDefinition"></a>2.4 读取 BeanDefinition</h2><p>BeanDefinition 也是一个接口，它封装了 Bean 的定义，Spring 根据 Bean 的定义，就能创建出符合要求的 Bean。</p><p>读取 BeanDefinition 可以通过下列两种类完成：</p><ul><li><p>BeanDefinitionReader</p></li><li><p>ClassPathBeanDefinitionScanner</p></li><li><p>BeanDefinitionReader</p></li></ul><p>该接口中对 loadBeanDefinitions() 方法进行了多种重载，支持传入一个或多个 Resource 对象、资源位置来加载 BeanDefinition。</p><p>它有一系列相关实现，比如：</p><ul><li>XmlBeanDefinitionReader：通过读取 XML 文件来加载；</li><li>PropertiesBeanDefinitionReader：通过读取 properties 文件来加载，此类已经被 @Deprecated 注解标记；</li></ul><p>除此之外，还有一个 AnnotatedBeanDefinitionReader，尽管它并不是 BeanDefinition 的子类，但它们俩长得很像，根据其类注释可知：它能够通过编程的方式对 Bean 进行注册，是 ClassPathBeanDefinitionScanner 的替代方案，能读取通过注解定义的 Bean。</p><ul><li>ClassPathBeanDefinitionScanner</li></ul><p>通过扫描指定包路径下的 @Component 及其派生注解来注册 Bean，是 @ComponentScan 注解的底层实现。</p><p>比如 MyBatis 通过继承 ClassPathBeanDefinitionScanner 实现通过 @MapperScan 注解来扫描指定包下的 Mapper 接口。</p><ul><li>BeanDefinitionRegistry</li></ul><p>AnnotatedBeanDefinitionReader 和 ClassPathBeanDefinitionScanner 中都有一个 BeanDefinitionRegistry 类型的成员变量，它是一个接口，提供了 BeanDefinition 的增加、删除和查找功能。</p><ul><li>注册与获取 Bean</li></ul><p>根据前面的补充，现在可以这样注册并获取 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultListableBeanFactoryTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 既实现了 BeanFactory，又实现了 BeanDefinitionRegistry</span></span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">        <span class="comment">// ClassPathBeanDefinitionScanner 的一种替代，编程式显式注册 bean</span></span><br><span class="line">        <span class="type">AnnotatedBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(beanFactory);</span><br><span class="line">        reader.registerBean(MyBean.class);</span><br><span class="line">        <span class="type">MyBean</span> <span class="variable">bean</span> <span class="operator">=</span> beanFactory.getBean(MyBean.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-ApplicationContext-接口体系"><a href="#2-5-ApplicationContext-接口体系" class="headerlink" title="2.5 ApplicationContext 接口体系"></a>2.5 ApplicationContext 接口体系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">EnvironmentCapable</span>, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationContext 接口继承了许多接口，其中：</p><ul><li>EnvironmentCapable：提供获取 Environment 的能力</li><li>ListableBeanFactory：提供了获取某种类型的 Bean 集合的能力</li><li>HierarchicalBeanFactory：提供了获取父容器的能力</li><li>MessageSource：提供了对国际化信息进行处理的能力</li><li>ApplicationEventPublisher：提供了事件发布能力</li><li>ResourcePatternResolver：提供了通过通配符获取多个资源的能力</li></ul><p>虽然 ApplicationContext 继承了很多接口，但这些能力的实现是通过一种委派（Delegate）的方式实现的，这种方式也被叫做委派模式，但它并不属于 GoF 的 23 种设计模式中的一种，是一种面向对象的设计模式。什么是委派呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ResourcePatternResolver</span> <span class="variable">resourcePatternResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> resourcePatternResolver.getResources(locationPattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现获取资源的方式并不是由实现类自身完成，而是交给其内部的一个成员变量完成，这样的方式就是委派（这和对象适配器模式很相似）。</p><p>在日常编码遇到这样的实现逻辑时，类名可以以 Delegate 结尾。</p><ul><li>ConfigurableApplicationContext</li></ul><p>ApplicationContext 有一个子接口 ConfigurableApplicationContext，从类名就可以看出，它提供了对 ApplicationContext 进行配置的能力，浏览其内部方法可知，提供了诸如设置父容器、设置 Environment 等能力。</p><ul><li>AbstractApplicationContext</li></ul><p>ApplicationContext 有一个非常重要的抽象实现 AbstractApplicationContext，其他具体实现都会继承这个抽象实现，在其内部通过委派的方式实现了一些接口的能力，除此之外还有一个与 Spring Bean 的生命周期息息相关的方法：refresh()。</p><h1 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h1><p>自定义一个 SpringBoot 的主启动类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A03Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A03Application.class, args);</span><br><span class="line">        <span class="comment">// 调用 close 方法，显示生命周期的销毁阶段</span></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动类所在路径下再定义一个类，使其能够被自动装配：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LifeCycleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LifeCycleBean</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autowire</span><span class="params">(<span class="meta">@Value(&quot;$&#123;JAVA_HOME&#125;&quot;)</span> String home)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;依赖注入: &#123;&#125;&quot;</span>, home);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a03.LifeCycleBean        : 构造</span><br><span class="line">indi.lcp.bean.a03.LifeCycleBean        : 依赖注入: D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">indi.lcp.bean.a03.LifeCycleBean        : 初始化</span><br><span class="line">indi.lcp.bean.a03.LifeCycleBean        : 销毁</span><br></pre></td></tr></table></figure><p>除此之外，Spring 还提供了一些对 Bean 生命周期的各个阶段进行拓展的 BeanPostProcessor，比如 InstantiationAwareBeanPostProcessor 和 DestructionAwareBeanPostProcessor。</p><p>实现这两个接口，并使用 @Component 注解标记实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">InstantiationAwareBeanPostProcessor</span>, DestructionAwareBeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeforeDestruction</span><span class="params">(Object o, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;lifeCycleBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 销毁执行之前，如 @PreDestroy&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;lifeCycleBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 实例化之前执行，这里返回的对象会替换掉原本的 bean&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;lifeCycleBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 实例化之后执行，如果返回 false 会跳过依赖注入节点&quot;</span>);</span><br><span class="line">            <span class="comment">// return false;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;lifeCycleBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 依赖注入阶段执行，如 @Autowired、@Value、@Resource&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;lifeCycleBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 初始化执行之前，这里返回的对象会替换掉原本的 bean，如 @PostConstruct、@ConfigurationProperties&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;lifeCycleBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 初始化之后执行，这里返回的对象会替换掉原本的 bean，如代理增强&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再运行主启动类，查看控制台的日志信息（只列举主要信息）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.bean.a03.MyBeanPostProcessor  : &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 实例化之前执行，这里返回的对象会替换掉原本的 bean</span><br><span class="line">indi.lcp.bean.a03.LifeCycleBean        : 构造</span><br><span class="line">indi.lcp.bean.a03.MyBeanPostProcessor  : &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 实例化之后执行，如果返回 <span class="literal">false</span> 会跳过依赖注入节点</span><br><span class="line">indi.lcp.bean.a03.MyBeanPostProcessor  : &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 依赖注入阶段执行，如 <span class="meta">@Autowired</span>、<span class="meta">@Value</span>、<span class="meta">@Resource</span></span><br><span class="line">indi.lcp.bean.a03.LifeCycleBean        : 依赖注入: D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">indi.lcp.bean.a03.MyBeanPostProcessor  : &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 初始化执行之前，这里返回的对象会替换掉原本的 bean，如 <span class="meta">@PostConstruct</span>、<span class="meta">@ConfigurationProperties</span></span><br><span class="line">indi.lcp.bean.a03.LifeCycleBean        : 初始化</span><br><span class="line">indi.lcp.bean.a03.MyBeanPostProcessor  : &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 初始化之后执行，这里返回的对象会替换掉原本的 bean，如代理增强</span><br><span class="line">indi.lcp.bean.a03.MyBeanPostProcessor  : &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 销毁执行之前，如 <span class="meta">@PreDestroy</span></span><br><span class="line">indi.lcp.bean.a03.LifeCycleBean        : 销毁</span><br></pre></td></tr></table></figure><p>为什么实现了 BeanPostProcessor 接口后就能够在 Bean 生命周期的各个阶段进行拓展呢？</p><p>这使用了模板方法设计模式。</p><p>如下代码，模拟 BeanFactory 构造 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;构造 &quot;</span> + bean);</span><br><span class="line">        System.out.println(<span class="string">&quot;依赖注入 &quot;</span> + bean);</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化 &quot;</span> + bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设现在需要在依赖注入之后，初始化之前进行其他的操作，那首先能想到的就是在这个位置直接书写相关操作的代码，但这会使代码更加臃肿、增加耦合性，显然不是一种好方式。</p><p>可以定义一个接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(Object bean)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后对 MyBeanFactory 进行修改：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;构造 &quot;</span> + bean);</span><br><span class="line">        System.out.println(<span class="string">&quot;依赖注入 &quot;</span> + bean);</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor processor : processors) &#123;</span><br><span class="line">            processor.inject(bean);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化 &quot;</span> + bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;BeanPostProcessor&gt; processors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addProcessor</span><span class="params">(BeanPostProcessor processor)</span> &#123;</span><br><span class="line">        processors.add(processor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后如果需要拓展，调用 MyBeanFactory 实例的 addProcessor() 方法添加拓展逻辑即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBeanFactory</span>();</span><br><span class="line">    beanFactory.addProcessor(bean -&gt; System.out.println(<span class="string">&quot;解析 @Autowired&quot;</span>));</span><br><span class="line">    beanFactory.addProcessor(bean -&gt; System.out.println(<span class="string">&quot;解析 @Resource&quot;</span>));</span><br><span class="line">    beanFactory.getBean();</span><br><span class="line">&#125;</span><br><span class="line">构造 java.lang.Object@49097b5d</span><br><span class="line">依赖注入 java.lang.Object@49097b5d</span><br><span class="line">解析 <span class="meta">@Autowired</span></span><br><span class="line">解析 <span class="meta">@Resource</span></span><br><span class="line">初始化 java.lang.Object@49097b5d</span><br></pre></td></tr></table></figure><p>Bean的生命周期</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YzU3ZDMzYzkwMWMwZDE0ODJmN2NmZWNhN2UwNWI0ZWZfTmlPNEE1cWdkM1dyTTlzRDRiOXd4MXVrM3dlN1dMa1VfVG9rZW46WlZ4SWJhTGw5b3dQMWZ4ZXFGOGN6c21PbnNoXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><h1 id="Bean-后置处理器"><a href="#Bean-后置处理器" class="headerlink" title="Bean 后置处理器"></a><strong>Bean 后置处理器</strong></h1><h2 id="4-1-常见的-Bean-后置处理器"><a href="#4-1-常见的-Bean-后置处理器" class="headerlink" title="4.1 常见的 Bean 后置处理器"></a><strong>4.1 常见的 Bean 后置处理器</strong></h2><p>现有如下三个类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lcp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/12/25 22:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean2</span><span class="params">(Bean2 bean2)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;@Autowired 生效: &#123;&#125;&quot;</span>, bean2);</span><br><span class="line">        <span class="built_in">this</span>.bean2 = bean2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Bean3 bean3;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean3</span><span class="params">(Bean3 bean3)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;@Resource 生效: &#123;&#125;&quot;</span>, bean3);</span><br><span class="line">        <span class="built_in">this</span>.bean3 = bean3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String home;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHome</span><span class="params">(<span class="meta">@Value(&quot;$&#123;JAVA_HOME&#125;&quot;)</span> String home)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;@Value 生效: &#123;&#125;&quot;</span>, home);</span><br><span class="line">        <span class="built_in">this</span>.home = home;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;@PostConstruct 生效&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;@PreDestroy 生效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean3</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bean2 和 Bean3 很简单，而在 Bean1 中使用了多个注解以实现 Bean 注入和值注入。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A04Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// GenericApplicationContext 是一个干净的容器</span></span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        <span class="comment">// 用原始方式注册三个 bean</span></span><br><span class="line">        context.registerBean(<span class="string">&quot;bean1&quot;</span>, Bean1.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;bean2&quot;</span>, Bean2.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;bean3&quot;</span>, Bean3.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化容器。执行 beanFactory 后置处理器，添加 bean 后置处理器，初始化所有单例</span></span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁容器</span></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述方法后，控制台中只打印了与 Spring 相关的日志信息，也就是说 Bean1 中使用的注解并没有生效。</p><p>向 GenericApplicationContext 添加一些与 Bean 后置处理器相关的 Bean，使得 Bean1 中使用的注解能够生效。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    context.registerBean(<span class="string">&quot;bean3&quot;</span>, Bean3.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析值注入内容</span></span><br><span class="line">    context.getDefaultListableBeanFactory().setAutowireCandidateResolver(<span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>());</span><br><span class="line">    <span class="comment">// @Autowired @Value</span></span><br><span class="line">    context.registerBean(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a04.Bean1 - <span class="meta">@Autowired</span> 生效: indi.lcp.bean.a04.Bean2@29b5cd00</span><br><span class="line">indi.lcp.bean.a04.Bean1 - <span class="meta">@Value</span> 生效: D:\environment\JDK1<span class="number">.8</span></span><br></pre></td></tr></table></figure><p>@Autowired 和 @Value 注解成功生效，但 @Resource、@PostConstruct 和 @PreDestroy 依旧没有生效，因此还需要添加解析它们的 Bean 后置处理器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Resource @PostConstruct @PreDestroy</span></span><br><span class="line">    context.registerBean(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a04.Bean1 - <span class="meta">@Resource</span> 生效: indi.lcp.bean.a04.Bean3@12cdcf4</span><br><span class="line">indi.lcp.bean.a04.Bean1 - <span class="meta">@Autowired</span> 生效: indi.lcp.bean.a04.Bean2@6121c9d6</span><br><span class="line">indi.lcp.bean.a04.Bean1 - <span class="meta">@Value</span> 生效: D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">indi.lcp.bean.a04.Bean1 - <span class="meta">@PostConstruct</span> 生效</span><br><span class="line">INFO indi.lcp.bean.a04.Bean1 - <span class="meta">@PreDestroy</span> 生效</span><br></pre></td></tr></table></figure><p>解析 @ConfigurationProperties</p><p>使用 @ConfigurationProperties 可以指定配置信息的前缀，使得配置信息的读取更加简单。比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;java&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean4</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String home;</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码用于获取环境变量中 java.home 和 java.version 的信息。</p><p>对先前的 main() 方法进行补充：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    </span><br><span class="line">    context.registerBean(<span class="string">&quot;bean4&quot;</span>, Bean4.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    System.out.println(context.getBean(Bean4.class));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bean4 成功添加到容器中，但值注入失败了，显然也是因为缺少解析 @ConfigurationProperties 注解的后置处理器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    </span><br><span class="line">    context.registerBean(<span class="string">&quot;bean4&quot;</span>, Bean4.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="comment">// @ConfigurationProperties</span></span><br><span class="line">        ConfigurationPropertiesBindingPostProcessor.register(context.getDefaultListableBeanFactory());</span><br><span class="line"></span><br><span class="line">    System.out.println(context.getBean(Bean4.class));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">Bean4(home=D:\environment\JDK1<span class="number">.8</span>\jre, version=<span class="number">1.8</span><span class="number">.0_251</span>)</span><br></pre></td></tr></table></figure><h2 id="4-2-AutowiredAnnotationBeanPostProcessor"><a href="#4-2-AutowiredAnnotationBeanPostProcessor" class="headerlink" title="4.2 AutowiredAnnotationBeanPostProcessor"></a><strong>4.2 AutowiredAnnotationBeanPostProcessor</strong></h2><p>通过前文可知 AutowiredAnnotationBeanPostProcessor 用于解析 @Autowired 和 @Value 注解，那它究竟是怎么工作的呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">    <span class="comment">// 注册成品 Bean，不再进行 Bean 的创建、依赖注入、初始化等操作</span></span><br><span class="line">    beanFactory.registerSingleton(<span class="string">&quot;bean2&quot;</span>, <span class="keyword">new</span> <span class="title class_">Bean2</span>());</span><br><span class="line">    beanFactory.registerSingleton(<span class="string">&quot;bean3&quot;</span>, <span class="keyword">new</span> <span class="title class_">Bean3</span>());</span><br><span class="line">    <span class="comment">// @Value</span></span><br><span class="line">    beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看哪些属性、方法加了 @Autowired，这称之为 InjectionMetadata</span></span><br><span class="line">    <span class="type">AutowiredAnnotationBeanPostProcessor</span> <span class="variable">postProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutowiredAnnotationBeanPostProcessor</span>();</span><br><span class="line">    postProcessor.setBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="type">Bean1</span> <span class="variable">bean1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    System.out.println(bean1);</span><br><span class="line">    <span class="comment">// 执行依赖注入，@Autowired、@Value</span></span><br><span class="line">    postProcessor.postProcessProperties(<span class="literal">null</span>, bean1, <span class="string">&quot;bean1&quot;</span>);</span><br><span class="line">    System.out.println(bean1);</span><br><span class="line">&#125;</span><br><span class="line">Bean1(bean2=<span class="literal">null</span>, bean3=<span class="literal">null</span>, home=<span class="literal">null</span>)</span><br><span class="line"><span class="number">21</span>:<span class="number">31</span>:<span class="number">27.409</span> [main] INFO indi.lcp.bean.a04.Bean1 - <span class="meta">@Value</span> 生效: $&#123;JAVA_HOME&#125;</span><br><span class="line"><span class="number">21</span>:<span class="number">31</span>:<span class="number">27.419</span> [main] INFO indi.lcp.bean.a04.Bean1 - <span class="meta">@Autowired</span> 生效: indi.lcp.bean.a04.Bean2@5bcab519</span><br><span class="line"><span class="title function_">Bean1</span><span class="params">(bean2=indi.lcp.bean.a04.Bean2@5bcab519, bean3=<span class="literal">null</span>, home=$&#123;JAVA_HOME&#125;)</span></span><br></pre></td></tr></table></figure><p>在未调用 AutowiredAnnotationBeanPostProcessor#postProcessProperties() 方法时，Bean1 中的 bean2、bean3 和 home 都没有注入成功，而在调用之后，成功注入了 bean2 和 home，但 home 的值似乎有点奇怪，并没有打印出前文中相同的值，可能是因为没有成功解析 #{}？</p><p>至于 bean3 为什么没注入成功，是因为 <code>bean3</code> 的注入是利用 @Resource，而不是 @Autowired。如果对 Bean1 进行修改：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Bean3 bean3;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean3</span><span class="params">(Bean3 bean3)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;@Resource 生效: &#123;&#125;&quot;</span>, bean3);</span><br><span class="line">        <span class="built_in">this</span>.bean3 = bean3;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">Bean1(bean2=<span class="literal">null</span>, bean3=<span class="literal">null</span>, home=<span class="literal">null</span>)</span><br><span class="line"><span class="number">21</span>:<span class="number">36</span>:<span class="number">36.402</span> [main] INFO indi.lcp.bean.a04.Bean1 - <span class="meta">@Value</span> 生效: $&#123;JAVA_HOME&#125;</span><br><span class="line"><span class="number">21</span>:<span class="number">36</span>:<span class="number">36.406</span> [main] INFO indi.lcp.bean.a04.Bean1 - <span class="meta">@Autowired</span> 生效: indi.lcp.bean.a04.Bean2@490ab905</span><br><span class="line"><span class="title function_">Bean1</span><span class="params">(bean2=indi.lcp.bean.a04.Bean2@490ab905, bean3=indi.lcp.bean.a04.Bean3@56ac3a89, home=$&#123;JAVA_HOME&#125;)</span></span><br></pre></td></tr></table></figure><p>成功注入了 bean3。如果想要成功注入 home，则需要在 BeanFactory 中添加 #{} 的解析器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// $&#123;&#125; 的解析器</span></span><br><span class="line">    beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>()::resolvePlaceholders);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    postProcessor.postProcessProperties(<span class="literal">null</span>, bean1, <span class="string">&quot;bean1&quot;</span>);</span><br><span class="line">    System.out.println(bean1);</span><br><span class="line">&#125;</span><br><span class="line">Bean1(bean2=<span class="literal">null</span>, bean3=<span class="literal">null</span>, home=<span class="literal">null</span>)</span><br><span class="line">indi.lcp.bean.a04.Bean1 - <span class="meta">@Value</span> 生效: D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">indi.lcp.bean.a04.Bean1 - <span class="meta">@Autowired</span> 生效: indi.lcp.bean.a04.Bean2@4fe3c938</span><br><span class="line"><span class="title function_">Bean1</span><span class="params">(bean2=indi.lcp.bean.a04.Bean2@4fe3c938, bean3=indi.lcp.bean.a04.Bean3@5383967b, home=D:\environment\JDK1<span class="number">.8</span>)</span></span><br></pre></td></tr></table></figure><p>AutowiredAnnotationBeanPostProcessor#postProcessProperties()</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> &#123;</span><br><span class="line">    <span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        metadata.inject(bean, beanName, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Injection of autowired dependencies failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 findAutowiringMetadata() 用于查找指定的 bean 对象中哪些地方使用了 @Autowired、@Value 等与注入相关的注解，并将这些信息封装在 InjectionMetadata 对象中，之后调用其 inject() 方法利用反射完成注入。</p><p>findAutowiringMetadata() 方法是一个私有方法，尝试利用反射进行调用并进行断点查看 InjectionMetadata 对象中的信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">AutowiredAnnotationBeanPostProcessor</span> <span class="variable">postProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutowiredAnnotationBeanPostProcessor</span>();</span><br><span class="line">    postProcessor.setBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="type">Bean1</span> <span class="variable">bean1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> AutowiredAnnotationBeanPostProcessor.class.getDeclaredMethod(<span class="string">&quot;findAutowiringMetadata&quot;</span>, String.class, Class.class, PropertyValues.class);</span><br><span class="line">    method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 获取 Bean1 上加了 @Value、@Autowired 注解的成员变量、方法参数信息</span></span><br><span class="line">    <span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> (InjectionMetadata) method.invoke(postProcessor, <span class="string">&quot;bean1&quot;</span>, Bean1.class, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 此处断点</span></span><br><span class="line">    System.out.println(metadata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InjectionMetadata 中有一个名为 injectedElements 的集合类型成员变量，injectedElements 存储了被相关注解标记的成员变量、方法的信息，因为 Bean1 中的 bean3 成员变量、setBean2() ，setHome() 方法恰好被 @Autowired 注解标记。</p><p>然后按照源码一样，调用 InjectionMetadata#inject() 方法进行依赖注入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Bean1 上加了 @Value、@Autowired 注解的成员变量、方法参数信息</span></span><br><span class="line">    <span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> (InjectionMetadata) method.invoke(postProcessor, <span class="string">&quot;bean1&quot;</span>, Bean1.class, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 InjectionMetadata 来进行依赖注入，注入时按类型查找值</span></span><br><span class="line">    metadata.inject(bean1, <span class="string">&quot;bean1&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(bean1);</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a04.Bean1 - <span class="meta">@Value</span> 生效: D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">indi.lcp.bean.a04.Bean1 - <span class="meta">@Autowired</span> 生效: indi.lcp.bean.a04.Bean2@5383967b</span><br><span class="line"><span class="title function_">Bean1</span><span class="params">(bean2=indi.lcp.bean.a04.Bean2@5383967b, bean3=indi.lcp.bean.a04.Bean3@2ac273d3, home=D:\environment\JDK1<span class="number">.8</span>)</span></span><br></pre></td></tr></table></figure><p>调用 inject() 方法后会利用反射进行依赖注入，但在反射之前，肯定得先拿到被注入的对象或值，那这些对象或值是怎么取到的呢？</p><p>可以通过以下代码概括：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如何按类型查找值</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">bean3</span> <span class="operator">=</span> Bean1.class.getDeclaredField(<span class="string">&quot;bean3&quot;</span>);</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(bean3, <span class="literal">false</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> beanFactory.doResolveDependency(dd1, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(o1);</span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">setBean2</span> <span class="operator">=</span> Bean1.class.getDeclaredMethod(<span class="string">&quot;setBean2&quot;</span>, Bean2.class);</span><br><span class="line">    <span class="comment">// MethodParameter 构造方法的第二个参数表示需要解析的方法中参数的索引</span></span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(<span class="keyword">new</span> <span class="title class_">MethodParameter</span>(setBean2, <span class="number">0</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> beanFactory.doResolveDependency(dd2, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(o2);</span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">setHome</span> <span class="operator">=</span> Bean1.class.getDeclaredMethod(<span class="string">&quot;setHome&quot;</span>, String.class);</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(<span class="keyword">new</span> <span class="title class_">MethodParameter</span>(setHome, <span class="number">0</span>), <span class="literal">true</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o3</span> <span class="operator">=</span> beanFactory.doResolveDependency(dd3, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(o3);</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a04.Bean3@2ac273d3</span><br><span class="line">indi.lcp.bean.a04.Bean2@192b07fd</span><br><span class="line">D:\environment\JDK1<span class="number">.8</span></span><br></pre></td></tr></table></figure><h1 id="BeanFactory-后置处理器"><a href="#BeanFactory-后置处理器" class="headerlink" title="BeanFactory 后置处理器"></a><strong>BeanFactory 后置处理器</strong></h1><h2 id="5-1-常见的-BeanFactory-后置处理器"><a href="#5-1-常见的-BeanFactory-后置处理器" class="headerlink" title="5.1 常见的 BeanFactory 后置处理器"></a><strong>5.1 常见的 BeanFactory 后置处理器</strong></h2><p>先引入要用到的依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要用到的类信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.lcp.bean.a05;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;indi.lcp.bean.a05.component&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/advanced_spring&quot;</span>);</span><br><span class="line">        dataSource.setName(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> indi.lcp.bean.a05;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我被 Spring 管理啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> indi.lcp.bean.a05.component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean2</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我被 Spring 管理啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续使用 GenericApplicationContext 作为容器，向容器中注册 config：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">config</span><br></pre></td></tr></table></figure><p>并没有打印出除 config 以外的 Bean 信息，也就是说 Config 类中的 @ComponentScan 和 @Bean 注解都没有生效。</p><p>根据经验，显然是因为缺少某个后置处理器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">    <span class="comment">// @ComponentScan @Bean @Import @ImportResource</span></span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a05.component.Bean2 - 我被 Spring 管理啦</span><br><span class="line">indi.lcp.bean.a05.Bean1 - 我被 Spring 管理啦</span><br><span class="line">com.alibaba.druid.pool.DruidDataSource - &#123;dataSource-<span class="number">1</span>,root&#125; inited</span><br><span class="line">config</span><br><span class="line">org.springframework.context.annotation.ConfigurationClassPostProcessor</span><br><span class="line">bean2</span><br><span class="line">bean1</span><br><span class="line">sqlSessionFactoryBean</span><br><span class="line">dataSource</span><br></pre></td></tr></table></figure><p>在使用 MyBatis 时，经常会使用到 @Mapper 注解，而这个注解的解析也需要使用到特定的 BeanFactory 后置处理器。</p><p>以下两个接口被 @Mapper 注解标记：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.lcp.bean.a05.mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mapper1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mapper2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后添加解析 @Mapper 注解的后置处理器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">    <span class="comment">// @ComponentScan @Bean @Import @ImportResource</span></span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">    context.registerBean(MapperScannerConfigurer.class,</span><br><span class="line">                i -&gt; i.getPropertyValues().add(<span class="string">&quot;basePackage&quot;</span>, <span class="string">&quot;indi.lcp.bean.a05.mapper&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 basePackage 是 MapperScannerConfigurer 中的一个成员变量，表示需要扫描的包路径，设置的值恰好是被 @Mapper 注解标记的接口所在的包路径。</p><p>控制台打印的信息中增加了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mapper1</span><br><span class="line">mapper2</span><br></pre></td></tr></table></figure><h2 id="5-2-模拟实现"><a href="#5-2-模拟实现" class="headerlink" title="5.2 模拟实现"></a><strong>5.2 模拟实现</strong></h2><p>移除向容器中添加的 ConfigurationClassPostProcessor 和 MapperScannerConfigurer 两个后置处理器，自行编码模拟它们功能的实现。</p><ul><li>组件扫描之 @ComponentScan</li></ul><p>在 Bean2 所在包路径下再增加两个类，用于后续测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.lcp.bean.a05.component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean3</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我被 Spring 管理啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean4</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我被 Spring 管理啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 ComponentScanPostProcessor 用于实现 @ComponentScan 注解的解析：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lcp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/1/7 22:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentScanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用 context.refresh() 方法时回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="type">ComponentScan</span> <span class="variable">componentScan</span> <span class="operator">=</span> AnnotationUtils.findAnnotation(Config.class, ComponentScan.class);</span><br><span class="line">        <span class="keyword">if</span> (componentScan != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String packageName : componentScan.basePackages()) &#123;</span><br><span class="line">                System.out.println(packageName);</span><br><span class="line">                <span class="comment">// indi.lcp.bean.a05.component -&gt; classpath*:indi/lcp/bean/a05/component/**/**.class</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;classpath*:&quot;</span> + packageName.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>) + <span class="string">&quot;/**/**.class&quot;</span>;</span><br><span class="line">                <span class="comment">//  Resource[] resources = context.getResources(path);</span></span><br><span class="line">                Resource[] resources = <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>().getResources(path);</span><br><span class="line">                <span class="type">CachingMetadataReaderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">                <span class="type">AnnotationBeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationBeanNameGenerator</span>();</span><br><span class="line">                <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                    <span class="type">MetadataReader</span> <span class="variable">reader</span> <span class="operator">=</span> factory.getMetadataReader(resource);</span><br><span class="line">                    <span class="type">AnnotationMetadata</span> <span class="variable">annotationMetadata</span> <span class="operator">=</span> reader.getAnnotationMetadata();</span><br><span class="line"><span class="comment">//                    System.out.println(&quot;类名: &quot; + reader.getClassMetadata().getClassName());</span></span><br><span class="line"><span class="comment">//                    System.out.println(&quot;是否加了 @Component: &quot; + annotationMetadata.hasAnnotation(Component.class.getName()));</span></span><br><span class="line"><span class="comment">//                    System.out.println(&quot;是否加了 @Component 派生: &quot; + annotationMetadata.hasMetaAnnotation(Component.class.getName()));</span></span><br><span class="line">                    <span class="keyword">if</span> (annotationMetadata.hasAnnotation(Component.class.getName())</span><br><span class="line">                            || annotationMetadata.hasMetaAnnotation(Component.class.getName())) &#123;</span><br><span class="line">                        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(reader.getClassMetadata().getClassName())</span><br><span class="line">                                .getBeanDefinition();</span><br><span class="line">                        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> generator.generateBeanName(beanDefinition, registry);</span><br><span class="line">                        registry.registerBeanDefinition(name, beanDefinition);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">    context.registerBean(ComponentScanPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a05.component</span><br><span class="line">indi.lcp.bean.a05.component.Bean2      : 我被 Spring 管理啦</span><br><span class="line">indi.lcp.bean.a05.component.Bean3      : 我被 Spring 管理啦</span><br><span class="line">config</span><br><span class="line">indi.lcp.bean.a05.ComponentScanPostProcessor</span><br><span class="line">bean2</span><br><span class="line">bean3</span><br></pre></td></tr></table></figure><p>没使用 ConfigurationClassPostProcessor 也实现了 @ComponentScan 注解的解析！</p><ul><li>@Bean 的解析</li></ul><p>Config 类中再增加一个方法作为干扰项：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;indi.lcp.bean.a05.component&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与解析 @ComponentScan 一样，自行编写一个 BeanFactoryPostProcessor 的实现类用于解析 @Bean 注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lcp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/1/7 22:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="type">CachingMetadataReaderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">        <span class="type">MetadataReader</span> <span class="variable">reader</span> <span class="operator">=</span> factory.getMetadataReader(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;indi/lcp/bean/a05/Config.class&quot;</span>));</span><br><span class="line">        Set&lt;MethodMetadata&gt; methods = reader.getAnnotationMetadata().getAnnotatedMethods(Bean.class.getName());</span><br><span class="line">        <span class="keyword">for</span> (MethodMetadata method : methods) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">            <span class="type">String</span> <span class="variable">initMethod</span> <span class="operator">=</span> method.getAnnotationAttributes(Bean.class.getName()).get(<span class="string">&quot;initMethod&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getMethodName();</span><br><span class="line">            <span class="type">BeanDefinitionBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition()</span><br><span class="line">                    .setFactoryMethodOnBean(methodName, <span class="string">&quot;config&quot;</span>)</span><br><span class="line">                    <span class="comment">// 工厂方法、构造方法的注入模式使用构造器模式</span></span><br><span class="line">                    .setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(initMethod)) &#123;</span><br><span class="line">                builder.setInitMethodName(initMethod);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> builder.getBeanDefinition();</span><br><span class="line">            registry.registerBeanDefinition(methodName, beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造 BeanDefinition 时调用了 setAutowireMode() 方法设置注入模式，这是因为在 <code>Config</code> 类中有一特殊的被 @Bean 标记的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">    <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">    sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收一个 DataSource 类型的参数，需要将容器中这个类型的 Bean 进行注入，设置的 AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR 注入模式则能完成这个功能。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(AtBeanPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a05.Config.bean1()</span><br><span class="line">indi.lcp.bean.a05.Config.sqlSessionFactoryBean(javax.sql.DataSource)</span><br><span class="line">indi.lcp.bean.a05.Config.dataSource()</span><br><span class="line">indi.lcp.bean.a05.Bean1                : 我被 Spring 管理啦</span><br><span class="line">com.alibaba.druid.pool.DruidDataSource   : &#123;dataSource-<span class="number">1</span>,root&#125; inited</span><br><span class="line">config</span><br><span class="line">indi.lcp.bean.a05.AtBeanPostProcessor</span><br><span class="line">bean1</span><br><span class="line">sqlSessionFactoryBean</span><br><span class="line">dataSource</span><br></pre></td></tr></table></figure><ul><li>@Mapper 的解析</li></ul><p>@Mapper 注解是在接口上使用的，但根据前文内容可知，@Mapper 被解析后在 Spring 容器中也存在与被标记的接口相关的 Bean。</p><p>难道 Spring 能管理接口？</p><p>那肯定是不行的，Spring 只能管理对象这是毋庸置疑的。那这些接口是怎么变成对象被 Spring 管理的呢？</p><p>这依赖于 MapperFactoryBean 将接口转换为对象。</p><p>在 Config 添加注册 Mapper1 和 Mapper2 的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MapperFactoryBean&lt;Mapper1&gt; <span class="title function_">mapper1</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">    MapperFactoryBean&lt;Mapper1&gt; factoryBean = <span class="keyword">new</span> <span class="title class_">MapperFactoryBean</span>&lt;&gt;(Mapper1.class);</span><br><span class="line">    factoryBean.setSqlSessionFactory(sqlSessionFactory);</span><br><span class="line">    <span class="keyword">return</span> factoryBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MapperFactoryBean&lt;Mapper2&gt; <span class="title function_">mapper2</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">    MapperFactoryBean&lt;Mapper2&gt; factoryBean = <span class="keyword">new</span> <span class="title class_">MapperFactoryBean</span>&lt;&gt;(Mapper2.class);</span><br><span class="line">    factoryBean.setSqlSessionFactory(sqlSessionFactory);</span><br><span class="line">    <span class="keyword">return</span> factoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再运行 main() 方法可以看到容器中存在名为 mapper1 和 mapper2 的 Bean。</p><p>这种方式虽然可以完成 Mapper 接口的注册，但每次只能单个注册，不能批量注册。</p><p>移除 Config 类中的 mapper1() 和 mapper2() 方法，自行编写 BeanDefinitionRegistryPostProcessor 接口的实现类完成 @Mapper 注解的解析：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lcp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/1/7 23:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="type">PathMatchingResourcePatternResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line">        Resource[] resources = resolver.getResources(<span class="string">&quot;classpath:indi/lcp/bean/a05/mapper/**/*.class&quot;</span>);</span><br><span class="line">        <span class="type">AnnotationBeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationBeanNameGenerator</span>();</span><br><span class="line">        <span class="type">CachingMetadataReaderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">        <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">            <span class="type">MetadataReader</span> <span class="variable">reader</span> <span class="operator">=</span> factory.getMetadataReader(resource);</span><br><span class="line">            <span class="type">ClassMetadata</span> <span class="variable">classMetadata</span> <span class="operator">=</span> reader.getClassMetadata();</span><br><span class="line">            <span class="keyword">if</span> (classMetadata.isInterface()) &#123;</span><br><span class="line">                <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(MapperFactoryBean.class)</span><br><span class="line">                        .addConstructorArgValue(classMetadata.getClassName())</span><br><span class="line">                        .setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE)</span><br><span class="line">                        .getBeanDefinition();</span><br><span class="line">                <span class="type">AbstractBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(classMetadata.getClassName())</span><br><span class="line">                        .getBeanDefinition();</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> generator.generateBeanName(bd, registry);</span><br><span class="line">                registry.registerBeanDefinition(name, beanDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line"></span><br><span class="line">    context.registerBean(AtBeanPostProcessor.class);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * AtBeanPostProcessor 的注册不能少，因为需要容器中存在 SqlSessionFactoryBean</span></span><br><span class="line"><span class="comment">     * 而 SqlSessionFactoryBean 是在配置类中利用 @Bean 进行注册的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    context.registerBean(MapperPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a05.Config.bean1()</span><br><span class="line">indi.lcp.bean.a05.Config.sqlSessionFactoryBean(javax.sql.DataSource)</span><br><span class="line">indi.lcp.bean.a05.Config.dataSource()</span><br><span class="line">indi.lcp.bean.a05.Bean1                : 我被 Spring 管理啦</span><br><span class="line">com.alibaba.druid.pool.DruidDataSource   : &#123;dataSource-<span class="number">1</span>,root&#125; inited</span><br><span class="line">config</span><br><span class="line">indi.lcp.bean.a05.AtBeanPostProcessor</span><br><span class="line">indi.lcp.bean.a05.MapperPostProcessor</span><br><span class="line">bean1</span><br><span class="line">sqlSessionFactoryBean</span><br><span class="line">dataSource</span><br><span class="line">mapper1</span><br><span class="line">mapper2</span><br></pre></td></tr></table></figure><p>容器中存在 mapper1 和 mapper2 两个 Bean。</p><h2 id="5-3-注册创建完成的-Bean"><a href="#5-3-注册创建完成的-Bean" class="headerlink" title="5.3. 注册创建完成的 Bean"></a>5.3. <strong>注册创建完成的 Bean</strong></h2><p>如果要将 Bean 添加到 Spring 容器中，需要先根据配置文件或注解信息为每一个 Bean 生成一个 BeanDefinition，然后将这些 BeanDefinition 添加到 BeanDefinitionRegistry 中，当创建 Bean 对象时，直接从 BeanDefinitionRegistry 中获取 BeanDefinition 来生成 Bean。</p><p>如果生成的 Bean 是单例的，Spring 会将它们保存到 SingletonBeanRegistry 中，后续需要时从这里面寻找，避免重复创建。</p><p>那么向 Spring 容器中添加单例 Bean 时，可以跳过注册 BeanDefinition，直接SingletonBeanRegistry 中添加创建完成的 Bean。既然添加的是创建完成的 Bean，所以 <strong>这个 Bean 不会经过 Spring 的生命周期。</strong></p><p>SingletonBeanRegistry 是一个接口，它有一个子接口名为 ConfigurableListableBeanFactory，而这恰好是 BeanFactoryPostProcessor 接口中抽象方法的参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试使用 BeanFactoryPostProcessor 注册创建完成的 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;bean2&quot;</span>, Bean2.class);</span><br><span class="line">        context.registerBean(MyBeanFactoryPostProcessor.class);</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">        System.out.println(context.getBean(Bean1.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">            <span class="type">Bean1</span> <span class="variable">bean1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">            bean1.setName(<span class="string">&quot;lcp&quot;</span>);</span><br><span class="line">            beanFactory.registerSingleton(<span class="string">&quot;bean1&quot;</span>, bean1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@ToString</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">        <span class="meta">@Setter</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setBean2</span><span class="params">(Bean2 bean2)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;依赖注入 bean2&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.bean2 = bean2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;初始化...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">bean2</span><br><span class="line">testBeanFactoryPostProcessor.MyBeanFactoryPostProcessor</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">TestBeanFactoryPostProcessor.Bean1(name=lcp, bean2=<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>BeanDefinition 的名称数组中不包含 bean1，也没有输出任何与经过 Spring 生命周期相关的日志信息，容器中 bean1 里注入的 bean2 也是 null。这表明通过这种方式注册的 Bean 不会注册 BeanDefinition，也不会经过 Spring 生命周期。</p><h1 id="Aware-接口"><a href="#Aware-接口" class="headerlink" title="Aware 接口"></a>Aware 接口</h1><h2 id="6-1-Aware-接口"><a href="#6-1-Aware-接口" class="headerlink" title="6.1. Aware 接口"></a>6.1. Aware 接口</h2><p>Aware 接口用于注入一些与容器相关的信息，比如：</p><ul><li>BeanNameAware 注入 Bean 的名字</li><li>BeanFactoryAware 注入 BeanFactory 容器</li><li>ApplicationContextAware 注入 ApplicationContext 容器</li><li>EmbeddedValueResolverAware 解析 ${}</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lcp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/1/8 16:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>, ApplicationContextAware &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前 Bean: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot;名字叫: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前 Bean: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot;容器是: &quot;</span> + applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;myBean&quot;</span>, MyBean.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">当前 Bean: indi.lcp.bean.a06.MyBean@16f7c8c1名字叫: myBean</span><br><span class="line">当前 Bean: indi.lcp.bean.a06.MyBean@16f7c8c1容器是: org.springframework.context.support.GenericApplicationContext@2669b199</span><br></pre></td></tr></table></figure><h2 id="6-2-InitializingBean"><a href="#6-2-InitializingBean" class="headerlink" title="6.2. InitializingBean"></a>6.2. InitializingBean</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>, ApplicationContextAware, InitializingBean &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前 Bean: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; 初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行 main() 方法有：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当前 Bean: indi.lcp.bean.a06.MyBean@16f7c8c1名字叫: myBean</span><br><span class="line">当前 Bean: indi.lcp.bean.a06.MyBean@16f7c8c1容器是: org.springframework.context.support.GenericApplicationContext@2669b199</span><br><span class="line">当前 Bean: indi.lcp.bean.a06.MyBean<span class="meta">@df27fae</span> 初始化</span><br></pre></td></tr></table></figure><p>当同时实现 Aware 接口和 InitializingBean 接口时，会先执行 Aware 接口。</p><p>BeanFactoryAware 、ApplicationContextAware 和 EmbeddedValueResolverAware 三个接口的功能可以使用 @Autowired 注解实现，InitializingBean 接口的功能也可以使用 @PostConstruct 注解实现，为什么还要使用接口呢？</p><p>@Autowired 和 @PostConstruct 注解的解析需要使用 Bean 后置处理器，属于拓展功能，而这些接口属于内置功能，不加任何拓展 Spring 就能识别。在某些情况下，拓展功能会失效，而内容功能不会失效。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>, ApplicationContextAware, InitializingBean &#123;</span><br><span class="line">           <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContextWithAutowired</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前 Bean: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; 使用 @Autowired 注解，容器是: &quot;</span> + applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前 Bean: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; 使用 @PostConstruct 注解初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再运行 main() 方法会发现使用的注解没有被成功解析，原因很简单，GenericApplicationContext 是一个干净的容器，其内部没有用于解析这些注解的后置处理器。如果想要这些注解生效，则需要像前文一样添加必要的后置处理器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context.registerBean(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">context.registerBean(CommonAnnotationBeanPostProcessor.class);</span><br></pre></td></tr></table></figure><h2 id="6-3-失效的-Autowired-注解"><a href="#6-3-失效的-Autowired-注解" class="headerlink" title="6.3. 失效的 @Autowired 注解"></a>6.3. 失效的 @Autowired 注解</h2><p>在某些情况下，尽管容器中存在必要的后置处理器，但 @Autowired 和 @PostConstruct 注解也会失效。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig1</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;注入 ApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;myConfig1&quot;</span>, MyConfig1.class);</span><br><span class="line">    context.registerBean(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">    context.registerBean(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">    <span class="comment">// 解析配置类中的注解</span></span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a06.MyConfig1            : 注入 ApplicationContext</span><br><span class="line">indi.lcp.bean.a06.MyConfig1            : 初始化</span><br></pre></td></tr></table></figure><p>@Autowired 和 @PostConstruct 注解成功被解析。</p><p>如果再对 Config1 进行一点小小的修改呢?</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig1</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BeanFactoryPostProcessor <span class="title function_">processor1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> processor -&gt; log.info(<span class="string">&quot;执行 processor1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Config1 中添加了一个被 @Bean 注解标记的 processor1() 方法，用于向容器中添加 BeanFactoryPostProcessor。</p><p>如果再运行 main() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.bean.a06.MyConfig1            : 执行 processor1</span><br></pre></td></tr></table></figure><p>processor1() 方法成功生效，但 @Autowired 和 @PostConstruct 注解的解析失败了。</p><p>对于 context.refresh(); 方法来说，它主要按照以下顺序干了三件事：</p><ul><li>执行 BeanFactory 后置处理器；</li><li>添加 Bean 后置处理器；</li><li>创建和初始化单例对象。</li></ul><p>比如当 Java 配置类不包括 BeanFactoryPostProcessor 时：</p><p>BeanFactoryPostProcessor 会在 Java 配置类初始化之前执行。</p><p>当 Java 配置类中定义了BeanFactoryPostProcessor 时，如果要创建配置类中的 BeanFactoryPostProcessor 就必须 提前 创建和初始化 Java 配置类。</p><p>在创建和初始化 Java 配置类时，由于 BeanPostProcessor 还未准备好，无法解析配置类中的 @Autowired 等注解，导致 @Autowired 等注解失效：</p><p>要解决这个问题也很简单，使用相关接口的功能实现注入和初始化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig2</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, ApplicationContextAware &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;注入 ApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BeanFactoryPostProcessor <span class="title function_">processor2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> processor -&gt; log.info(<span class="string">&quot;执行 processor2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改下 main() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;myConfig2&quot;</span>, MyConfig2.class);</span><br><span class="line">    context.registerBean(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">    context.registerBean(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析配置类中的注解</span></span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a06.MyConfig2            : 注入 ApplicationContext</span><br><span class="line">indi.lcp.bean.a06.MyConfig2            : 初始化</span><br><span class="line">indi.lcp.bean.a06.MyConfig2            : 执行 processor2</span><br></pre></td></tr></table></figure><ol><li><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li><li><p>Aware 接口提供了一种 内置 的注入手段，可以注入 BeanFactory、ApplicationContext；</p></li><li><p>InitializingBean 接口提供了一种 内置 的初始化手段；</p></li><li><p>内置的注入和初始化不受拓展功能的影响，总会被执行，因此 Spring 框架内部的类总是使用这些接口。</p></li></ol><h1 id="初始化与销毁"><a href="#初始化与销毁" class="headerlink" title="初始化与销毁"></a>初始化与销毁</h1><p>初始化和销毁 Bean 的实现有三种：</p><ol><li>依赖于后置处理器提供的拓展功能</li><li>相关接口的功能</li><li>使用 @Bean 注解中的属性进行指定</li></ol><p>当同时存在以上三种方式时，它们的执行顺序也将按照上述顺序进行执行。</p><p>包含三种初始化方式的 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;初始化1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;初始化2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init3</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;初始化3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含三种销毁方式的 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> <span class="keyword">implements</span> <span class="title class_">DisposableBean</span> &#123;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy1</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;销毁1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;销毁2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy3</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;销毁3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A07Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A07Application.class, args);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init3&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(destroyMethod = &quot;destroy3&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a07.Bean1                : 初始化<span class="number">1</span></span><br><span class="line">indi.lcp.bean.a07.Bean1                : 初始化<span class="number">2</span></span><br><span class="line">indi.lcp.bean.a07.Bean1                : 初始化<span class="number">3</span></span><br><span class="line">indi.lcp.bean.a07.Bean2                : 销毁<span class="number">1</span></span><br><span class="line">indi.lcp.bean.a07.Bean2                : 销毁<span class="number">2</span></span><br><span class="line">indi.lcp.bean.a07.Bean2                : 销毁<span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h1><h2 id="8-1-Scope-的类型与销毁"><a href="#8-1-Scope-的类型与销毁" class="headerlink" title="8.1 Scope 的类型与销毁"></a>8.1 Scope 的类型与销毁</h2><p>Scope 用于指定 Bean 的作用范围，有如下五个取值：</p><ul><li>singleton：单例（默认值）。容器启动时创建（未设置延迟），容器关闭时销毁</li><li>prototype：多例。每次使用时创建，不会自动销毁，需要调用 DefaultListableBeanFactory#destroyBean() 进行销毁</li><li>request：作用于 Web 应用的请求范围。每次请求用到此 Bean 时创建，请求结束时销毁</li><li>session：作用于 Web 应用的会话范围。每个会话用到此 Bean 时创建，会话结束时销毁</li><li>application：作用于 Web 应用的 ServletContext。Web 容器用到此 Bean 时创建，容器关闭时销毁</li></ul><p>前两个取值不再赘述，重点看下后三个取值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(WebApplicationContext.SCOPE_REQUEST)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanForRequest</span> &#123;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(WebApplicationContext.SCOPE_SESSION)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanForSession</span> &#123;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(WebApplicationContext.SCOPE_APPLICATION)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanForApplication</span> &#123;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写一个 Controller 进行测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanForRequest beanForRequest;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanForSession beanForSession;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanForApplication beanForApplication;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/test&quot;, produces = &quot;text/html&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(HttpServletRequest request, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置 session 过期时间为 10 秒</span></span><br><span class="line">        session.setMaxInactiveInterval(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// ServletContext sc = request.getServletContext();</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;ul&gt;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;li&gt;request scope: &quot;</span> +  beanForRequest + <span class="string">&quot;&lt;/li&gt;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;li&gt;session scope: &quot;</span> +  beanForSession + <span class="string">&quot;&lt;/li&gt;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;li&gt;application scope: &quot;</span> +  beanForApplication + <span class="string">&quot;&lt;/li&gt;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;/ul&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主启动类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A08Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(A08Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用的 JDK 版本大于 8，需要要启动参数中添加如下信息避免报错：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--add-opens java.base/java.lang=ALL-UNNAMED</span><br></pre></td></tr></table></figure><p>但更建议在 pom.xml 中添加以下配置，一劳永逸：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;argLine&gt;</span><br><span class="line">                    --add-opens java.base/java.lang=ALL-UNNAMED</span><br><span class="line">                &lt;/argLine&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>运行主启动类，在浏览器中访问 <a href="http://localhost:8080/test%EF%BC%8C%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%98%BE%E7%A4%BA%EF%BC%9A">http://localhost:8080/test，页面上显示：</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request scope: indi.lcp.bean.a08.BeanForRequest@34d37122</span><br><span class="line">session scope: indi.lcp.bean.a08.BeanForSession@75ee7b19</span><br><span class="line">application scope: indi.lcp.bean.a08.BeanForApplication@68b50897</span><br></pre></td></tr></table></figure><p>刷新页面，页面上的信息变化为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request scope: indi.lcp.bean.a08.BeanForRequest@2db4ac39</span><br><span class="line">session scope: indi.lcp.bean.a08.BeanForSession@75ee7b19</span><br><span class="line">application scope: indi.lcp.bean.a08.BeanForApplication@68b50897</span><br></pre></td></tr></table></figure><p>可以看到 request scope 发生了变化，session scope 和 application scope 没有变化。</p><p>这是因为刷新页面后就产生了一个新的请求，而 request 的作用范围只在一个请求内，因此每一个新请求就对应一个新的对象。</p><p>那要怎么改变 session scope 呢？</p><p>换一个浏览器访问 <a href="http://localhost:8080/test%EF%BC%8C%E4%B8%A4%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E4%BC%9A%E8%AF%9D%E8%82%AF%E5%AE%9A%E4%B8%8D%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%EF%BC%8C%E6%AD%A4%E6%97%B6">http://localhost:8080/test，两个浏览器中的会话肯定不是同一个，此时</a> session scope 应该会发生变化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request scope: indi.lcp.bean.a08.BeanForRequest@2286f290</span><br><span class="line">session scope: indi.lcp.bean.a08.BeanForSession@4f025f73</span><br><span class="line">application scope: indi.lcp.bean.a08.BeanForApplication@68b50897</span><br></pre></td></tr></table></figure><p>application 的作用范围是 ServletContext，要想 application scope 发生变化可以重启程序。</p><ul><li>销毁</li></ul><p>当刷新页面后，除了 request scope 的值发生变化外，在 IDEA 的控制台能看到以下信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.bean.a08.BeanForRequest       : destroy</span><br></pre></td></tr></table></figure><p>这表示 request 作用范围的 Bean 进行了销毁，执行了销毁方法。</p><p>如果想看到 session 作用范围的 Bean 执行销毁方法，可以等 session 过期时在控制台上看到对应的信息。默认情况下，session 的过期时间是 30 分钟，为了更好地测试，可以在配置文件中添加：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 修改 session 过期时间为 10s</span><br><span class="line">server.servlet.session.timeout=10s</span><br></pre></td></tr></table></figure><p>这个配置是全局的，如果只想针对某个请求进行配置，则可以：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/test&quot;, produces = &quot;text/html&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(HttpServletRequest request, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置 session 过期时间为 10 秒</span></span><br><span class="line">    session.setMaxInactiveInterval(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置 session 过期时间为 10 秒后，并不表示不进行任何操作 10 秒后就能在控制台上看到执行销毁方法的信息，经过测试，大概会等 1 分钟，静静等待 1 分钟左右，控制台上显示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.bean.a08.BeanForSession       : destroy</span><br></pre></td></tr></table></figure><p>很遗憾没有办法看到 application 作用范围的 Bean 执行销毁方法，因为 Spring 似乎并没有对 application 作用范围的 Bean 进行正确的销毁处理，因此在 Servlet 容器销毁时看不到 application 作用范围的 Bean 执行销毁方法。</p><h2 id="8-2-Scope-失效分析"><a href="#8-2-Scope-失效分析" class="headerlink" title="8.2. Scope 失效分析"></a>8.2. Scope 失效分析</h2><p>现有两个类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">F1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> F1 f1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后进行测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;indi.lcp.bean.a09&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A09Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A09Application.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> context.getBean(E.class);</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF1());</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF1());</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF1());</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在问题来了：F1 被 @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) 标记，之后向 e 中注入了 f1，那么 log.info(“{}”, e.getF1()); 打印出的 f1 应该都不是同一个对象吗？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F1@5fdcaa40</span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F1@5fdcaa40</span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F1@5fdcaa40</span><br></pre></td></tr></table></figure><p>获取到的 f1 居然都是同一个，也就是说向单例对象中注入多例对象失败了。</p><p>对于单例对象来说，依赖注入仅发生了一次，后续不会再注入其他的 f1，因此 e 始终使用的是第一次注入的 f1：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NDUzMTFiYTBlZjFlZGJhZDU4NzdkOTU3ZDVjMTZhZWJfVnRoUEJZYXZaeVpTUXdsclRkSTd2VFo5UzhKUEVLdzdfVG9rZW46UWxySGJwTm1Hb2xjZEx4UEozTmNmTUhEbmtoXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>为了解决这个问题，可以使用 @Lazy 生成代理对象，虽然代理对象依旧是同一个，但每次使用代理对象中的方法时，会由代理对象创建新的目标对象：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTI3ZmUxMzE3MjU3MWM2NGRlODM5OGU5NWI1MDUwNDJfeldLT0t1QU83VVBtV3JSbmtNWmhiMHJ1clB6OHlvUDdfVG9rZW46UWU0MWJRRVdrb29JT3J4OWQxNGNNN0lZblVmXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>解决方式一</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> F1 f1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再修改下 main() 方法，打印下 f1 的 Class 信息，查看是否是代理对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A09Application.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> context.getBean(E.class);</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF1().getClass());</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF1());</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF1());</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF1());</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a09.A09Application       : <span class="keyword">class</span> <span class="title class_">indi</span>.lcp.bean.a09.F1$$EnhancerBySpringCGLIB$$ea96cbb5</span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F1@<span class="number">37271612</span></span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F1@4c309d4d</span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F1@37883b97</span><br></pre></td></tr></table></figure><p>使用 @Lazy 注解后，注入的是代理对象，每次获取到的 f1 不再是同一个。</p><p>解决方式二</p><p>除了使用 @Lazy 注解外，可以使用 @Scope 注解的 proxyMode 属性指定代理模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(</span></span><br><span class="line"><span class="meta">        value = ConfigurableBeanFactory.SCOPE_PROTOTYPE,</span></span><br><span class="line"><span class="meta">        proxyMode = ScopedProxyMode.TARGET_CLASS</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">F2</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> F2 f2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后再测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;indi.lcp.bean.a09&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A09Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A09Application.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> context.getBean(E.class);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF2().getClass());</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF2());</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF2());</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF2());</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a09.A09Application       : <span class="keyword">class</span> <span class="title class_">indi</span>.lcp.bean.a09.F2$$EnhancerBySpringCGLIB$$f28665e2</span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F2@2525ff7e</span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F2@524d6d96</span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F2@152aa092</span><br></pre></td></tr></table></figure><p>解决方式三</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">F3</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectFactory&lt;F3&gt; f3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> F3 <span class="title function_">getF3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> f3.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;indi.lcp.bean.a09&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A09Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A09Application.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> context.getBean(E.class);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF3());</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF3());</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F3@76f2bbc1</span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F3@306cf3ea</span><br></pre></td></tr></table></figure><p>解决方式四</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">F4</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> F4 <span class="title function_">getF4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(F4.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;indi.lcp.bean.a09&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A09Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A09Application.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> context.getBean(E.class);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF4());</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF4());</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F4@2beee7ff</span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F4@5136d012</span><br></pre></td></tr></table></figure><p>如果对性能要求较高，则推荐使用后两种方式，前两种使用代理会有一定的性能损耗；如果不在乎那点性能损耗，则可以使用第一种方式，这种方式最简单。</p><p>四种解决方式虽然不同，但在理念上殊途同归，都是推迟了其他 Scope Bean 的获取，或者说按需加载。</p><h1 id="AspectJ-编译器增强"><a href="#AspectJ-编译器增强" class="headerlink" title="AspectJ 编译器增强"></a>AspectJ 编译器增强</h1><p>创建一个 SpringBoot 项目，除了常见的依赖外，记得导入 AOP 相关的依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>Service 类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(MyService.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切面类，注意这个切面类没有被 Spring 管理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意此切面并未被 Spring 管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(MyAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* indi.lcp.service.MyService.foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;before()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于测试的主启动类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A10Application</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(A10Application.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A10Application.class, args);</span><br><span class="line">        <span class="type">MyService</span> <span class="variable">service</span> <span class="operator">=</span> context.getBean(MyService.class);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;service class: &#123;&#125;&quot;</span>, service.getClass());</span><br><span class="line">        service.foo();</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行主启动类后，控制台会显示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.A10Application                : service class: <span class="keyword">class</span> <span class="title class_">indi</span>.lcp.service.MyService</span><br><span class="line">indi.lcp.aop.MyAspect                  : before()</span><br><span class="line">indi.lcp.service.MyService             : foo()</span><br></pre></td></tr></table></figure><p>如果完全按照上述步骤进行，会发现 输出结果和给出的结果不一样。</p><p>在揭晓答案前，查看 service.getClass() 打印出的信息，它打印出的是原始类的 Class 信息，而非代理类的 Class 信息。</p><p>如果要问到 Spring AOP 的实现原理是什么，一下就能想到的是使用了代理，但这里并没有使用代理，依旧实现了增强。</p><p>这是因为在 pom.xml 中还引入了一个插件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;aspectj-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.11</span>&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;complianceLevel&gt;<span class="number">1.8</span>&lt;/complianceLevel&gt;</span><br><span class="line">                &lt;source&gt;<span class="number">8</span>&lt;/source&gt;</span><br><span class="line">                &lt;target&gt;<span class="number">8</span>&lt;/target&gt;</span><br><span class="line">                &lt;showWeaveInfo&gt;<span class="literal">true</span>&lt;/showWeaveInfo&gt;</span><br><span class="line">                &lt;verbose&gt;<span class="literal">true</span>&lt;/verbose&gt;</span><br><span class="line">                &lt;Xlint&gt;ignore&lt;/Xlint&gt;</span><br><span class="line">                &lt;encoding&gt;UTF-<span class="number">8</span>&lt;/encoding&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;execution&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;!-- use <span class="built_in">this</span> goal to weave all your main classes --&gt;</span><br><span class="line">                        &lt;goal&gt;compile&lt;/goal&gt;</span><br><span class="line">                        &lt;!-- use <span class="built_in">this</span> goal to weave all your test classes --&gt;</span><br><span class="line">                        &lt;goal&gt;test-compile&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                &lt;/execution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>之后不再使用 IDEA 自带的编译器进行编译，而是使用 Maven 编译</p><p>编译之后查看生成的 target 文件夹下的 MyService.class 文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(MyService.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyService</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        MyAspect.aspectOf().before();</span><br><span class="line">        log.info(<span class="string">&quot;foo()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 foo() 方法中增加了一行代码：MyAspect.aspectOf().before();，也就是这行代码对 foo() 方法实现了增强。</p><p>这种方式属于编译时增强，和 Lombok 类似。</p><p>既然如此，那岂不是说使用这种方式时，没有 Spring 容器也能实现方法的增强？</p><p>确实如此。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A10Application</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(A10Application.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyService</span>();</span><br><span class="line">        log.info(<span class="string">&quot;service class: &#123;&#125;&quot;</span>, service.getClass());</span><br><span class="line">        service.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.A10Application - service class: <span class="keyword">class</span> <span class="title class_">indi</span>.lcp.service.MyService</span><br><span class="line">indi.lcp.aop.MyAspect - before()</span><br><span class="line">indi.lcp.service.MyService - foo()</span><br></pre></td></tr></table></figure><p>除此之外，使用这种方式，就算 foo() 方法是静态方法，也能够成功增强。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(MyService.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A10Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyService.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.aop.MyAspect - before()</span><br><span class="line">indi.lcp.service.MyService - foo()</span><br></pre></td></tr></table></figure><h1 id="Agent-类加载"><a href="#Agent-类加载" class="headerlink" title="Agent 类加载"></a>Agent 类加载</h1><p>重新创建一个 SpringBoot 项目，同样需要导入 AOP 相关的依赖。</p><p>一个 Service 类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo()&quot;</span>);</span><br><span class="line">        bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;bar()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个切面类，注意这个切面类没有被 Spring 管理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* indi.lcp.service.MyService.*())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;before()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个用于测试的主启动类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A11Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A11Application.class, args);</span><br><span class="line">        <span class="type">MyService</span> <span class="variable">service</span> <span class="operator">=</span> context.getBean(MyService.class);</span><br><span class="line">        log.info(<span class="string">&quot;service class: &#123;&#125;&quot;</span>, service.getClass());</span><br><span class="line">        service.foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行主启动类后，控制台会显示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.A11Application                : service class: <span class="keyword">class</span> <span class="title class_">indi</span>.lcp.service.MyService</span><br><span class="line">indi.lcp.aop.MyAspect                  : before()</span><br><span class="line">indi.lcp.service.MyService             : foo()</span><br><span class="line">indi.lcp.aop.MyAspect                  : before()</span><br><span class="line">indi.lcp.service.MyService             : bar()</span><br></pre></td></tr></table></figure><p>如果完全按照上述步骤进行，会发现输出结果和给出的结果不一样。</p><p>那是怎么达到增强的效果呢？</p><p>首先得在 resources 目录下新建 META-INF 文件夹，并在 META-INF 目录下新建 aop.xml 文件，其内容如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;aspectj&gt;</span><br><span class="line">    &lt;aspects&gt;</span><br><span class="line">        &lt;!--    切面类全限定类名    --&gt;</span><br><span class="line">        &lt;aspect name=<span class="string">&quot;indi.lcp.aop.MyAspect&quot;</span>/&gt;</span><br><span class="line">        &lt;weaver options=<span class="string">&quot;-verbose -showWeaveInfo&quot;</span>&gt;</span><br><span class="line">            &lt;!--      被增强方法所在类的全限定类名      --&gt;</span><br><span class="line">            &lt;include within=<span class="string">&quot;indi.lcp.service.MyService&quot;</span>/&gt;</span><br><span class="line">            &lt;!--    切面类全限定类名    --&gt;</span><br><span class="line">            &lt;include within=<span class="string">&quot;indi.lcp.aop.MyAspect&quot;</span>/&gt;</span><br><span class="line">        &lt;/weaver&gt;</span><br><span class="line">    &lt;/aspects&gt;</span><br><span class="line">&lt;/aspectj&gt;</span><br></pre></td></tr></table></figure><p>在运行 main() 方法前添加 VM options：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-javaagent:D:\environment\Maven\<span class="number">3.6</span><span class="number">.3</span>-repository\.m2\repository\org\aspectj\aspectjweaver\<span class="number">1.9</span><span class="number">.7</span>\aspectjweaver-<span class="number">1.9</span><span class="number">.7</span>.jar</span><br></pre></td></tr></table></figure><p>其中的 D:\environment\Maven\3.6.3-repository.m2 指本地 Maven 仓库地址，还需要确保本地仓库中存在 1.9.7 版本的 aspectjweaver，否则修改至对应版本。</p><p>这时控制台输出的信息就和前文的内容一样了。</p><p>从输出的内容可以看到 service.getClass() 打印出的信息也是原始类的 Class 信息，而非代理类的 Class 信息。因此不依赖 Spring 容器，直接 new 一个 MyService 实例并调用其 foo() 方法也能达到增强的目的。</p><p>如果查看 MyService 对应的 class 文件，会发现其内容并没有被修改，可以断定不是编译时增强，这里是在类加载时增强</p><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><ol><li><h2 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h2></li></ol><p>JDK 动态代理 只能 针对接口进行代理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标对象</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来加载在运行期间动态生成的字节码</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> JdkProxyDemo.class.getClassLoader();</span><br><span class="line">        <span class="type">Foo</span> <span class="variable">proxy</span> <span class="operator">=</span> (Foo) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Foo.class&#125;, (p, method, params) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">            <span class="comment">// 目标.方法(参数) --&gt; 方法.invoke(目标, 参数)</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, params);</span><br><span class="line">            System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">            <span class="comment">// 也返回目标方法执行的结果</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        proxy.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before...</span><br><span class="line">target foo</span><br><span class="line">after...</span><br></pre></td></tr></table></figure><p>代理对象和目标对象是兄弟关系，都实现了相同的接口，因此不能将代理对象强转成目标对象类型；</p><p>代理类与目标类之间没有继承关系，因此目标类可以被 final 修饰。</p><h2 id="11-2-CGLib-动态代理"><a href="#11-2-CGLib-动态代理" class="headerlink" title="11.2. CGLib 动态代理"></a>11.2. CGLib 动态代理</h2><p>CGLib 动态代理与 JDK 动态代理不一样，无需目标类实现某个特定的接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Target</span> <span class="variable">proxy</span> <span class="operator">=</span> (Target) Enhancer.create(Target.class, (MethodInterceptor) (obj, method, params, methodProxy) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">            <span class="comment">// 用方法反射调用目标</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, params);</span><br><span class="line">            System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        proxy.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before...</span><br><span class="line">target foo</span><br><span class="line">after...</span><br></pre></td></tr></table></figure><p>调用目标方法的方式有三种，上文使用的是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, params);</span><br></pre></td></tr></table></figure><p>使用这种方式，将利用反射对目标方法进行调用。</p><p>还可以使用 methodProxy 不利用反射对目标方法进行调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部没使用反射，需要目标（spring 的选择）</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> methodProxy.invoke(target, args); </span><br><span class="line"><span class="comment">// 内部没使用反射，需要代理</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> methodProxy.invokeSuper(obj, args); </span><br></pre></td></tr></table></figure><ul><li>与 JDK 动态代理相比，CGLib 动态代理无需实现接口</li><li>代理对象和目标对象是父子关系，也就是说代理类继承了目标类</li><li>由于代理类继承了目标类，因此目标类不能被 final 修饰，否则将出现以下异常信息：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: Cannot subclass <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a12.CglibProxyDemo$Target</span><br></pre></td></tr></table></figure><ul><li>代理类继承目标类后，还会重写目标类中要求被增强的方法，因此被增强的方法不能被 final 修饰，否则将无法被增强，但不会抛出异常</li></ul><h1 id="JDK-动态代理原理"><a href="#JDK-动态代理原理" class="headerlink" title="JDK 动态代理原理"></a>JDK 动态代理原理</h1><h2 id="12-1-JDK-动态代理的模拟"><a href="#12-1-JDK-动态代理的模拟" class="headerlink" title="12.1 JDK 动态代理的模拟"></a>12.1 JDK 动态代理的模拟</h2><p>模拟 JDK 动态代理的实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">implements</span> <span class="title class_">A13</span>.Foo&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 功能增强</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 调用目标</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">A13</span>.Target().foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">$Proxy0</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">$Proxy0</span>();</span><br><span class="line">    proxy.foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before...</span><br><span class="line">target foo</span><br></pre></td></tr></table></figure><p>代码的实现很简单，但仔细想一下，如果是 JDK 中的实现：</p><p>“功能增强”的代码实现会直接硬编码吗？直接打印？</p><p>“调用目标”的代码就这样直接写上去？存不存在满足某些条件才调用目标的场景呢？</p><p>也就是说，“功能增强”和“调用目标”这两部分的代码都是不确定的。</p><p>针对这种“不确定”的实现，可以提供一个抽象类，等到用户具体使用时才实现抽象类，重写抽象方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">implements</span> <span class="title class_">A13</span>.Foo&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> A13.InvocationHandler h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(A13.InvocationHandler h) &#123;</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        h.invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">$Proxy0</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">$Proxy0</span>(<span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 功能增强</span></span><br><span class="line">            System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">            <span class="comment">// 2. 调用目标</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">A13</span>.Target().foo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    proxy.foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法，控制台依旧成功打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before...</span><br><span class="line">target foo</span><br></pre></td></tr></table></figure><p>多个抽象方法的接口</p><p>这样的实现依旧有问题，如果接口中提供了两个抽象方法呢？比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时无论是目标类，还是代理类都要重写这个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">implements</span> <span class="title class_">A13</span>.Foo&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> A13.InvocationHandler h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(A13.InvocationHandler h) &#123;</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        h.invoke();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        h.invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">$Proxy0</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">$Proxy0</span>(<span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 功能增强</span></span><br><span class="line">            System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">            <span class="comment">// 2. 调用目标</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">A13</span>.Target().foo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    proxy.foo();</span><br><span class="line">    <span class="comment">// 调用另一个方法</span></span><br><span class="line">    proxy.bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时再执行 main() 方法，控制台上打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before...</span><br><span class="line">target foo</span><br><span class="line">before...</span><br><span class="line">target foo</span><br></pre></td></tr></table></figure><p>打印结果有点问题。当调用代理对象的 bar() 方法时，输出了 target foo，而不是 bar() 方法应该打印的 target bar。</p><p>原因就出在实现 InvocationHandler 的 invoke() 方法时，依旧只调用了目标类的 foo() 方法，而不是 bar() 方法。</p><p>也就是说，在调用代理对象中的某个方法时，增强的应该是目标对象中对应的方法，希望在调用目标方法时能够动态编码。</p><p>那么可以在 invoke() 方法中添加两个入参，分别表示需要调用的目标方法和目标方法的参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加参数之后需要修改代理类，并将实现的抽象方法的 Method 对象与参数传递给 invoke() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">implements</span> <span class="title class_">A13</span>.Foo&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> A13.InvocationHandler h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(A13.InvocationHandler h) &#123;</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> A13.Foo.class.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        h.invoke(method, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> A13.Foo.class.getMethod(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        h.invoke(method, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要修改下 main() 方法中 InvocationHandler 的实现，利用传递的 Method 对象和参数信息反射调用目标方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">$Proxy0</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">$Proxy0</span>(<span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            <span class="comment">// 1. 功能增强</span></span><br><span class="line">            System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">            <span class="comment">// 2. 调用目标</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(<span class="keyword">new</span> <span class="title class_">Target</span>(), params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    proxy.foo();</span><br><span class="line">    <span class="comment">// 调用另一个方法</span></span><br><span class="line">    proxy.bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再执行 main() 方法，控制台上打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before...</span><br><span class="line">target foo</span><br><span class="line">before...</span><br><span class="line">target bar</span><br></pre></td></tr></table></figure><p>有返回值的抽象方法</p><p>优化还在继续，如果抽象方法有返回值呢？比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了这个接口的目标类和代理类重写的方法都需要有具体的返回值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target bar&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标类很简单，直接返回，那代理类返回什么？</p><p>InvocationHandler 的 invoke() 方法是对“功能增强”和“调用目标”的抽象，因此可以使 invoke() 方法也返回一个值，返回的值即为目标方法的返回值，这样就可以使得代理类中的方法有值可返。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    Object <span class="title function_">invoke</span><span class="params">(Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">implements</span> <span class="title class_">A13</span>.Foo &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> A13.InvocationHandler h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(A13.InvocationHandler h) &#123;</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">foo</span> <span class="operator">=</span> A13.Foo.class.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">            h.invoke(foo, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">bar</span> <span class="operator">=</span> A13.Foo.class.getMethod(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) h.invoke(bar, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 main() 方法，打印 bar() 方法的返回值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">$Proxy0</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">$Proxy0</span>(<span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            <span class="comment">// 1. 功能增强</span></span><br><span class="line">            System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">            <span class="comment">// 2. 调用目标</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">new</span> <span class="title class_">Target</span>(), params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    proxy.foo();</span><br><span class="line">    <span class="comment">// 调用另一个方法</span></span><br><span class="line">    System.out.println(proxy.bar());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before...</span><br><span class="line">target foo</span><br><span class="line">before...</span><br><span class="line">target bar</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><p>在静态代码块里创建 Method 实例</p><p>每调用一次代理对象中的方法都会创建一个 Method 实例，这些实例是可以复用的，因此可以将这些实例的创建移动到静态代码块中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">implements</span> <span class="title class_">A13</span>.Foo &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> A13.InvocationHandler h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(A13.InvocationHandler h) &#123;</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            h.invoke(foo, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) h.invoke(bar, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Method foo;</span><br><span class="line">    <span class="keyword">static</span> Method bar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            foo = A13.Foo.class.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">            bar = A13.Foo.class.getMethod(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invoke() 方法增加代理对象作为参数</p><p>在 JDK 提供的 InvocationHandler 接口的 invoke() 方法还将代理对象作为方法的参数，以便用户根据实际情况使用。继续修改自定义的 InvocationHandler 接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改代理类中对 invoke() 方法的调用，第一个参数为当前类的实例，即 this：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">implements</span> <span class="title class_">A13</span>.Foo &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            h.invoke(<span class="built_in">this</span>, foo, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) h.invoke(<span class="built_in">this</span>, bar, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main() 方法重写的 invoke() 方法也要增加 proxy 参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">$Proxy0</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">$Proxy0</span>(<span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            <span class="comment">// 1. 功能增强</span></span><br><span class="line">            System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">            <span class="comment">// 2. 调用目标</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">new</span> <span class="title class_">Target</span>(), params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    proxy.foo();</span><br><span class="line">    <span class="comment">// 调用另一个方法</span></span><br><span class="line">    System.out.println(proxy.bar());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法，结果不发生变化。</p><p>向 JDK 靠齐</p><p>到此为止，自定义的 InvocationHandler 接口与 JDK 提供的 InvocationHandler 接口无异，注释自定义的 InvocationHandler，更换为 JDK 提供的 InvocationHandler 接口。</p><p>在 JDK 提供的 InvocationHandler 接口的注释中有一句：@see Proxy，在 Proxy 类的代码中有：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Proxy</span><span class="params">(InvocationHandler h)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy 类中有一个 InvocationHandler 对象的成员变量。</p><p>因此还可以使代理类 $Proxy0 继承 Proxy 来进一步减少代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">A13</span>.Foo &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6909541593982979501L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler h) &#123;</span><br><span class="line">        <span class="built_in">super</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-2-代理类的源码"><a href="#12-2-代理类的源码" class="headerlink" title="12.2 代理类的源码"></a>12.2 代理类的源码</h2><p>JDK 动态代理生成的代理类是以字节码的形式存在的，并不存在所谓的 .java 文件，但也不是说就没办法看到生成的代理类信息了。</p><p>以【11.1 JDK 动态代理】中的程序为例，查看 JDK 生成的代理类信息。</p><p>利用 Arthas 反编译代理类字节码文件</p><p>如果要使用 Arthas 的反编译功能需要满足两个条件：</p><p>知道被反编译文件的全限定类名</p><p>程序不能中断，需要存在 Java 进程</p><p>为了满足这个条件，可以在控制台打印出生成的代理类的全限定类名，然后利用阻塞 IO 使程序不中断：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 原始对象</span></span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来加载在运行期间动态生成的字节码</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> JdkProxyDemo.class.getClassLoader();</span><br><span class="line">    <span class="type">Foo</span> <span class="variable">proxy</span> <span class="operator">=</span> (Foo) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Foo.class&#125;, (p, method, params) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">        <span class="comment">// 目标.方法(参数) --&gt; 方法.invoke(目标, 参数)</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, params);</span><br><span class="line">        System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">        <span class="comment">// 也返回目标方法执行的结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印代理类的全限定类名</span></span><br><span class="line">    System.out.println(proxy.getClass());</span><br><span class="line">    </span><br><span class="line">    proxy.foo();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只要不在控制台上输入并回车，程序就不会终端</span></span><br><span class="line">    System.in.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a12.$Proxy0</span><br><span class="line">before...</span><br><span class="line">target foo</span><br><span class="line">after...</span><br></pre></td></tr></table></figure><p>其中的 indi.lcp.a12.$Proxy0 就是生成的代理类的全限定类名，可以把它复制下来，之后按照【10. Agent 类加载】中使用 Arthas 的方式 indi.lcp.a12.$Proxy0 进行反编译即可。</p><p>将生成的代理类字节码文件保存在磁盘上</p><p>除了借助外部工具外，还可以直接将 JDK 生成的代理类字节码文件保存在磁盘上，其做法与【Lambda 与序列化】一文中将函数式接口动态生成的 Class 保存到磁盘上类似。</p><p>可以在 main() 方法开头加一句：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.getProperties().put(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">System.getProperties().put(<span class="string">&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br></pre></td></tr></table></figure><p>不同版本的 JDK 添加的配置信息不同，至于具体是哪一个可以查看 JDK 中 ProxyGenerator 类中的 saveGeneratedFiles 成员变量，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">saveGeneratedFiles</span> <span class="operator">=</span> (Boolean)AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">GetBooleanAction</span>(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>));</span><br></pre></td></tr></table></figure><p>显然，此处应该使用第一种方式来设置系统属性。最终的 main() 方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 将动态代理生成的 class 保存到磁盘</span></span><br><span class="line">     System.getProperties().put(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原始对象</span></span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来加载在运行期间动态生成的字节码</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> JdkProxyDemo.class.getClassLoader();</span><br><span class="line">    <span class="type">Foo</span> <span class="variable">proxy</span> <span class="operator">=</span> (Foo) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Foo.class&#125;, (p, method, params) -&gt; &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    proxy.foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，还可以通过在运行前添加 VM options：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Dsun.misc.ProxyGenerator.saveGeneratedFiles=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>如果既在代码里设置了系统属性，又配置了 VM options，最终以代码中的配置为主。</p><p>运行 main() 方法，在当前项目目录下生成 indi.lcp.a12.$Proxy0.class 文件，查看其内容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="built_in">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m2, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m3, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m0, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;indi.lcp.a12.JdkProxyDemo$Foo&quot;</span>).getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其内容与自定义的 $Proxy0 几乎无异，只不过 JDK 生成的代理类信息还生成 equals()、toString() 和 hashCode() 三个方法对应的 Method 对象，并对它们也进行了相同的增强。</p><h2 id="12-3-JDK-代理类字节码生成"><a href="#12-3-JDK-代理类字节码生成" class="headerlink" title="12.3 JDK 代理类字节码生成"></a>12.3 JDK 代理类字节码生成</h2><p>JDK 在生成代理类时，没有经历源码阶段、编译阶段，而是直接到字节码阶段，使用了 ASM 来完成。</p><p>ASM 的学习成本较高，在此不做过多介绍，本节将采用一直“曲线求国”的方式，使用 IDEA 的 ASM Bytecode outline 插件将 Java 源码转换成使用 ASM 编写的代码。</p><p>ASM Bytecode outline 插件在高版本 Java 中可能无法很好地工作，建议在 Java8 环境下使用。</p><p>自行编写一个接口和代理类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6059465134835974286L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Method foo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            foo = Foo.class.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler h) &#123;</span><br><span class="line">        <span class="built_in">super</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, foo, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上述代码进行编译，编译成功后在 $Proxy0 文件中右击，选择 Show Bytecode outline 浏览当前类对应的字节码信息</p><p>查看 ASMified，并拷贝其内容，复制到 $Proxy0Dump 中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jdk.internal.org.objectweb.asm.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lcp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/1/16 22:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0Dump</span> <span class="keyword">implements</span> <span class="title class_">Opcodes</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] dump() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">        FieldVisitor fv;</span><br><span class="line">        MethodVisitor mv;</span><br><span class="line">        AnnotationVisitor av0;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成类信息</span></span><br><span class="line">        cw.visit(<span class="number">52</span>, ACC_PUBLIC + ACC_SUPER, <span class="string">&quot;indi/lcp/$Proxy0&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;java/lang/reflect/Proxy&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;indi/lcp/Foo&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">        cw.visitSource(<span class="string">&quot;$Proxy0.java&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            fv = cw.visitField(ACC_PRIVATE + ACC_FINAL + ACC_STATIC, <span class="string">&quot;serialVersionUID&quot;</span>, <span class="string">&quot;J&quot;</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Long</span>(<span class="number">6059465134835974286L</span>));</span><br><span class="line">            fv.visitEnd();</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            fv = cw.visitField(ACC_STATIC, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;Ljava/lang/reflect/Method;&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            fv.visitEnd();</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            mv = cw.visitMethod(ACC_PROTECTED, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            mv.visitParameter(<span class="string">&quot;h&quot;</span>, <span class="number">0</span>);</span><br><span class="line">            mv.visitCode();</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            mv.visitLabel(l0);</span><br><span class="line">            mv.visitLineNumber(<span class="number">26</span>, l0);</span><br><span class="line">            mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">            mv.visitVarInsn(ALOAD, <span class="number">1</span>);</span><br><span class="line">            mv.visitMethodInsn(INVOKESPECIAL, <span class="string">&quot;java/lang/reflect/Proxy&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            mv.visitLabel(l1);</span><br><span class="line">            mv.visitLineNumber(<span class="number">27</span>, l1);</span><br><span class="line">            mv.visitInsn(RETURN);</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            mv.visitLabel(l2);</span><br><span class="line">            mv.visitLocalVariable(<span class="string">&quot;this&quot;</span>, <span class="string">&quot;Lindi/lcp/$Proxy0;&quot;</span>, <span class="literal">null</span>, l0, l2, <span class="number">0</span>);</span><br><span class="line">            mv.visitLocalVariable(<span class="string">&quot;h&quot;</span>, <span class="string">&quot;Ljava/lang/reflect/InvocationHandler;&quot;</span>, <span class="literal">null</span>, l0, l2, <span class="number">1</span>);</span><br><span class="line">            mv.visitMaxs(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">            mv.visitEnd();</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            mv = cw.visitMethod(ACC_PUBLIC, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            mv.visitCode();</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            mv.visitTryCatchBlock(l0, l1, l2, <span class="string">&quot;java/lang/Throwable&quot;</span>);</span><br><span class="line">            mv.visitLabel(l0);</span><br><span class="line">            mv.visitLineNumber(<span class="number">32</span>, l0);</span><br><span class="line">            mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">            mv.visitFieldInsn(GETFIELD, <span class="string">&quot;indi/lcp/$Proxy0&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;Ljava/lang/reflect/InvocationHandler;&quot;</span>);</span><br><span class="line">            mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">            mv.visitFieldInsn(GETSTATIC, <span class="string">&quot;indi/lcp/$Proxy0&quot;</span>, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;Ljava/lang/reflect/Method;&quot;</span>);</span><br><span class="line">            mv.visitInsn(ACONST_NULL);</span><br><span class="line">            mv.visitMethodInsn(INVOKEINTERFACE, <span class="string">&quot;java/lang/reflect/InvocationHandler&quot;</span>, <span class="string">&quot;invoke&quot;</span>, <span class="string">&quot;(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            mv.visitInsn(POP);</span><br><span class="line">            mv.visitLabel(l1);</span><br><span class="line">            mv.visitLineNumber(<span class="number">35</span>, l1);</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            mv.visitJumpInsn(GOTO, l3);</span><br><span class="line">            mv.visitLabel(l2);</span><br><span class="line">            mv.visitLineNumber(<span class="number">33</span>, l2);</span><br><span class="line">            mv.visitFrame(Opcodes.F_SAME1, <span class="number">0</span>, <span class="literal">null</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;java/lang/Throwable&quot;</span>&#125;);</span><br><span class="line">            mv.visitVarInsn(ASTORE, <span class="number">1</span>);</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            mv.visitLabel(l4);</span><br><span class="line">            mv.visitLineNumber(<span class="number">34</span>, l4);</span><br><span class="line">            mv.visitTypeInsn(NEW, <span class="string">&quot;java/lang/reflect/UndeclaredThrowableException&quot;</span>);</span><br><span class="line">            mv.visitInsn(DUP);</span><br><span class="line">            mv.visitVarInsn(ALOAD, <span class="number">1</span>);</span><br><span class="line">            mv.visitMethodInsn(INVOKESPECIAL, <span class="string">&quot;java/lang/reflect/UndeclaredThrowableException&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/Throwable;)V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            mv.visitInsn(ATHROW);</span><br><span class="line">            mv.visitLabel(l3);</span><br><span class="line">            mv.visitLineNumber(<span class="number">36</span>, l3);</span><br><span class="line">            mv.visitFrame(Opcodes.F_SAME, <span class="number">0</span>, <span class="literal">null</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">            mv.visitInsn(RETURN);</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            mv.visitLabel(l5);</span><br><span class="line">            mv.visitLocalVariable(<span class="string">&quot;throwable&quot;</span>, <span class="string">&quot;Ljava/lang/Throwable;&quot;</span>, <span class="literal">null</span>, l4, l3, <span class="number">1</span>);</span><br><span class="line">            mv.visitLocalVariable(<span class="string">&quot;this&quot;</span>, <span class="string">&quot;Lindi/lcp/$Proxy0;&quot;</span>, <span class="literal">null</span>, l0, l5, <span class="number">0</span>);</span><br><span class="line">            mv.visitMaxs(<span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">            mv.visitEnd();</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            mv = cw.visitMethod(ACC_STATIC, <span class="string">&quot;&lt;clinit&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            mv.visitCode();</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            mv.visitTryCatchBlock(l0, l1, l2, <span class="string">&quot;java/lang/NoSuchMethodException&quot;</span>);</span><br><span class="line">            mv.visitLabel(l0);</span><br><span class="line">            mv.visitLineNumber(<span class="number">19</span>, l0);</span><br><span class="line">            mv.visitLdcInsn(Type.getType(<span class="string">&quot;Lindi/lcp/Foo;&quot;</span>));</span><br><span class="line">            mv.visitLdcInsn(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">            mv.visitInsn(ICONST_0);</span><br><span class="line">            mv.visitTypeInsn(ANEWARRAY, <span class="string">&quot;java/lang/Class&quot;</span>);</span><br><span class="line">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/lang/Class&quot;</span>, <span class="string">&quot;getMethod&quot;</span>, <span class="string">&quot;(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            mv.visitFieldInsn(PUTSTATIC, <span class="string">&quot;indi/lcp/$Proxy0&quot;</span>, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;Ljava/lang/reflect/Method;&quot;</span>);</span><br><span class="line">            mv.visitLabel(l1);</span><br><span class="line">            mv.visitLineNumber(<span class="number">22</span>, l1);</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            mv.visitJumpInsn(GOTO, l3);</span><br><span class="line">            mv.visitLabel(l2);</span><br><span class="line">            mv.visitLineNumber(<span class="number">20</span>, l2);</span><br><span class="line">            mv.visitFrame(Opcodes.F_SAME1, <span class="number">0</span>, <span class="literal">null</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;java/lang/NoSuchMethodException&quot;</span>&#125;);</span><br><span class="line">            mv.visitVarInsn(ASTORE, <span class="number">0</span>);</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            mv.visitLabel(l4);</span><br><span class="line">            mv.visitLineNumber(<span class="number">21</span>, l4);</span><br><span class="line">            mv.visitTypeInsn(NEW, <span class="string">&quot;java/lang/NoSuchMethodError&quot;</span>);</span><br><span class="line">            mv.visitInsn(DUP);</span><br><span class="line">            mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/lang/NoSuchMethodException&quot;</span>, <span class="string">&quot;getMessage&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            mv.visitMethodInsn(INVOKESPECIAL, <span class="string">&quot;java/lang/NoSuchMethodError&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            mv.visitInsn(ATHROW);</span><br><span class="line">            mv.visitLabel(l3);</span><br><span class="line">            mv.visitLineNumber(<span class="number">23</span>, l3);</span><br><span class="line">            mv.visitFrame(Opcodes.F_SAME, <span class="number">0</span>, <span class="literal">null</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">            mv.visitInsn(RETURN);</span><br><span class="line">            mv.visitLocalVariable(<span class="string">&quot;e&quot;</span>, <span class="string">&quot;Ljava/lang/NoSuchMethodException;&quot;</span>, <span class="literal">null</span>, l4, l3, <span class="number">0</span>);</span><br><span class="line">            mv.visitMaxs(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">            mv.visitEnd();</span><br><span class="line">        &#125;</span><br><span class="line">        cw.visitEnd();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cw.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试方法使用 $Proxy0Dump 生成 $Proxy0 的 class 文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] dump = $Proxy0Dump.dump();</span><br><span class="line"></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;$Proxy0.class&quot;</span>);</span><br><span class="line">        os.write(dump, <span class="number">0</span>, dump.length);</span><br><span class="line">        os.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，在工作目录下生成 $Proxy0.class。</p><p>工作目录查看方式：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGUxMTExNDRkYzgyYWI2YzVmMjBkYjU3OTkwODljZjRfMHFXVHRPWDFGbkQyMVB6UGZvREJ6eTczUnZIY1JLOW9fVG9rZW46VmlDd2JoSm1Jb1ZxSWx4R3E2Q2NoR2RWbjdnXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>也就是说会在 D:\Code\IdeaCode\advanced-spring 目录下生成 $Proxy0.class 文件，IDEA 反编译后的内容与手动编写的 $Proxy0.java 文件的内容无异。</p><p>实际使用时并不需要使用 $Proxy0Dump 生成 $Proxy.class 文件，而是利用 ClassLoader 直接加载类信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">byte</span>[] dump = $Proxy0Dump.dump();</span><br><span class="line"></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoader</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.defineClass(name, dump, <span class="number">0</span>, dump.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; proxyClass = classLoader.loadClass(<span class="string">&quot;indi.lcp.$Proxy0&quot;</span>);</span><br><span class="line">    Constructor&lt;?&gt; constructor = proxyClass.getConstructor(InvocationHandler.class);</span><br><span class="line">    <span class="type">Foo</span> <span class="variable">fooProxy</span> <span class="operator">=</span> (Foo) constructor.newInstance((InvocationHandler) (proxy, method, args1) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;模拟调用目标&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    fooProxy.foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before...</span><br><span class="line">模拟调用目标</span><br></pre></td></tr></table></figure><h2 id="12-4-JDK-反射优化"><a href="#12-4-JDK-反射优化" class="headerlink" title="12.4 JDK 反射优化"></a>12.4 JDK 反射优化</h2><p>使用 JDK 的动态代理时，会使用反射调用方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, params);</span><br></pre></td></tr></table></figure><p>相比于正常调用方法，利用反射的性能要稍微低一些，JDK 有怎么反射进行优化吗？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMethodProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">foo</span> <span class="operator">=</span> TestMethodProxy.class.getMethod(<span class="string">&quot;foo&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">17</span>; i++) &#123;</span><br><span class="line">            show(i, foo);</span><br><span class="line">            foo.invoke(<span class="literal">null</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法反射调用时，底层使用了 MethodAccessor 的实现类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> i, Method foo)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">getMethodAccessor</span> <span class="operator">=</span> Method.class.getDeclaredMethod(<span class="string">&quot;getMethodAccessor&quot;</span>);</span><br><span class="line">        getMethodAccessor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> getMethodAccessor.invoke(foo);</span><br><span class="line">        <span class="keyword">if</span> (invoke == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot;:&quot;</span> + <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// DelegatingMethodAccessorImpl 的全限定类名（不同版本的 JDK 存在差异）</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">delegate</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.DelegatingMethodAccessorImpl&quot;</span>).getDeclaredField(<span class="string">&quot;delegate&quot;</span>);</span><br><span class="line">        delegate.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(i + <span class="string">&quot;: &quot;</span> + delegate.get(invoke));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        System.out.println(i + <span class="string">&quot;: foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="literal">null</span></span><br><span class="line"><span class="number">1</span>: foo</span><br><span class="line"><span class="number">2</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">2</span>: foo</span><br><span class="line"><span class="number">3</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">3</span>: foo</span><br><span class="line"><span class="number">4</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">4</span>: foo</span><br><span class="line"><span class="number">5</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">5</span>: foo</span><br><span class="line"><span class="number">6</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">6</span>: foo</span><br><span class="line"><span class="number">7</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">7</span>: foo</span><br><span class="line"><span class="number">8</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">8</span>: foo</span><br><span class="line"><span class="number">9</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">9</span>: foo</span><br><span class="line"><span class="number">10</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">10</span>: foo</span><br><span class="line"><span class="number">11</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">11</span>: foo</span><br><span class="line"><span class="number">12</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">12</span>: foo</span><br><span class="line"><span class="number">13</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">13</span>: foo</span><br><span class="line"><span class="number">14</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">14</span>: foo</span><br><span class="line"><span class="number">15</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">15</span>: foo</span><br><span class="line"><span class="number">16</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">16</span>: foo</span><br><span class="line"><span class="number">17</span>: sun.reflect.GeneratedMethodAccessor2@5b2133b1</span><br><span class="line"><span class="number">17</span>: foo</span><br></pre></td></tr></table></figure><p>从上述信息可知，第一次调用时没有使用 MethodAccessor 对象，从第二次到第十六次，使用了 NativeMethodAccessorImpl 对象，而在第十七次使用了 GeneratedMethodAccessor2 对象。</p><p>NativeMethodAccessorImpl 基于 Java 本地 API 实现，性能较低，第十七次调用换成 GeneratedMethodAccessor2 后，性能得到一定的提升。</p><p>使用 Arthas 反编译查看 GeneratedMethodAccessor2 类中的信息，内容如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneratedMethodAccessor2</span> <span class="keyword">extends</span> <span class="title class_">MethodAccessorImpl</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Loose catch block</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object object, Object[] objectArray)</span> <span class="keyword">throws</span> InvocationTargetException &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 正常调用方法</span></span><br><span class="line">            TestMethodProxy.foo((<span class="type">int</span>)c);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvocationTargetException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassCastException | NullPointerException runtimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="built_in">super</span>.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在反编译得到的代码中，不再是通过反射调用方法，而是直接正常调用方法，即：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TestMethodProxy.foo((<span class="type">int</span>)c);</span><br></pre></td></tr></table></figure><p>因此性能得到了提升，但这样的提升也是有一定代价的：为优化 一个 方法的反射调用，生成了一个 GeneratedMethodAccessor2 代理类。</p><h1 id="CGLib-动态代理原理"><a href="#CGLib-动态代理原理" class="headerlink" title="CGLib 动态代理原理"></a><strong>CGLib</strong> <strong>动态代理原理</strong></h1><h2 id="13-1-CGLib-动态代理的模拟"><a href="#13-1-CGLib-动态代理的模拟" class="headerlink" title="13.1 CGLib 动态代理的模拟"></a><strong>13.1</strong> <strong>CGLib</strong> <strong>动态代理的模拟</strong></h2><p>同样先模拟下 CGLib 动态代理的模拟：</p><p>被代理的类，即目标类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save(int)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">long</span> i)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save(long)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CGLib 动态代理生成的代理类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">extends</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor methodInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMethodInterceptor</span><span class="params">(MethodInterceptor methodInterceptor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.methodInterceptor = methodInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Method save0;</span><br><span class="line">    <span class="keyword">static</span> Method save1;</span><br><span class="line">    <span class="keyword">static</span> Method save2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            save0 = Target.class.getMethod(<span class="string">&quot;save&quot;</span>);</span><br><span class="line">            save1 = Target.class.getMethod(<span class="string">&quot;save&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">            save2 = Target.class.getMethod(<span class="string">&quot;save&quot;</span>, <span class="type">long</span>.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            methodInterceptor.intercept(<span class="built_in">this</span>, save0, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>], <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            methodInterceptor.intercept(<span class="built_in">this</span>, save1, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;i&#125;, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">long</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            methodInterceptor.intercept(<span class="built_in">this</span>, save2, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;i&#125;, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">Proxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>();</span><br><span class="line">    proxy.setMethodInterceptor(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">            <span class="comment">// 反射调用</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    proxy.save();</span><br><span class="line">    proxy.save(<span class="number">1</span>);</span><br><span class="line">    proxy.save(<span class="number">2L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before</span><br><span class="line"><span class="title function_">save</span><span class="params">()</span></span><br><span class="line">before</span><br><span class="line"><span class="title function_">save</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line">before</span><br><span class="line"><span class="title function_">save</span><span class="params">(<span class="type">long</span>)</span></span><br></pre></td></tr></table></figure><h2 id="13-2-MethodProxy"><a href="#13-2-MethodProxy" class="headerlink" title="13.2 MethodProxy"></a><strong>13.2 MethodProxy</strong></h2><p>在上述 Proxy 类中，重写了父类中的方法，并在重写的方法中调用了 <code>intercept()</code> 方法，重写的这些方法相当于是带增强功能的方法。</p><p>在 JDK 的动态代理中，使用反射对方法进行调用，而在 CGLib 动态代理中，可以使用 <code>intercept()</code> 方法中 <code>MethodProxy</code> 类型的参数实现不经过反射来调用方法。</p><p>接收的 <code>MethodProxy</code> 类型的参数可以像 <code>Method</code> 类型的参数一样，在静态代码块中被实例化。</p><p>可以通过静态方法 <code>MethodProxy.create()</code> 来创建 <code>MethodProxy</code> 对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> MethodProxy <span class="title function_">create</span><span class="params">(Class c1, Class c2, String desc, String name1, String name2)</span> &#123;</span><br><span class="line">   <span class="type">MethodProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodProxy</span>();</span><br><span class="line">   proxy.sig1 = <span class="keyword">new</span> <span class="title class_">Signature</span>(name1, desc);</span><br><span class="line">   proxy.sig2 = <span class="keyword">new</span> <span class="title class_">Signature</span>(name2, desc);</span><br><span class="line">   proxy.createInfo = <span class="keyword">new</span> <span class="title class_">CreateInfo</span>(c1, c2);</span><br><span class="line">   <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参数 <code>c1</code> 指目标类（或者说原始类）的 <code>Class</code> 对象；</li><li>参数 <code>c2</code> 指代理类的 <code>Class</code> 对象；</li><li>参数 <code>desc</code> 指方法描述符（【Lambda 与序列化】一文中介绍了关于 Java 描述符的更多内容）；</li><li>参数 <code>name1</code> 指带 <strong>增强</strong> 功能的方法名称；</li><li>参数 <code>name2</code> 指带 <strong>原始</strong> 功能的方法名称。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">extends</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor methodInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMethodInterceptor</span><span class="params">(MethodInterceptor methodInterceptor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.methodInterceptor = methodInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Method save0;</span><br><span class="line">    <span class="keyword">static</span> Method save1;</span><br><span class="line">    <span class="keyword">static</span> Method save2;</span><br><span class="line">    <span class="keyword">static</span> MethodProxy save0Proxy;</span><br><span class="line">    <span class="keyword">static</span> MethodProxy save1Proxy;</span><br><span class="line">    <span class="keyword">static</span> MethodProxy save2Proxy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            save0 = Target.class.getMethod(<span class="string">&quot;save&quot;</span>);</span><br><span class="line">            save1 = Target.class.getMethod(<span class="string">&quot;save&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">            save2 = Target.class.getMethod(<span class="string">&quot;save&quot;</span>, <span class="type">long</span>.class);</span><br><span class="line"></span><br><span class="line">            save0Proxy = MethodProxy.create(Target.class, Proxy.class, <span class="string">&quot;()V&quot;</span>, <span class="string">&quot;save&quot;</span>, <span class="string">&quot;saveSuper&quot;</span>);</span><br><span class="line">            save1Proxy = MethodProxy.create(Target.class, Proxy.class, <span class="string">&quot;(I)V&quot;</span>, <span class="string">&quot;save&quot;</span>, <span class="string">&quot;saveSuper&quot;</span>);</span><br><span class="line">            save2Proxy = MethodProxy.create(Target.class, Proxy.class, <span class="string">&quot;(J)V&quot;</span>, <span class="string">&quot;save&quot;</span>, <span class="string">&quot;saveSuper&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 带原始功能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveSuper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.save();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveSuper</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.save(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveSuper</span><span class="params">(<span class="type">long</span> i)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.save(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 带增强功能的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            methodInterceptor.intercept(<span class="built_in">this</span>, save0, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>], save0Proxy);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            methodInterceptor.intercept(<span class="built_in">this</span>, save1, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;i&#125;, save1Proxy);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">long</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            methodInterceptor.intercept(<span class="built_in">this</span>, save2, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;i&#125;, save2Proxy);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>main()</code> 方法中不再使用 <code>Method</code> 类型的参数对方法进行调用，而是使用 <code>MethodProxy</code> 类型的参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部没有反射调用，但需要结合目标对象使用</span></span><br><span class="line"><span class="keyword">return</span> methodProxy.invoke(target, args);</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部没有反射调用，但需要结合代理对象使用</span></span><br><span class="line"><span class="keyword">return</span> methodProxy.invokeSuper(o, args);</span><br></pre></td></tr></table></figure><h1 id="MethodProxy-原理"><a href="#MethodProxy-原理" class="headerlink" title="MethodProxy 原理"></a>MethodProxy 原理</h1><p>调用 methodProxy.invoke() 方法时，会额外使用一个代理类，该代理类配合目标对象使用。调用 methodProxy.invokeSuper() 方法时，也会额外使用一个代理类，该代理类配合代理对象使用。</p><p>当调用 MethodProxy 对象的 invoke() 方法或 invokeSuper() 方法时，就会生成这两个代理类，它们都继承至 FastClass。</p><p>FastClass 是一个抽象类，其内部有多个抽象方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FastClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(String var1, Class[] var2)</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(Class[] var1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title function_">invoke</span><span class="params">(<span class="type">int</span> var1, Object var2, Object[] var3)</span> <span class="keyword">throws</span> InvocationTargetException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title function_">newInstance</span><span class="params">(<span class="type">int</span> var1, Object[] var2)</span> <span class="keyword">throws</span> InvocationTargetException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(Signature signature)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">getMaxIndex</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点讲解 invoke() 方法与 getIndex(Signature signature) 方法。</p><p>模拟生成的与目标类相关的代理类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetFastClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Signature</span> <span class="variable">s0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Signature</span>(<span class="string">&quot;save&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Signature</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Signature</span>(<span class="string">&quot;save&quot;</span>, <span class="string">&quot;(I)V&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Signature</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Signature</span>(<span class="string">&quot;save&quot;</span>, <span class="string">&quot;(J)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;获取目标方法的编号&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Target 目标类中的方法：</span></span><br><span class="line"><span class="comment">     * save()             0</span></span><br><span class="line"><span class="comment">     * save(int)          1</span></span><br><span class="line"><span class="comment">     * save(long)         2</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> signature 包含方法名称、参数返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 方法编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(Signature signature)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s0.equals(signature)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s1.equals(signature)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s2.equals(signature)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 getIndex() 方法返回的方法编号正常调用目标对象方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index       方法编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target       目标对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 调用目标对象方法需要的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 方法返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(<span class="type">int</span> index, Object target, Object[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            ((Target) target).save();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">            ((Target) target).save((<span class="type">int</span>) args[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">2</span>) &#123;</span><br><span class="line">            ((Target) target).save((<span class="type">long</span>) args[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;无此方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TargetFastClass</span> <span class="variable">fastClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetFastClass</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> fastClass.getIndex(<span class="keyword">new</span> <span class="title class_">Signature</span>(<span class="string">&quot;save&quot;</span>, <span class="string">&quot;()V&quot;</span>));</span><br><span class="line">        fastClass.invoke(index, <span class="keyword">new</span> <span class="title class_">Target</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        index = fastClass.getIndex(<span class="keyword">new</span> <span class="title class_">Signature</span>(<span class="string">&quot;save&quot;</span>, <span class="string">&quot;(J)V&quot;</span>));</span><br><span class="line">        fastClass.invoke(index, <span class="keyword">new</span> <span class="title class_">Target</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">2L</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">save()</span><br><span class="line">save(<span class="type">long</span>)</span><br></pre></td></tr></table></figure><p>模拟生成的与代理类相关的代理类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFastClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Signature</span> <span class="variable">s0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Signature</span>(<span class="string">&quot;saveSuper&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Signature</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Signature</span>(<span class="string">&quot;saveSuper&quot;</span>, <span class="string">&quot;(I)V&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Signature</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Signature</span>(<span class="string">&quot;saveSuper&quot;</span>, <span class="string">&quot;(J)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;获取代理方法的编号&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Proxy 代理类中的方法：</span></span><br><span class="line"><span class="comment">     * saveSuper()             0</span></span><br><span class="line"><span class="comment">     * saveSuper(int)          1</span></span><br><span class="line"><span class="comment">     * saveSuper(long)         2</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> signature 包含方法名称、参数返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 方法编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(Signature signature)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s0.equals(signature)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s1.equals(signature)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s2.equals(signature)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 getIndex() 方法返回的方法编号正常调用代理对象中带原始功能的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 方法编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args  调用方法需要的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 方法返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(<span class="type">int</span> index, Object proxy, Object[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            ((Proxy) proxy).saveSuper();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">            ((Proxy) proxy).saveSuper((<span class="type">int</span>) args[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">2</span>) &#123;</span><br><span class="line">            ((Proxy) proxy).saveSuper((<span class="type">long</span>) args[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;无此方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProxyFastClass</span> <span class="variable">fastClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFastClass</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> fastClass.getIndex(<span class="keyword">new</span> <span class="title class_">Signature</span>(<span class="string">&quot;saveSuper&quot;</span>, <span class="string">&quot;()V&quot;</span>));</span><br><span class="line">        fastClass.invoke(index, <span class="keyword">new</span> <span class="title class_">Proxy</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">save()</span><br></pre></td></tr></table></figure><p>总结</p><p>调用 MethodProxy.create() 方法创建 MethodProxy 对象时，要求传递带增强功能的方法名称、带原始功能的方法名称以及方法描述符。</p><p>根据两个方法名称和方法描述符可以在调用生成的两个代理类中的 getIndex() 方法时获取被增强方法的编号，之后：</p><p>调用 methodProxy.invoke() 方法时，就相当于调用 TargetFastClass 中的 invoke() 方法，并在这个 invoke() 方法中正常调用目标对象方法（Spring 底层的选择）。</p><p>调用 methodProxy.invokeSuper() 方法时，就相当于调用 ProxyFastClass 中的 invoke() 方法，并在这个 invoke() 方法中正常调用代理对象中带原始功能的方法。</p><p>与 JDK 中优化反射调用方法的对比</p><p>在 JDK 中需要反射调用 16 次方法后才会生成优化反射调用的代理类，而在 CGLib 中，当调用 MethodProxy.create() 方法时就会生成由于优化反射调用的代理类；</p><p>在 JDK 中一个方法的反射调用优化就要生成一个代理类，而在 CGLib 中，一个代理类生成两个 FastClass 代理类。</p><h1 id="JDK-和-CGLib-的统一"><a href="#JDK-和-CGLib-的统一" class="headerlink" title="JDK 和 CGLib 的统一"></a>JDK 和 CGLib 的统一</h1><h2 id="15-1-advisor"><a href="#15-1-advisor" class="headerlink" title="15.1. advisor"></a>15.1. advisor</h2><p>切面有 aspect 和 advisor 两个概念，aspect 是多组通知（advice）和切点（pointcut）的组合，也是实际编码时使用的，advisor 则是更细粒度的切面，仅包含一个通知和切点，aspect 在生效之前会被拆解成多个 advisor。</p><p>Spring 中对切点、通知、切面的抽象如下：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NzIwNmVmNTNhMmQzMWJiZjcyZWU4MzhhNDYzNzU1NWFfeEt3SjhNNkV1Y0d4RjJsMTRIU1VDTGM2eVYxUmdRVUNfVG9rZW46Q2R3a2J2VE1kb0NSYXl4SjIwMWNoZ3pJbnFmXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>切点：即 Pointcut，其典型实现是 AspectJExpressionPointcut</p><p>通知：即 Advice，其典型子类接口为 MethodInterceptor，表示环绕通知</p><p>切面：即 Advisor，仅包含一个切点和通知</p><p>本节将重点介绍 advisor 切面。</p><h2 id="15-2-切面与代理对象的创建"><a href="#15-2-切面与代理对象的创建" class="headerlink" title="15.2 切面与代理对象的创建"></a>15.2 切面与代理对象的创建</h2><p>通过以下四步创建切面和代理：</p><ul><li>备好切点</li><li>备好通知</li><li>备好切面</li><li>创建代理</li></ul><p>在 Spring 中，切点通过接口 org.springframework.aop.Pointcut 来表示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pointcut</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据类型过滤</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ClassFilter <span class="title function_">getClassFilter</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据方法匹配</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MethodMatcher <span class="title function_">getMethodMatcher</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Canonical Pointcut instance that always matches.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Pointcut</span> <span class="variable">TRUE</span> <span class="operator">=</span> TruePointcut.INSTANCE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pointcut 接口有很多实现类，比如：</p><p>AnnotationMatchingPointcut：通过注解进行匹配</p><p>AspectJExpressionPointcut：通过 AspectJ 表达式进行匹配（本节的选择）</p><p>在 Spring 中，通知的表示也有很多接口，在此介绍最基本、最重要的接口 org.aopalliance.intercept.MethodInterceptor，这个接口实现的通知属于环绕通知。</p><p>在 Spring 中，切面的实现也有很多，在此选择 DefaultPointcutAdvisor，创建这种切面时，传递一个节点和通知。</p><p>最后创建代理对象时，无需显式实现 JDK 动态代理或 CGLib 动态代理，Spring 提供了名为 ProxyFactory 的工厂，其内部通过不同的情况选择不同的代理实现，更方便地创建代理对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">I1</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target1</span> <span class="keyword">implements</span> <span class="title class_">I1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target1 foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target1 bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target2 foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target2 bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 两个切面概念：</span></span><br><span class="line"><span class="comment">     *  aspect =</span></span><br><span class="line"><span class="comment">     *          通知 1 （advice） + 切点 1（pointcut）</span></span><br><span class="line"><span class="comment">     *          通知 2 （advice） + 切点 2（pointcut）</span></span><br><span class="line"><span class="comment">     *          通知 3 （advice） + 切点 3（pointcut）</span></span><br><span class="line"><span class="comment">     *          ...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * advisor = 更细粒度的切面，包含一个通知和切点</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 备好切点（根据 AspectJ 表达式进行匹配）</span></span><br><span class="line">    <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">    pointcut.setExpression(<span class="string">&quot;execution(* foo())&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 备好通知</span></span><br><span class="line">    <span class="type">MethodInterceptor</span> <span class="variable">advice</span> <span class="operator">=</span> invocation -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 3. 备好切面</span></span><br><span class="line">    <span class="type">DefaultPointcutAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice);</span><br><span class="line">    <span class="comment">// 4. 创建代理</span></span><br><span class="line">    <span class="type">Target1</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target1</span>();</span><br><span class="line">    <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">    factory.setTarget(target);</span><br><span class="line">    factory.addAdvisor(advisor);</span><br><span class="line">    </span><br><span class="line">    <span class="type">I1</span> <span class="variable">proxy</span> <span class="operator">=</span> (I1) factory.getProxy();</span><br><span class="line">    System.out.println(proxy.getClass());</span><br><span class="line">    proxy.foo();</span><br><span class="line">    proxy.bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a15.A15$Target1$$EnhancerBySpringCGLIB$$381723d1</span><br><span class="line">before...</span><br><span class="line">target1 foo</span><br><span class="line">after...</span><br><span class="line">target1 bar</span><br></pre></td></tr></table></figure><p>foo() 方法被增强，但 bar() 并没有，并且选择了 CGLib 动态代理作为代理的实现。</p><p>Spring 是根据什么信息来选择不同的动态代理实现呢？</p><p>ProxyFactory 的父类 ProxyConfig 中有个名为 proxyTargetClass 的布尔类型成员变量：</p><ul><li>当 proxyTargetClass &#x3D;&#x3D; false，并且目标对象所在类实现了接口时，将选择 JDK 动态代理；</li><li>当 proxyTargetClass &#x3D;&#x3D; false，但目标对象所在类未实现接口时，将选择 CGLib 动态代理；</li><li>当 proxyTargetClass &#x3D;&#x3D; true，总是选择 CGLib 动态代理。</li></ul><p>上文中的 target 对象的所在类 Targer1 实现了 I1 接口，最终为什么依旧选择了 CGLib 动态代理作为代理类的创建方式呢？</p><p>这是因为并没有显示这是 target 对象的实现类，Spring 认为其并未实现接口。</p><p>设置 factory 对象的 interfaces 信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">factory.setInterfaces(target.getClass().getInterfaces());</span><br></pre></td></tr></table></figure><p>之后再运行 main()，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a15.$Proxy0</span><br><span class="line">before...</span><br><span class="line">target1 foo</span><br><span class="line">after...</span><br><span class="line">target1 bar</span><br></pre></td></tr></table></figure><p>此时选择的动态代理实现方式是 JDK 动态代理。</p><p>再设置 factory 对象的 proxyTargetClass 为 true：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">factory.setProxyTargetClass(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出以下内容，选择 CGLib 动态代理作为动态代理的实现方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a15.A15$Target1$$EnhancerBySpringCGLIB$$34c2d9b8</span><br><span class="line">before...</span><br><span class="line">target1 foo</span><br><span class="line">after...</span><br><span class="line">target1 bar</span><br></pre></td></tr></table></figure><p>再将 proxyTargetClass 的值修改回 false，并修改目标对象的所在类为 Target2，Target2 并未实现任何接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 创建代理</span></span><br><span class="line">    <span class="type">Target2</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target2</span>();</span><br><span class="line">    <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">    factory.setTarget(target);</span><br><span class="line">    factory.addAdvisor(advisor);</span><br><span class="line">    factory.setInterfaces(target.getClass().getInterfaces());</span><br><span class="line">    factory.setProxyTargetClass(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Target2</span> <span class="variable">proxy</span> <span class="operator">=</span> (Target2) factory.getProxy();</span><br><span class="line">    System.out.println(proxy.getClass());</span><br><span class="line">    proxy.foo();</span><br><span class="line">    proxy.bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出以下内容，依旧选择 CGLib 动态代理作为动态代理的实现方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a15.A15$Target2$$EnhancerBySpringCGLIB$$4bb2ac74</span><br><span class="line">before...</span><br><span class="line">target2 foo</span><br><span class="line">after...</span><br><span class="line">target2 bar</span><br></pre></td></tr></table></figure><p>ProxyFactory 是用来创建代理的核心实现，使用 AopProxyFactory 选择具体的代理实现：</p><ul><li>JdkDynamicAopProxy</li><li>ObjenesisCglibAopProxy</li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTY3MmM0YTk0MDZkOTRkYTE4MTQ0YzNiNmIxNmVkZDZfN1BkMlJoZ25jcU5TWFV6RmsyZjFVcUQzcjBsWndiaW1fVG9rZW46TzRIY2JaVWVlb0RXdm14UjBKUWN3Vngzbm1oXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>AopProxyFactory 根据 proxyTargetClass 等设置选择 AopProxy 实现，AopProxy 通过 getProxy() 方法创建代理对象。</p><p>上述类图中的类与接口都实现了 Advised 接口，能够获得关联的切面集合与目标（实际上是从 ProxyFactory 中获取的）。</p><p>调用代理方法时，会借助 ProxyFactory 统一将通知转换为环绕通知 MethodInterceptor。</p><h1 id="切点匹配"><a href="#切点匹配" class="headerlink" title="切点匹配"></a>切点匹配</h1><p>上一节中，选择 AspectJExpressionPointcut 作为切点的实现，判断编写的 AspectJ 表达式是否与某一方法匹配可以使用其 matches() 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">    <span class="type">AspectJExpressionPointcut</span> <span class="variable">pt1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">    pt1.setExpression(<span class="string">&quot;execution(* bar())&quot;</span>);</span><br><span class="line">    System.out.println(pt1.matches(T1.class.getMethod(<span class="string">&quot;foo&quot;</span>), T1.class));</span><br><span class="line">    System.out.println(pt1.matches(T1.class.getMethod(<span class="string">&quot;bar&quot;</span>), T1.class));</span><br><span class="line"></span><br><span class="line">    <span class="type">AspectJExpressionPointcut</span> <span class="variable">pt2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">    pt2.setExpression(<span class="string">&quot;@annotation(org.springframework.transaction.annotation.Transactional)&quot;</span>);</span><br><span class="line">    System.out.println(pt2.matches(T1.class.getMethod(<span class="string">&quot;foo&quot;</span>), T1.class));</span><br><span class="line">    System.out.println(pt2.matches(T1.class.getMethod(<span class="string">&quot;bar&quot;</span>), T1.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T1</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><p>@Transactional 是 Spring 中使用频率非常高的注解，那它底层是通过 AspectJExpressionPointcut 与 @annotation() 切点表达式相结合对目标方法进行匹配的吗？</p><p>答案是否定的。@Transactional 注解除了可以作用在方法上，还可以作用在类（或接口）上。</p><p>在底层 @Transactional 注解的匹配使用到了 StaticMethodMatcherPointcut，在此模拟一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">StaticMethodMatcherPointcut</span> <span class="variable">pt3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticMethodMatcherPointcut</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">            <span class="comment">// 检查方法上是否添加了 @Transactional 注解</span></span><br><span class="line">            <span class="type">MergedAnnotations</span> <span class="variable">annotations</span> <span class="operator">=</span> MergedAnnotations.from(method);</span><br><span class="line">            <span class="keyword">if</span> (annotations.isPresent(Transactional.class)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查类上或所实现的接口是否添加了 @Transactional 注解</span></span><br><span class="line">            annotations = MergedAnnotations.from(targetClass, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY);</span><br><span class="line">            <span class="keyword">return</span> annotations.isPresent(Transactional.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    System.out.println(pt3.matches(T1.class.getMethod(<span class="string">&quot;foo&quot;</span>), T1.class));</span><br><span class="line">    System.out.println(pt3.matches(T1.class.getMethod(<span class="string">&quot;bar&quot;</span>), T1.class));</span><br><span class="line">    System.out.println(pt3.matches(T2.class.getMethod(<span class="string">&quot;foo&quot;</span>), T2.class));</span><br><span class="line">    System.out.println(pt3.matches(T3.class.getMethod(<span class="string">&quot;foo&quot;</span>), T3.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T1</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I3</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T3</span> <span class="keyword">implements</span> <span class="title class_">I3</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>无论是 AspectJExpressionPointcut 还是 StaticMethodMatcherPointcut，它们都实现了MethodMatcher 接口，用来执行方法的匹配。</p><h1 id="从-Aspect-到-Advisor"><a href="#从-Aspect-到-Advisor" class="headerlink" title="从 @Aspect 到 Advisor"></a>从 @Aspect 到 Advisor</h1><ol><li><h2 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h2></li></ol><p>准备一下类：</p><ul><li>两个目标类:</li></ul><p>一个使用 @Aspect 的高级切面</p><p>一个利用配置类实现的低级切面 Advisor</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target1 foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target2 bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 高级切面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Aspect1</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aspect1 before...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aspect1 after...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 低级切面，由一个切点和一个通知组成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Advisor <span class="title function_">advisor3</span><span class="params">(MethodInterceptor advice3)</span> &#123;</span><br><span class="line">        <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">        pointcut.setExpression(<span class="string">&quot;execution(* foo())&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MethodInterceptor <span class="title function_">advices</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> invocation -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;advice3 before...&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">            System.out.println(<span class="string">&quot;advice3 after...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 main() 方法创建 Spring 容器，并添加必要的 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;aspect1&quot;</span>, Aspect1.class);</span><br><span class="line">    context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">aspect1</span><br><span class="line">config</span><br><span class="line">org.springframework.context.annotation.ConfigurationClassPostProcessor</span><br><span class="line">advisor3</span><br><span class="line">advices</span><br></pre></td></tr></table></figure><p>Spring 中存在一个名为 AnnotationAwareAspectJAutoProxyCreator 的 Bean 后置处理器，尽管它的名称中没有 BeanPostProcessor 的字样，但它确实是实现了 BeanPostProcessor 接口的。</p><p>AnnotationAwareAspectJAutoProxyCreator 有两个主要作用：</p><ul><li>找到容器中所有的切面，针对高级切面，将其转换为低级切面；</li><li>根据切面信息，利用 ProxyFactory 创建代理对象。</li></ul><p>AnnotationAwareAspectJAutoProxyCreator 实现了 BeanPostProcessor，可以在 Bean 生命周期中的一些阶段对 Bean 进行拓展。AnnotationAwareAspectJAutoProxyCreator 可以在 Bean 进行 依赖注入之前、Bean 初始化之后 对 Bean 进行拓展。</p><p>重点介绍 AnnotationAwareAspectJAutoProxyCreator 中的两个方法：</p><ul><li>findEligibleAdvisors()：位于父类 AbstractAdvisorAutoProxyCreator 中，用于找到符合条件的切面类。低级切面直接添加，高级切面转换为低级切面再添加。</li><li>wrapIfNecessary()：位于父类 AbstractAutoProxyCreator 中，用于将有资格被代理的 Bean 进行包装，即创建代理对象。</li></ul><p>findEligibleAdvisors() 方法</p><p>findEligibleAdvisors() 方法接收两个参数：</p><ul><li>beanClass：配合切面使用的目标类 Class 信息</li><li>beanName：当前被代理的 Bean 的名称</li></ul><p>修改 main() 方法，向容器中添加 AnnotationAwareAspectJAutoProxyCreator 后置处理器，测试 findEligibleAdvisors() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;aspect1&quot;</span>, Aspect1.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">        context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line"></span><br><span class="line">        context.registerBean(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line"></span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试 findEligibleAdvisors 方法</span></span><br><span class="line">        <span class="type">AnnotationAwareAspectJAutoProxyCreator</span> <span class="variable">creator</span> <span class="operator">=</span> context.getBean(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line">        <span class="comment">// 获取能够配合 Target1 使用的切面</span></span><br><span class="line">        List&lt;Advisor&gt; advisors = creator.findEligibleAdvisors(Target1.class, <span class="string">&quot;target1&quot;</span>);</span><br><span class="line">        advisors.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.aop.interceptor.ExposeInvocationInterceptor.ADVISOR</span><br><span class="line">org.springframework.aop.support.DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [org.springframework.aop.framework.autoproxy.A17$Config$$Lambda$<span class="number">56</span>/<span class="number">802243390</span>@7bd4937b]</span><br><span class="line">InstantiationModelAwarePointcutAdvisor: expression [execution(* foo())]; advice method [<span class="keyword">public</span> <span class="keyword">void</span> org.springframework.aop.framework.autoproxy.A17$Aspect1.before()]; perClauseKind=SINGLETON</span><br><span class="line">InstantiationModelAwarePointcutAdvisor: expression [execution(* foo())]; advice method [<span class="keyword">public</span> <span class="keyword">void</span> org.springframework.aop.framework.autoproxy.A17$Aspect1.after()]; perClauseKind=SINGLETON</span><br></pre></td></tr></table></figure><p>打印出 4 个能配合 Target1 使用的切面信息，其中：</p><ul><li>第一个切面 ExposeInvocationInterceptor.ADVISOR 是 Spring 为每个代理对象都会添加的切面；</li><li>第二个切面 DefaultPointcutAdvisor 是自行编写的低级切面；</li><li>第三个和第四个切面 InstantiationModelAwarePointcutAdvisor 是由高级切面转换得到的两个低级切面。</li></ul><p>若按照 creator.findEligibleAdvisors(Target2.class, “target2”) 的方式进行调用，控制台不会打印出任何信息，因为没有任何切面能够配合 Target2 使用。</p><p>wrapIfNecessary() 方法</p><p>wrapIfNecessary() 方法内部调用了 findEligibleAdvisors() 方法，若 findEligibleAdvisors() 方法返回的集合不为空，则表示需要创建代理对象。</p><p>如果需要创建对象，wrapIfNecessary() 方法返回的是代理对象，否则仍然是原对象。</p><p>wrapIfNecessary() 方法接收三个参数：</p><ul><li>bean：原始 Bean 实例</li><li>beanName：Bean 的名称</li><li>cacheKey：用于元数据访问的缓存 key</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> creator.wrapIfNecessary(<span class="keyword">new</span> <span class="title class_">Target1</span>(), <span class="string">&quot;target1&quot;</span>, <span class="string">&quot;target1&quot;</span>);</span><br><span class="line">    System.out.println(o1.getClass());</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> creator.wrapIfNecessary(<span class="keyword">new</span> <span class="title class_">Target2</span>(), <span class="string">&quot;target2&quot;</span>, <span class="string">&quot;target2&quot;</span>);</span><br><span class="line">    System.out.println(o2.getClass());</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.aop.framework.autoproxy.A17$Target1$$EnhancerBySpringCGLIB$$634976f6</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.aop.framework.autoproxy.A17$Target2</span><br></pre></td></tr></table></figure><p>Target1 对象是被代理的，而 Target2 依旧是原对象。</p><p>如果将 o1 转换为 Target1，并调用 foo() 方法，foo() 方法将被增强：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    ((Target1) o1).foo();</span><br><span class="line">    </span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">advice3 before...</span><br><span class="line">aspect1 before...</span><br><span class="line">target1 foo</span><br><span class="line">aspect1 after...</span><br><span class="line">advice3 after...</span><br></pre></td></tr></table></figure><p>切面的顺序控制</p><p>根据上述打印的信息可知，低级切面相比于高级切面先一步被执行，这个执行顺序是可以被控制的。</p><p>针对高级切面来说，可以在类上使用 @Order 注解，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Aspect1</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aspect1 before...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aspect1 after...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在高级切面中，@Order 只有放在类上才生效，放在方法上不会生效。比如高级切面中有多个前置通知，这些前置通知对应的方法上使用 @Order 注解是无法生效的。</p><p>针对低级切面，需要设置 advisor 的 order 值，而不是向高级切面那样使用 @Order 注解，使用 @Order 注解设置在 advisor3() 方法上是无用的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 低级切面，由一个切点和一个通知组成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Advisor <span class="title function_">advisor3</span><span class="params">(MethodInterceptor advice3)</span> &#123;</span><br><span class="line">        <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">        pointcut.setExpression(<span class="string">&quot;execution(* foo())&quot;</span>);</span><br><span class="line">        <span class="type">DefaultPointcutAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice3);</span><br><span class="line">        <span class="comment">// 设置切面执行顺序</span></span><br><span class="line">        advisor.setOrder(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> advisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置完成后，高级切面的执行优先级高于低级切面。执行 main() 方法验证执行顺序是否改变：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">aspect1 before...</span><br><span class="line">advice3 before...</span><br><span class="line">target1 foo</span><br><span class="line">advice3 after...</span><br><span class="line">aspect1 after...</span><br></pre></td></tr></table></figure><h2 id="17-2-代理对象创建时机"><a href="#17-2-代理对象创建时机" class="headerlink" title="17.2. 代理对象创建时机"></a>17.2. 代理对象创建时机</h2><p>使用 AnnotationAwareAspectJAutoProxyCreator Bean 后置处理器创建代理对象的时机有以下两个选择：</p><p>Bean 的依赖注入之前</p><p>Bean 初始化完成之后</p><p>这两个时机二选一，不会重复创建代理对象。</p><p>以下述代码为例，查看代理对象的创建时机：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.aop.framework.autoproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A17_1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">        context.registerBean(Config.class);</span><br><span class="line">        context.refresh();</span><br><span class="line">        context.close();</span><br><span class="line">        <span class="comment">// 创建 -&gt; (*) 依赖注入 -&gt; 初始化 (*)</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解析 <span class="doctag">@AspectJ</span> 注解，产生代理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> AnnotationAwareAspectJAutoProxyCreator <span class="title function_">annotationAwareAspectJAutoProxyCreator</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationAwareAspectJAutoProxyCreator</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解析 <span class="doctag">@Autowired</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> AutowiredAnnotationBeanPostProcessor <span class="title function_">autowiredAnnotationBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutowiredAnnotationBeanPostProcessor</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解析 <span class="doctag">@PostConstruct</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> CommonAnnotationBeanPostProcessor <span class="title function_">commonAnnotationBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonAnnotationBeanPostProcessor</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Advisor <span class="title function_">advisor</span><span class="params">(MethodInterceptor advice)</span> &#123;</span><br><span class="line">            <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">            pointcut.setExpression(<span class="string">&quot;execution(* foo())&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> MethodInterceptor <span class="title function_">advice</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> invocation -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Bean1</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Bean1()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Bean1 init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Bean2</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Bean2()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean1</span><span class="params">(Bean1 bean1)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Bean2 setBean1(bean1) class is: &quot;</span> + bean1.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Bean2 init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 bean2 中注入了 bean1。运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Bean1()</span><br><span class="line">Bean1 <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">Creating implicit proxy <span class="keyword">for</span> bean <span class="string">&#x27;bean1&#x27;</span> with <span class="number">0</span> common interceptors and <span class="number">2</span> specific interceptors </span><br><span class="line"><span class="title function_">Bean2</span><span class="params">()</span></span><br><span class="line">Bean2 <span class="title function_">setBean1</span><span class="params">(bean1)</span> <span class="keyword">class</span> <span class="title class_">is</span>: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.aop.framework.autoproxy.A17_1$Bean1$$EnhancerBySpringCGLIB$$b7d6405</span><br><span class="line">Bean2 <span class="title function_">init</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>在 bean1 初始化完成后，额外打印了一句日志信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Creating implicit proxy <span class="keyword">for</span> bean <span class="string">&#x27;bean1&#x27;</span> with <span class="number">0</span> common interceptors and <span class="number">2</span> specific interceptors</span><br></pre></td></tr></table></figure><p>表示为 bean1 创建了隐式代理。</p><p>此时代理对象在 Bean 初始化完成之后创建。</p><p>之后为 bean2 进行依赖注入时，注入的 bean1 是代理对象。</p><p>在 Bean1 类中添加 setBean2() 方法，表示向 bean1 中注入 bean2，此时 bean1 依赖 bean2，而 bean2 原本就依赖了 bean1，出现循环依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean2</span><span class="params">(Bean2 bean2)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean1 setBean2(bean2) class is: &quot;</span> + bean2.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean1 init()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行 main() 方法，查看 bean1 的代理对象的生成时机：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Bean1()</span><br><span class="line">Bean2()</span><br><span class="line">Creating implicit proxy <span class="keyword">for</span> bean <span class="string">&#x27;bean1&#x27;</span> with <span class="number">0</span> common interceptors and <span class="number">2</span> specific interceptors </span><br><span class="line">Bean2 <span class="title function_">setBean1</span><span class="params">(bean1)</span> <span class="keyword">class</span> <span class="title class_">is</span>: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.aop.framework.autoproxy.A17_1$Bean1$$EnhancerBySpringCGLIB$$5cff48bf</span><br><span class="line">Bean2 <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">Bean1 <span class="title function_">setBean2</span><span class="params">(bean2)</span> <span class="keyword">class</span> <span class="title class_">is</span>: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.aop.framework.autoproxy.A17_1$Bean2</span><br><span class="line">Bean1 <span class="title function_">init</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>首先进行 bean1 的实例化，然后进行 bean1 的依赖注入，但此时容器中并没有 bean2，因此需要进行 bean2 的实例化。</p><p>接下来进行 bean2 的依赖注入，向 bean2 中注入 bean1，注入的 bean1 应该是被增强的，即它的代理对象，因此创建 bean1 的代理对象后再完成 bean2 的依赖注入。</p><p>接着继续 bean2 的生命周期，完成 bean2 的初始化阶段，最后回到 bean1 的依赖注入阶段，向 bean1 中注入 bean2，最后完成 bean1 的初始化阶段。</p><p>总结</p><p>代理对象的创建时机：</p><ul><li>无循环依赖时，在 Bean 初始化阶段之后创建；</li><li>有循环依赖时，在 Bean 实例化后、依赖注入之前创建，并将代理对象暂存于二级缓存。Bean 的依赖注入阶段和初始化阶段不应该被增强，仍应被施加于原始对象。</li></ul><h2 id="17-3-高级切面转低级切面"><a href="#17-3-高级切面转低级切面" class="headerlink" title="17.3 高级切面转低级切面"></a>17.3 高级切面转低级切面</h2><p>调用 AnnotationAwareAspectJAutoProxyCreator 对象的 findEligibleAdvisors() 方法时，获取能配合目标 Class 使用的切面，最终返回 Advisor 列表。在搜索过程中，如果遇到高级切面，则会将其转换成低级切面。</p><p>现有切面类与目标类信息如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Aspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;around...before&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;around...after&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高级切面中与通知类型相关的常用注解有 5 个：</p><ul><li>@Before：前置通知</li><li>@AfterReturning：后置通知</li><li>@AfterThrowing：异常通知</li><li>@After：最终通知</li><li>@Around：环绕通知</li></ul><p>以解析 @Before 注解为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 切面对象实例工厂，用于后续反射调用切面中的方法</span></span><br><span class="line">    <span class="type">AspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonAspectInstanceFactory</span>(<span class="keyword">new</span> <span class="title class_">Aspect</span>());</span><br><span class="line">    <span class="comment">// 高级切面转低级切面类</span></span><br><span class="line">    List&lt;Advisor&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Method method : Aspect.class.getDeclaredMethods()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(Before.class)) &#123;</span><br><span class="line">            <span class="comment">// 解析切点</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> method.getAnnotation(Before.class).value();</span><br><span class="line">            <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">            pointcut.setExpression(expression);</span><br><span class="line">            <span class="comment">// 通知类。前置通知对应的通知类是 AspectJMethodBeforeAdvice</span></span><br><span class="line">            <span class="type">AspectJMethodBeforeAdvice</span> <span class="variable">advice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJMethodBeforeAdvice</span>(method, pointcut, factory);</span><br><span class="line">            <span class="comment">// 切面</span></span><br><span class="line">            <span class="type">Advisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice);</span><br><span class="line">            list.add(advisor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Advisor advisor : list) &#123;</span><br><span class="line">        System.out.println(advisor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.aop.support.DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [org.springframework.aop.aspectj.AspectJMethodBeforeAdvice: advice method [<span class="keyword">public</span> <span class="keyword">void</span> org.springframework.aop.framework.autoproxy.A17_2$Aspect.before2()]; aspect name <span class="string">&#x27;&#x27;</span>]</span><br><span class="line"></span><br><span class="line">org.springframework.aop.support.DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [org.springframework.aop.aspectj.AspectJMethodBeforeAdvice: advice method [<span class="keyword">public</span> <span class="keyword">void</span> org.springframework.aop.framework.autoproxy.A17_2$Aspect.before1()]; aspect name <span class="string">&#x27;&#x27;</span>]</span><br></pre></td></tr></table></figure><p>@Before 标记的前置通知会被转换成原始的 AspectJMethodBeforeAdvice 形式，该对象包含了以下信息：</p><ul><li>通知对应的方法信息</li><li>切点信息</li><li>通知对象如何创建，本例公用一个 Aspect 对象</li></ul><p>通知相关注解与原始通知类对应关系如下：</p><p>注解                                       对应的原始通知类</p><p>@Before                          AspectJMethodBeforeAdvice</p><p>@AfterReturning               AspectJAfterReturningAdvice</p><p>@AfterThrowing               AspectJAfterThrowingAdvice</p><p>@After                            AspectJAfterAdvice</p><p>@Around                         AspectJAroundAdvice</p><h1 id="静态通知调用"><a href="#静态通知调用" class="headerlink" title="静态通知调用"></a>静态通知调用</h1><h2 id="18-1-统一转换成环绕通知"><a href="#18-1-统一转换成环绕通知" class="headerlink" title="18.1 统一转换成环绕通知"></a>18.1 统一转换成环绕通知</h2><p>通知相关注解都对应一个原始通知类，在 Spring 底层会将这些通知转换成环绕通知 MethodInterceptor。如果原始通知类本就实现了 MethodInterceptor 接口，则无需转换。</p><p>原始通知类                                               是否需要转换成 MethodInterceptor</p><p>AspectJMethodBeforeAdvice                                  ✅</p><p>AspectJAfterReturningAdvice                                 ✅</p><p>AspectJAfterThrowingAdvice                                  ❌</p><p>AspectJAfterAdvice                                               ❌</p><p>AspectJAroundAdvice                                            ❌</p><p>使用 ProxyFactory 无论基于哪种方式创建代理对象，最终调用 advice（通知，或者说通知对应的方法）的都是 MethodInvocation 对象。</p><p>项目中存在的 advisor（原本的低级切面和由高级切面转换得到的低级切面）往往不止一个，它们一个套一个地被调用，因此需要一个调用链对象，即 MethodInvocation。</p><p>MethodInvocation 需要知道 advice 有哪些，还需要知道目标对象是哪个。调用次序如下：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGRjYmVkNjRiMDY2NzVjYjZlOWNkNTNmNTU2YjUxNGRfQW5XQm8zR0o1cTVxZkNnTmlzWXNTWkFJUVp0eGlscUNfVG9rZW46UWY4bWJLbVRzbzdLVHh4TWllcGNoT2pzblplXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>由上图可知，环绕 通知最适合作为 advice，而 Before、AfterReturning 都应该转换成环绕通知。</p><p>统一转换成环绕通知的形式，体现了设计模式中的适配器模式：</p><p>对外更方便使用和区分各种通知类型</p><p>对内统一都是环绕通知，统一使用 MethodInterceptor 表示</p><p>通过 ProxyFactory 对象的 getInterceptorsAndDynamicInterceptionAdvice() 方法将其他通知统一转换为 MethodInterceptor 环绕通知：</p><table><thead><tr><th>注解</th><th>原始通知类</th><th>适配器</th><th>拦截器</th></tr></thead><tbody><tr><td>@Before</td><td>AspectJMethodBeforeAdvice</td><td>MethodBeforeAdviceAdapter</td><td>MethodBeforeAdviceInterceptor</td></tr><tr><td>@AfterReturning</td><td>AspectJAfterReturningAdvice</td><td>AspectJAfterReturningAdvice</td><td>AfterReturningAdviceInterceptor</td></tr></tbody></table><p>转换得到的通知都是静态通知，体现在 getInterceptorsAndDynamicInterceptionAdvice() 方法中的 Interceptors 部分，这些通知在被调用时无需再次检查切点，直接调用即可。</p><p>切面类与目标类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Aspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;execution(* foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;execution(* foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;around...before&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;around...after&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将高级切面转换成低级切面，并将通知统一转换成环绕通知：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">AspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonAspectInstanceFactory</span>(<span class="keyword">new</span> <span class="title class_">Aspect</span>());</span><br><span class="line">    <span class="comment">// 1. 高级切面转低级切面类</span></span><br><span class="line">    List&lt;Advisor&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Method method : Aspect.class.getDeclaredMethods()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(Before.class)) &#123;</span><br><span class="line">            <span class="comment">// 解析切点</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> method.getAnnotation(Before.class).value();</span><br><span class="line">            <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">            pointcut.setExpression(expression);</span><br><span class="line">            <span class="comment">// 通知类</span></span><br><span class="line">            <span class="type">AspectJMethodBeforeAdvice</span> <span class="variable">advice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJMethodBeforeAdvice</span>(method, pointcut, factory);</span><br><span class="line">            <span class="comment">// 切面</span></span><br><span class="line">            <span class="type">Advisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice);</span><br><span class="line">            list.add(advisor);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.isAnnotationPresent(AfterReturning.class)) &#123;</span><br><span class="line">            <span class="comment">// 解析切点</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> method.getAnnotation(AfterReturning.class).value();</span><br><span class="line">            <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">            pointcut.setExpression(expression);</span><br><span class="line">            <span class="comment">// 通知类</span></span><br><span class="line">            <span class="type">AspectJAfterReturningAdvice</span> <span class="variable">advice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJAfterReturningAdvice</span>(method, pointcut, factory);</span><br><span class="line">            <span class="comment">// 切面</span></span><br><span class="line">            <span class="type">Advisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice);</span><br><span class="line">            list.add(advisor);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.isAnnotationPresent(Around.class)) &#123;</span><br><span class="line">            <span class="comment">// 解析切点</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> method.getAnnotation(Around.class).value();</span><br><span class="line">            <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">            pointcut.setExpression(expression);</span><br><span class="line">            <span class="comment">// 通知类</span></span><br><span class="line">            <span class="type">AspectJAroundAdvice</span> <span class="variable">advice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJAroundAdvice</span>(method, pointcut, factory);</span><br><span class="line">            <span class="comment">// 切面</span></span><br><span class="line">            <span class="type">Advisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice);</span><br><span class="line">            list.add(advisor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Advisor advisor : list) &#123;</span><br><span class="line">        System.out.println(advisor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通知统一转换为环绕通知 MethodInterceptor</span></span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">    <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">    proxyFactory.setTarget(target);</span><br><span class="line">    proxyFactory.addAdvisors(list);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    List&lt;Object&gt; methodInterceptorList = proxyFactory.getInterceptorsAndDynamicInterceptionAdvice(Target.class.getMethod(<span class="string">&quot;foo&quot;</span>), Target.class);</span><br><span class="line">    <span class="keyword">for</span> (Object o : methodInterceptorList) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据打印信息可知：</p><p>前置通知 AspectJMethodBeforeAdvice 被转换成 MethodBeforeAdviceInterceptor</p><p>环绕通知 AspectJAroundAdvice 保持不变</p><p>后置通知 AspectJAfterReturningAdvice 被转换成 AfterReturningAdviceInterceptor</p><h2 id="18-2-调用链执行"><a href="#18-2-调用链执行" class="headerlink" title="18.2 调用链执行"></a>18.2 调用链执行</h2><p>高级切面成功转换成低级切面，切面中的通知也全部转换成环绕通知 MethodInterceptor，最后还要调用这些通知和目标方法。</p><p>这个调用交由调用链对象 MethodInvocation 来完成，在调用链对象中存放了所有经过转换得到的环绕通知和目标方法。</p><p>MethodInvocation 是一个接口，其最根本的实现是 ReflectiveMethodInvocation。</p><p>构建 ReflectiveMethodInvocation 对象需要 6 个参数：</p><ol><li>proxy：代理对象</li><li>target：目标对象</li><li>method：目标对象中的方法对象</li><li>arguments：调用目标对象中的方法需要的参数</li><li>targetClass：目标对象的 Class 对象</li><li>interceptorsAndDynamicMethodMatchers：转换得到的环绕通知列表</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">// 3. 创建并执行调用链 (环绕通知s + 目标)</span></span><br><span class="line">    <span class="type">MethodInvocation</span> <span class="variable">methodInvocation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReflectiveMethodInvocation</span>(</span><br><span class="line">        <span class="literal">null</span>, target, Target.class.getMethod(<span class="string">&quot;foo&quot;</span>), <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>], Target.class, methodInterceptorList</span><br><span class="line">    );</span><br><span class="line">    methodInvocation.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后会抛出异常：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalStateException: No MethodInvocation found:</span><br></pre></td></tr></table></figure><p>提示没有找到 MethodInvocation。但调用链对象不是已经创建好了吗？</p><p>这是因为调用链在执行过程会调用到很多通知，而某些通知内部可能需要使用调用链对象。因此需要将调用链对象存放在某一位置，使所有通知都能获取到调用链对象。</p><p>这个“位置”就是 当前线程。</p><p>那怎么将调用链对象放入当前线程呢？</p><p>可以在所有通知的最外层再添加一个环绕通知，其作用是将调用链对象放入当前线程。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=Zjg2MzQ2YTE5OTBjYTM1OWEzNmZkODNmYjYyZGNmM2RfS2hDWXI1NVVZd1NVOXNlM0t1c1hqV2hsNnNNbld1UHNfVG9rZW46THRjVmJROVVyb0xZOUd4cEVXUGNETmxFbkFoXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>可以使用 Spring 提供的 ExposeInvocationInterceptor 作为最外层的环绕通知。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通知统一转换为环绕通知 MethodInterceptor</span></span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">    <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">    proxyFactory.setTarget(target);</span><br><span class="line">    <span class="comment">// 在最外层添加环绕通知，把 MethodInvocation 放入当前线程</span></span><br><span class="line">    proxyFactory.addAdvice(ExposeInvocationInterceptor.INSTANCE);</span><br><span class="line">    proxyFactory.addAdvisors(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">// 3. 创建并执行调用链 (环绕通知s + 目标)</span></span><br><span class="line">    <span class="type">MethodInvocation</span> <span class="variable">methodInvocation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReflectiveMethodInvocation</span>(</span><br><span class="line">        <span class="literal">null</span>, target, Target.class.getMethod(<span class="string">&quot;foo&quot;</span>), <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>], Target.class, methodInterceptorList</span><br><span class="line">    );</span><br><span class="line">    methodInvocation.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行 main() 方法不再报错，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before1</span><br><span class="line">around...before</span><br><span class="line">before2</span><br><span class="line">target foo</span><br><span class="line">around...after</span><br><span class="line">afterReturning</span><br></pre></td></tr></table></figure><h2 id="18-3-模拟实现调用链"><a href="#18-3-模拟实现调用链" class="headerlink" title="18.3 模拟实现调用链"></a>18.3 模拟实现调用链</h2><p>调用链执行过程是一个递归过程。执行 proceed() 方法将调用调用链中下一个通知或目标方法。当调用链中没有通知时，就调用目标方法，反之调用下一个通知。</p><p>这体现了设计模式中的责任链模式。</p><p>目标类 Target：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Target foo()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 MethodInterceptor 接口，编写两个环绕通知：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Advice1</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Advice1.before()&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;Advice1.after()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Advice2</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Advice2.before()&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;Advice2.after()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 MethodInvocation 接口，实现自己的调用链：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyInvocation</span> <span class="keyword">implements</span> <span class="title class_">MethodInvocation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] args;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;MethodInterceptor&gt; methodInterceptorList;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocation</span><span class="params">(Object target, Method method, Object[] args, List&lt;MethodInterceptor&gt; methodInterceptorList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">        <span class="built_in">this</span>.method = method;</span><br><span class="line">        <span class="built_in">this</span>.args = args;</span><br><span class="line">        <span class="built_in">this</span>.methodInterceptorList = methodInterceptorList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Method <span class="title function_">getMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object[] getArguments() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; methodInterceptorList.size()) &#123;</span><br><span class="line">            <span class="comment">// 调用目标，结束递归并返回</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逐一调用通知</span></span><br><span class="line">        <span class="type">MethodInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> methodInterceptorList.get(count++ - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归操作交给通知类</span></span><br><span class="line">        <span class="keyword">return</span> interceptor.invoke(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getThis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AccessibleObject <span class="title function_">getStaticPart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 main() 方法，执行调用链，查看控制台输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">    List&lt;MethodInterceptor&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Advice1</span>(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Advice2</span>()</span><br><span class="line">    ));</span><br><span class="line">    <span class="type">MyInvocation</span> <span class="variable">invocation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocation</span>(target, Target.class.getMethod(<span class="string">&quot;foo&quot;</span>), <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>], list);</span><br><span class="line">    invocation.proceed();</span><br><span class="line">&#125;</span><br><span class="line">Advice1.before()</span><br><span class="line">Advice2.before()</span><br><span class="line">Target <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">Advice2.after()</span><br><span class="line">Advice1.after()</span><br></pre></td></tr></table></figure><h2 id="18-4-代理对象调用流程"><a href="#18-4-代理对象调用流程" class="headerlink" title="18.4 代理对象调用流程"></a>18.4 代理对象调用流程</h2><p>以 JDK 动态代理实现为例：</p><ul><li>从 ProxyFactory 获得 Target 和环绕通知链，根据它们创建 MethodInvocation 对象，简称 mi</li><li>首次执行 mi.proceed() 后发现有下一个环绕通知，调用它的 invoke(mi)</li><li>进入环绕通知 1，执行前增强，再次调用 mi.proceed() 后又发现有下一个环绕通知，调用它的 invoke(mi)</li><li>进入环绕通知 2，执行前增强，调用 mi.proceed() 发现没有环绕通知，调用 mi.invokeJoinPoint() 执行目标方法</li><li>目标方法执行结束，将结果返回给环绕通知 2，执行环绕通知 2 的后增强</li><li>环绕通知 2 继续将结果返回给环绕通知 1，执行环绕通知 1 的后增强</li><li>环绕通知 1 返回最终的结果</li></ul><h1 id="动态通知调用"><a href="#动态通知调用" class="headerlink" title="动态通知调用"></a>动态通知调用</h1><p>前文的示例都是静态通知调用，无需参数绑定，执行时无需切点信息，性能较高。</p><p>相应地就有动态通知调用，它需要参数绑定，执行时还需要切点信息，性能较低。比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态通知调用，无需参数绑定，性能较高</span></span><br><span class="line"><span class="comment">     * 执行时无需切点信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* foo(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态通知调用，需要参数绑定，性能较低</span></span><br><span class="line"><span class="comment">     * 执行时还需要切点信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* foo(..)) &amp;&amp; args(x)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;before(%d)\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标类 Target：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;target foo(%d)\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类 MyConfig：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AnnotationAwareAspectJAutoProxyCreator <span class="title function_">proxyCreator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationAwareAspectJAutoProxyCreator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyAspect <span class="title function_">myAspect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyAspect</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 main() 方法，新建 Spring 容器，查找符合条件的切面，将所有通知转换成环绕通知：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">    context.registerBean(MyConfig.class);</span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="type">AnnotationAwareAspectJAutoProxyCreator</span> <span class="variable">creator</span> <span class="operator">=</span> context.getBean(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line">    List&lt;Advisor&gt; list = creator.findEligibleAdvisors(Target.class, <span class="string">&quot;target&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">    <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">    factory.setTarget(target);</span><br><span class="line">    factory.addAdvisors(list);</span><br><span class="line"></span><br><span class="line">    List&lt;Object&gt; interceptorList = factory.getInterceptorsAndDynamicInterceptionAdvice(Target.class.getMethod(<span class="string">&quot;foo&quot;</span>, <span class="type">int</span>.class), Target.class);</span><br><span class="line">    <span class="keyword">for</span> (Object o : interceptorList) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 main() 方法，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.aop.interceptor.ExposeInvocationInterceptor@73e22a3d</span><br><span class="line">org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor@47faa49c</span><br><span class="line">org.springframework.aop.framework.InterceptorAndDynamicMethodMatcher@28f2a10f</span><br></pre></td></tr></table></figure><p>第一个 ExposeInvocationInterceptor 对象是 Spring 添加的环绕通知，第二个 MethodBeforeAdviceInterceptor 对象是前置通知转换得到的环绕通知，那 InterceptorAndDynamicMethodMatcher 对象是什么呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterceptorAndDynamicMethodMatcher</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> MethodInterceptor interceptor;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> MethodMatcher methodMatcher;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">InterceptorAndDynamicMethodMatcher</span><span class="params">(MethodInterceptor interceptor, MethodMatcher methodMatcher)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.interceptor = interceptor;</span><br><span class="line">      <span class="built_in">this</span>.methodMatcher = methodMatcher;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InterceptorAndDynamicMethodMatcher 并没有实现 MethodInterceptor 接口，它 不是一个环绕通知，对应了动态通知调用。</p><p>因此 ProxyFactory 对象的 getInterceptorsAndDynamicInterceptionAdvice() 方法返回的不仅是转换得到的环绕通知，还有对应动态通知调用的 InterceptorAndDynamicMethodMatcher 对象。</p><p>InterceptorAndDynamicMethodMatcher 对象中包含了环绕通知 interceptor 对象和切点信息 methodMatcher（前文使用过的 AspectJExpressionPointcut 也实现了 MethodMatcher 接口）。</p><p>尝试查看 InterceptorAndDynamicMethodMatcher 对象中包含的信息，但该类并未声明成 public，其成员变量也未被 public 修饰，也没提供获取的方式，但可以使用反射：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : interceptorList) &#123;</span><br><span class="line">        showDetail(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showDetail</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;org.springframework.aop.framework.InterceptorAndDynamicMethodMatcher&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (clazz.isInstance(o)) &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">methodMatcher</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;methodMatcher&quot;</span>);</span><br><span class="line">            methodMatcher.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Field</span> <span class="variable">methodInterceptor</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;interceptor&quot;</span>);</span><br><span class="line">            methodInterceptor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;环绕通知和切点：&quot;</span> + o);</span><br><span class="line">            System.out.println(<span class="string">&quot;\t切点为：&quot;</span> + methodMatcher.get(o));</span><br><span class="line">            System.out.println(<span class="string">&quot;\t通知为：&quot;</span> + methodInterceptor.get(o));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;普通环绕通知：&quot;</span> + o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">普通环绕通知：org.springframework.aop.interceptor.ExposeInvocationInterceptor@73e22a3d</span><br><span class="line">普通环绕通知：org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor@47faa49c</span><br><span class="line">环绕通知和切点：org.springframework.aop.framework.InterceptorAndDynamicMethodMatcher<span class="meta">@f736069</span></span><br><span class="line">        切点为：AspectJExpressionPointcut: (<span class="type">int</span> x) execution(* foo(..)) &amp;&amp; args(x)</span><br><span class="line">        通知为：org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor@6da21078</span><br></pre></td></tr></table></figure><p>根据打印的切点信息可知，InterceptorAndDynamicMethodMatcher 对象的确对应了动态通知调用。</p><p>最后创建调用链对象，执行通知和原始方法：。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> factory.getProxy();</span><br><span class="line">    <span class="type">MethodInvocation</span> <span class="variable">methodInvocation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReflectiveMethodInvocation</span>(</span><br><span class="line">        proxy, target, Target.class.getMethod(<span class="string">&quot;foo&quot;</span>, <span class="type">int</span>.class), <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">100</span>&#125;, Target.class, interceptorList</span><br><span class="line">    ) &#123;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    methodInvocation.proceed();</span><br><span class="line">&#125;</span><br><span class="line">before1</span><br><span class="line"><span class="title function_">before</span><span class="params">(<span class="number">100</span>)</span></span><br><span class="line">target <span class="title function_">foo</span><span class="params">(<span class="number">100</span>)</span></span><br></pre></td></tr></table></figure><p> 动态通知调用需要切点信息，需要对参数进行匹配和绑定，复杂程度高，性能比静态通知调用低。</p><h1 id="RequestMappingHandlerMapping-与-RequestMappingHandlerAdapter"><a href="#RequestMappingHandlerMapping-与-RequestMappingHandlerAdapter" class="headerlink" title="RequestMappingHandlerMapping 与 RequestMappingHandlerAdapter"></a>RequestMappingHandlerMapping 与 RequestMappingHandlerAdapter</h1><h2 id="20-1-DispatcherServlet-的初始化"><a href="#20-1-DispatcherServlet-的初始化" class="headerlink" title="20.1 DispatcherServlet 的初始化"></a>20.1 DispatcherServlet 的初始化</h2><p>选择支持内嵌Tomcat 服务器的 Spring 容器作为 ApplicationContext 的实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigServletWebServerApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>(WebConfig.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebConfig 作为配置类，向 Spring 容器中添加内嵌 Web 容器工厂、DispatcherServlet 和 DispatcherServlet 注册对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内嵌 Web 容器工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">tomcatServletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 DispatcherServlet</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册 DispatcherServlet，Spring MVC 的入口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">dispatcherServletRegistrationBean</span><span class="params">(DispatcherServlet dispatcherServlet)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Tomcat initialized with <span class="title function_">port</span><span class="params">(s)</span>: <span class="number">8080</span> (http)</span><br><span class="line">Root WebApplicationContext: initialization completed in <span class="number">2132</span> ms</span><br></pre></td></tr></table></figure><p>Tomcat 容器初始化成功，Spring 容器初始化成功，但 DispatcherServlet 还未被初始化。</p><p>当Tomcat 服务器 首次 使用到 DispatcherServlet 时，才会由Tomcat 服务器初始化 DispatcherServlet。</p><p>清空控制台信息，使用浏览器访问 localhost:8080，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">信息: Initializing Spring DispatcherServlet <span class="string">&#x27;dispatcherServlet&#x27;</span></span><br><span class="line">[INFO ] Initializing Servlet <span class="string">&#x27;dispatcherServlet&#x27;</span> </span><br><span class="line">[TRACE] No MultipartResolver <span class="string">&#x27;multipartResolver&#x27;</span> declared </span><br><span class="line">[TRACE] No LocaleResolver <span class="string">&#x27;localeResolver&#x27;</span>: using <span class="keyword">default</span> [AcceptHeaderLocaleResolver] </span><br><span class="line">[TRACE] No ThemeResolver <span class="string">&#x27;themeResolver&#x27;</span>: using <span class="keyword">default</span> [FixedThemeResolver] </span><br><span class="line">[TRACE] No HandlerMappings declared <span class="keyword">for</span> servlet <span class="string">&#x27;dispatcherServlet&#x27;</span>: using <span class="keyword">default</span> strategies from DispatcherServlet.properties </span><br><span class="line">[TRACE] No HandlerAdapters declared <span class="keyword">for</span> servlet <span class="string">&#x27;dispatcherServlet&#x27;</span>: using <span class="keyword">default</span> strategies from DispatcherServlet.properties </span><br><span class="line">[TRACE] No HandlerExceptionResolvers declared in servlet <span class="string">&#x27;dispatcherServlet&#x27;</span>: using <span class="keyword">default</span> strategies from DispatcherServlet.properties </span><br><span class="line">[TRACE] No RequestToViewNameTranslator <span class="string">&#x27;viewNameTranslator&#x27;</span>: using <span class="keyword">default</span> [DefaultRequestToViewNameTranslator] </span><br><span class="line">[TRACE] No ViewResolvers declared <span class="keyword">for</span> servlet <span class="string">&#x27;dispatcherServlet&#x27;</span>: using <span class="keyword">default</span> strategies from DispatcherServlet.properties </span><br><span class="line">[TRACE] No FlashMapManager <span class="string">&#x27;flashMapManager&#x27;</span>: using <span class="keyword">default</span> [SessionFlashMapManager] </span><br><span class="line">[INFO] Completed initialization in <span class="number">482</span> ms </span><br></pre></td></tr></table></figure><p>完成 DispatcherServlet 的初始化。</p><p>使用 DEBUG 查看 DispatcherServlet 的初始化时机</p><p>断点 DispatcherServlet 的 onRefresh() 方法中 this.initStrategies(context); 的所在行：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.initStrategies(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 DEBUG 方式重启程序，此时程序尚未执行到断点处。</p><p>再次在浏览器中访问 localhost:8080，程序执行到断点处。</p><p>查看调用栈可知，是从 GenericServlet 的 init() 方法执行到 onRefresh() 方法的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="built_in">this</span>.config = config;</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此 DispatcherServlet 的初始化流程走的是 Servlet 的初始化流程。</p><p>使 DispatcherServlet 在Tomcat 服务器启动时被初始化</p><p>修改添加到 Spring 容器的 DispatcherServlet 注册 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">dispatcherServletRegistrationBean</span><span class="params">(DispatcherServlet dispatcherServlet)</span> &#123;</span><br><span class="line">    <span class="type">DispatcherServletRegistrationBean</span> <span class="variable">registrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置其 loadOnStartup 为一个正数。</p><p>当存在多个 DispatcherServlet 需要被注册时，设置的 loadOnStartup 越大，优先级越小，初始化顺序越靠后。</p><p>再次重启程序，根据控制台输出的内容可知，不仅完成 Tomcat 和 Spring 容器的初始化，DispatcherServlet 也初始化成功。</p><p>抽取配置信息到配置文件中</p><p>使用 @PropertySource 注解设置配置类需要读取的配置文件，以便后续读取配置文件中的内容。</p><p>要读取配置文件中的内容，可以使用 @Value 注解，但该注解一次仅仅能够读取一个值，现实是往往需要从配置文件中读取多个值。</p><p>可以使用 @EnableConfigurationProperties 注解完成配置文件信息与对象的绑定，后续使用时作为 @Bean 注解标记的方法的参数直接在方法中使用即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server.port=<span class="number">9090</span></span><br><span class="line">spring.mvc.servlet.load-on-startup=<span class="number">1</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;WebMvcProperties.class, ServerProperties.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内嵌 Web 容器工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">tomcatServletWebServerFactory</span><span class="params">(ServerProperties serverProperties)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>(serverProperties.getPort());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 DispatcherServlet</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册 DispatcherServlet，Spring MVC 的入口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">dispatcherServletRegistrationBean</span><span class="params">(DispatcherServlet dispatcherServlet,</span></span><br><span class="line"><span class="params">                                                                               WebMvcProperties webMvcProperties)</span> &#123;</span><br><span class="line">        <span class="type">DispatcherServletRegistrationBean</span> <span class="variable">registrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        registrationBean.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup());</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次重启程序，根据控制台输出的内容可知，Tomcat 此时监听的端口是 9090，DispatcherServlet 也在 Tomcat 启动时被初始化。</p><p>DispatcherServlet 初始化时执行的操作</p><p>回到 DispatcherServlet 的 onRefresh() 方法，它又调用了 initStrategies() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initStrategies</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.initMultipartResolver(context);</span><br><span class="line">    <span class="built_in">this</span>.initLocaleResolver(context);</span><br><span class="line">    <span class="built_in">this</span>.initThemeResolver(context);</span><br><span class="line">    <span class="built_in">this</span>.initHandlerMappings(context);</span><br><span class="line">    <span class="built_in">this</span>.initHandlerAdapters(context);</span><br><span class="line">    <span class="built_in">this</span>.initHandlerExceptionResolvers(context);</span><br><span class="line">    <span class="built_in">this</span>.initRequestToViewNameTranslator(context);</span><br><span class="line">    <span class="built_in">this</span>.initViewResolvers(context);</span><br><span class="line">    <span class="built_in">this</span>.initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中初始化了一系列组件，见名识意即可，重点介绍：</p><p>initHandlerMappings()：初始化处理器映射器</p><p>initHandlerAdapters()：初始化处理器适配器</p><p>initHandlerExceptionResolvers()：初始化异常处理器</p><p>在所有的初始化方法中都有一个相似的逻辑，首先使用一个布尔值判断是否检测 所有 目标组件。</p><p>Spring 支持父子容器嵌套，如果判断的布尔值为 true，那么 Spring 不仅会在当前容器中获取目标组件，还会在其所有父级容器中寻找。</p><p>以 initHandlerMappings() 为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.handlerMappings = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.detectAllHandlerMappings) &#123; <span class="comment">// 是否需要检测所有处理器映射器</span></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 无需检测所有处理器映射器时，获取当前容器中的处理器映射器</span></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前容器中没有处理器映射器时，设置默认的处理器映射器</span></span><br><span class="line">        <span class="built_in">this</span>.handlerMappings = <span class="built_in">this</span>.getDefaultStrategies(context, HandlerMapping.class);</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-2-RequestMappingHandlerMapping"><a href="#20-2-RequestMappingHandlerMapping" class="headerlink" title="20.2 RequestMappingHandlerMapping"></a>20.2 RequestMappingHandlerMapping</h2><p>HandlerMapping，即处理器映射器，用于建立请求路径与控制器方法的映射关系。</p><p>RequestMappingHandlerMapping 是 HandlerMapping 的一种实现，根据类名可知，它是通过 @RequestMapping 注解来实现路径映射。</p><p>当 Spring 容器中没有 HandlerMapping 的实现时，尽管 DispatcherServlet 在初始化时会添加一些默认的实现，但这些实现不会交由 Spring 管理，而是作为 DispatcherServlet 的成员变量。</p><p>在配置类中将 RequestMappingHandlerMapping 添加到 Spring 容器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RequestMappingHandlerMapping <span class="title function_">requestMappingHandlerMapping</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerMapping</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个控制器类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Controller1</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;test1()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">test2</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;test2(&#123;&#125;)&quot;</span>, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/test3&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">test3</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;test3(&#123;&#125;)&quot;</span>, token);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test4&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;test4&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 main() 方法，从 Spring 容器中获取 RequestMappingHandlerMapping，再获取请求路径与映射器方法的映射关系，并根据给定请求获取控制器方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">AnnotationConfigServletWebServerApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>(WebConfig.class);</span><br><span class="line">    <span class="comment">// 解析 @RequestMapping 以及派生注解，在初始化时生成路径与控制器方法的映射关系</span></span><br><span class="line">    <span class="type">RequestMappingHandlerMapping</span> <span class="variable">handlerMapping</span> <span class="operator">=</span> context.getBean(RequestMappingHandlerMapping.class);</span><br><span class="line">    <span class="comment">// 获取映射结果</span></span><br><span class="line">    Map&lt;RequestMappingInfo, HandlerMethod&gt; handlerMethods = handlerMapping.getHandlerMethods();</span><br><span class="line">    handlerMethods.forEach((k, v) -&gt; System.out.println(k + <span class="string">&quot; = &quot;</span> + v));</span><br><span class="line">    <span class="comment">// 根据给定请求获取控制器方法，返回处理器执行链</span></span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">chain</span> <span class="operator">=</span> handlerMapping.getHandler(<span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/test1&quot;</span>));</span><br><span class="line">    System.out.println(chain);</span><br><span class="line">&#125;</span><br><span class="line">&#123;GET [/test1]&#125; = indi.lcp.a20.Controller1#test1()</span><br><span class="line">&#123;POST [/test2]&#125; = indi.lcp.a20.Controller1#test2(String)</span><br><span class="line">&#123;PUT [/test3]&#125; = indi.lcp.a20.Controller1#test3(String)</span><br><span class="line">&#123; [/test4]&#125; = indi.lcp.a20.Controller1#test4()</span><br><span class="line">HandlerExecutionChain with [indi.lcp.a20.Controller1#test1()] and <span class="number">0</span> interceptors</span><br></pre></td></tr></table></figure><p>getHandler() 方法返回的对象时处理器执行链，不仅包含映射器方法，还包含需要执行的拦截器信息</p><p>需要导入以下依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="20-3-RequestMappingHandlerAdapter"><a href="#20-3-RequestMappingHandlerAdapter" class="headerlink" title="20.3 RequestMappingHandlerAdapter"></a>20.3 RequestMappingHandlerAdapter</h2><p>RequestMappingHandlerAdapter 实现了 HandlerAdapter 接口，HandlerAdapter 用于执行控制器方法，而 RequestMapping 表明 RequestMappingHandlerAdapter 用于执行被 @RequestMapping 注解标记的控制器方法。</p><p>同样需要在配置类中将 RequestMappingHandlerAdapter 添加到 Spring 容器，但该类中需要测试的方法被 protected 修饰，无法直接使用，因此创建一个子类，将子类添加到 Spring 容器中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRequestMappingHandlerAdapter</span> <span class="keyword">extends</span> <span class="title class_">RequestMappingHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">invokeHandlerMethod</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MyRequestMappingHandlerAdapter <span class="title function_">myRequestMappingHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyRequestMappingHandlerAdapter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main() 方法中测试 RequestMappingHandlerAdapter 的 invokeHandlerMethod() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/test2&quot;</span>);</span><br><span class="line">    request.setParameter(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lcp&quot;</span>);</span><br><span class="line">    <span class="type">MockHttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletResponse</span>();</span><br><span class="line">    <span class="type">MyRequestMappingHandlerAdapter</span> <span class="variable">handlerAdapter</span> <span class="operator">=</span> context.getBean(MyRequestMappingHandlerAdapter.class);</span><br><span class="line">    handlerAdapter.invokeHandlerMethod(request, response, ((HandlerMethod) handlerMapping.getHandler(request).getHandler()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现控制器方法的调用很简单，但如何将请求参数与方法参数相绑定的呢？</p><p>显然是需要解析 @RequestParam 注解。</p><p>Spring 支持许多种类的控制器方法参数，不同种类的参数使用不同的解析器，使用 MyRequestMappingHandlerAdapter 的 getArgumentResolvers() 方法获取所有参数解析器。</p><p>Spring 也支持许多种类的控制器方法返回值类型，使用 MyRequestMappingHandlerAdapter 的 getReturnValueHandlers() 方法获取所有返回值处理器。</p><p>自定义参数解析器</p><p>假如经常需要使用到请求头中的 Token 信息，自定义 @Token 注解，使用该注解标记控制器方法的哪个参数来获取 Token 信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.PARAMETER)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Token &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使 test3() 控制器方法参数被 @Token 标记：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PutMapping(&quot;/test3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">test3</span><span class="params">(<span class="meta">@Token</span> String token)</span> &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;test3(&#123;&#125;)&quot;</span>, token);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义参数解析器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenArgumentResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodArgumentResolver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parameter.getParameterAnnotation(Token.class) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter,</span></span><br><span class="line"><span class="params">                                  ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">                                  NativeWebRequest webRequest,</span></span><br><span class="line"><span class="params">                                  WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> webRequest.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将参数解析器添加到 HandlerAdapter 中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MyRequestMappingHandlerAdapter <span class="title function_">myRequestMappingHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TokenArgumentResolver</span> <span class="variable">tokenArgumentResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TokenArgumentResolver</span>();</span><br><span class="line">    <span class="type">MyRequestMappingHandlerAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRequestMappingHandlerAdapter</span>();</span><br><span class="line">    adapter.setCustomArgumentResolvers(Collections.singletonList(tokenArgumentResolver));</span><br><span class="line">    <span class="keyword">return</span> adapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试执行 test3() 控制器方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">tokenRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>(<span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;/test3&quot;</span>);</span><br><span class="line">    tokenRequest.addHeader(<span class="string">&quot;token&quot;</span>, <span class="string">&quot;token info&quot;</span>);</span><br><span class="line">    handlerAdapter.invokeHandlerMethod(tokenRequest, response, ((HandlerMethod) handlerMapping.getHandler(tokenRequest).getHandler()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义返回值处理器</p><p>当 @ResponseBody 标记了控制器方法时，方法的返回值会转换成 JSON 写入响应体中。</p><p>自定义 @Yml 注解，被 @Yml 注解标记的控制器方法的返回值会转换成 YAML 写入响应体中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Yml &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使 test4() 控制器方法被 @Yml 注解标记：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test4&quot;)</span></span><br><span class="line"><span class="meta">@Yml</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;test4&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义返回值处理器将返回值转换成 YAML：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YmlReturnValueHandler</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodReturnValueHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> returnType.getMethodAnnotation(Yml.class) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(Object returnValue,</span></span><br><span class="line"><span class="params">                                  MethodParameter returnType,</span></span><br><span class="line"><span class="params">                                  ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">                                  NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 转换返回结果为 YAML</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>().dump(returnValue);</span><br><span class="line">        <span class="comment">// 将 YAML 字符串写入响应体</span></span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> webRequest.getNativeResponse(HttpServletResponse.class);</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/plain;charset=utf-8&quot;</span>);</span><br><span class="line">        response.getWriter().print(str);</span><br><span class="line">        <span class="comment">// 设置请求已经处理完毕</span></span><br><span class="line">        mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将返回值处理器添加到 HandlerAdapter 中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MyRequestMappingHandlerAdapter <span class="title function_">myRequestMappingHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MyRequestMappingHandlerAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRequestMappingHandlerAdapter</span>();</span><br><span class="line">    <span class="type">YmlReturnValueHandler</span> <span class="variable">ymlReturnValueHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YmlReturnValueHandler</span>();</span><br><span class="line">    adapter.setCustomReturnValueHandlers(Collections.singletonList(ymlReturnValueHandler));</span><br><span class="line">    <span class="keyword">return</span> adapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试执行 test4() 控制器方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">test4Req</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/test4&quot;</span>);</span><br><span class="line">    handlerAdapter.invokeHandlerMethod(test4Req, response, ((HandlerMethod) handlerMapping.getHandler(test4Req).getHandler()));</span><br><span class="line">    <span class="type">byte</span>[] content = response.getContentAsByteArray();</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(content, StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参数解析器"><a href="#参数解析器" class="headerlink" title="参数解析器"></a>参数解析器</h1><p>Spring 提供了许多种类的控制器方法参数解析器，定义一个包含多个不同种类参数的控制器方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(&quot;name1&quot;)</span> String name1, // name1=张三</span></span><br><span class="line"><span class="params">            String name2, // name2=李四</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(&quot;age&quot;)</span> <span class="type">int</span> age, // age=<span class="number">18</span></span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(name = &quot;home&quot;, defaultValue = &quot;$&#123;JAVA_HOME&#125;&quot;)</span> String home1, // spring 获取数据</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file, // 上传文件</span></span><br><span class="line"><span class="params">            <span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id, //  /test/<span class="number">124</span>   /test/&#123;id&#125;</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestHeader(&quot;Content-Type&quot;)</span> String header,</span></span><br><span class="line"><span class="params">            <span class="meta">@CookieValue(&quot;token&quot;)</span> String token,</span></span><br><span class="line"><span class="params">            <span class="meta">@Value(&quot;$&#123;JAVA_HOME&#125;&quot;)</span> String home2, // spring 获取数据  $&#123;&#125; #&#123;&#125;</span></span><br><span class="line"><span class="params">            HttpServletRequest request, // request, response, session ...</span></span><br><span class="line"><span class="params">            <span class="meta">@ModelAttribute(&quot;abc&quot;)</span> User user1, // name=zhang&amp;age=<span class="number">18</span></span></span><br><span class="line"><span class="params">            User user2, // name=zhang&amp;age=<span class="number">18</span></span></span><br><span class="line"><span class="params">            <span class="meta">@RequestBody</span> User user3 // json</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将控制器方法封装成 HandlerMethod 并打印方法中每个参数的信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 控制器方法封装成 HandlerMethod</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> Controller.class.getMethod(<span class="string">&quot;test&quot;</span>, String.class, String.class,</span><br><span class="line">            <span class="type">int</span>.class, String.class, MultipartFile.class,</span><br><span class="line">            <span class="type">int</span>.class, String.class, String.class,</span><br><span class="line">            String.class, HttpServletRequest.class, User.class,</span><br><span class="line">            User.class, User.class);</span><br><span class="line">    <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">Controller</span>(), method);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析每个参数值</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">annotations</span> <span class="operator">=</span> Arrays.stream(parameter.getParameterAnnotations())</span><br><span class="line">                .map(i -&gt; i.annotationType().getSimpleName()).collect(Collectors.joining());</span><br><span class="line">        <span class="type">String</span> <span class="variable">appendAt</span> <span class="operator">=</span> annotations.length() &gt; <span class="number">0</span> ? <span class="string">&quot;@&quot;</span> + annotations + <span class="string">&quot; &quot;</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 设置参数名解析器</span></span><br><span class="line">        parameter.initParameterNameDiscovery(<span class="keyword">new</span> <span class="title class_">DefaultParameterNameDiscoverer</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span> + parameter.getParameterIndex() + <span class="string">&quot;] &quot;</span> + appendAt +</span><br><span class="line">                parameter.getParameterType().getSimpleName() + <span class="string">&quot; &quot;</span> + parameter.getParameterName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">0</span>] <span class="meta">@RequestParam</span> String name1</span><br><span class="line">[<span class="number">1</span>] String name2</span><br><span class="line">[<span class="number">2</span>] <span class="meta">@RequestParam</span> <span class="type">int</span> age</span><br><span class="line">[<span class="number">3</span>] <span class="meta">@RequestParam</span> String home1</span><br><span class="line">[<span class="number">4</span>] <span class="meta">@RequestParam</span> MultipartFile file</span><br><span class="line">[<span class="number">5</span>] <span class="meta">@PathVariable</span> <span class="type">int</span> id</span><br><span class="line">[<span class="number">6</span>] <span class="meta">@RequestHeader</span> String header</span><br><span class="line">[<span class="number">7</span>] <span class="meta">@CookieValue</span> String token</span><br><span class="line">[<span class="number">8</span>] <span class="meta">@Value</span> String home2</span><br><span class="line">[<span class="number">9</span>] HttpServletRequest request</span><br><span class="line">[<span class="number">10</span>] <span class="meta">@ModelAttribute</span> User user1</span><br><span class="line">[<span class="number">11</span>] User user2</span><br><span class="line">[<span class="number">12</span>] <span class="meta">@RequestBody</span> User user3</span><br></pre></td></tr></table></figure><h2 id="21-1-RequestParam"><a href="#21-1-RequestParam" class="headerlink" title="21.1. @RequestParam"></a>21.1. @RequestParam</h2><p>@RequestParam 注解的解析需要使用到 RequestParamMethodArgumentResolver 参数解析器。构造时需要两个参数：</p><ul><li>beanFactory：Bean 工厂对象。需要解析 ${} 时，就需要指定 Bean 工厂对象</li><li>useDefaultResolution：布尔类型参数。为 false 表示只解析添加了 @RequestParam 注解的参数，为 true 针对未添加 @RequestParam 注解的参数也使用该参数解析器进行解析。</li></ul><p>RequestParamMethodArgumentResolver 利用 resolveArgument() 方法完成参数的解析，该方法需要传递四个参数：</p><ul><li>parameter：参数对象</li><li>mavContainer：ModelAndView 容器，用来存储中间的 Model 结果</li><li>webRequest：由 ServletWebRequest 封装后的请求对象</li><li>binderFactory：数据绑定工厂，用于完成对象绑定和类型转换，比如将字符串类型的 18 转换成整</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(WebConfig.class);</span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getBeanFactory();</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> mockRequest();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制器方法封装成 HandlerMethod</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> Controller.class.getMethod(<span class="string">&quot;test&quot;</span>, String.class, String.class,</span><br><span class="line">            <span class="type">int</span>.class, String.class, MultipartFile.class,</span><br><span class="line">            <span class="type">int</span>.class, String.class, String.class,</span><br><span class="line">            String.class, HttpServletRequest.class, User.class,</span><br><span class="line">            User.class, User.class);</span><br><span class="line">    <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">Controller</span>(), method);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备对象绑定与类型转换</span></span><br><span class="line">    <span class="type">ServletRequestDataBinderFactory</span> <span class="variable">binderFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRequestDataBinderFactory</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备 ModelAndViewContainer 用来存储中间的 Model 结果</span></span><br><span class="line">    <span class="type">ModelAndViewContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndViewContainer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析每个参数值</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">        <span class="comment">// useDefaultResolution 为 false 表示必须添加 @RequestParam 注解</span></span><br><span class="line">        <span class="type">RequestParamMethodArgumentResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">annotations</span> <span class="operator">=</span> Arrays.stream(parameter.getParameterAnnotations())</span><br><span class="line">                .map(i -&gt; i.annotationType().getSimpleName()).collect(Collectors.joining());</span><br><span class="line">        <span class="type">String</span> <span class="variable">appendAt</span> <span class="operator">=</span> annotations.length() &gt; <span class="number">0</span> ? <span class="string">&quot;@&quot;</span> + annotations + <span class="string">&quot; &quot;</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 设置参数名解析器</span></span><br><span class="line">        parameter.initParameterNameDiscovery(<span class="keyword">new</span> <span class="title class_">DefaultParameterNameDiscoverer</span>());</span><br><span class="line">        <span class="type">String</span> <span class="variable">paramInfo</span> <span class="operator">=</span> <span class="string">&quot;[&quot;</span> + parameter.getParameterIndex() + <span class="string">&quot;] &quot;</span> + appendAt +</span><br><span class="line">                parameter.getParameterType().getSimpleName() + <span class="string">&quot; &quot;</span> + parameter.getParameterName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resolver.supportsParameter(parameter)) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> resolver.resolveArgument(parameter, container, <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request), binderFactory);</span><br><span class="line">            System.out.println(Objects.requireNonNull(v).getClass());</span><br><span class="line">            System.out.println(paramInfo + <span class="string">&quot; -&gt; &quot;</span> + v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(paramInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">[<span class="number">0</span>] <span class="meta">@RequestParam</span> String name1 -&gt; zhangsan</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">[<span class="number">1</span>] String name2 -&gt; lisi</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.Integer</span><br><span class="line">[<span class="number">2</span>] <span class="meta">@RequestParam</span> <span class="type">int</span> age -&gt; <span class="number">18</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">[<span class="number">3</span>] <span class="meta">@RequestParam</span> String home1 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile</span><br><span class="line">[<span class="number">4</span>] <span class="meta">@RequestParam</span> MultipartFile file -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile<span class="meta">@f2ff811</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalStateException: Optional <span class="type">int</span> parameter <span class="string">&#x27;id&#x27;</span> is present but cannot be translated into a <span class="literal">null</span> value due to being declared as a primitive type. Consider declaring it as object wrapper <span class="keyword">for</span> the corresponding primitive type.</span><br></pre></td></tr></table></figure><p>控制器方法 test() 的前 5 个参数解析成功，但在解析第 6 个参数时产生了异常。</p><p>这是因为在构造 RequestParamMethodArgumentResolver 对象时，将 useDefaultResolution 设置为 true，针对未添加 @RequestParam 注解的参数都使用该参数解析器进行解析。第 6 个参数需要的 id 信息使用该解析器解析得到的结果是 null，无法将 null 值赋值给基本类型 int，显然第 6 个及其以后的参数应该使用其他参数解析器进行解析。</p><p>多个参数解析器的组合 - 组合模式</p><p>不同种类的参数需要不同的参数解析器，当前使用的参数解析器不支持当前参数的解析时，就应该换一个参数解析器进行解析。</p><p>可以将所有参数解析器添加到一个集合中，然后遍历这个集合，实现上述需求。</p><p>Spring 提供了名为 HandlerMethodArgumentResolverComposite 的类，对上述逻辑进行封装。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析每个参数值</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">        <span class="comment">// 多个参数解析器的组合</span></span><br><span class="line">        <span class="type">HandlerMethodArgumentResolverComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>();</span><br><span class="line">        composite.addResolvers(</span><br><span class="line">                <span class="comment">// useDefaultResolution 为 false 表示必须添加 @RequestParam 注解</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">true</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (composite.supportsParameter(parameter)) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> composite.resolveArgument(parameter, container, <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request), binderFactory);</span><br><span class="line">            System.out.println(paramInfo + <span class="string">&quot; -&gt; &quot;</span> + v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(paramInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21-2-PathVariable"><a href="#21-2-PathVariable" class="headerlink" title="21.2 @PathVariable"></a>21.2 @PathVariable</h2><p>@PathVariable 注解的解析需要使用到 PathVariableMethodArgumentResolver 参数解析器。构造时无需传入任何参数。</p><p>使用该解析器需要一个 Map 集合，该 Map 集合是 @RequestMapping 注解上指定的路径和实际 URL 路径进行匹配后，得到的路径上的参数与实际路径上的值的关系（获取这个 Map 并将其设置给 request 作用域由 HandlerMapping 完成）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析每个参数值</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">        <span class="comment">// 多个参数解析器的组合</span></span><br><span class="line">        <span class="type">HandlerMethodArgumentResolverComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>();</span><br><span class="line">        composite.addResolvers(</span><br><span class="line">            <span class="comment">// useDefaultResolution 为 false 表示必须添加 @RequestParam 注解</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">false</span>),</span><br><span class="line">            <span class="comment">// 解析 @PathVariable</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PathVariableMethodArgumentResolver</span>()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 RequestParamMethodArgumentResolver 参数解析器的构造，将 useDefaultResolution 设置为 false，让程序 暂时 不抛出异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>] <span class="meta">@RequestParam</span> String name1 -&gt; zhangsan</span><br><span class="line">[<span class="number">1</span>] String name2</span><br><span class="line">[<span class="number">2</span>] <span class="meta">@RequestParam</span> <span class="type">int</span> age -&gt; <span class="number">18</span></span><br><span class="line">[<span class="number">3</span>] <span class="meta">@RequestParam</span> String home1 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">4</span>] <span class="meta">@RequestParam</span> MultipartFile file -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@11c9af63</span><br><span class="line">[<span class="number">5</span>] <span class="meta">@PathVariable</span> <span class="type">int</span> id -&gt; <span class="number">123</span></span><br></pre></td></tr></table></figure><h2 id="21-3-RequestHeader"><a href="#21-3-RequestHeader" class="headerlink" title="21.3 @RequestHeader"></a>21.3 @RequestHeader</h2><p>@RequestHeader 注解的解析需要使用到 RequestHeaderMethodArgumentResolver 参数解析器。构造时需要传入一个Bean 工厂对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析每个参数值</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">        <span class="comment">// 多个参数解析器的组合</span></span><br><span class="line">        <span class="type">HandlerMethodArgumentResolverComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>();</span><br><span class="line">        composite.addResolvers(</span><br><span class="line">            <span class="comment">// useDefaultResolution 为 false 表示必须添加 @RequestParam 注解</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">false</span>),</span><br><span class="line">            <span class="comment">// 解析 @PathVariable</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PathVariableMethodArgumentResolver</span>(),</span><br><span class="line">            <span class="comment">// 解析 @RequestHeader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestHeaderMethodArgumentResolver</span>(beanFactory)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">0</span>] <span class="meta">@RequestParam</span> String name1 -&gt; zhangsan</span><br><span class="line">[<span class="number">1</span>] String name2</span><br><span class="line">[<span class="number">2</span>] <span class="meta">@RequestParam</span> <span class="type">int</span> age -&gt; <span class="number">18</span></span><br><span class="line">[<span class="number">3</span>] <span class="meta">@RequestParam</span> String home1 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">4</span>] <span class="meta">@RequestParam</span> MultipartFile file -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@3943a2be</span><br><span class="line">[<span class="number">5</span>] <span class="meta">@PathVariable</span> <span class="type">int</span> id -&gt; <span class="number">123</span></span><br><span class="line">[<span class="number">6</span>] <span class="meta">@RequestHeader</span> String header -&gt; application/json</span><br></pre></td></tr></table></figure><h2 id="21-4-CookieValue"><a href="#21-4-CookieValue" class="headerlink" title="21.4 @CookieValue"></a>21.4 @CookieValue</h2><p>@CookieValue 注解的解析需要使用到 ServletCookieValueMethodArgumentResolver 参数解析器。构造时需要传入一个Bean 工厂对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析每个参数值</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">        <span class="comment">// 多个参数解析器的组合</span></span><br><span class="line">        <span class="type">HandlerMethodArgumentResolverComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>();</span><br><span class="line">        composite.addResolvers(</span><br><span class="line">            <span class="comment">// useDefaultResolution 为 false 表示必须添加 @RequestParam 注解</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">false</span>),</span><br><span class="line">            <span class="comment">// 解析 @PathVariable</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PathVariableMethodArgumentResolver</span>(),</span><br><span class="line">            <span class="comment">// 解析 @RequestHeader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestHeaderMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 @CookieValue</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletCookieValueMethodArgumentResolver</span>(beanFactory)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">0</span>] <span class="meta">@RequestParam</span> String name1 -&gt; zhangsan</span><br><span class="line">[<span class="number">1</span>] String name2</span><br><span class="line">[<span class="number">2</span>] <span class="meta">@RequestParam</span> <span class="type">int</span> age -&gt; <span class="number">18</span></span><br><span class="line">[<span class="number">3</span>] <span class="meta">@RequestParam</span> String home1 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">4</span>] <span class="meta">@RequestParam</span> MultipartFile file -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@1329eff</span><br><span class="line">[<span class="number">5</span>] <span class="meta">@PathVariable</span> <span class="type">int</span> id -&gt; <span class="number">123</span></span><br><span class="line">[<span class="number">6</span>] <span class="meta">@RequestHeader</span> String header -&gt; application/json</span><br><span class="line">[<span class="number">7</span>] <span class="meta">@CookieValue</span> String token -&gt; <span class="number">123456</span></span><br></pre></td></tr></table></figure><h2 id="21-5-Value"><a href="#21-5-Value" class="headerlink" title="21.5 @Value"></a>21.5 @Value</h2><p>@Value 注解的解析需要使用到 ExpressionValueMethodArgumentResolver 参数解析器。构造时需要传入一个Bean 工厂对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析每个参数值</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">        <span class="comment">// 多个参数解析器的组合</span></span><br><span class="line">        <span class="type">HandlerMethodArgumentResolverComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>();</span><br><span class="line">        composite.addResolvers(</span><br><span class="line">            <span class="comment">// useDefaultResolution 为 false 表示必须添加 @RequestParam 注解</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">false</span>),</span><br><span class="line">            <span class="comment">// 解析 @PathVariable</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PathVariableMethodArgumentResolver</span>(),</span><br><span class="line">            <span class="comment">// 解析 @RequestHeader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestHeaderMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 @CookieValue</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletCookieValueMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 @Value</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ExpressionValueMethodArgumentResolver</span>(beanFactory)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">0</span>] <span class="meta">@RequestParam</span> String name1 -&gt; zhangsan</span><br><span class="line">[<span class="number">1</span>] String name2</span><br><span class="line">[<span class="number">2</span>] <span class="meta">@RequestParam</span> <span class="type">int</span> age -&gt; <span class="number">18</span></span><br><span class="line">[<span class="number">3</span>] <span class="meta">@RequestParam</span> String home1 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">4</span>] <span class="meta">@RequestParam</span> MultipartFile file -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@46fa7c39</span><br><span class="line">[<span class="number">5</span>] <span class="meta">@PathVariable</span> <span class="type">int</span> id -&gt; <span class="number">123</span></span><br><span class="line">[<span class="number">6</span>] <span class="meta">@RequestHeader</span> String header -&gt; application/json</span><br><span class="line">[<span class="number">7</span>] <span class="meta">@CookieValue</span> String token -&gt; <span class="number">123456</span></span><br><span class="line">[<span class="number">8</span>] <span class="meta">@Value</span> String home2 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br></pre></td></tr></table></figure><h2 id="21-6-HttpServletRequest"><a href="#21-6-HttpServletRequest" class="headerlink" title="21.6 HttpServletRequest"></a>21.6 HttpServletRequest</h2><p>HttpServletRequest 类型的参数的解析需要使用到 ServletRequestMethodArgumentResolver 参数解析器。构造时无需传入任何参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析每个参数值</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">        <span class="comment">// 多个参数解析器的组合</span></span><br><span class="line">        <span class="type">HandlerMethodArgumentResolverComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>();</span><br><span class="line">        composite.addResolvers(</span><br><span class="line">            <span class="comment">// useDefaultResolution 为 false 表示必须添加 @RequestParam 注解</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">false</span>),</span><br><span class="line">            <span class="comment">// 解析 @PathVariable</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PathVariableMethodArgumentResolver</span>(),</span><br><span class="line">            <span class="comment">// 解析 @RequestHeader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestHeaderMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 @CookieValue</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletCookieValueMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 @Value</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ExpressionValueMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 HttpServletRequest</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletRequestMethodArgumentResolver</span>()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">0</span>] <span class="meta">@RequestParam</span> String name1 -&gt; zhangsan</span><br><span class="line">[<span class="number">1</span>] String name2</span><br><span class="line">[<span class="number">2</span>] <span class="meta">@RequestParam</span> <span class="type">int</span> age -&gt; <span class="number">18</span></span><br><span class="line">[<span class="number">3</span>] <span class="meta">@RequestParam</span> String home1 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">4</span>] <span class="meta">@RequestParam</span> MultipartFile file -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@5f683daf</span><br><span class="line">[<span class="number">5</span>] <span class="meta">@PathVariable</span> <span class="type">int</span> id -&gt; <span class="number">123</span></span><br><span class="line">[<span class="number">6</span>] <span class="meta">@RequestHeader</span> String header -&gt; application/json</span><br><span class="line">[<span class="number">7</span>] <span class="meta">@CookieValue</span> String token -&gt; <span class="number">123456</span></span><br><span class="line">[<span class="number">8</span>] <span class="meta">@Value</span> String home2 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">9</span>] HttpServletRequest request -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest@152aa092</span><br></pre></td></tr></table></figure><p>ServletRequestMethodArgumentResolver 参数解析器不仅可以解析 HttpServletRequest 类型的参数，还支持许多其他类型的参数，其支持的参数类型可在 supportsParameter() 方法中看到：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; paramType = parameter.getParameterType();</span><br><span class="line">    <span class="keyword">return</span> (WebRequest.class.isAssignableFrom(paramType) ||</span><br><span class="line">            ServletRequest.class.isAssignableFrom(paramType) ||</span><br><span class="line">            MultipartRequest.class.isAssignableFrom(paramType) ||</span><br><span class="line">            HttpSession.class.isAssignableFrom(paramType) ||</span><br><span class="line">            (pushBuilder != <span class="literal">null</span> &amp;&amp; pushBuilder.isAssignableFrom(paramType)) ||</span><br><span class="line">            (Principal.class.isAssignableFrom(paramType) &amp;&amp; !parameter.hasParameterAnnotations()) ||</span><br><span class="line">            InputStream.class.isAssignableFrom(paramType) ||</span><br><span class="line">            Reader.class.isAssignableFrom(paramType) ||</span><br><span class="line">            HttpMethod.class == paramType ||</span><br><span class="line">            Locale.class == paramType ||</span><br><span class="line">            TimeZone.class == paramType ||</span><br><span class="line">            ZoneId.class == paramType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21-7-ModelAttribute"><a href="#21-7-ModelAttribute" class="headerlink" title="21.7 @ModelAttribute"></a>21.7 @ModelAttribute</h2><p>@ModelAttribute 注解的解析需要使用到 ServletModelAttributeMethodProcessor 参数解析器。构造时需要传入一个布尔类型的值。为 false 时，表示 @ModelAttribute 不是不必须的，即是必须的。</p><p>针对 @ModelAttribute(“abc”) User user1 和 User user2 两种参数来说，尽管后者没有使用 @ModelAttribute 注解，但它们使用的是同一种解析器。</p><p>添加两个 ServletModelAttributeMethodProcessor 参数解析器，先解析带 @ModelAttribute 注解的参数，再解析不带 @ModelAttribute 注解的参数。</p><p>通过 ServletModelAttributeMethodProcessor 解析得到的数据还会被存入 ModelAndViewContainer 中。存储的数据结构是一个 Map，其 key 为 @ModelAttribute 注解指定的 value 值，在未显式指定的情况下，默认为对象类型的首字母小写对应的字符串。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(</span></span><br><span class="line"><span class="params">                // 指定 value</span></span><br><span class="line"><span class="params">        <span class="meta">@ModelAttribute(&quot;abc&quot;)</span> User user1, // name=zhang&amp;age=<span class="number">18</span></span></span><br><span class="line"><span class="params">        User user2, // name=zhang&amp;age=<span class="number">18</span></span></span><br><span class="line"><span class="params">        <span class="meta">@RequestBody</span> User user3 // json</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析每个参数值</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">        <span class="comment">// 多个参数解析器的组合</span></span><br><span class="line">        <span class="type">HandlerMethodArgumentResolverComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>();</span><br><span class="line">        composite.addResolvers(</span><br><span class="line">            <span class="comment">// useDefaultResolution 为 false 表示必须添加 @RequestParam 注解</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">false</span>),</span><br><span class="line">            <span class="comment">// 解析 @PathVariable</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PathVariableMethodArgumentResolver</span>(),</span><br><span class="line">            <span class="comment">// 解析 @RequestHeader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestHeaderMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 @CookieValue</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletCookieValueMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 @Value</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ExpressionValueMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 HttpServletRequest</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletRequestMethodArgumentResolver</span>(),</span><br><span class="line">            <span class="comment">// 解析 @ModelAttribute，且不能省略</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">false</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">true</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (composite.supportsParameter(parameter)) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> composite.resolveArgument(parameter, container, <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request), binderFactory);</span><br><span class="line">            System.out.println(paramInfo + <span class="string">&quot; -&gt; &quot;</span> + v);</span><br><span class="line">            <span class="comment">// 打印模型数据</span></span><br><span class="line">            <span class="type">ModelMap</span> <span class="variable">modelMap</span> <span class="operator">=</span> container.getModel();</span><br><span class="line">            <span class="keyword">if</span> (MapUtils.isNotEmpty(modelMap)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;模型数据: &quot;</span> + modelMap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(paramInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">0</span>] <span class="meta">@RequestParam</span> String name1 -&gt; zhangsan</span><br><span class="line">[<span class="number">1</span>] String name2</span><br><span class="line">[<span class="number">2</span>] <span class="meta">@RequestParam</span> <span class="type">int</span> age -&gt; <span class="number">18</span></span><br><span class="line">[<span class="number">3</span>] <span class="meta">@RequestParam</span> String home1 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">4</span>] <span class="meta">@RequestParam</span> MultipartFile file -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@2beee7ff</span><br><span class="line">[<span class="number">5</span>] <span class="meta">@PathVariable</span> <span class="type">int</span> id -&gt; <span class="number">123</span></span><br><span class="line">[<span class="number">6</span>] <span class="meta">@RequestHeader</span> String header -&gt; application/json</span><br><span class="line">[<span class="number">7</span>] <span class="meta">@CookieValue</span> String token -&gt; <span class="number">123456</span></span><br><span class="line">[<span class="number">8</span>] <span class="meta">@Value</span> String home2 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">9</span>] HttpServletRequest request -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest@5fa07e12</span><br><span class="line">[<span class="number">10</span>] <span class="meta">@ModelAttribute</span> User user1 -&gt; A21.User(name=张三, age=<span class="number">18</span>)</span><br><span class="line">模型数据: &#123;abc=A21.User(name=张三, age=<span class="number">18</span>), org.springframework.validation.BindingResult.abc=org.springframework.validation.BeanPropertyBindingResult: <span class="number">0</span> errors&#125;</span><br><span class="line">[<span class="number">11</span>] User user2 -&gt; A21.User(name=张三, age=<span class="number">18</span>)</span><br><span class="line">模型数据: &#123;abc=A21.User(name=张三, age=<span class="number">18</span>), org.springframework.validation.BindingResult.abc=org.springframework.validation.BeanPropertyBindingResult: <span class="number">0</span> errors, user=A21.User(name=张三, age=<span class="number">18</span>), org.springframework.validation.BindingResult.user=org.springframework.validation.BeanPropertyBindingResult: <span class="number">0</span> errors&#125;</span><br><span class="line">[<span class="number">12</span>] <span class="meta">@RequestBody</span> User user3 -&gt; A21.User(name=李四, age=<span class="number">20</span>)</span><br><span class="line">模型数据: &#123;abc=A21.User(name=张三, age=<span class="number">18</span>), org.springframework.validation.BindingResult.abc=org.springframework.validation.BeanPropertyBindingResult: <span class="number">0</span> errors, user=A21.User(name=张三, age=<span class="number">18</span>), org.springframework.validation.BindingResult.user=org.springframework.validation.BeanPropertyBindingResult: <span class="number">0</span> errors&#125;</span><br></pre></td></tr></table></figure><p>@RequestBody User user3 参数也被 ServletModelAttributeMethodProcessor 解析了，如果想使其数据通过 JSON 数据转换而来，则需要使用另一个参数解析器。</p><h2 id="21-8-RequestBody"><a href="#21-8-RequestBody" class="headerlink" title="21.8 @RequestBody"></a>21.8 @RequestBody</h2><p>@RequestBody 注解的解析需要使用到 RequestResponseBodyMethodProcessor 参数解析器。构造时需要传入一个消息转换器列表。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析每个参数值</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">        <span class="comment">// 多个参数解析器的组合</span></span><br><span class="line">        <span class="type">HandlerMethodArgumentResolverComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>();</span><br><span class="line">        composite.addResolvers(</span><br><span class="line">            <span class="comment">// useDefaultResolution 为 false 表示必须添加 @RequestParam 注解</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">false</span>),</span><br><span class="line">            <span class="comment">// 解析 @PathVariable</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PathVariableMethodArgumentResolver</span>(),</span><br><span class="line">            <span class="comment">// 解析 @RequestHeader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestHeaderMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 @CookieValue</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletCookieValueMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 @Value</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ExpressionValueMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 HttpServletRequest</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletRequestMethodArgumentResolver</span>(),</span><br><span class="line">            <span class="comment">// 解析 @ModelAttribute，且不能省略</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">false</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>())),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">true</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">0</span>] <span class="meta">@RequestParam</span> String name1 -&gt; zhangsan</span><br><span class="line">[<span class="number">1</span>] String name2</span><br><span class="line">[<span class="number">2</span>] <span class="meta">@RequestParam</span> <span class="type">int</span> age -&gt; <span class="number">18</span></span><br><span class="line">[<span class="number">3</span>] <span class="meta">@RequestParam</span> String home1 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">4</span>] <span class="meta">@RequestParam</span> MultipartFile file -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@5e17553a</span><br><span class="line">[<span class="number">5</span>] <span class="meta">@PathVariable</span> <span class="type">int</span> id -&gt; <span class="number">123</span></span><br><span class="line">[<span class="number">6</span>] <span class="meta">@RequestHeader</span> String header -&gt; application/json</span><br><span class="line">[<span class="number">7</span>] <span class="meta">@CookieValue</span> String token -&gt; <span class="number">123456</span></span><br><span class="line">[<span class="number">8</span>] <span class="meta">@Value</span> String home2 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">9</span>] HttpServletRequest request -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest@13bc8645</span><br><span class="line">[<span class="number">10</span>] <span class="meta">@ModelAttribute</span> User user1 -&gt; A21.User(name=张三, age=<span class="number">18</span>)</span><br><span class="line">[<span class="number">11</span>] User user2 -&gt; A21.User(name=张三, age=<span class="number">18</span>)</span><br><span class="line">[<span class="number">12</span>] <span class="meta">@RequestBody</span> User user3 -&gt; A21.User(name=李四, age=<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>@RequestBody User user3 参数数据通过 JSON 数据得到，与上一节的解析进行区分。</p><p>除此之外，添加的参数解析器顺序也影响着解析结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">false</span>),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>())),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>先添加解析 @ModelAttribute 注解的解析器，再添加解析 @RequestBody 注解的解析器，最后添加解析省略了 @ModelAttribute 注解的解析器。如果更换最后两个解析器的顺序，那么 @RequestBody User user3 将会被 ServletModelAttributeMethodProcessor 解析，而不是 RequestResponseBodyMethodProcessor。</p><p>因此 String name2 参数也能通过添加同种参数但不同构造参数的解析器进行解析，注意添加的解析器的顺序，先处理对象，再处理单个参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析每个参数值</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">        <span class="comment">// 多个参数解析器的组合</span></span><br><span class="line">        <span class="type">HandlerMethodArgumentResolverComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>();</span><br><span class="line">        composite.addResolvers(</span><br><span class="line">            <span class="comment">// useDefaultResolution 为 false 表示必须添加 @RequestParam 注解</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">false</span>),</span><br><span class="line">            <span class="comment">// 解析 @PathVariable</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PathVariableMethodArgumentResolver</span>(),</span><br><span class="line">            <span class="comment">// 解析 @RequestHeader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestHeaderMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 @CookieValue</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletCookieValueMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 @Value</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ExpressionValueMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 HttpServletRequest</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletRequestMethodArgumentResolver</span>(),</span><br><span class="line">            <span class="comment">// 解析 @ModelAttribute，且不能省略</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">false</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>())),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">true</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">true</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">0</span>] <span class="meta">@RequestParam</span> String name1 -&gt; zhangsan</span><br><span class="line">[<span class="number">1</span>] String name2 -&gt; lisi</span><br><span class="line">[<span class="number">2</span>] <span class="meta">@RequestParam</span> <span class="type">int</span> age -&gt; <span class="number">18</span></span><br><span class="line">[<span class="number">3</span>] <span class="meta">@RequestParam</span> String home1 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">4</span>] <span class="meta">@RequestParam</span> MultipartFile file -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@5e17553a</span><br><span class="line">[<span class="number">5</span>] <span class="meta">@PathVariable</span> <span class="type">int</span> id -&gt; <span class="number">123</span></span><br><span class="line">[<span class="number">6</span>] <span class="meta">@RequestHeader</span> String header -&gt; application/json</span><br><span class="line">[<span class="number">7</span>] <span class="meta">@CookieValue</span> String token -&gt; <span class="number">123456</span></span><br><span class="line">[<span class="number">8</span>] <span class="meta">@Value</span> String home2 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">9</span>] HttpServletRequest request -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest@13bc8645</span><br><span class="line">[<span class="number">10</span>] <span class="meta">@ModelAttribute</span> User user1 -&gt; A21.User(name=张三, age=<span class="number">18</span>)</span><br><span class="line">[<span class="number">11</span>] User user2 -&gt; A21.User(name=张三, age=<span class="number">18</span>)</span><br><span class="line">[<span class="number">12</span>] <span class="meta">@RequestBody</span> User user3 -&gt; A21.User(name=李四, age=<span class="number">20</span>)</span><br></pre></td></tr></table></figure><h1 id="获取参数名"><a href="#获取参数名" class="headerlink" title="获取参数名"></a>获取参数名</h1><p>在项目的 src 目录外创建一个 Bean2.java 文件，使其不会被 IDEA 自动编译：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.lcp.a22;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将命令行切换到 Bean2.java 文件所在目录的位置，执行 javac .\Bean2.java 命令手动编译 Bean2.java。查看 Bean2.class 文件的内容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.lcp.a22;<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String var1, <span class="type">int</span> var2)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译生成的 class 文件中的 foo() 方法的参数名称不再是 name 和 age，也就是说直接使用 javac 命令进行编译得到的字节码文件不会保存方法的参数名称。</p><p>执行 javac -parameters .\Bean2.java 再次编译 Bean2.java，并查看得到的 Bean2.class 文件内容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.lcp.a22;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foo() 方法的参数名称得以保留。</p><p>还可以使用 javap -c -v .\Bean2.class 命令反编译 Bean2.class，foo() 方法的反编译结果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(java.lang.String, <span class="type">int</span>)</span>;</span><br><span class="line">  descriptor: (Ljava/lang/String;I)V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">0</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span><br><span class="line">       <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">  MethodParameters:</span><br><span class="line">    Name                           Flags</span><br><span class="line">    name</span><br><span class="line">    age</span><br></pre></td></tr></table></figure><p>foo() 方法的参数信息被保存在 MethodParameters 中，可以使用 反射 获取：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 反射获取参数名</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">foo</span> <span class="operator">=</span> Bean2.class.getMethod(<span class="string">&quot;foo&quot;</span>, String.class, <span class="type">int</span>.class);</span><br><span class="line">    <span class="keyword">for</span> (Parameter parameter : foo.getParameters()) &#123;</span><br><span class="line">        System.out.println(parameter.getName());       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">name</span><br><span class="line">age</span><br></pre></td></tr></table></figure><p>使用 javac -g .\Bean2.java 命令进行编译也会保留方法的参数信息。再次使用 javap 反编译 Bean2.class，foo() 方法的反编译结果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(java.lang.String, <span class="type">int</span>)</span>;</span><br><span class="line">  descriptor: (Ljava/lang/String;I)V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">0</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span><br><span class="line">       <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lindi/lcp/a22/Bean2;</span><br><span class="line">          <span class="number">0</span>       <span class="number">1</span>     <span class="number">1</span>  name   Ljava/lang/String;</span><br><span class="line">          <span class="number">0</span>       <span class="number">1</span>     <span class="number">2</span>   age   I</span><br></pre></td></tr></table></figure><p>foo() 方法的参数信息被保存在 LocalVariableTable 中，不能使用反射获取，但可以使用 ASM 获取，使用 Spring 封装的解析工具：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 反射获取参数名</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">foo</span> <span class="operator">=</span> Bean2.class.getMethod(<span class="string">&quot;foo&quot;</span>, String.class, <span class="type">int</span>.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于 LocalVariableTable 本地变量表获取</span></span><br><span class="line">    <span class="type">LocalVariableTableParameterNameDiscoverer</span> <span class="variable">discoverer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariableTableParameterNameDiscoverer</span>();</span><br><span class="line">    String[] parameterNames = discoverer.getParameterNames(foo);</span><br><span class="line">    System.out.println(Arrays.toString(parameterNames));</span><br><span class="line">&#125;</span><br><span class="line">[name, age]</span><br></pre></td></tr></table></figure><p>在【21. 参数解析器】中并没有使用 LocalVariableTableParameterNameDiscoverer，而是使用的是 DefaultParameterNameDiscoverer。DefaultParameterNameDiscoverer 将两种实现进行了统一：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultParameterNameDiscoverer</span> <span class="keyword">extends</span> <span class="title class_">PrioritizedParameterNameDiscoverer</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">DefaultParameterNameDiscoverer</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (KotlinDetector.isKotlinReflectPresent() &amp;&amp; !NativeDetector.inNativeImage()) &#123;</span><br><span class="line">         addDiscoverer(<span class="keyword">new</span> <span class="title class_">KotlinReflectionParameterNameDiscoverer</span>());</span><br><span class="line">      &#125;</span><br><span class="line">      addDiscoverer(<span class="keyword">new</span> <span class="title class_">StandardReflectionParameterNameDiscoverer</span>());</span><br><span class="line">      addDiscoverer(<span class="keyword">new</span> <span class="title class_">LocalVariableTableParameterNameDiscoverer</span>());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javac -g 的局限性</p><p>假设有这样一个接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.lcp.a22;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String name, <span class="type">int</span> age)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用 javac -g .\Bean1.java 命令进行编译后，再利用 javap 查看 foo() 方法的反编译结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(java.lang.String, <span class="type">int</span>)</span>;</span><br><span class="line">  descriptor: (Ljava/lang/String;I)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_ABSTRACT</span><br></pre></td></tr></table></figure><p>并没有记录抽象方法 foo() 的参数信息。</p><p>如果使用 javac -parameters .\Bean1.java 呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(java.lang.String, <span class="type">int</span>)</span>;</span><br><span class="line">  descriptor: (Ljava/lang/String;I)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_ABSTRACT</span><br><span class="line">  MethodParameters:</span><br><span class="line">    Name                           Flags</span><br><span class="line">    name</span><br><span class="line">    age</span><br></pre></td></tr></table></figure><p>参数信息得以保留。</p><h1 id="对象绑定与类型转换"><a href="#对象绑定与类型转换" class="headerlink" title="对象绑定与类型转换"></a>对象绑定与类型转换</h1><h2 id="23-1-三种转换接口"><a href="#23-1-三种转换接口" class="headerlink" title="23.1 三种转换接口"></a>23.1 三种转换接口</h2><p>底层第一套转换接口与实现</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjQxZTQwMjAzNWNkMGMyNzc5NTlmZWEwNGZlNGYyZWFfdjZVeWJXZ21TUTQ0UlpEY1VKR1FXRUUzUjBrclN3MnZfVG9rZW46T2g5MGJDOGxib1hlM0d4cThCUWNDdmlJbnhkXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>Printer 把其它类型转为 String</p><p>Parser 把 String 转为其它类型</p><p>Formatter 综合 Printer 与 Parser 的功能</p><p>Converter 把类型 S 转为类型 T</p><p>Printer、Parser、Converter 经过适配转换成 GenericConverter 放入 Converters 集合</p><p>FormattingConversionService 利用其它接口实现转换</p><p>底层第二套转换接口</p><p>由 JDK 提供，而不是 Spring。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YzdmNDk0ZDIxYTVkNjc5OWUzZTMwMmIzNzFjMWY4ZjRfZDZQYUw5d2kxZ0t6cVJrY0JwNHNEM1pLcWhra0t3bXZfVG9rZW46SHhOQWJrRVBub2s0Slh4RHZza2NtWTllbkliXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>PropertyEditor 将 String 与其它类型相互转换</p><p>PropertyEditorRegistry 可以注册多个 PropertyEditor 对象</p><p>可以通过 FormatterPropertyEditorAdapter 与第一套接口进行适配</p><p>高层转换接口与实现</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjE1NGQ4NjJjMzQzOTM2YTIwYTFjZWFiMmI5OThiYTZfNTBLS0xPdXJkblAyUDIwYjU3SXF1TDBQOGxWUHI3a2tfVG9rZW46WVhWYmIyZTJpb1k5V2Z4aVM5TmM3WXRzbkZnXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>它们都实现了 TypeConverter 高层转换接口，在转换时会用到 TypeConverterDelegate 委派ConversionService 与 PropertyEditorRegistry 真正执行转换（使用 Facade 门面模式）</p><p>首先查看是否存在实现了 PropertyEditorRegistry 的自定义转换器，@InitBinder 注解实现的就是自定义转换器（用了适配器模式把 Formatter 转为需要的 PropertyEditor）</p><p>再查看是否存在 ConversionService 实现</p><p>再利用默认的 PropertyEditor 实现</p><p>最后有一些特殊处理</p><p>SimpleTypeConverter 仅做类型转换</p><p>BeanWrapperImpl 利用 Property，即 Getter&#x2F;Setter，为 Bean 的属性赋值，，必要时进行类型转换</p><p>DirectFieldAccessor 利用 Field，即字段，为 Bean 的字段赋值，必要时进行类型转换</p><p>ServletRequestDataBinder 为 Bean 的属性执行绑定，必要时进行类型转换，根据布尔类型成员变量 directFieldAccess 选择利用 Property 还是 Field，还具备校验与获取校验结果功能</p><h2 id="23-2-使用示例"><a href="#23-2-使用示例" class="headerlink" title="23.2 使用示例"></a>23.2 使用示例</h2><p>SimpleTypeConverter</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SimpleTypeConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleTypeConverter</span>();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> converter.convertIfNecessary(<span class="string">&quot;13&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">    System.out.println(number);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> converter.convertIfNecessary(<span class="string">&quot;1999/03/04&quot;</span>, Date.class);</span><br><span class="line">    System.out.println(date);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">13</span></span><br><span class="line">Thu Mar <span class="number">04</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1999</span></span><br></pre></td></tr></table></figure><p>BeanWrapperImpl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 利用反射为 bean 的属性赋值</span></span><br><span class="line">    <span class="type">MyBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    <span class="type">BeanWrapperImpl</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(bean);</span><br><span class="line">    wrapper.setPropertyValue(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">    wrapper.setPropertyValue(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    wrapper.setPropertyValue(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;1999/03/04&quot;</span>);</span><br><span class="line">    System.out.println(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> String b;</span><br><span class="line">    <span class="keyword">private</span> Date c;</span><br><span class="line">&#125;</span><br><span class="line">TestBeanWrapper.MyBean(a=<span class="number">10</span>, b=hello, c=Thu Mar <span class="number">04</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1999</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 利用反射为 bean 的字段赋值</span></span><br><span class="line">    <span class="type">MyBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    <span class="type">DirectFieldAccessor</span> <span class="variable">accessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectFieldAccessor</span>(bean);</span><br><span class="line">    accessor.setPropertyValue(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">    accessor.setPropertyValue(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    accessor.setPropertyValue(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;1999/03/04&quot;</span>);</span><br><span class="line">    System.out.println(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> String b;</span><br><span class="line">    <span class="keyword">private</span> Date c;</span><br><span class="line">&#125;</span><br><span class="line">TestFieldAccessor.MyBean(a=<span class="number">10</span>, b=hello, c=Thu Mar <span class="number">04</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1999</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 执行数据绑定</span></span><br><span class="line">    <span class="type">MyBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    <span class="type">DataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataBinder</span>(bean);</span><br><span class="line">    <span class="type">MutablePropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>();</span><br><span class="line">    pvs.add(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">    pvs.add(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    pvs.add(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;1999/03/04&quot;</span>);</span><br><span class="line">    binder.bind(pvs);</span><br><span class="line">    System.out.println(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> String b;</span><br><span class="line">    <span class="keyword">private</span> Date c;</span><br><span class="line">&#125;</span><br><span class="line">TestDataBinder.MyBean(a=<span class="number">10</span>, b=hello, c=Thu Mar <span class="number">04</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1999</span>)</span><br></pre></td></tr></table></figure><p>如果 MyBean 没有提供 Getter&#x2F;Setter 方法，可以调用 DataBinder 的 initDirectFieldAccess() 方法使数据绑定逻辑走字段赋值，而不是属性赋值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 执行数据绑定</span></span><br><span class="line">    <span class="type">MyBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    <span class="type">DataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataBinder</span>(bean);</span><br><span class="line">    binder.initDirectFieldAccess();</span><br><span class="line">    <span class="type">MutablePropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>();</span><br><span class="line">    pvs.add(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">    pvs.add(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    pvs.add(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;1999/03/04&quot;</span>);</span><br><span class="line">    binder.bind(pvs);</span><br><span class="line">    System.out.println(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> String b;</span><br><span class="line">    <span class="keyword">private</span> Date c;</span><br><span class="line">&#125;</span><br><span class="line">TestDataBinder.MyBean(a=<span class="number">10</span>, b=hello, c=Thu Mar <span class="number">04</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1999</span>)</span><br></pre></td></tr></table></figure><p>Web 环境下的数据绑定</p><p>Web 环境下的数据绑定需要使用 DataBinder 的子类 ServletRequestDataBinder。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// web 环境下的数据绑定</span></span><br><span class="line">    <span class="type">MyBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    <span class="type">DataBinder</span> <span class="variable">dataBinder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRequestDataBinder</span>(bean);</span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>();</span><br><span class="line">    request.setParameter(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">    request.setParameter(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    request.setParameter(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;1999/03/04&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dataBinder.bind(<span class="keyword">new</span> <span class="title class_">ServletRequestParameterPropertyValues</span>(request));</span><br><span class="line"></span><br><span class="line">    System.out.println(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> String b;</span><br><span class="line">    <span class="keyword">private</span> Date c;</span><br><span class="line">&#125;</span><br><span class="line">TestServletDataBinder.MyBean(a=<span class="number">10</span>, b=hello, c=Thu Mar <span class="number">04</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1999</span>)</span><br></pre></td></tr></table></figure><h2 id="23-3-绑定器工厂"><a href="#23-3-绑定器工厂" class="headerlink" title="23.3 绑定器工厂"></a>23.3 绑定器工厂</h2><p>现有如下两个类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Web 环境下进行数据绑定：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>();</span><br><span class="line">    request.setParameter(<span class="string">&quot;birthday&quot;</span>, <span class="string">&quot;1999|01|02&quot;</span>);</span><br><span class="line">    request.setParameter(<span class="string">&quot;address.name&quot;</span>, <span class="string">&quot;成都&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="type">ServletRequestDataBinder</span> <span class="variable">dataBinder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRequestDataBinder</span>(user);</span><br><span class="line"></span><br><span class="line">    dataBinder.bind(<span class="keyword">new</span> <span class="title class_">ServletRequestParameterPropertyValues</span>(request));</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>birthday 和 address.name 都能绑定成功吗？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TestServletDataBinderFactory.User(birthday=<span class="literal">null</span>, address=TestServletDataBinderFactory.Address(name=成都))</span><br></pre></td></tr></table></figure><p>birthday 绑定失败，要想使其绑定成功，需要自定义转换器，有两种方式：</p><p>使用 Spring 提供的 ConversionService</p><p>使用 JDK 提供的 PropertyEditorRegistry</p><p>创建 DataBinder 的职责交由 DataBinderFactory 完成，以便添加各种选项，拓展不同的自定义转换器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>();</span><br><span class="line">    request.setParameter(<span class="string">&quot;birthday&quot;</span>, <span class="string">&quot;1999|01|02&quot;</span>);</span><br><span class="line">    request.setParameter(<span class="string">&quot;address.name&quot;</span>, <span class="string">&quot;成都&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="type">ServletRequestDataBinderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRequestDataBinderFactory</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="type">WebDataBinder</span> <span class="variable">dataBinder</span> <span class="operator">=</span> factory.createBinder(<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request), user, <span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dataBinder.bind(<span class="keyword">new</span> <span class="title class_">ServletRequestParameterPropertyValues</span>(request));</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台输出的结果不变。</p><p>利用 @InitBinder 自定义转换器</p><p>声明一个 Controller 类，其中包含一个被 @InitBinder 注解标记的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">(WebDataBinder dataBinder)</span> &#123;</span><br><span class="line">        <span class="comment">// 拓展 dataBinder 的转换器</span></span><br><span class="line">        dataBinder.addCustomFormatter(<span class="keyword">new</span> <span class="title class_">MyDateFormatter</span>(<span class="string">&quot;用 @InitBinder 进行拓展&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 WebDataBinder 作为方法参数，在方法体内添加自定义转换器 MyDateFormatter：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDateFormatter</span> <span class="keyword">implements</span> <span class="title class_">Formatter</span>&lt;Date&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyDateFormatter</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="comment">// 仅做测试</span></span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">print</span><span class="params">(Date date, Locale locale)</span> &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy|MM|dd&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sdf.format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">parse</span><span class="params">(String text, Locale locale)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; 进入了: &#123;&#125;&quot;</span>, desc);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy|MM|dd&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sdf.parse(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造 DataBinderFactory 时传入 InvocableHandlerMethod 列表，列表中包含根据 Controller 对象、Controller 类中被 @InitBinder 注解标记的方法对象构造的 InvocableHandlerMethod 对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">InvocableHandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvocableHandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">MyController</span>(), MyController.class.getMethod(<span class="string">&quot;myMethod&quot;</span>, WebDataBinder.class));</span><br><span class="line"></span><br><span class="line">    <span class="type">ServletRequestDataBinderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRequestDataBinderFactory</span>(Collections.singletonList(handlerMethod), <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次执行 main()，birthday 被成功绑定：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[DEBUG] indi.lcp.a23.MyDateFormatter      - &gt;&gt;&gt;&gt;&gt;&gt; 进入了: 用 <span class="meta">@InitBinder</span> 进行拓展 </span><br><span class="line">TestServletDataBinderFactory.User(birthday=Sat Jan <span class="number">02</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1999</span>, address=TestServletDataBinderFactory.Address(name=成都))</span><br></pre></td></tr></table></figure><p>这种方式使用了 JDK 提供的 PropertyEditorRegistry，证据就在 WebDataBinder 的 addCustomFormatter() 方法中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCustomFormatter</span><span class="params">(Formatter&lt;?&gt; formatter)</span> &#123;</span><br><span class="line">   <span class="type">FormatterPropertyEditorAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormatterPropertyEditorAdapter</span>(formatter);</span><br><span class="line">   getPropertyEditorRegistry().registerCustomEditor(adapter.getFieldType(), adapter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConversionService 拓展</p><p>选择 FormattingConversionService 作为 ConversionService 的实现，向其中添加自定义转换器 MyDateFormatter。</p><p>构造 DataBinderFactory 时传入 WebBindingInitializer 的实现，因此将 FormattingConversionService 封装成 ConfigurableWebBindingInitializer 传入 DataBinderFactory 的构造方法中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip-- </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 ConversionService 转换</span></span><br><span class="line">    <span class="type">FormattingConversionService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormattingConversionService</span>();</span><br><span class="line">    service.addFormatter(<span class="keyword">new</span> <span class="title class_">MyDateFormatter</span>(<span class="string">&quot;用 ConversionService 方式拓展转换功能&quot;</span>));</span><br><span class="line">    <span class="type">ConfigurableWebBindingInitializer</span> <span class="variable">initializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurableWebBindingInitializer</span>();</span><br><span class="line">    initializer.setConversionService(service);</span><br><span class="line">    <span class="type">ServletRequestDataBinderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRequestDataBinderFactory</span>(<span class="literal">null</span>, initializer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">[DEBUG] indi.lcp.a23.MyDateFormatter      - &gt;&gt;&gt;&gt;&gt;&gt; 进入了: 用 ConversionService 方式拓展转换功能 </span><br><span class="line">TestServletDataBinderFactory.User(birthday=Sat Jan <span class="number">02</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1999</span>, address=TestServletDataBinderFactory.Address(name=成都))</span><br></pre></td></tr></table></figure><p>如果同时存在 @InitBinder 和 ConversionService，将以 @InitBinder 为主，@InitBinder 实现的转换器属于自定义转换器，自定义转换器的优先级更高：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip-- </span></span><br><span class="line"></span><br><span class="line">    <span class="type">FormattingConversionService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormattingConversionService</span>();</span><br><span class="line">    service.addFormatter(<span class="keyword">new</span> <span class="title class_">MyDateFormatter</span>(<span class="string">&quot;用 ConversionService 方式拓展转换功能&quot;</span>));</span><br><span class="line">    <span class="type">ConfigurableWebBindingInitializer</span> <span class="variable">initializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurableWebBindingInitializer</span>();</span><br><span class="line">    initializer.setConversionService(service);</span><br><span class="line">    <span class="type">InvocableHandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvocableHandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">MyController</span>(), MyController.class.getMethod(<span class="string">&quot;myMethod&quot;</span>, WebDataBinder.class));</span><br><span class="line">    <span class="type">ServletRequestDataBinderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRequestDataBinderFactory</span>(Collections.singletonList(handlerMethod), initializer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">[DEBUG] indi.lcp.a23.MyDateFormatter      - &gt;&gt;&gt;&gt;&gt;&gt; 进入了: 用 <span class="meta">@InitBinder</span> 进行拓展 </span><br><span class="line">TestServletDataBinderFactory.User(birthday=Sat Jan <span class="number">02</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1999</span>, address=TestServletDataBinderFactory.Address(name=成都))</span><br></pre></td></tr></table></figure><p>默认的 ConversionService</p><p>ConversionService 有一个默认实现 DefaultFormattingConversionService，它还是 FormattingConversionService 的子类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip-- </span></span><br><span class="line"></span><br><span class="line">    <span class="type">DefaultFormattingConversionService</span> <span class="variable">conversionService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFormattingConversionService</span>();</span><br><span class="line">    <span class="type">ConfigurableWebBindingInitializer</span> <span class="variable">initializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurableWebBindingInitializer</span>();</span><br><span class="line">    initializer.setConversionService(conversionService);</span><br><span class="line">    <span class="type">ServletRequestDataBinderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRequestDataBinderFactory</span>(<span class="literal">null</span>, initializer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TestServletDataBinderFactory.User(birthday=<span class="literal">null</span>, address=TestServletDataBinderFactory.Address(name=成都))</span><br></pre></td></tr></table></figure><p>birthday 绑定失败，默认的 ConversionService 需要搭配注解 @DateTimeFormat 使用。在目标类的字段上使用该注解标记，并指定被转换的日期格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@DateTimeFormat(pattern = &quot;yyyy|MM|dd&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行 main() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TestServletDataBinderFactory.User(birthday=Sat Jan <span class="number">02</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1999</span>, address=TestServletDataBinderFactory.Address(name=成都))</span><br></pre></td></tr></table></figure><p>在 SpringBoot 中还提供了 ApplicationConversionService，它也是 FormattingConversionService 的子类，上述代码将 DefaultFormattingConversionService 换成 ApplicationConversionService 也能达到相同效果。</p><h2 id="23-4-Spring-的泛型操作技巧"><a href="#23-4-Spring-的泛型操作技巧" class="headerlink" title="23.4 Spring 的泛型操作技巧"></a>23.4 Spring 的泛型操作技巧</h2><p>有一基类 BaseDao，接收一个泛型参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseDao</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">findOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>围绕 BaseDao 有如下五个类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeDao</span> <span class="keyword">extends</span> <span class="title class_">BaseDao</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDao</span> <span class="keyword">extends</span> <span class="title class_">BaseDao</span>&lt;Student&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDao</span> <span class="keyword">extends</span> <span class="title class_">BaseDao</span>&lt;Teacher&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试获取 BaseDao 子类泛型参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. java api</span></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">// 带有泛型信息的父类信息</span></span><br><span class="line">    <span class="type">Type</span> <span class="variable">teacherDaoType</span> <span class="operator">=</span> TeacherDao.class.getGenericSuperclass();</span><br><span class="line">    System.out.println(<span class="string">&quot;TeacherDao type: &quot;</span> + teacherDaoType);</span><br><span class="line">    System.out.println(<span class="string">&quot;TeacherDao type class: &quot;</span> + teacherDaoType.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="type">Type</span> <span class="variable">employeeDaoType</span> <span class="operator">=</span> EmployeeDao.class.getGenericSuperclass();</span><br><span class="line">    System.out.println(<span class="string">&quot;EmployeeDao type: &quot;</span> + employeeDaoType);</span><br><span class="line">    System.out.println(<span class="string">&quot;EmployeeDao type class: &quot;</span> + employeeDaoType.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有泛型参数的 Type 对象才是 ParameterizedType 类型</span></span><br><span class="line">    <span class="keyword">if</span> (teacherDaoType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">        <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) teacherDaoType;</span><br><span class="line">        System.out.println(parameterizedType.getActualTypeArguments()[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. spring api 1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    Class&lt;?&gt; t = GenericTypeResolver.resolveTypeArgument(TeacherDao.class, BaseDao.class);</span><br><span class="line">    System.out.println(t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. spring api 2</span></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    System.out.println(ResolvableType.forClass(StudentDao.class).getSuperType().getGeneric().resolve());</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">TeacherDao type: indi.lcp.a23.sub.BaseDao</span><br><span class="line">TeacherDao type class: <span class="keyword">class</span> <span class="title class_">sun</span>.reflect.generics.reflectiveObjects.ParameterizedTypeImpl</span><br><span class="line">EmployeeDao type: <span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a23.sub.BaseDao</span><br><span class="line">EmployeeDao type class: <span class="keyword">class</span> <span class="title class_">java</span>.lang.Class</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a23.sub.Teacher</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a23.sub.Teacher</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a23.sub.Student</span><br></pre></td></tr></table></figure><h1 id="ControllerAdvice-之-InitBinder"><a href="#ControllerAdvice-之-InitBinder" class="headerlink" title="ControllerAdvice 之 @InitBinder"></a>ControllerAdvice 之 @InitBinder</h1><p>功能与使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@ControllerAdvice</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyControllerAdvice</span> &#123;</span><br><span class="line">        <span class="meta">@InitBinder</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">binder3</span><span class="params">(WebDataBinder webDataBinder)</span> &#123;</span><br><span class="line">            webDataBinder.addCustomFormatter(<span class="keyword">new</span> <span class="title class_">MyDateFormatter</span>(<span class="string">&quot;binder3 转换器&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Controller</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller1</span> &#123;</span><br><span class="line">        <span class="meta">@InitBinder</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">binder1</span><span class="params">(WebDataBinder webDataBinder)</span> &#123;</span><br><span class="line">            webDataBinder.addCustomFormatter(<span class="keyword">new</span> <span class="title class_">MyDateFormatter</span>(<span class="string">&quot;binder1 转换器&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Controller</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller2</span> &#123;</span><br><span class="line">        <span class="meta">@InitBinder</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">binder21</span><span class="params">(WebDataBinder webDataBinder)</span> &#123;</span><br><span class="line">            webDataBinder.addCustomFormatter(<span class="keyword">new</span> <span class="title class_">MyDateFormatter</span>(<span class="string">&quot;binder21 转换器&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@InitBinder</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">binder22</span><span class="params">(WebDataBinder webDataBinder)</span> &#123;</span><br><span class="line">            webDataBinder.addCustomFormatter(<span class="keyword">new</span> <span class="title class_">MyDateFormatter</span>(<span class="string">&quot;binder22 转换器&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 @InitBinder 作用的方法存在于被 @ControllerAdvice 标记的类里面时，是对 所有 控制器都生效的自定义类型转换器。当 @InitBinder 作用的方法存在于被 @Controller 标记的类里面时，是 只对当前 控制器生效的自定义类型转换器。</p><p>@InitBinder 的来源有两个：</p><ol><li>@ControllerAdvice 标记的类中 @InitBinder 标记的方法，由 RequestMappingHandlerAdapter 在初始化时解析并记录</li><li>@Controller 标记的类中 @InitBinder 标记的方法，由 RequestMappingHandlerAdapter 在控制器方法首次执行时解析并记录</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(WebConfig.class);</span><br><span class="line">    <span class="type">RequestMappingHandlerAdapter</span> <span class="variable">handlerAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerAdapter</span>();</span><br><span class="line"></span><br><span class="line">    handlerAdapter.setApplicationContext(context);</span><br><span class="line">    handlerAdapter.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;1. 刚开始...&quot;</span>);</span><br><span class="line">    showBindMethods(handlerAdapter);</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showBindMethods</span><span class="params">(RequestMappingHandlerAdapter handlerAdapter)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">initBinderAdviceCache</span> <span class="operator">=</span> RequestMappingHandlerAdapter.class.getDeclaredField(<span class="string">&quot;initBinderAdviceCache&quot;</span>);</span><br><span class="line">    initBinderAdviceCache.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    Map&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; globalMap = (Map&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt;) initBinderAdviceCache.get(handlerAdapter);</span><br><span class="line">    log.debug(<span class="string">&quot;全局的 @InitBinder 方法 &#123;&#125;&quot;</span>,</span><br><span class="line">              globalMap.values().stream()</span><br><span class="line">              .flatMap(ms -&gt; ms.stream().map(m -&gt; m.getName()))</span><br><span class="line">              .collect(Collectors.toList())</span><br><span class="line">             );</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">initBinderCache</span> <span class="operator">=</span> RequestMappingHandlerAdapter.class.getDeclaredField(<span class="string">&quot;initBinderCache&quot;</span>);</span><br><span class="line">    initBinderCache.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; controllerMap = (Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;) initBinderCache.get(handlerAdapter);</span><br><span class="line">    log.debug(<span class="string">&quot;控制器的 @InitBinder 方法 &#123;&#125;&quot;</span>,</span><br><span class="line">              controllerMap.entrySet().stream()</span><br><span class="line">              .flatMap(e -&gt; e.getValue().stream().map(v -&gt; e.getKey().getSimpleName() + <span class="string">&quot;.&quot;</span> + v.getName()))</span><br><span class="line">              .collect(Collectors.toList())</span><br><span class="line">             );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.a24.A24                  - <span class="number">1.</span> 刚开始... </span><br><span class="line">indi.lcp.a24.A24                  - 全局的 <span class="meta">@InitBinder</span> 方法 [binder3] </span><br><span class="line">indi.lcp.a24.A24                  - 控制器的 <span class="meta">@InitBinder</span> 方法 [] </span><br></pre></td></tr></table></figure><p>全局的 @InitBinder 方法被解析并记录，但控制器中被 @InitBinder 标记的方法并没有被解析记录。</p><p>模拟调用控制器方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    </span><br><span class="line">    log.debug(<span class="string">&quot;1. 刚开始...&quot;</span>);</span><br><span class="line">    showBindMethods(handlerAdapter);</span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">getDataBinderFactory</span> <span class="operator">=</span> RequestMappingHandlerAdapter.class.getDeclaredMethod(<span class="string">&quot;getDataBinderFactory&quot;</span>, HandlerMethod.class);</span><br><span class="line">    getDataBinderFactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;2. 模拟调用 Controller1 的 foo 方法...&quot;</span>);</span><br><span class="line">    getDataBinderFactory.invoke(handlerAdapter, <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">WebConfig</span>.Controller1(), WebConfig.Controller1.class.getMethod(<span class="string">&quot;foo&quot;</span>)));</span><br><span class="line">    showBindMethods(handlerAdapter);</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;3. 模拟调用 Controller2 的 bar 方法时...&quot;</span>);</span><br><span class="line">    getDataBinderFactory.invoke(handlerAdapter, <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">WebConfig</span>.Controller2(), WebConfig.Controller2.class.getMethod(<span class="string">&quot;bar&quot;</span>)));</span><br><span class="line">    showBindMethods(handlerAdapter);</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1.</span> 刚开始... </span><br><span class="line">全局的 <span class="meta">@InitBinder</span> 方法 [binder3] </span><br><span class="line">控制器的 <span class="meta">@InitBinder</span> 方法 [] </span><br><span class="line"><span class="number">2.</span> 模拟调用 Controller1 的 foo 方法... </span><br><span class="line">全局的 <span class="meta">@InitBinder</span> 方法 [binder3] </span><br><span class="line">控制器的 <span class="meta">@InitBinder</span> 方法 [Controller1.binder1] </span><br><span class="line"><span class="number">3.</span> 模拟调用 Controller2 的 bar 方法时... </span><br><span class="line">全局的 <span class="meta">@InitBinder</span> 方法 [binder3] </span><br><span class="line">控制器的 <span class="meta">@InitBinder</span> 方法 [Controller1.binder1, Controller2.binder22, Controller2.binder21] </span><br></pre></td></tr></table></figure><p>首次调用控制器中的方法时，控制器中被 @InitBinder 标记方法被解析记录。</p><h1 id="控制器方法执行流程"><a href="#控制器方法执行流程" class="headerlink" title="控制器方法执行流程"></a>控制器方法执行流程</h1><p>ServletInvocableHandlerMethod 的组成</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmE3MDE2MTdiYWU2Mjk2NjdmMDkwZmY3MDRhYWE2NzFfU25qV00yRUxuOE91WEpQZXFJZHlkZFlTRFp2bWxPNEVfVG9rZW46UlQyR2IzM0wyb2NId3h4VUpFQWNwa1Mwbm10XzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><p>HandlerMethod 需要：</p><ul><li>bean，即哪个 Controller</li><li>method，即 Controller 中的哪个方法</li></ul><p>ServletInvocableHandlerMethod 需要：</p><ul><li>WebDataBinderFactory，用于对象绑定、类型转换</li><li>ParameterNameDiscoverer，用于参数名解析</li><li>HandlerMethodArgumentResolverComposite，用于解析参数</li><li>HandlerMethodReturnValueHandlerComposite，用于处理返回值</li></ul><p>控制器方法执行流程</p><p>以 RequestMappingHandlerAdapter 为起点，创建 WebDataBinderFactory，添加自定义类型转换器，再创建 ModelFactory，添加 Model 数据</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NjRjNTQxNzk2ODJjMzYzMGNmNzg2NmRkYzljY2E2MDZfbXQ1M1dSelZzWUhiZ2o2N3NGVHRMSkJxVUowOTlPaklfVG9rZW46UmtGRWJvVTJpb2ZjaDB4ZWJFc2NFQUN3bjBkXzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><p>接下来调用 ServletInvocableHandlerMethod，主要完成三件事：</p><ul><li>准备参数</li><li>反射调用控制器方法</li><li>处理返回值</li></ul><h1 id="ControllerAdvice-之-ModelAttribute"><a href="#ControllerAdvice-之-ModelAttribute" class="headerlink" title="ControllerAdvice 之 @ModelAttribute"></a>ControllerAdvice 之 @ModelAttribute</h1><p>准备 @ModelAttribute 在整个 HandlerAdapter 调用过程中所处的位置</p><p>功能与使用</p><p>@ModelAttribute 可以作用在参数上和方法上。</p><p>当其作用在参数上时，会将请求中的参数信息 按名称 注入到指定对象中，并将这个对象信息自动添加到 ModelMap 中。当未指定 @ModelAttribute 的 value 时，添加到 ModelMap 中的 key 是对象类型首字母小写对应的字符串。此时的 @ModelAttribute 注解由 ServletModelAttributeMethodProcessor 解析。</p><p>当其作用在方法上时：</p><p>如果该方法在被 @Controller 注解标记的类中，会在当前控制器中每个控制器方法执行前执行被 @ModelAttribute 标记的方法，如果该方法有返回值，自动将返回值添加到 ModelMap 中。当未指定 @ModelAttribute 的 value 时，添加到 ModelMap 中的 key 是返回值类型首字母小写对应的字符串。</p><p>如果该方法在被 @ControllerAdvice 注解标记的类中，会在所有控制器方法执行前执行该方法。</p><p>作用在方法上的 @ModelAttribute 注解由 RequestMappingHandlerAdapter 解析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller1</span> &#123;</span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.OK)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">foo</span><span class="params">(<span class="meta">@ModelAttribute(&quot;u&quot;)</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 @ResponseStatus 注解，咋不考虑返回值的处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyControllerAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@ModelAttribute(&quot;a&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">aa</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先不使用 RequestMappingHandlerAdapter 对作用在方法上的 @ModelAttribute 注解进行解析，沿用【25. 控制器方法执行流程】中的 main() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">foo</span><br><span class="line">&#123;u=WebConfig.User(name=lcp), org.springframework.validation.BindingResult.u=org.springframework.validation.BeanPropertyBindingResult: <span class="number">0</span> errors&#125;</span><br></pre></td></tr></table></figure><p>再解析方法上的 @ModelAttribute 注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(WebConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">RequestMappingHandlerAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerAdapter</span>();</span><br><span class="line">    adapter.setApplicationContext(context);</span><br><span class="line">    adapter.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>();</span><br><span class="line">    request.setParameter(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lcp&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取模型工厂</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">getModelFactory</span> <span class="operator">=</span> RequestMappingHandlerAdapter.class.getDeclaredMethod(<span class="string">&quot;getModelFactory&quot;</span>, HandlerMethod.class, WebDataBinderFactory.class);</span><br><span class="line">    getModelFactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">ModelFactory</span> <span class="variable">modelFactory</span> <span class="operator">=</span> (ModelFactory) getModelFactory.invoke(adapter, handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化模型数据</span></span><br><span class="line">    modelFactory.initModel(<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request), container, handlerMethod);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">foo</span><br><span class="line">&#123;a=aa, u=WebConfig.User(name=lcp), org.springframework.validation.BindingResult.u=org.springframework.validation.BeanPropertyBindingResult: <span class="number">0</span> errors&#125;</span><br></pre></td></tr></table></figure><p>{a&#x3D;aa} 也被放入到 ModelAndViewContainer 中。</p><h1 id="返回值处理器"><a href="#返回值处理器" class="headerlink" title="返回值处理器"></a>返回值处理器</h1><p>含有多种返回值的控制器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;test1()&quot;</span>);</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;view1&quot;</span>);</span><br><span class="line">        mav.addObject(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;test2()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;view2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;test3()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;test4()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HttpEntity&lt;User&gt; <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;test5()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;赵六&quot;</span>, <span class="number">40</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HttpHeaders <span class="title function_">test6</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;test6()&quot;</span>);</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        headers.add(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> headers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">test7</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;test7()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;钱七&quot;</span>, <span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试渲染视图需要用到的配置</p><p>为测试对视图的渲染，采用 Freemarker 进行测试，先导入 Freemarker 依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>Freemarker 配置类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FreeMarkerConfigurer <span class="title function_">freeMarkerConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FreeMarkerConfigurer</span> <span class="variable">configurer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FreeMarkerConfigurer</span>();</span><br><span class="line">        configurer.setDefaultEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        configurer.setTemplateLoaderPath(<span class="string">&quot;classpath:templates&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> configurer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * FreeMarkerView 在借助 Spring 初始化时，会要求在 web 环境才会走 setConfiguration, 这里想办法去掉了 web 环境的约束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FreeMarkerViewResolver <span class="title function_">viewResolver</span><span class="params">(FreeMarkerConfigurer configurer)</span> &#123;</span><br><span class="line">        <span class="type">FreeMarkerViewResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FreeMarkerViewResolver</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> AbstractUrlBasedView <span class="title function_">instantiateView</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">FreeMarkerView</span> <span class="variable">view</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FreeMarkerView</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isContextRequired</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                view.setConfiguration(configurer.getConfiguration());</span><br><span class="line">                <span class="keyword">return</span> view;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        resolver.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        resolver.setPrefix(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        resolver.setSuffix(<span class="string">&quot;.ftl&quot;</span>);</span><br><span class="line">        resolver.setExposeSpringMacroHelpers(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> resolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染视图使用的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">renderView</span><span class="params">(ApplicationContext context, ModelAndViewContainer container,</span></span><br><span class="line"><span class="params">                               ServletWebRequest webRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; 渲染视图&quot;</span>);</span><br><span class="line">    <span class="type">FreeMarkerViewResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> context.getBean(FreeMarkerViewResolver.class);</span><br><span class="line">    <span class="type">String</span> <span class="variable">viewName</span> <span class="operator">=</span> container.getViewName() != <span class="literal">null</span> ? container.getViewName() : <span class="keyword">new</span> <span class="title class_">DefaultRequestToViewNameTranslator</span>().getViewName(webRequest.getRequest());</span><br><span class="line">    log.debug(<span class="string">&quot;没有获取到视图名, 采用默认视图名: &#123;&#125;&quot;</span>, viewName);</span><br><span class="line">    <span class="comment">// 每次渲染时, 会产生新的视图对象, 它并非被 Spring 所管理, 但确实借助了 Spring 容器来执行初始化</span></span><br><span class="line">    <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> resolver.resolveViewName(viewName, Locale.getDefault());</span><br><span class="line">    view.render(container.getModel(), webRequest.getRequest(), webRequest.getResponse());</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(((MockHttpServletResponse) webRequest.getResponse()).getContentAsByteArray(), StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供构造 HandlerMethodReturnValueHandlerComposite 对象的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HandlerMethodReturnValueHandlerComposite <span class="title function_">getReturnValueHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">HandlerMethodReturnValueHandlerComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodReturnValueHandlerComposite</span>();</span><br><span class="line">    composite.addHandlers(Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ModelAndViewMethodReturnValueHandler</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ViewNameMethodReturnValueHandler</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">false</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HttpEntityMethodProcessor</span>(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>())),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HttpHeadersReturnValueHandler</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>())),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">true</span>)</span><br><span class="line">    ));</span><br><span class="line">    <span class="keyword">return</span> composite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试返回值处理器的方法 testReturnValueProcessor()</p><p>利用两个函数式接口 Comsumer，对 Mock 的请求进行补充，或者在请求处理完毕后，输出 Mock 的响应信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testReturnValueProcessor</span><span class="params">(ApplicationContext context, String methodName,</span></span><br><span class="line"><span class="params">                                             Consumer&lt;MockHttpServletRequest&gt; requestConsumer,</span></span><br><span class="line"><span class="params">                                             Consumer&lt;MockHttpServletResponse&gt; responseConsumer)</span> &#123;</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> Controller.class.getMethod(methodName);</span><br><span class="line">    <span class="type">Controller</span> <span class="variable">controller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Controller</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(controller);</span><br><span class="line"></span><br><span class="line">    <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(context, method);</span><br><span class="line">    <span class="type">ModelAndViewContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndViewContainer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">HandlerMethodReturnValueHandlerComposite</span> <span class="variable">composite</span> <span class="operator">=</span> getReturnValueHandler();</span><br><span class="line">    <span class="type">MethodParameter</span> <span class="variable">returnType</span> <span class="operator">=</span> handlerMethod.getReturnType();</span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>();</span><br><span class="line">    Optional.ofNullable(requestConsumer).ifPresent(i -&gt; i.accept(request));</span><br><span class="line">    <span class="type">MockHttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletResponse</span>();</span><br><span class="line">    <span class="type">ServletWebRequest</span> <span class="variable">webRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response);</span><br><span class="line">    <span class="keyword">if</span> (composite.supportsReturnType(returnType)) &#123;</span><br><span class="line">        composite.handleReturnValue(returnValue, returnType, container, webRequest);</span><br><span class="line">        System.out.println(container.getModel());</span><br><span class="line">        System.out.println(container.getViewName());</span><br><span class="line">        <span class="keyword">if</span> (!container.isRequestHandled()) &#123;</span><br><span class="line">            <span class="comment">// 渲染视图</span></span><br><span class="line">            renderView(context, container, webRequest);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Optional.ofNullable(responseConsumer).ifPresent(i -&gt; i.accept(response));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="27-1-ModelAndView"><a href="#27-1-ModelAndView" class="headerlink" title="27.1 ModelAndView"></a>27.1 ModelAndView</h2><p>ModelAndView 类型的返回值由 ModelAndViewMethodReturnValueHandler 处理，构造时无需传入任何参数。</p><p>解析 ModelAndView 时，将其中的视图和模型数据分别提取出来，放入 ModelAndViewContainer 中，之后根据视图信息找到对应的模板页面，再将模型数据填充到模板页面中，完成视图的渲染。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(WebConfig.class);</span><br><span class="line">    test1(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    testReturnValueProcessor(context, <span class="string">&quot;test1&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的模板页面 view1.ftl：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;zh&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;view1&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello! $&#123;name&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">indi.lcp.a27.A27$Controller       - test1() </span><br><span class="line">&#123;name=张三&#125;</span><br><span class="line">view1</span><br><span class="line">indi.lcp.a27.A27                  - &gt;&gt;&gt;&gt;&gt;&gt; 渲染视图 </span><br><span class="line">indi.lcp.a27.A27                  - 没有获取到视图名, 采用默认视图名: view1 </span><br><span class="line">indi.lcp.a27.WebConfig$<span class="number">1</span>$<span class="number">1</span>        - View name <span class="string">&#x27;view1&#x27;</span>, model &#123;name=张三&#125; </span><br><span class="line">indi.lcp.a27.WebConfig$<span class="number">1</span>$<span class="number">1</span>        - Rendering [/view1.ftl] </span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;zh&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;view1&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello! 张三&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="27-2-字符串类型"><a href="#27-2-字符串类型" class="headerlink" title="27.2 字符串类型"></a>27.2 字符串类型</h2><p>控制器方法的返回值是字符串类型时，返回的字符串即为视图的名称。与 ModelAndView 类型的返回值相比，不包含模型数据。</p><p>此种类型的返回值由 ViewNameMethodReturnValueHandler 处理，构造时无需传入任何参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    testReturnValueProcessor(context, <span class="string">&quot;test2&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的模板页面 view2.ftl：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;zh&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;view2&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">indi.lcp.a27.A27$Controller       - test2() </span><br><span class="line">&#123;&#125;</span><br><span class="line">view2</span><br><span class="line">indi.lcp.a27.A27                  - &gt;&gt;&gt;&gt;&gt;&gt; 渲染视图 </span><br><span class="line">indi.lcp.a27.A27                  - 没有获取到视图名, 采用默认视图名: view2 </span><br><span class="line">indi.lcp.a27.WebConfig$<span class="number">1</span>$<span class="number">1</span>        - View name <span class="string">&#x27;view2&#x27;</span>, model &#123;&#125; </span><br><span class="line">indi.lcp.a27.WebConfig$<span class="number">1</span>$<span class="number">1</span>        - Rendering [/view2.ftl] </span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;zh&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;view2&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="27-3-ModelAttribute"><a href="#27-3-ModelAttribute" class="headerlink" title="27.3 @ModelAttribute"></a>27.3 @ModelAttribute</h2><p>@ModelAttribute 的用法在【26. ControllerAdvice 之 @ModelAttribute】中已经介绍过，简单来说，当 @ModelAttribute 注解作用在方法上时，会将方法的返回值作为模型数据添加到 ModelAndViewContainer 中。</p><p>@ModelAttribute 标记的方法的返回值由 ServletModelAttributeMethodProcessor 解析，构造时需要传入一个布尔类型数据 annotationNotRequired，表示 @ModelAttribute 注解是否不是必须的。</p><p>模型数据已经有了，但视图名称又是什么呢？</p><p>在实际开发场景中，控制器方法需要被 @RequestMapping 标记，并指定请求地址，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;test3()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当未找到视图名称时，默认以请求路径作为视图名称。</p><p>但在本节测试中省略了路径映射这一步，因此需要通过编程的方式将请求路径解析后的结果放入 request 作用域中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Consumer&lt;MockHttpServletRequest&gt; <span class="title function_">mockHttpServletRequestConsumer</span><span class="params">(String methodName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> req -&gt; &#123;</span><br><span class="line">        req.setRequestURI(<span class="string">&quot;/&quot;</span> + methodName);</span><br><span class="line">        UrlPathHelper.defaultInstance.resolveAndCacheLookupPath(req);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> <span class="string">&quot;test3&quot;</span>;</span><br><span class="line">    testReturnValueProcessor(context, methodName, </span><br><span class="line">                             mockHttpServletRequestConsumer(methodName), <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的模板页面 test3.ftl：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;zh&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;test3&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello! $&#123;user.name&#125; $&#123;user.age&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">indi.lcp.a27.A27$Controller       - test3() </span><br><span class="line">&#123;user=A27.User(name=李四, age=<span class="number">20</span>)&#125;</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">indi.lcp.a27.A27                  - &gt;&gt;&gt;&gt;&gt;&gt; 渲染视图 </span><br><span class="line">indi.lcp.a27.A27                  - 没有获取到视图名, 采用默认视图名: test3 </span><br><span class="line">indi.lcp.a27.WebConfig$<span class="number">1</span>$<span class="number">1</span>        - View name <span class="string">&#x27;test3&#x27;</span>, model &#123;user=A27.User(name=李四, age=<span class="number">20</span>)&#125; </span><br><span class="line">indi.lcp.a27.WebConfig$<span class="number">1</span>$<span class="number">1</span>        - Rendering [/test3.ftl] </span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;zh&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;test3&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello! 李四 <span class="number">20</span>&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>针对控制器方法 test4() 也可以按照相同方式测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> <span class="string">&quot;test4&quot;</span>;</span><br><span class="line">    testReturnValueProcessor(context, methodName, mockHttpServletRequestConsumer(methodName), <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的模板页面 test4.ftl：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;zh&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;test4&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello! $&#123;user.name&#125; $&#123;user.age&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">indi.lcp.a27.A27$Controller       - test4() </span><br><span class="line">&#123;user=A27.User(name=王五, age=<span class="number">30</span>)&#125;</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">indi.lcp.a27.A27                  - &gt;&gt;&gt;&gt;&gt;&gt; 渲染视图 </span><br><span class="line">indi.lcp.a27.A27                  - 没有获取到视图名, 采用默认视图名: test4 </span><br><span class="line">indi.lcp.a27.WebConfig$<span class="number">1</span>$<span class="number">1</span>        - View name <span class="string">&#x27;test4&#x27;</span>, model &#123;user=A27.User(name=王五, age=<span class="number">30</span>)&#125; </span><br><span class="line">indi.lcp.a27.WebConfig$<span class="number">1</span>$<span class="number">1</span>        - Rendering [/test4.ftl] </span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;zh&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;test4&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello! 王五 <span class="number">30</span>&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>与解析参数类似，返回值处理器的执行顺序也有严格要求。</p><h2 id="27-4-HttpEntity"><a href="#27-4-HttpEntity" class="headerlink" title="27.4 HttpEntity"></a>27.4 HttpEntity</h2><p>HttpEntity 类型的返回值由 HttpEntityMethodProcessor 处理，构造时需要传入一个消息转换器列表。</p><p>这种类型的返回值表示响应完成，无需经过视图的解析、渲染流程再生成响应。可在处理器的 handleReturnValue() 方法中得以论证：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span><br><span class="line"><span class="params">                              ModelAndViewContainer mavContainer, </span></span><br><span class="line"><span class="params">                              NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 一进入方法就设置请求处理完毕</span></span><br><span class="line">    mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HttpEntity 中包含了状态码、响应体信息和响应头信息。</p><p>尝试在请求处理完毕后，输出响应体信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Consumer&lt;MockHttpServletResponse&gt; RESPONSE_CONSUMER = resp -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (String name : resp.getHeaderNames()) &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; = &quot;</span> + resp.getHeader(name));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(resp.getContentAsByteArray(), StandardCharsets.UTF_8));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    testReturnValueProcessor(context, <span class="string">&quot;test5&quot;</span>, <span class="literal">null</span>, RESPONSE_CONSUMER);</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.a27.A27$Controller       - test5() </span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">Content-Type = application/json</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;赵六&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">40</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="27-5-HttpHeaders"><a href="#27-5-HttpHeaders" class="headerlink" title="27.5 HttpHeaders"></a>27.5 HttpHeaders</h2><p>与 HttpEntity 相比，HttpHeaders 只包含响应头信息，HttpHeaders 类型的返回值由 HttpHeadersReturnValueHandler 处理，构造时无需传入任何参数。</p><p>与 HttpEntity 一样，这种类型的返回值也表示响应完成，无需经过视图的解析、渲染流程再生成响应，也可在处理器的 handleReturnValue() 方法中得以论证（省略源码）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    testReturnValueProcessor(context, <span class="string">&quot;test6&quot;</span>, <span class="literal">null</span>, RESPONSE_CONSUMER);</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.a27.A27$Controller       - test6() </span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">Content-Type = text/html</span><br></pre></td></tr></table></figure><h2 id="27-6-ResponseBody"><a href="#27-6-ResponseBody" class="headerlink" title="27.6 @ResponseBody"></a>27.6 @ResponseBody</h2><p>@ResponseBody 标记的方法的返回值由 RequestResponseBodyMethodProcessor 处理，构造时需要传入一个消息转换器列表。</p><p>这样的返回值也表示响应完成，无需经过视图的解析、渲染流程再生成响应，也可在处理器的 handleReturnValue() 方法中得以论证（省略源码）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    testReturnValueProcessor(context, <span class="string">&quot;test7&quot;</span>, <span class="literal">null</span>, RESPONSE_CONSUMER);</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.a27.A27$Controller       - test7() </span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">Content-Type = application/json</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;钱七&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">50</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h1><p>在构造参数解析器 RequestResponseBodyMethodProcessor、返回值解析器 HttpEntityMethodProcessor 和 HttpEntityMethodProcessor 时，都需要传入消息转换器列表。</p><p>消息转换器的基类是 HttpMessageConverter。</p><p>介绍两个常见的消息转换器的实现：</p><ul><li>MappingJackson2XmlHttpMessageConverter</li><li>MappingJackson2XmlHttpMessageConverter</li></ul><p>一个 User 类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonCreator</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="meta">@JsonProperty(&quot;name&quot;)</span> String name, <span class="meta">@JsonProperty(&quot;age&quot;)</span> <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 User 对象转换成 JSON 格式的数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MockHttpOutputMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpOutputMessage</span>();</span><br><span class="line">    <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 判断能否将对象转换成目标消息格式</span></span><br><span class="line">    <span class="keyword">if</span> (converter.canWrite(User.class, MediaType.APPLICATION_JSON)) &#123;</span><br><span class="line">        converter.write(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>), MediaType.APPLICATION_JSON, message);</span><br><span class="line">        System.out.println(message.getBodyAsString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><p>将 User 对象转换成 XML 格式的数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MockHttpOutputMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpOutputMessage</span>();</span><br><span class="line">    <span class="type">MappingJackson2XmlHttpMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2XmlHttpMessageConverter</span>();</span><br><span class="line">    <span class="keyword">if</span> (converter.canWrite(User.class, MediaType.APPLICATION_XML)) &#123;</span><br><span class="line">        converter.write(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>), MediaType.APPLICATION_XML, message);</span><br><span class="line">        System.out.println(message.getBodyAsString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 MappingJackson2XmlHttpMessageConverter 时，需要额外导入依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;User&gt;&lt;name&gt;李四&lt;/name&gt;&lt;age&gt;<span class="number">20</span>&lt;/age&gt;&lt;/User&gt;</span><br></pre></td></tr></table></figure><p>将 JSON 格式的数据转换成 User 对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//language=JSON</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  \&quot;name\&quot;: \&quot;李四\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  \&quot;age\&quot;: 20\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    <span class="type">MockHttpInputMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpInputMessage</span>(json.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">    <span class="keyword">if</span> (converter.canRead(User.class, MediaType.APPLICATION_JSON)) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">read</span> <span class="operator">=</span> converter.read(User.class, message);</span><br><span class="line">        System.out.println(read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">A28.User(name=李四, age=<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>如果存在多个消息转换器呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>();</span><br><span class="line">    <span class="type">MockHttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletResponse</span>();</span><br><span class="line">    <span class="type">ServletWebRequest</span> <span class="variable">webRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response);</span><br><span class="line"></span><br><span class="line">    request.addHeader(HttpHeaders.ACCEPT, MimeTypeUtils.APPLICATION_XML_VALUE);</span><br><span class="line">    response.setContentType(MimeTypeUtils.APPLICATION_JSON_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="type">RequestResponseBodyMethodProcessor</span> <span class="variable">processor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MappingJackson2XmlHttpMessageConverter</span>()</span><br><span class="line">    ));</span><br><span class="line">    processor.handleReturnValue(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MethodParameter</span>(A28.class.getMethod(<span class="string">&quot;user&quot;</span>), -<span class="number">1</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ModelAndViewContainer</span>(),</span><br><span class="line">        webRequest</span><br><span class="line">    );</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(response.getContentAsByteArray(), StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">user</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以添加的消息转换器顺序为主，比如此处会将 User 对象转换成 JSON 格式的数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><p>调换添加的消息转换器顺序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">RequestResponseBodyMethodProcessor</span> <span class="variable">processor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MappingJackson2XmlHttpMessageConverter</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>()</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这下会将 User 对象转换成 XML 格式的数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;User&gt;&lt;name&gt;张三&lt;/name&gt;&lt;age&gt;<span class="number">18</span>&lt;/age&gt;&lt;/User&gt;</span><br></pre></td></tr></table></figure><p>再将添加的消息转换器顺序还原，在请求头中添加 Accept 信息，指定数据格式为 XML：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    request.addHeader(HttpHeaders.ACCEPT, MimeTypeUtils.APPLICATION_XML_VALUE);</span><br><span class="line">    <span class="type">RequestResponseBodyMethodProcessor</span> <span class="variable">processor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MappingJackson2XmlHttpMessageConverter</span>()</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管转换成 JSON 的转换器在前，但会以请求头中指定的 Accept 信息为主：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;User&gt;&lt;name&gt;张三&lt;/name&gt;&lt;age&gt;<span class="number">18</span>&lt;/age&gt;&lt;/User&gt;</span><br></pre></td></tr></table></figure><p>在上文基础上，在指定响应的 Content-Type 为 application&#x2F;json：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    request.addHeader(HttpHeaders.ACCEPT, MimeTypeUtils.APPLICATION_XML_VALUE);</span><br><span class="line">    response.setContentType(MimeTypeUtils.APPLICATION_JSON_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="type">RequestResponseBodyMethodProcessor</span> <span class="variable">processor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MappingJackson2XmlHttpMessageConverter</span>()</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时又会以 Content-Type 的信息为主：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><p>总结</p><p>@ResponseBody 注解由 RequestResponseBodyMethodProcessor 解析，但涉及到的数据格式转换由消息转换器完成。</p><p>当存在多个消息转换器时，如果选择 MediaType：</p><ul><li>首先看 @RequestMapping 注解的 produces 为主，相当于设置了响应的 Content-Type，比如：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(produces = MimeTypeUtils.APPLICATION_JSON_VALUE)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">user</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>再看请求头中的 Accept 是否指定了目标格式</li><li>最后按照消息转换器的添加顺序进行转换</li></ul><h1 id="ControllerAdvice-之-ResponseBodyAdvice"><a href="#ControllerAdvice-之-ResponseBodyAdvice" class="headerlink" title="ControllerAdvice 之 ResponseBodyAdvice"></a>ControllerAdvice 之 ResponseBodyAdvice</h1><p>ResponseBodyAdvice 是一个接口，对于实现了这个接口并被 @ControllerAdvice 标记的类来说，能够在调用每个控制器方法返回结果前，调用重写的 ResponseBodyAdvice 接口中的 beforeBodyWrite() 方法对返回值进行增强。</p><p>现有一个控制器类与内部使用到的 User 类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用控制器方法，并输出响应数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(WebConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">ServletInvocableHandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletInvocableHandlerMethod</span>(</span><br><span class="line">        context.getBean(WebConfig.MyController.class),</span><br><span class="line">        WebConfig.MyController.class.getMethod(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">    handlerMethod.setDataBinderFactory(<span class="keyword">new</span> <span class="title class_">ServletRequestDataBinderFactory</span>(Collections.emptyList(), <span class="literal">null</span>));</span><br><span class="line">    handlerMethod.setParameterNameDiscoverer(<span class="keyword">new</span> <span class="title class_">DefaultParameterNameDiscoverer</span>());</span><br><span class="line">    <span class="comment">// 设置参数解析器（省略源码）</span></span><br><span class="line">    handlerMethod.setHandlerMethodArgumentResolvers(getArgumentResolvers(context));</span><br><span class="line">    <span class="comment">// 设置返回值处理器（省略源码）</span></span><br><span class="line">    handlerMethod.setHandlerMethodReturnValueHandlers(getReturnValueHandlers(context));</span><br><span class="line"></span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>();</span><br><span class="line">    <span class="type">MockHttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletResponse</span>();</span><br><span class="line">    <span class="type">ModelAndViewContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndViewContainer</span>();</span><br><span class="line">    handlerMethod.invokeAndHandle(<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response), container);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(response.getContentAsByteArray(), StandardCharsets.UTF_8));</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台输出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><p>在实际开发场景中常常需要对返回的数据类型进行统一，比如都返回 Result 类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonCreator</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Result</span><span class="params">(<span class="meta">@JsonProperty(&quot;code&quot;)</span> <span class="type">int</span> code, <span class="meta">@JsonProperty(&quot;data&quot;)</span> Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Result</span><span class="params">(<span class="type">int</span> code, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">200</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">200</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">error</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">500</span>, <span class="string">&quot;服务器内部错误:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了直接让控制器方法返回 Result 外，还可以使用 ResponseBodyAdvice 进行增强：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyControllerAdvice</span> <span class="keyword">implements</span> <span class="title class_">ResponseBodyAdvice</span>&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter returnType,</span></span><br><span class="line"><span class="params">                            Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 满足条件才转换</span></span><br><span class="line"><span class="comment">         * 1. 控制器方法被 @ResponseBody 注解标记</span></span><br><span class="line"><span class="comment">         * 2. 控制器方法所在类被 @ResponseBody 注解或包含 @ResponseBody 注解的注解标记</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> returnType.getMethodAnnotation(ResponseBody.class) != <span class="literal">null</span></span><br><span class="line">            || AnnotationUtils.findAnnotation(returnType.getContainingClass(), ResponseBody.class) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">beforeBodyWrite</span><span class="params">(Object body,</span></span><br><span class="line"><span class="params">                                  MethodParameter returnType,</span></span><br><span class="line"><span class="params">                                  MediaType selectedContentType,</span></span><br><span class="line"><span class="params">                                  Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType,</span></span><br><span class="line"><span class="params">                                  ServerHttpRequest request,</span></span><br><span class="line"><span class="params">                                  ServerHttpResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Result) &#123;</span><br><span class="line">            <span class="keyword">return</span> body;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行上述增强后，再运行 main() 方法， 输出结果不变， 这是因为没有将实现的 ResponseBodyAdvice 添加到返回值处理器中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HandlerMethodReturnValueHandlerComposite <span class="title function_">getReturnValueHandlers</span><span class="params">(AnnotationConfigApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加 advice</span></span><br><span class="line">    List&lt;ControllerAdviceBean&gt; annotatedBeans = ControllerAdviceBean.findAnnotatedBeans(context);</span><br><span class="line">    List&lt;Object&gt; responseBodyAdviceList = annotatedBeans.stream()</span><br><span class="line">        .filter(b -&gt; b.getBeanType() != <span class="literal">null</span> </span><br><span class="line">                &amp;&amp; ResponseBodyAdvice.class.isAssignableFrom(b.getBeanType()))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="type">HandlerMethodReturnValueHandlerComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodReturnValueHandlerComposite</span>();</span><br><span class="line">    <span class="comment">// 省略其他返回值处理器的添加</span></span><br><span class="line">    composite.addHandler(<span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(</span><br><span class="line">        Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>()),</span><br><span class="line">        responseBodyAdviceList</span><br><span class="line">    ));</span><br><span class="line">    composite.addHandler(<span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">true</span>));</span><br><span class="line">    <span class="keyword">return</span> composite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行 main() 方法，控制台输出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;code&quot;</span>:<span class="number">200</span>,<span class="string">&quot;data&quot;</span>:&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>如果将控制器方法修改成以下形式，也能输出相同的结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>DispatcherServlet 中对异常处理的核心方法是 processHandlerException()，在这个方法中会对所有异常解析器进行遍历，然后使用每个异常解析器对异常信息进行处理。</p><p>存放异常解析器的是 DispatcherServlet 中泛型为 HandlerExceptionResolver、名为 handlerExceptionResolvers 的列表成员变量。</p><p>HandlerExceptionResolver 是一个接口，本节讲解解析 @ExceptionHandler 注解的异常解析器 ExceptionHandlerExceptionResolver。</p><p>四个控制器类，测试异常处理方法被 @ResponseBody 注解标记、异常处理方法返回 ModelAndView、嵌套异常和对异常处理方法的参数处理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">handle</span><span class="params">(ArithmeticException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singletonMap(<span class="string">&quot;error&quot;</span>, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handler</span><span class="params">(ArithmeticException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;test2&quot;</span>, Collections.singletonMap(<span class="string">&quot;error&quot;</span>, e.getMessage()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">handle</span><span class="params">(IOException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singletonMap(<span class="string">&quot;error&quot;</span>, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">handle</span><span class="params">(Exception e, HttpServletRequest request)</span> &#123;</span><br><span class="line">        System.out.println(request);</span><br><span class="line">        <span class="keyword">return</span> Collections.singletonMap(<span class="string">&quot;error&quot;</span>, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExceptionHandlerExceptionResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExceptionHandlerExceptionResolver</span>();</span><br><span class="line">    resolver.setMessageConverters(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>()));</span><br><span class="line">    <span class="comment">// 调用该方法，添加默认的参数解析器和返回值处理器</span></span><br><span class="line">    resolver.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>();</span><br><span class="line">    <span class="type">MockHttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletResponse</span>();</span><br><span class="line">    <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">Controller1</span>(), Controller1.class.getMethod(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    <span class="type">Exception</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;除以零&quot;</span>);</span><br><span class="line">    resolver.resolveException(request, response, handlerMethod, e);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(response.getContentAsByteArray(), StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">    handlerMethod = <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">Controller2</span>(), Controller2.class.getMethod(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> resolver.resolveException(request, response, handlerMethod, e);</span><br><span class="line">    System.out.println(modelAndView.getModel());</span><br><span class="line">    System.out.println(modelAndView.getViewName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 嵌套异常</span></span><br><span class="line">    handlerMethod = <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">Controller3</span>(), Controller3.class.getMethod(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    e = <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;e1&quot;</span>, <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;e2&quot;</span>, <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;e3&quot;</span>)));</span><br><span class="line">    resolver.resolveException(request, response, handlerMethod, e);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(response.getContentAsByteArray(), StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常处理方法参数处理</span></span><br><span class="line">    handlerMethod = <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">Controller4</span>(), Controller4.class.getMethod(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    e = <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;e4&quot;</span>);</span><br><span class="line">    resolver.resolveException(request, response, handlerMethod, e);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(response.getContentAsByteArray(), StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;error&quot;</span>:<span class="string">&quot;除以零&quot;</span>&#125;</span><br><span class="line">&#123;error=除以零&#125;</span><br><span class="line">test2</span><br><span class="line">&#123;<span class="string">&quot;error&quot;</span>:<span class="string">&quot;除以零&quot;</span>&#125;&#123;<span class="string">&quot;error&quot;</span>:<span class="string">&quot;e3&quot;</span>&#125;</span><br><span class="line">org.springframework.mock.web.MockHttpServletRequest@7c1e2a9e</span><br><span class="line">&#123;<span class="string">&quot;error&quot;</span>:<span class="string">&quot;除以零&quot;</span>&#125;&#123;<span class="string">&quot;error&quot;</span>:<span class="string">&quot;e3&quot;</span>&#125;&#123;<span class="string">&quot;error&quot;</span>:<span class="string">&quot;e4&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="ControllerAdvice-之-ExceptionHandler"><a href="#ControllerAdvice-之-ExceptionHandler" class="headerlink" title="ControllerAdvice 之 @ExceptionHandler"></a>ControllerAdvice 之 @ExceptionHandler</h1><p>控制器中被 @ExceptionHandler 标记的异常处理方法只会在当前控制器中生效，如果想要某个异常处理方法全局生效，则需要将异常处理方法编写在被 @ControllerAdvice 注解标记的类中。</p><p>一个“朴素”的控制器类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当不存在任何异常处理方法时，调用控制器中的 foo() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>();</span><br><span class="line">    <span class="type">MockHttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletResponse</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">ExceptionHandlerExceptionResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExceptionHandlerExceptionResolver</span>();</span><br><span class="line">    resolver.setMessageConverters(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2XmlHttpMessageConverter</span>()));</span><br><span class="line">    resolver.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">    <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">Controller1</span>(), Controller1.class.getMethod(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    <span class="type">Exception</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;e1&quot;</span>);</span><br><span class="line">    resolver.resolveException(request, response, handlerMethod, exception);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(response.getContentAsByteArray(), StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main() 方法运行后，控制台不输出任何信息。</p><p>编写配置类，向 Spring 容器中添加 ExceptionHandlerExceptionResolver，并声明全局异常处理方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@ControllerAdvice</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyControllerAdvice</span> &#123;</span><br><span class="line">        <span class="meta">@ExceptionHandler</span></span><br><span class="line">        <span class="meta">@ResponseBody</span></span><br><span class="line">        <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">handle</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.singletonMap(<span class="string">&quot;error&quot;</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ExceptionHandlerExceptionResolver <span class="title function_">resolver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ExceptionHandlerExceptionResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExceptionHandlerExceptionResolver</span>();</span><br><span class="line">        resolver.setMessageConverters(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>()));</span><br><span class="line">        <span class="comment">// 无需调用 resolver.afterPropertiesSet(); 方法，这是 Spring 的提供的内置拓展，会在 Spring 生命周期中自动执行</span></span><br><span class="line">        <span class="keyword">return</span> resolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExceptionHandlerExceptionResolver 不再直接通过 new 关键词构造，而是从 Spring 容器中获取：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>();</span><br><span class="line">    <span class="type">MockHttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletResponse</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(WebConfig.class);</span><br><span class="line">    <span class="type">ExceptionHandlerExceptionResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> context.getBean(ExceptionHandlerExceptionResolver.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">Controller1</span>(), Controller1.class.getMethod(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    <span class="type">Exception</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;e1&quot;</span>);</span><br><span class="line">    resolver.resolveException(request, response, handlerMethod, exception);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(response.getContentAsByteArray(), StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Tomcat-异常处理"><a href="#Tomcat-异常处理" class="headerlink" title="Tomcat 异常处理"></a>Tomcat 异常处理</h1><p>可以利用 @ExceptionHandler 和 @ControllerAdvice 注解全局对控制器方法中抛出的异常进行处理，但针对诸如 filter 中不在控制器方法中的异常就变得无能为力了。</p><p>因此需要一个更上层的“异常处理者”，这个“异常处理者”就是 Tomcat 服务器。</p><h2 id="32-1-Tomcat-的错误页处理"><a href="#32-1-Tomcat-的错误页处理" class="headerlink" title="32.1 Tomcat 的错误页处理"></a>32.1 Tomcat 的错误页处理</h2><p>首先将“老三样”利用配置类添加到 Spring 容器中，还要将 RequestMappingHandlerMapping 和 RequestMappingHandlerAdapter 也添加到 Spring 容器中。</p><p>必要的控制器也不能少，控制器方法手动制造异常，但不提供使用 @ExceptionHandler 实现的异常处理方法，将产生的异常交由 Tomcat 处理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">servletRegistrationBean</span><span class="params">(DispatcherServlet dispatcherServlet)</span> &#123;</span><br><span class="line">        <span class="type">DispatcherServletRegistrationBean</span> <span class="variable">registrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RequestMappingHandlerMapping <span class="title function_">requestMappingHandlerMapping</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 解析 @RequestMapping</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerMapping</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RequestMappingHandlerAdapter <span class="title function_">requestMappingHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RequestMappingHandlerAdapter</span> <span class="variable">handlerAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerAdapter</span>();</span><br><span class="line">        <span class="comment">// 注意默认的 RequestMappingHandlerAdapter 不会带 jackson 转换器</span></span><br><span class="line">        handlerAdapter.setMessageConverters(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>()));</span><br><span class="line">        <span class="keyword">return</span> handlerAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Controller</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">        <span class="meta">@RequestMapping(&quot;test&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> ModelAndView <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 AnnotationConfigServletWebServerApplicationContext 创建 Spring Web 容器，并输出所有的路径映射信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigServletWebServerApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>(WebConfig.class);</span><br><span class="line">    <span class="type">RequestMappingHandlerMapping</span> <span class="variable">handlerMapping</span> <span class="operator">=</span> context.getBean(RequestMappingHandlerMapping.class);</span><br><span class="line">    handlerMapping.getHandlerMethods().forEach((k, v) -&gt; System.out.println(<span class="string">&quot;映射路径: &quot;</span> + k + <span class="string">&quot;\t方法信息: &quot;</span> + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台只输出一条路径映射信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">映射路径: &#123; [/test]&#125;        方法信息: indi.lcp.a32.WebConfig$MyController#test()</span><br></pre></td></tr></table></figure><p>在浏览器中访问 <a href="http://localhost:8080/test">http://localhost:8080/test</a> 地址：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=Mzc1YWY5MTc2YjFjMWM2OTVjZTNjMmUwZTY5YmQwMTdfNWhyaEpYaGg2Skp4dE1iMjFpbUJVcXNhY09hcW9QcHRfVG9rZW46Q3VsSWJlbDBBb3EyOGx4b1VpeGN3NGxUbmNoXzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><p>显示 Tomcat 的错误处理页，并在页面中输出了错误信息。</p><p>Tomcat 默认提供的错误处理方式返回的是 HTML 格式的数据，但需要返回 JSON 格式的数据又该怎么自定义呢？</p><p>修改 Tomcat 默认的错误处理路径，并添加后置处理器进行注册：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改了 Tomcat 服务器默认错误地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ErrorPageRegistrar <span class="title function_">errorPageRegistrar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * ErrorPageRegistrar 由 SpringBoot 提供，TomcatServletWebServerFactory 也实现了该接口</span></span><br><span class="line"><span class="comment">     * 出现错误，会使用请求转发 forward 跳转到 error 地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> webServerFactory -&gt; webServerFactory.addErrorPages(<span class="keyword">new</span> <span class="title class_">ErrorPage</span>(<span class="string">&quot;/error&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ErrorPageRegistrarBeanPostProcessor <span class="title function_">errorPageRegistrarBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在 TomcatServletWebServerFactory 初始化完成前，获取容器中所有的 ErrorPageRegistrar</span></span><br><span class="line"><span class="comment">     * 并将这些 ErrorPageRegistrar 进行注册</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ErrorPageRegistrarBeanPostProcessor</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启程序，再次在浏览器中访问 <a href="http://localhost:8080/test%EF%BC%8C%E6%AD%A4%E6%97%B6%E9%A1%B5%E9%9D%A2%E4%B8%8A%E4%B8%8D%E5%86%8D%E6%98%BE%E7%A4%BA">http://localhost:8080/test，此时页面上不再显示</a> Tomcat 的默认错误处理页，而是产生了 404 错误。</p><p>这是因为整个程序中并没有名称为 error 的页面，或者为 &#x2F;error 的请求路径。在控制器中添加请求路径为 &#x2F;error 的控制器方法，该方法被 @ResponseBody 标记，最终返回 JSON 格式的数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/error&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">error</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// tomcat 会将异常对象存储到 request 作用域中，可以直接获取</span></span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">e</span> <span class="operator">=</span> (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);</span><br><span class="line">    <span class="keyword">return</span> Collections.singletonMap(<span class="string">&quot;error&quot;</span>, e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次重启程序，控制台输出的路径映射信息多了一条：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">映射路径: &#123; [/error]&#125;        方法信息: indi.lcp.a32.WebConfig$MyController#error(HttpServletRequest)</span><br><span class="line">映射路径: &#123; [/test]&#125;        方法信息: indi.lcp.a32.WebConfig$MyController#test()</span><br></pre></td></tr></table></figure><p>在浏览器中访问 <a href="http://localhost:8080/test">http://localhost:8080/test</a> ：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWFhZWFhYTE4NjhhYjA3YTE5ZTYxOWZlN2EwNGZhNmVfdXExNUNiZmtwSm1lVEc4WmxHeUdQUXh0cW1ON3Zva1lfVG9rZW46Sm9nUWJMRmFjb1VtcFB4dTRWT2NDMmlHbndiXzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><h2 id="32-2-BasicErrorController"><a href="#32-2-BasicErrorController" class="headerlink" title="32.2 BasicErrorController"></a>32.2 BasicErrorController</h2><p>BasicErrorController 是由 SpringBoot 提供的类，它也是一个控制器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&#123;&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicErrorController</span> <span class="keyword">extends</span> <span class="title class_">AbstractErrorController</span> &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的映射路径会先从配置文件中读取，在未进行任何配置的情况下，默认路径是 &#x2F;error。</p><p>向容器中添加 BasicErrorController，构造 BasicErrorController 时需要传递两个参数：</p><ul><li>errorAttributes：错误属性，可以理解成封装的错误信息对象</li><li>errorProperties：也可以翻译成错误属性，用于对输出的错误信息进行配置</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> BasicErrorController <span class="title function_">basicErrorController</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BasicErrorController</span>(<span class="keyword">new</span> <span class="title class_">DefaultErrorAttributes</span>(), <span class="keyword">new</span> <span class="title class_">ErrorProperties</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移除前文添加的 error() 控制器方法。</p><p>再次重启程序，控制台输出的路径映射信息为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">映射路径: &#123; [/error]&#125;        方法信息: org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController#error(HttpServletRequest)</span><br><span class="line">映射路径: &#123; [/test]&#125;        方法信息: indi.lcp.a32.WebConfig$MyController#test()</span><br><span class="line">映射路径: &#123; [/error], produces [text/html]&#125;        方法信息: org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController#errorHtml(HttpServletRequest, HttpServletResponse)</span><br></pre></td></tr></table></figure><p>路径映射信息多了两条，它们的请求路径一样，但根据不同的请求来源返回不同格式的数据。</p><p>使用接口测试工具访问</p><p>如果采用 Postman 等接口测试工具访问 <a href="http://localhost:8080/test">http://localhost:8080/test</a> 路径时，将返回 JSON 格式的数据，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;timestamp&quot;</span>: <span class="number">1674736682248</span>,</span><br><span class="line">  <span class="string">&quot;status&quot;</span>: <span class="number">500</span>,</span><br><span class="line">  <span class="string">&quot;error&quot;</span>: <span class="string">&quot;Internal Server Error&quot;</span>,</span><br><span class="line">  <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/test&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>timestamp、status 等响应内容就是错误属性 errorAttributes 的中包含的内容。</p><p>返回的数据中并没有显示异常信息，可以通过配置文件进行配置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server.error.include-exception=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>也可以在添加 BasicErrorController 到 Spring 容器中时，设置错误属性 errorProperties：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> BasicErrorController <span class="title function_">basicErrorController</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ErrorProperties</span> <span class="variable">errorProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorProperties</span>();</span><br><span class="line">    errorProperties.setIncludeException(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BasicErrorController</span>(<span class="keyword">new</span> <span class="title class_">DefaultErrorAttributes</span>(), errorProperties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启程序，再次使用接口测试工具访问 <a href="http://localhost:8080/test%EF%BC%9A">http://localhost:8080/test：</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;timestamp&quot;</span>: <span class="number">1674736991768</span>,</span><br><span class="line">  <span class="string">&quot;status&quot;</span>: <span class="number">500</span>,</span><br><span class="line">  <span class="string">&quot;error&quot;</span>: <span class="string">&quot;Internal Server Error&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exception&quot;</span>: <span class="string">&quot;java.lang.ArithmeticException&quot;</span>,</span><br><span class="line">  <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/test&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用浏览器访问</p><p>如果使用浏览器访问 <a href="http://localhost:8080/test%EF%BC%8C%E5%8F%88%E4%BC%9A%E5%9B%9E%E5%88%B0%E2%80%9C%E8%A7%A3%E6%94%BE%E5%89%8D%E2%80%9D%EF%BC%8C%E6%98%BE%E7%A4%BA%E4%B8%8E">http://localhost:8080/test，又会回到“解放前”，显示与</a> Tomcat 的默认错误处理页相同的内容。</p><p>这是因为使用浏览器访问时，将调用 BasicErrorController 中的 errorHtml() 控制器方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">    produces = &#123;&quot;text/html&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">errorHtml</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="type">HttpStatus</span> <span class="variable">status</span> <span class="operator">=</span> <span class="built_in">this</span>.getStatus(request);</span><br><span class="line">    Map&lt;String, Object&gt; model = Collections.unmodifiableMap(<span class="built_in">this</span>.getErrorAttributes(request, <span class="built_in">this</span>.getErrorAttributeOptions(request, MediaType.TEXT_HTML)));</span><br><span class="line">    response.setStatus(status.value());</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="built_in">this</span>.resolveErrorView(request, response, status, model);</span><br><span class="line">    <span class="keyword">return</span> modelAndView != <span class="literal">null</span> ? modelAndView : <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;error&quot;</span>, model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法返回 ModelAndView，并且在没有添加新的错误视图的情况下，尝试寻找视图名称为 error 的视图。</p><p>这里既没有添加新的错误视图，也没有名称为 error 的视图，因此最终又会交由 Tomcat 进行处理。</p><p>尝试向 Spring 容器中添加一个 View 视图，Bean 的名字 必须 是 error：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">error</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (model, request, response) -&gt; &#123;</span><br><span class="line">        System.out.println(model);</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        response.getWriter().print(<span class="string">&quot;&lt;h3&gt;服务器内部错误&lt;/h3&gt;&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能够在查找指定名称的视图时按照 View 类型的 Bean 的名称进行匹配，还需要添加一个解析器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ViewResolver <span class="title function_">viewResolver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// View 类型的 Bean 的名称即为视图名称</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanNameViewResolver</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启程序，使用浏览器访问 <a href="http://localhost:8080/test%EF%BC%9A">http://localhost:8080/test：</a></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NjgzODA4NzBjY2VjMjU3MTZiNmU3ZmE4NjY3NTQ2MWRfMVBUVUZ5M1lUMGJRMlJkUTFBdERVNTJlZGtTWjRFVXRfVG9rZW46U29zdWJtZVozb3p3UzZ4V3VRaWNLejBKblRnXzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><p>控制台还打印出： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;timestamp=Thu Jan <span class="number">26</span> <span class="number">21</span>:<span class="number">01</span>:<span class="number">50</span> CST <span class="number">2023</span>, status=<span class="number">500</span>, error=Internal Server Error, exception=java.lang.ArithmeticException, path=/test&#125;</span><br></pre></td></tr></table></figure><h1 id="BeanNameUrlHandlerMapping-与-SimpleControllerHandlerAdapter"><a href="#BeanNameUrlHandlerMapping-与-SimpleControllerHandlerAdapter" class="headerlink" title="BeanNameUrlHandlerMapping 与 SimpleControllerHandlerAdapter"></a>BeanNameUrlHandlerMapping 与 SimpleControllerHandlerAdapter</h1><h2 id="33-1-功能与使用"><a href="#33-1-功能与使用" class="headerlink" title="33.1 功能与使用"></a>33.1 功能与使用</h2><p>BeanNameUrlHandlerMapping 与 RequestMappingHandlerMapping 类似，也是用于解析请求路径，只不过 BeanNameUrlHandlerMapping 将根据请求路径在 Spring 容器中寻找同名的 Bean，对请求进行处理，这个 Bean 必须 以 &#x2F; 开头。比如：请求路径为 &#x2F;c1，寻找的 Bean 的名称也是 &#x2F;c1。</p><p>SimpleControllerHandlerAdapter 与 RequestMappingHandlerAdapter 也类似，也是用于调用控制器方法，但要求控制器类必须实现 org.springframework.web.servlet.mvc.Controller 接口。</p><p>现有三个控制器类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;/c1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller1</span> <span class="keyword">implements</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        response.getWriter().print(<span class="string">&quot;this is c1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;/c2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller2</span> <span class="keyword">implements</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        response.getWriter().print(<span class="string">&quot;this is c2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;/c3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Controller <span class="title function_">controller3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (request, response) -&gt; &#123;</span><br><span class="line">        response.getWriter().print(<span class="string">&quot;this is c3&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供配置类 WebConfig，添加 Web 换件下必要的 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">servletRegistrationBean</span><span class="params">(DispatcherServlet dispatcherServlet)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BeanNameUrlHandlerMapping <span class="title function_">beanNameUrlHandlerMapping</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanNameUrlHandlerMapping</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SimpleControllerHandlerAdapter <span class="title function_">simpleControllerHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleControllerHandlerAdapter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigServletWebServerApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>(WebConfig.class);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，在浏览器中访问 <a href="http://localhost:8080/c1%EF%BC%8C%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%98%BE%E7%A4%BA">http://localhost:8080/c1，页面上显示</a> this is c1。更换请求路径为 c2、c3 后，也会出现类似的信息。</p><h2 id="33-2-自定义实现"><a href="#33-2-自定义实现" class="headerlink" title="33.2 自定义实现"></a>33.2 自定义实现</h2><p>在配置类 WebConfig 中移除 Spring 提供的 BeanNameUrlHandlerMapping 与 SimpleControllerHandlerAdapter，手动编码实现它们的功能。</p><p>为了与前文的测试形成对比，将 Controller2 的 Bean 名称设置为 c2，而不是 &#x2F;c2，使其不能被解析到。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyHandlerMapping</span> <span class="keyword">implements</span> <span class="title class_">HandlerMapping</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        <span class="type">Controller</span> <span class="variable">controller</span> <span class="operator">=</span> controllerMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (controller == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HandlerExecutionChain</span>(controller);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Controller&gt; controllerMap;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        controllerMap = context.getBeansOfType(Controller.class).entrySet().stream()</span><br><span class="line">            .filter(i -&gt; i.getKey().startsWith(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> handler <span class="keyword">instanceof</span> Controller;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                               HttpServletResponse response,</span></span><br><span class="line"><span class="params">                               Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> Controller) &#123;</span><br><span class="line">            ((Controller) handler).handleRequest(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，在浏览器中访问：</p><p><a href="http://localhost:8080/c1%EF%BC%8C%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%98%BE%E7%A4%BA">http://localhost:8080/c1，页面上显示</a> this is c1；</p><p><a href="http://localhost:8080/c2%EF%BC%8C%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%98%BE%E7%A4%BA">http://localhost:8080/c2，页面上显示</a> 404；</p><p><a href="http://localhost:8080/c3%EF%BC%8C%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%98%BE%E7%A4%BA">http://localhost:8080/c3，页面上显示</a> this is c3。</p><h1 id="RouterFunctionMapping-与-HandlerFunctionAdapter"><a href="#RouterFunctionMapping-与-HandlerFunctionAdapter" class="headerlink" title="RouterFunctionMapping 与 HandlerFunctionAdapter"></a>RouterFunctionMapping 与 HandlerFunctionAdapter</h1><p>RouterFunctionMapping 在初始化时，在 Spring 容器中收集所有 RouterFunction，RouterFunction 包括两部分：</p><ol><li>RequestPredicate：设置映射条件</li><li>HandlerFunction：处理逻辑</li></ol><p>当请求到达时，根据映射条件找到 HandlerFunction，即 handler，然后使用 HandlerFunctionAdapter 调用 handler。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">servletRegistrationBean</span><span class="params">(DispatcherServlet dispatcherServlet)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouterFunctionMapping <span class="title function_">routerFunctionMapping</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RouterFunctionMapping</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HandlerFunctionAdapter <span class="title function_">handlerFunctionAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HandlerFunctionAdapter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title function_">r1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> route(GET(<span class="string">&quot;/r1&quot;</span>), req -&gt; ok().body(<span class="string">&quot;this is r1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title function_">r2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> route(GET(<span class="string">&quot;/r2&quot;</span>), req -&gt; ok().body(<span class="string">&quot;this is r2&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigServletWebServerApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>(WebConfig.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，在浏览器中访问 <a href="http://localhost:8080/r1%EF%BC%8C%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%98%BE%E7%A4%BA">http://localhost:8080/r1，页面上显示</a> this is r1，访问 r2 时也类似。</p><h1 id="SimpleUrlHandlerMapping-与HttpRequestHandlerAdapter"><a href="#SimpleUrlHandlerMapping-与HttpRequestHandlerAdapter" class="headerlink" title="SimpleUrlHandlerMapping 与HttpRequestHandlerAdapter"></a>SimpleUrlHandlerMapping 与HttpRequestHandlerAdapter</h1><h2 id="35-1-功能与使用"><a href="#35-1-功能与使用" class="headerlink" title="35.1 功能与使用"></a>35.1 功能与使用</h2><p>概括一下，这两个主要用于静态资源处理，SimpleUrlHandlerMapping 用于静态资源映射，而静态资源处理器是 ResourceHttpRequestHandler，HttpRequestHandlerAdapter 用于处理器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">servletRegistrationBean</span><span class="params">(DispatcherServlet dispatcherServlet)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SimpleUrlHandlerMapping <span class="title function_">simpleUrlHandlerMapping</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">        <span class="type">SimpleUrlHandlerMapping</span> <span class="variable">mapping</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleUrlHandlerMapping</span>();</span><br><span class="line">        <span class="comment">// 设置静态资源处理器，得到所有映射关系</span></span><br><span class="line">        Map&lt;String, ResourceHttpRequestHandler&gt; map = context.getBeansOfType(ResourceHttpRequestHandler.class);</span><br><span class="line">        mapping.setUrlMap(map);</span><br><span class="line">        <span class="keyword">return</span> mapping;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HttpRequestHandlerAdapter <span class="title function_">httpRequestHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpRequestHandlerAdapter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;/**&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResourceHttpRequestHandler <span class="title function_">handler1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ResourceHttpRequestHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceHttpRequestHandler</span>();</span><br><span class="line">        <span class="comment">// 以 / 结尾表示目录，否则认为是文件</span></span><br><span class="line">        handler.setLocations(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;static/&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;/img/**&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResourceHttpRequestHandler <span class="title function_">handler2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ResourceHttpRequestHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceHttpRequestHandler</span>();</span><br><span class="line">        handler.setLocations(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;images/&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加的两个 ResourceHttpRequestHandler 类型的 Bean，分别设置了它们处理 ClassPath 路径下哪个目录下的静态资源，那如何将请求路径与静态资源访问路径进行映射呢？</p><p>也就是说，当要访问 ClassPath 路径下的 static 目录下的静态资源时，应该通过哪个请求路径呢？</p><p>可以利用通配符设置添加的 ResourceHttpRequestHandler 类型的 Bean 的名称。</p><p>比如设置 Bean 的名称为 &#x2F;**，那么在访问 localhost:8080&#x2F;r1.html 时，就会尝试访问 ClassPath 路径下 static 目录中名为 r1.html 的静态资源；又比如设置 Bean 的名称为 &#x2F;img&#x2F;**，那么在访问 localhost:8080&#x2F;img&#x2F;1.jpg 时， 就会尝试访问 ClassPath 路径下 images 目录中名为 1.jpg 的静态资源。</p><h2 id="35-2-资源解析器"><a href="#35-2-资源解析器" class="headerlink" title="35.2 资源解析器"></a>35.2 资源解析器</h2><p>ResourceHttpRequestHandler 用于对静态资源进行处理，但静态资源解析的功能是由 ResourceResolver 完成的。</p><p>ResourceHttpRequestHandler 实现了 InitializingBean 接口，查看重写的 afterPropertiesSet()：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    resolveResourceLocations();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.resourceResolvers.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.resourceResolvers.add(<span class="keyword">new</span> <span class="title class_">PathResourceResolver</span>());</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用的资源解析器列表为空时，默认添加最基本的资源解析器 PathResourceResolver。</p><p>尝试添加额外的资源解析器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;/**&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResourceHttpRequestHandler <span class="title function_">handler1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ResourceHttpRequestHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceHttpRequestHandler</span>();</span><br><span class="line">    <span class="comment">// 以 / 结尾表示目录，否则认为是文件</span></span><br><span class="line">    handler.setLocations(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;static/&quot;</span>)));</span><br><span class="line">    <span class="comment">// 不使用默认的资源解析器，而是使用自行添加的</span></span><br><span class="line">    handler.setResourceResolvers(Arrays.asList(</span><br><span class="line">            <span class="comment">// 读取资源时使用缓存</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CachingResourceResolver</span>(<span class="keyword">new</span> <span class="title class_">ConcurrentMapCache</span>(<span class="string">&quot;cache1&quot;</span>)),</span><br><span class="line">            <span class="comment">// 读取压缩资源</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">EncodedResourceResolver</span>(),</span><br><span class="line">            <span class="comment">// 最基本的：从磁盘上读取静态资源</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PathResourceResolver</span>()</span><br><span class="line">    ));</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加了三个资源解析器：</p><ul><li>CachingResourceResolver：对静态资源进行缓存</li><li>EncodedResourceResolver：对静态资源进行压缩</li><li>PathResourceResolver：最基本的资源处理器</li></ul><p>还要注意添加的顺序，先尝试从缓存中获取，再尝试获取压缩文件，最后才是直接从磁盘上读取。</p><p>针对 EncodedResourceResolver 来说，Spring 不会自行对静态资源进行压缩，需要在配置类中提供压缩方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initGzip</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;static&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> resource.getFile();</span><br><span class="line">    <span class="keyword">for</span> (File file : dir.listFiles(pathname -&gt; pathname.getName().endsWith(<span class="string">&quot;.html&quot;</span>))) &#123;</span><br><span class="line">        System.out.println(file);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">             <span class="type">GZIPOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GZIPOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file.getAbsoluteFile() + <span class="string">&quot;.gz&quot;</span>))) &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span> * <span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类对应的 Bean 初始化阶段时，将 ClassPath 路径下 static 目录中的静态资源进行压缩。</p><p>比如 static 目录下的 r1.html 会被压缩成 r1.html.gz，在访问 r1.html 时，会访问压缩文件 r1.html.gz，由浏览器识别并解压成 r1.html 进行访问，减少网络传输数据量。</p><h2 id="35-3-欢迎页处理"><a href="#35-3-欢迎页处理" class="headerlink" title="35.3 欢迎页处理"></a>35.3 欢迎页处理</h2><p>将访问 根路径 的请求，映射到某一欢迎页。这个功能由 WelcomePageHandlerMapping 完成。</p><p>设置静态资源欢迎页为 ClassPath 下 static 目录中的 index.html 文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title function_">welcomePageHandlerMapping</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> context.getResource(<span class="string">&quot;classpath:static/index.html&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WelcomePageHandlerMapping</span>(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        context,</span><br><span class="line">        resource,</span><br><span class="line">        <span class="string">&quot;/**&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序会根据配置的欢迎页映射器生成一个实现了 Controller 接口的处理器，使用 SimpleControllerHandlerAdapter 执行生成的处理器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SimpleControllerHandlerAdapter <span class="title function_">simpleControllerHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleControllerHandlerAdapter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启程序，控制台会输出一条如下的日志，表示欢迎页配置成功：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">o.s.b.a.w.s.WelcomePageHandlerMapping - Adding welcome page: <span class="keyword">class</span> <span class="title class_">path</span> resource [<span class="keyword">static</span>/index.html] </span><br></pre></td></tr></table></figure><p>在浏览器上访问 localhost:8080 时，会直接访问静态资源 static&#x2F;index.html 的内容。</p><p>注意： 如果重启程序后访问 localhost:8080 并没有跳转到配置的欢迎页，可以重新编译项目后在运行。</p><p>总结</p><p>WelcomePageHandlerMapping 作为欢迎页映射器，只将根路径，即 &#x2F; 映射到配置的欢迎页。</p><p>它内置了一个处理器，名为 ParameterizableViewController，该处理器不执行逻辑，仅根据固定的视图名 forward:index.html 去寻找视图。</p><p>SimpleControllerHandlerAdapter 用于调用处理器，根据重定向到根路径的 index.html 页面，执行静态资源处理器，访问 static 目录下的 index.html 文件（在配置类中自行配置的）。</p><h2 id="35-4-映射器与适配器总结"><a href="#35-4-映射器与适配器总结" class="headerlink" title="35.4 映射器与适配器总结"></a>35.4 映射器与适配器总结</h2><p>HandlerMapping 用于建立请求路径与控制器之间的映射关系：</p><ul><li>RequestMappingHandlerMapping：解析 @RequestMapping 及其派生注解，建立请求路径与控制器方法之间的映射关系</li><li>WelcomePageHandlerMapping：映射 &#x2F; 根路径，寻找欢迎页</li><li>BeanNameUrlHandlerMapping：与 Bean 的名称进行匹配，要求名称必须以 &#x2F; 开头</li><li>RouterFunctionMapping：将 RequestPredicate 映射到 HandlerFunction</li><li>SimpleUrlHandlerMapping：静态资源映射</li></ul><p>映射器之间的顺序也是有要求的，SpringBoot 中的映射器按上述顺序排序。</p><p>HandlerAdapter 用于对各种处理器进行适配调用（适配器 模式）：</p><ul><li>RequestMappingHandlerAdapter：执行被 @RequestMapping 标记的控制器方法，内部还会使用参数解析器、返回值处理器对控制器方法的参数、返回值进行处理（组合 模式）</li><li>SimpleControllerHandlerAdapter：执行实现了 Controller 接口的处理器</li><li>HandlerFunctionAdapter：处理 HandlerFunction 函数式接口</li><li>HttpRequestHandlerAdapter：处理 HttpRequestHandler 接口，用于静态资源处理</li></ul><p>ResourceHttpRequestHandler 中的 setResourceResolvers() 方法是 责任链 模式体现。</p><h1 id="MVC-处理流程"><a href="#MVC-处理流程" class="headerlink" title="MVC 处理流程"></a>MVC 处理流程</h1><p>当浏览器发送一个请求 <a href="http://localhost:8080/hello">http://localhost:8080/hello</a> 后，请求到达服务器，其处理流程是：</p><p>服务器提供了 DispatcherServlet，它使用的是标准 Servlet 技术</p><p>路径：默认映射路径为 &#x2F;，即会匹配到所有请求 URL，可作为请求的统一入口，DispatcherServlet 也被称之为 前控制器。但也有例外：</p><p>JSP 不会匹配到 DispatcherServlet</p><p>其它有路径的 Servlet 匹配优先级也高于 DispatcherServlet</p><p>创建：在 SpringBoot 中，由自动配置类 DispatcherServletAutoConfiguration 提供 DispatcherServlet 的 Bean</p><p>初始化：DispatcherServlet 初始化时会优先到容器里寻找各种组件，作为它的成员变量</p><p>HandlerMapping，初始化时记录映射关系</p><p>HandlerAdapter，初始化时准备参数解析器、返回值处理器、消息转换器</p><p>HandlerExceptionResolver，初始化时准备参数解析器、返回值处理器、消息转换器</p><p>ViewResolver</p><p>DispatcherServlet 利用 RequestMappingHandlerMapping 查找控制器方法</p><p>例如根据 &#x2F;hello 路径找到被 @RequestMapping(“&#x2F;hello”) 标记的控制器方法，控制器方法会被封装成 HandlerMethod 对象，并结合 匹配到的拦截器 一起返回给 DispatcherServlet。</p><p>HandlerMethod 和 拦截器 合称为 HandlerExecutionChain（调用链）对象。</p><p>DispatcherServlet 接下来会</p><p>调用拦截器的 preHandle() 方法，返回一个布尔类型的值。若返回 true，则放行，进行后续调用，反之拦截请求，不进行后续调用；</p><p>RequestMappingHandlerAdapter 调用处理器方法，准备数据绑定工厂、模型工厂、ModelAndViewContainer、将 HandlerMethod 完善为 ServletInvocableHandlerMethod</p><p>@ControllerAdvice 全局增强点 1️⃣：利用 @ModelAttribute 补充模型数据</p><p>@ControllerAdvice 全局增强点 2️⃣：利用 @InitBinder 补充自定义类型转换器</p><p>使用 HandlerMethodArgumentResolver 准备参数</p><p>@ControllerAdvice 全局增强点 3️⃣：利用 RequestBodyAdvice 接口对请求体增强</p><p>调用 ServletInvocableHandlerMethod</p><p>使用 HandlerMethodReturnValueHandler 处理返回值</p><p>@ControllerAdvice 全局增强点 4️⃣：利用 RequestBodyAdvice 对响应体增强</p><p>根据 ModelAndViewContainer 获取 ModelAndView</p><p>如果返回的 ModelAndView 为 null，不走第 4 步视图解析及渲染流程。例如返回值处理器调用了 HttpMessageConverter 将结果转换为 JSON，这时 ModelAndView 就为 null</p><p>如果返回的 ModelAndView 不为 null，会在第 4 步走视图解析及渲染流程</p><p>调用拦截器的 postHandle() 方法</p><p>处理异常或视图渲染</p><p>如果 1~3 步中出现异常，使用 ExceptionHandlerExceptionResolver 处理异常流程</p><p>@ControllerAdvice 全局增强点 5️⃣：利用 @ExceptionHandler 进行统一异常处理</p><p>未出现异常时，进行视图解析及渲染流程</p><p>调用拦截器的 afterCompletion() 方法</p><h1 id="Boot-骨架项目"><a href="#Boot-骨架项目" class="headerlink" title="Boot 骨架项目"></a>Boot 骨架项目</h1><p>使用 IDEA 创建 SpringBoot 项目时，会创建出 .mvn 目录、HELP.md、mvnw 和 mvnw.cmd 等不必要的文件。</p><p>如果是 Linux 环境下，执行以下命令获取 SpringBoot 的骨架，并添加 web、mysql、mybatis 依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -G https:<span class="comment">//start.spring.io/pom.xml -d dependencies=web,mysql,mybatis -o pom.xml</span></span><br></pre></td></tr></table></figure><p>也可以使用 Postman 等接口测试工具来实现。</p><p>更多用法执行以下命令进行参考：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl https:<span class="comment">//start.spring.io</span></span><br></pre></td></tr></table></figure><h1 id="Boot-War-项目"><a href="#Boot-War-项目" class="headerlink" title="Boot War 项目"></a>Boot War 项目</h1><h2 id="38-1-项目的构建"><a href="#38-1-项目的构建" class="headerlink" title="38.1 项目的构建"></a>38.1 项目的构建</h2><p>利用 IDEA 创建新模块 test_war，区别在于选择的打包方式是 War：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MjZkMjVhYTAwNmZjOTg2ZGUxNzg5ODdiYjkyYjUwNTNfMGZmeHk5QlBFY1pDT2JPMkwzWFFhZlI1cW1RaUtYS3pfVG9rZW46VzUxRmJTdnBObzBaa3N4UGczdmM2ZlpIbjQzXzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><p>选择依赖时，勾选 Spring Web。</p><p>一般来说，选择 War 作为打包方式都是为了使用 JSP，因为 JSP 不能配合 Jar 打包方式使用。</p><p>JSP 文件的存放路径是固定的，在 src&#x2F;main 目录下的 webapp 目录，如果没有 webapp 目录，需要自行创建。之后新建 hello.jsp：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h3&gt;Hello!&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>之后新建控制器类 HelloController，编写控制器方法 hello()，返回值类型是 String，要求返回的是视图名称：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后要在配置文件中配置视图的前缀、后缀，使控制器方法返回的视图名称对应视图名称的 JSP 页面：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.mvc.view.prefix=/</span><br><span class="line">spring.mvc.view.suffix=.jsp</span><br></pre></td></tr></table></figure><h2 id="38-2-项目的测试"><a href="#38-2-项目的测试" class="headerlink" title="38.2 项目的测试"></a>38.2 项目的测试</h2><p>使用外置 Tomcat 测试</p><p>首先得安装外置 Tomcat，省略安装步骤。</p><p>然后在 IDEA 的 Run&#x2F;Debug Configurations 中进行配置，选择安装的外置 Tomcat：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MjA3MjQxMjkwMzk4NDliYmRjZTIwMTQzNDFhNjQ5YTNfdm1zRlpSeldkc2h2RWk5ZEFXbHdSSzhuaGFXbzN3QU5fVG9rZW46WTdFMGJTM2Vqb1RkYlB4UXRCdmM4SjFPbkhkXzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><p>然后在 Deployment 中指定当前项目的部署方式和应用程序上下文路径：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NjMxMzBmNmEzMTYzNjM3YzJlNTMzZmJmOTU2MTEwOTdfcHVtN1dDVW1zTWFtQ3BQMm5QTzM3VWxrR2wwNlJsdENfVG9rZW46QmsxbWIzZnB1b0FxbG94SXRKd2NZWXpJbjRkXzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><p>尽管使用外置 Tomcat 进行测试，但主启动类不能少：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestWarApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(TestWarApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，还要编写 ServletInitializer，在外置 Tomcat 启动时，找到 SpringBoot 项目的主启动类，执行 SpringBoot 流程：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletInitializer</span> <span class="keyword">extends</span> <span class="title class_">SpringBootServletInitializer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> SpringApplicationBuilder <span class="title function_">configure</span><span class="params">(SpringApplicationBuilder application)</span>   &#123;</span><br><span class="line">        <span class="keyword">return</span> application.sources(TestWarApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有 ServletInitializer 类，则无法使 SpringBoot 项目使用外置 Tomcat。</p><p>运行程序后，访问 localhost:8080&#x2F;hello，页面进入编写的 hello.jsp 页面</p><p>使用内嵌 Tomcat 测试</p><p>打包方式为 Jar 时，直接运行主启动类，然后访问对应的请求路径即可跳转到指定的视图中，那打包访问变成 War 之后，使用这种方式还能够成功跳转吗？</p><p>程序运行成功后，访问 localhost:8080&#x2F;hello，页面并没有按照预期跳转到 hello.jsp 页面中，也是下载了该页面。</p><p>这是因为内嵌 Tomcat 中不具备 JSP 解析能力，如果要想使其具备解析 JSP 的能力，需要添加依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>之后再访问 localhost:8080&#x2F;hello，页面进入编写的 hello.jsp 页面。</p><p>使用内嵌 Tomcat 测试遇到的问题</p><p>添加 tomcat-embed-jasper 依赖后，访问 localhost:8080&#x2F;hello，仍在下载 hello.jsp。</p><p>答：清理浏览器缓存，在浏览器的 DevTools 中的 Network 内 勾选 Disable cache 以禁用缓存。</p><p>添加 tomcat-embed-jasper 依赖后，访问 localhost:8080&#x2F;hello，页面 404。</p><p>答：设置运行主启动类的 Run&#x2F;Debug Configurations 中的 Working directory 为当前模块所在目录。</p><p>参考链接：springboot 在idea多模块下 子模块的web项目用内置tomcat启动访问jsp报404</p><h1 id="Boot-启动过程"><a href="#Boot-启动过程" class="headerlink" title="Boot 启动过程"></a>Boot 启动过程</h1><h2 id="39-1-SpringApplication-的构造"><a href="#39-1-SpringApplication-的构造" class="headerlink" title="39.1 SpringApplication 的构造"></a>39.1 SpringApplication 的构造</h2><p>SpringBoot 的主启动类类似于：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BootApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(BootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 SpringApplication#run() 方法是核心方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> run(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终使用 new 关键字构造了 SpringApplication 对象，然后调用了非静态 run() 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="literal">null</span>, primarySources);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.primarySources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    <span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="built_in">this</span>.bootstrapRegistryInitializers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">        getSpringFactoriesInstances(BootstrapRegistryInitializer.class));</span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造 SpringApplication 对象时做了如下几件事：</p><p>获取 Bean Definition 源</p><p>推断应用类型</p><p>添加 ApplicationContext 初始化器</p><p>添加事件监听器</p><p>主类推断</p><p>获取 Bean Definition 源</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A39_1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SpringApplication</span> <span class="variable">spring</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(A39_1.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并初始化 Spring 容器</span></span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> spring.run(args);</span><br><span class="line">        Arrays.stream(context.getBeanDefinitionNames()).forEach(i -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;name: &quot;</span> + i +</span><br><span class="line">                               <span class="string">&quot; 来源: &quot;</span> + context.getBeanFactory().getBeanDefinition(i).getResourceDescription());</span><br><span class="line">        &#125;);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出错误信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Web application could not be started as there was no org.springframework.boot.web.servlet.server.ServletWebServerFactory bean defined in the context.</span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Check your application<span class="string">&#x27;s dependencies for a supported servlet web server.</span></span><br><span class="line"><span class="string">Check the configured web application type.</span></span><br></pre></td></tr></table></figure><p>这是因为添加了 spring-boot-starter-web 依赖，但 Spring 容器中并没有 ServletWebServerFactory 类型的 Bean。向容器中添加即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后在运行 main() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name: org.springframework.context.annotation.internalConfigurationAnnotationProcessor 来源: <span class="literal">null</span></span><br><span class="line">name: org.springframework.context.annotation.internalAutowiredAnnotationProcessor 来源: <span class="literal">null</span></span><br><span class="line">name: org.springframework.context.annotation.internalCommonAnnotationProcessor 来源: <span class="literal">null</span></span><br><span class="line">name: org.springframework.context.event.internalEventListenerProcessor 来源: <span class="literal">null</span></span><br><span class="line">name: org.springframework.context.event.internalEventListenerFactory 来源: <span class="literal">null</span></span><br><span class="line">name: a39_1 来源: <span class="literal">null</span></span><br><span class="line">name: org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory 来源: <span class="literal">null</span></span><br><span class="line">name: bean2 来源: indi.lcp.a39.A39_1</span><br><span class="line">name: servletWebServerFactory 来源: indi.lcp.a39.A39_1</span><br></pre></td></tr></table></figure><p>来源为 null 的 Bean 是由 Spring 提供的“内置” Bean。</p><p>使用 XML 配置文件添加 Bean，并利用 setSources() 方法设置创建 ApplicationContext 的其他源：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SpringApplication</span> <span class="variable">spring</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(A39_1.class);</span><br><span class="line">    spring.setSources(Collections.singleton(<span class="string">&quot;classpath:b01.xml&quot;</span>));</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行 main() 方法，控制台打印的内容多了一条：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name: bean1 来源: <span class="keyword">class</span> <span class="title class_">path</span> resource [b01.xml]</span><br></pre></td></tr></table></figure><p>推断应用类型</p><p>应用类型的推断在构造方法中可以看到：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip-- </span></span><br><span class="line">        <span class="comment">// 推断应用类型</span></span><br><span class="line">    <span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推断逻辑由 WebApplicationType 枚举中的 deduceFromClasspath() 方法完成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> WebApplicationType <span class="title function_">deduceFromClasspath</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ClassUtils.isPresent() 判断类路径下是否存在某个类</span></span><br><span class="line">    <span class="keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="literal">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="literal">null</span>)</span><br><span class="line">        &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="comment">// 响应式 Web 应用</span></span><br><span class="line">        <span class="keyword">return</span> WebApplicationType.REACTIVE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ClassUtils.isPresent(className, <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 非 Web 应用</span></span><br><span class="line">            <span class="keyword">return</span> WebApplicationType.NONE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Web 应用</span></span><br><span class="line">    <span class="keyword">return</span> WebApplicationType.SERVLET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用反射调用 deduceFromClasspath() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">deduceFromClasspath</span> <span class="operator">=</span> WebApplicationType.class.getDeclaredMethod(<span class="string">&quot;deduceFromClasspath&quot;</span>);</span><br><span class="line">    deduceFromClasspath.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;\t应用类型为: &quot;</span> + deduceFromClasspath.invoke(<span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">应用类型为: SERVLET</span><br></pre></td></tr></table></figure><p>添加 ApplicationContext 初始化器</p><p>调用 SpringApplication 对象的 run() 方法时会创建 ApplicationContext，最后调用 ApplicationContext 的 refresh() 方法完成初始化。</p><p>在创建与初始化完成之间的一些拓展功能就由 ApplicationContext 初始化器完成。</p><p>在 SpringApplication 的构造方法中，添加的初始化器信息从配置文件中读取：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="comment">// 从配置文件中读取初始化器</span></span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以调用 SpringApplication 对象的 addInitializers() 方法添加自定义初始化器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    spring.addInitializers(applicationContext -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (applicationContext <span class="keyword">instanceof</span> GenericApplicationContext) &#123;</span><br><span class="line">            <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> (GenericApplicationContext) applicationContext;</span><br><span class="line">            context.registerBean(<span class="string">&quot;bean3&quot;</span>, Bean3.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并初始化 Spring 容器</span></span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> spring.run(args);</span><br><span class="line">    Arrays.stream(context.getBeanDefinitionNames()).forEach(i -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name: &quot;</span> + i +</span><br><span class="line">                           <span class="string">&quot; 来源: &quot;</span> + context.getBeanFactory().getBeanDefinition(i).getResourceDescription());</span><br><span class="line">    &#125;);</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean3</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印的 Bean 又多了一条：</p><p>name: bean3 来源: null</p><p>添加事件监听器</p><p>与添加 ApplicationContext 初始化器一样，在 SpringApplication 的构造方法中，添加的事件监听器信息从配置文件中读取：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="comment">// 从配置文件中读取事件监听器</span></span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以调用 SpringApplication 对象的 addListeners() 方法添加自定义事件监听器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="comment">// 输出所有事件信息</span></span><br><span class="line">    spring.addListeners(event -&gt; System.out.println(<span class="string">&quot;\t事件为: &quot;</span> + event));</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印的事件信息汇总后如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationStartingEvent</span><br><span class="line">        事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent</span><br><span class="line">        事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationContextInitializedEvent</span><br><span class="line">        事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationPreparedEvent</span><br><span class="line">        事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.web.servlet.context.ServletWebServerInitializedEvent</span><br><span class="line">        事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.context.event.ContextRefreshedEvent</span><br><span class="line">        事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationStartedEvent</span><br><span class="line">        事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.availability.AvailabilityChangeEvent</span><br><span class="line">        事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationReadyEvent</span><br><span class="line">        事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.availability.AvailabilityChangeEvent</span><br><span class="line">        事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.availability.AvailabilityChangeEvent</span><br><span class="line">        事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.context.event.ContextClosedEvent</span><br></pre></td></tr></table></figure><p>主类推断</p><p>主类推断在构造方法中可以看到：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="comment">// 主类推断</span></span><br><span class="line">    <span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推断逻辑由 deduceMainApplicationClass() 方法完成，利用反射调用该方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">deduceMainApplicationClass</span> <span class="operator">=</span> SpringApplication.class.getDeclaredMethod(<span class="string">&quot;deduceMainApplicationClass&quot;</span>);</span><br><span class="line">    deduceMainApplicationClass.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;\t主类是: &quot;</span> + deduceMainApplicationClass.invoke(spring));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">主类是: <span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a39.A39_1</span><br></pre></td></tr></table></figure><h2 id="39-2-SpringApplication-run-的分析"><a href="#39-2-SpringApplication-run-的分析" class="headerlink" title="39.2 SpringApplication#run() 的分析"></a>39.2 SpringApplication#run() 的分析</h2><p>第一步：获取 SpringApplicationRunListeners</p><p>在执行 run() 方法时，首先会获取到 SpringApplicationRunListeners，它是事件发布器的组合，能够在 SpringBoot 启动的各个阶段中发布事件。</p><p>SpringApplicationRunListeners 中使用 SpringApplicationRunListener 来描述单个事件发布器，SpringApplicationRunListener 是一个接口，它有且仅有一个实现类 EventPublishingRunListener。</p><p>在 SpringBoot 中，事件发布器都是在配置文件中读取，从 META-INF&#x2F;spring.factories 中读取，该文件中有这样一句：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Run Listeners</span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">org.springframework.boot.context.event.EventPublishingRunListener</span><br></pre></td></tr></table></figure><p>自行实现从 META-INF&#x2F;spring.factories 配置文件中读取事件发布器信息，并发布各种事件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A39_2</span> &#123;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SpringApplication</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>();</span><br><span class="line">        app.addListeners(i -&gt; System.out.println(i.getClass()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取时间发送器实现类名</span></span><br><span class="line">        List&lt;String&gt; names = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">            SpringApplicationRunListener.class,</span><br><span class="line">            A39_2.class.getClassLoader()</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            <span class="comment">// System.out.println(name);</span></span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(name);</span><br><span class="line">            Constructor&lt;?&gt; constructor = clazz.getConstructor(SpringApplication.class, String[].class);</span><br><span class="line">            <span class="type">SpringApplicationRunListener</span> <span class="variable">publisher</span> <span class="operator">=</span> (SpringApplicationRunListener) constructor.newInstance(app, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发布事件</span></span><br><span class="line">            <span class="type">DefaultBootstrapContext</span> <span class="variable">bootstrapContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultBootstrapContext</span>();</span><br><span class="line">            <span class="comment">// spring boot 开始启动</span></span><br><span class="line">            publisher.starting(bootstrapContext);</span><br><span class="line">            <span class="comment">// 环境信息准备完毕</span></span><br><span class="line">            publisher.environmentPrepared(bootstrapContext, <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>());</span><br><span class="line">            <span class="comment">// 创建 spring 容器，调用初始化器之后发布此事件</span></span><br><span class="line">            <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">            publisher.contextPrepared(context);</span><br><span class="line">            <span class="comment">// 所有 bean definition 加载完毕</span></span><br><span class="line">            publisher.contextLoaded(context);</span><br><span class="line">            <span class="comment">// spring 容器初始化完毕（调用 refresh() 方法后）</span></span><br><span class="line">            context.refresh();</span><br><span class="line">            publisher.started(context, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// spring boot 启动完毕</span></span><br><span class="line">            publisher.ready(context, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动过程中出现异常，spring boot 启动出错</span></span><br><span class="line">            publisher.failed(context, <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;出错了&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 SpringBoot 启动过程中，总共发布 7 种事件。</p><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationStartingEvent</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationContextInitializedEvent</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationPreparedEvent</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.context.event.ContextRefreshedEvent</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationStartedEvent</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.availability.AvailabilityChangeEvent</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationReadyEvent</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.availability.AvailabilityChangeEvent</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationFailedEvent</span><br></pre></td></tr></table></figure><p>但打印出的事件种类并不止 7 种，这是因为包含了其他事件发布器发布的事件，EventPublishingRunListener 发布的事件的全限定类名包含 boot.context.event，根据这个条件重新计算，恰好 7 个。</p><p>第八到十一步：完成 Spring 容器的创建</p><p>第八步：创建容器。在构造 SpringApplication 时已经推断出应用的类型，使用应用类型直接创建即可。</p><p>第九步：准备容器。回调在构造 SpringApplication 时添加的初始化器。</p><p>第十步：加载 Bean 定义。从配置类、XML 配置文件读取 BeanDefinition，或者扫描某一包路径下的 BeanDefinition。</p><p>第十一步：调用 ApplicationContext 的 refresh() 方法，完成 Spring 容器的创建。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SpringApplication</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>();</span><br><span class="line">    app.addInitializers(applicationContext -&gt; System.out.println(<span class="string">&quot;执行初始化器增强...&quot;</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 8. 创建容器&quot;</span>);</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> createApplicationContext(WebApplicationType.SERVLET);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 9. 准备容器&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (ApplicationContextInitializer initializer : app.getInitializers()) &#123;</span><br><span class="line">        initializer.initialize(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 10. 加载 Bean 定义&quot;</span>);</span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getDefaultListableBeanFactory();</span><br><span class="line">    <span class="type">AnnotatedBeanDefinitionReader</span> <span class="variable">reader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(beanFactory);</span><br><span class="line">    <span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line">    <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(beanFactory);</span><br><span class="line"></span><br><span class="line">    reader1.register(Config.class);</span><br><span class="line">    reader2.loadBeanDefinitions(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;b03.xml&quot;</span>));</span><br><span class="line">    scanner.scan(<span class="string">&quot;indi.lcp.a39.sub&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 11. refresh 容器&quot;</span>);</span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name: &quot;</span> + name + <span class="string">&quot; 来源: &quot;</span> + beanFactory.getBeanDefinition(name).getResourceDescription());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> GenericApplicationContext <span class="title function_">createApplicationContext</span><span class="params">(WebApplicationType type)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SERVLET:</span><br><span class="line">            context = <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REACTIVE:</span><br><span class="line">            context = <span class="keyword">new</span> <span class="title class_">AnnotationConfigReactiveWebServerApplicationContext</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NONE:</span><br><span class="line">            context = <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及到的配置类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean4</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean5</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean5 <span class="title function_">bean5</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean5</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML 配置文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;bean4&quot;</span> class=<span class="string">&quot;indi.lcp.a39.A39_3.Bean4&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>indi.lcp.a39.sub 包下的 Bean 信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.lcp.a39.sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean7</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出的 Bean 信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name: org.springframework.context.annotation.internalConfigurationAnnotationProcessor 来源: <span class="literal">null</span></span><br><span class="line">name: org.springframework.context.annotation.internalAutowiredAnnotationProcessor 来源: <span class="literal">null</span></span><br><span class="line">name: org.springframework.context.annotation.internalCommonAnnotationProcessor 来源: <span class="literal">null</span></span><br><span class="line">name: org.springframework.context.event.internalEventListenerProcessor 来源: <span class="literal">null</span></span><br><span class="line">name: org.springframework.context.event.internalEventListenerFactory 来源: <span class="literal">null</span></span><br><span class="line">name: a39_3.Config 来源: <span class="literal">null</span></span><br><span class="line">name: bean4 来源: <span class="keyword">class</span> <span class="title class_">path</span> resource [b03.xml]</span><br><span class="line">name: bean7 来源: file [D:\Code\IdeaCode\advanced-spring\boot\target\classes\indi\lcp\a39\sub\Bean7.class]</span><br><span class="line">name: org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory 来源: <span class="literal">null</span></span><br><span class="line">name: bean5 来源: indi.lcp.a39.A39_3$Config</span><br><span class="line">name: servletWebServerFactory 来源: indi.lcp.a39.A39_3$Config</span><br></pre></td></tr></table></figure><p>第二步：封装启动 args</p><p>调用 DefaultApplicationArguments 的构造方法，传入 args 即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. 封装启动 args&quot;</span>);</span><br><span class="line">    <span class="type">DefaultApplicationArguments</span> <span class="variable">arguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第十二步：执行 Runner</p><p>在 SpringBoot 启动成功后，可以执行一些 Runner，进行一些预处理或测试。Runner 有两种，分别是 CommandLineRunner 和 ApplicationRunner：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们都是函数式接口，内部的抽象方法长得也很像，只不过：</p><p>CommandLineRunner 直接接收启动参数；</p><p>ApplicationRunner 则是接收封装后的 ApplicationArguments，即 第二步 封装的对象。</p><p>在配置类中添加这两种类型的 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CommandLineRunner <span class="title function_">commandLineRunner</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> args -&gt; System.out.println(<span class="string">&quot;commandLineRunner()...&quot;</span> + Arrays.toString(args));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ApplicationRunner <span class="title function_">applicationRunner</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">        <span class="comment">// 获取原始参数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;applicationRunner()...&quot;</span> </span><br><span class="line">                           + Arrays.toString(args.getSourceArgs()));</span><br><span class="line">        <span class="comment">// 获取选项名称，参数中带有 `--` 的参数</span></span><br><span class="line">        System.out.println(args.getOptionNames());</span><br><span class="line">        <span class="comment">// 获取选项值</span></span><br><span class="line">        System.out.println(args.getOptionValues(<span class="string">&quot;server.port&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取非选项参数</span></span><br><span class="line">        System.out.println(args.getNonOptionArgs());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 Runner：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. 封装启动 args&quot;</span>);</span><br><span class="line">    <span class="type">DefaultApplicationArguments</span> <span class="variable">arguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 12. 执行 runner&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (CommandLineRunner runner : context.getBeansOfType(CommandLineRunner.class).values()) &#123;</span><br><span class="line">        runner.run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ApplicationRunner runner : context.getBeansOfType(ApplicationRunner.class).values()) &#123;</span><br><span class="line">        runner.run(arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法时，需要添加程序参数 –server.port&#x3D;8080 debug：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MmI4Yjg1YmYyNGVmNTdjNDM0OTM3YThhYjExZjcxNjRfR3dSNTdHemJEOERjOVQ3UzFJUUREV0c5NlFoMkJWU21fVG9rZW46SDA4cmJLUHFXb3cyMUF4OWhFUWNZdlVYbjJkXzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <span class="number">12.</span> 执行 runner</span><br><span class="line"><span class="title function_">commandLineRunner</span><span class="params">()</span>...[--server.port=<span class="number">8080</span>, debug]</span><br><span class="line">applicationRunner()...[--server.port=<span class="number">8080</span>, debug]</span><br><span class="line">[server.port]</span><br><span class="line">[<span class="number">8080</span>]</span><br><span class="line">[debug]</span><br></pre></td></tr></table></figure><p>第三步：准备 Environment 添加命令行参数</p><p>Environment 即环境对象，是对配置信息的抽象，配置信息的来源有多种，比如：系统环境变量、properties 配置文件、YAML 配置文件等等。</p><p>SpringBoot 提供了名为 ApplicationEnvironment 的类表示环境对象，它是 Spring 中 StandardEnvironment 环境对象的子类。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MGFlYjc2Mzc5MjI4NGY1OTFiNzUxNTBjMzI5ODBkNTBfdlZ4WHd3RVJ3STJyQVU1dEpMVE5qVFl3cmxBRGNqNkRfVG9rZW46UndLVWJLNzhnb2dWTzN4OGY1bGNPYlZSbmtlXzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><p>默认情况下，创建的 ApplicationEnvironment 对象中配置信息的来源只有两个：</p><ul><li>系统属性</li><li>系统变量</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lcp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/1/28 12:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Step3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationEnvironment</span>();</span><br><span class="line">        env.getPropertySources().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">PropertiesPropertySource &#123;name=<span class="string">&#x27;systemProperties&#x27;</span>&#125;</span><br><span class="line">SystemEnvironmentPropertySource &#123;name=<span class="string">&#x27;systemEnvironment&#x27;</span>&#125;    </span><br></pre></td></tr></table></figure><p>针对相同名称的配置信息，按照来源的先后顺序获取。</p><p>获取 JAVA_HOME 的配置信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationEnvironment</span>();</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;JAVA_HOME&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">D:\environment\JDK1<span class="number">.8</span></span><br></pre></td></tr></table></figure><p>由于 PropertiesPropertySource 中并不存在名为 JAVA_HOME 的配置信息，因此从系统环境变量 SystemEnvironmentPropertySource 中获取 JAVA_HOME 的配置信息。</p><p>在 IDEA 的 Run&#x2F;Debug Configurations 中的 VM options 添加 -DJAVA_HOME&#x3D;abc，使得 PropertiesPropertySource 中存在名为 JAVA_HOME 的配置信息：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=N2FjM2ZhMjFjMjM5ZWI4N2U3N2EwYmMwYzRhNWJlZTJfeVNqelljY3ZFYVVnTGZQSVVRZHVPQ3RNam1POUU3ck9fVG9rZW46UDZmR2J5UEFDb3VyYWh4cmpaRGNGVkkybmhmXzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><p>之后再运行 main() 方法，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">abc</span><br></pre></td></tr></table></figure><p>如果想从配置文件 application.properties 中读取配置信息，可以添加配置信息的来源。配置文件的优先级最低，添加来源时调用 addLast() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationEnvironment</span>();</span><br><span class="line">    env.getPropertySources().addLast(<span class="keyword">new</span> <span class="title class_">ResourcePropertySource</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;application.properties&quot;</span>)));</span><br><span class="line">    env.getPropertySources().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;author.name&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">author.name=<span class="string">&quot;lcp&quot;</span></span><br><span class="line">PropertiesPropertySource &#123;name=<span class="string">&#x27;systemProperties&#x27;</span>&#125;</span><br><span class="line">SystemEnvironmentPropertySource &#123;name=<span class="string">&#x27;systemEnvironment&#x27;</span>&#125;</span><br><span class="line">ResourcePropertySource &#123;name=<span class="string">&#x27;class path resource [application.properties]&#x27;</span>&#125;</span><br><span class="line"><span class="string">&quot;lcp&quot;</span></span><br></pre></td></tr></table></figure><p>而在 SpringBoot 中，这里 只 添加 SimpleCommandLinePropertySource，并且它的优先级最高，使用 addFirst() 方法添加：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationEnvironment</span>();</span><br><span class="line">    env.getPropertySources().addLast(<span class="keyword">new</span> <span class="title class_">ResourcePropertySource</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;application.properties&quot;</span>)));</span><br><span class="line">    env.getPropertySources().addFirst(<span class="keyword">new</span> <span class="title class_">SimpleCommandLinePropertySource</span>(args));</span><br><span class="line">    env.getPropertySources().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;author.name&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法前，需要添加程序参数 –author.name&#x3D;默烦：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NzBiMTc3MTA0ZWMzMmM0NDAwOTk3ZWMzNzIzYWJmYTNfdXh3QXcwM0cxWk9yVU1qQm11NVdMY0ZBNkgzTWc1RGtfVG9rZW46SkVMaWJOSkhQb0pMT1B4SDJxRGM4OHZabmdoXzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleCommandLinePropertySource &#123;name=<span class="string">&#x27;commandLineArgs&#x27;</span>&#125;</span><br><span class="line">PropertiesPropertySource &#123;name=<span class="string">&#x27;systemProperties&#x27;</span>&#125;</span><br><span class="line">SystemEnvironmentPropertySource &#123;name=<span class="string">&#x27;systemEnvironment&#x27;</span>&#125;</span><br><span class="line">ResourcePropertySource &#123;name=<span class="string">&#x27;class path resource [application.properties]&#x27;</span>&#125;</span><br><span class="line">默烦</span><br></pre></td></tr></table></figure><p>第四步：添加 ConfigurationPropertySources</p><p>有一 step4.properties 文件，其内容如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">user.first-name=George</span><br><span class="line">user.middle_name=Walker</span><br><span class="line">user.lastName=Bush</span><br></pre></td></tr></table></figure><p>尝试读取文件中的内容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationEnvironment</span>();</span><br><span class="line">    env.getPropertySources().addLast(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ResourcePropertySource</span>(<span class="string">&quot;step4&quot;</span>, <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;step4.properties&quot;</span>))</span><br><span class="line">    );</span><br><span class="line">    env.getPropertySources().forEach(System.out::println);</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;user.first-name&quot;</span>));</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;user.middle-name&quot;</span>));</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;user.last-name&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>step4.properties 文件中配置信息的 key 是 user.middle_name，但在读取时，使用的是 user.middle-name；还有 user.lastName 的 key，但读取时使用 user.last-name。能读取成功吗？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PropertiesPropertySource &#123;name=<span class="string">&#x27;systemProperties&#x27;</span>&#125;</span><br><span class="line">SystemEnvironmentPropertySource &#123;name=<span class="string">&#x27;systemEnvironment&#x27;</span>&#125;</span><br><span class="line">ResourcePropertySource &#123;name=<span class="string">&#x27;step4&#x27;</span>&#125;</span><br><span class="line">George</span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure><p>显然是不行的，为了能读取成功，需要实现 松散绑定，添加 ConfigurationPropertySources：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    ConfigurationPropertySources.attach(env);</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">ConfigurationPropertySourcesPropertySource &#123;name=<span class="string">&#x27;configurationProperties&#x27;</span>&#125;</span><br><span class="line">PropertiesPropertySource &#123;name=<span class="string">&#x27;systemProperties&#x27;</span>&#125;</span><br><span class="line">SystemEnvironmentPropertySource &#123;name=<span class="string">&#x27;systemEnvironment&#x27;</span>&#125;</span><br><span class="line">ResourcePropertySource &#123;name=<span class="string">&#x27;step4&#x27;</span>&#125;</span><br><span class="line">George</span><br><span class="line">Walker</span><br><span class="line">Bush</span><br></pre></td></tr></table></figure><p>第五步：使用 EnvironmentPostProcessorApplicationListener 进行环境对象后置处理</p><p>在第三步中 只 添加 SimpleCommandLinePropertySource，读取 properties、YAML 配置文件的源就是在第五步中添加的。</p><p>完成这样功能需要使用到 EnvironmentPostProcessor，其具体实现是 ConfigDataEnvironmentPostProcessor。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SpringApplication</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>();</span><br><span class="line">    <span class="type">ApplicationEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationEnvironment</span>();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 增强前&quot;</span>);</span><br><span class="line">    env.getPropertySources().forEach(System.out::println);</span><br><span class="line">    <span class="type">ConfigDataEnvironmentPostProcessor</span> <span class="variable">processor1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigDataEnvironmentPostProcessor</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DeferredLogs</span>(), <span class="keyword">new</span> <span class="title class_">DefaultBootstrapContext</span>()</span><br><span class="line">    );</span><br><span class="line">    processor1.postProcessEnvironment(env, app);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 增强后&quot;</span>);</span><br><span class="line">    env.getPropertySources().forEach(System.out::println);</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;author.name&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomValuePropertySourceEnvironmentPostProcessor</span> <span class="variable">processor2</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RandomValuePropertySourceEnvironmentPostProcessor</span>(<span class="keyword">new</span> <span class="title class_">DeferredLog</span>());</span><br><span class="line">    processor2.postProcessEnvironment(env, app);</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 增强前</span><br><span class="line">PropertiesPropertySource &#123;name=<span class="string">&#x27;systemProperties&#x27;</span>&#125;</span><br><span class="line">SystemEnvironmentPropertySource &#123;name=<span class="string">&#x27;systemEnvironment&#x27;</span>&#125;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 增强后</span><br><span class="line">PropertiesPropertySource &#123;name=<span class="string">&#x27;systemProperties&#x27;</span>&#125;</span><br><span class="line">SystemEnvironmentPropertySource &#123;name=<span class="string">&#x27;systemEnvironment&#x27;</span>&#125;</span><br><span class="line">OriginTrackedMapPropertySource &#123;name=<span class="string">&#x27;Config resource &#x27;</span><span class="keyword">class</span> <span class="title class_">path</span> resource [application.properties]<span class="string">&#x27; via location &#x27;</span>optional:classpath:/<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line"><span class="string">&quot;lcp&quot;</span></span><br></pre></td></tr></table></figure><p>EnvironmentPostProcessor 还有一个有趣的实现：RandomValuePropertySourceEnvironmentPostProcessor，该实现提供了随机值的生成。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 再次增强后&quot;</span>);</span><br><span class="line">    env.getPropertySources().forEach(System.out::println);</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;random.string&quot;</span>));</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;random.int&quot;</span>));</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;random.uuid&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 再次增强后</span><br><span class="line">PropertiesPropertySource &#123;name=<span class="string">&#x27;systemProperties&#x27;</span>&#125;</span><br><span class="line">SystemEnvironmentPropertySource &#123;name=<span class="string">&#x27;systemEnvironment&#x27;</span>&#125;</span><br><span class="line">RandomValuePropertySource &#123;name=<span class="string">&#x27;random&#x27;</span>&#125;</span><br><span class="line">OriginTrackedMapPropertySource &#123;name=<span class="string">&#x27;Config resource &#x27;</span><span class="keyword">class</span> <span class="title class_">path</span> resource [application.properties]<span class="string">&#x27; via location &#x27;</span>optional:classpath:/<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">5ef4038a709215938cbd3e1c031f66dd</span><br><span class="line"><span class="number">1481116109</span></span><br><span class="line">18548e0b-8bad-458b-b38e-bf793aa24ced</span><br></pre></td></tr></table></figure><p>在 SpringBoot 中的实现是不会采取上述示例代码的方式来添加后置处理器，同样会从 META-INF&#x2F;spring.factories 配置文件中读取并初始化后置处理器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Environment Post Processors</span><br><span class="line">org.springframework.boot.env.EnvironmentPostProcessor=\</span><br><span class="line">org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\</span><br><span class="line">org.springframework.boot.context.config.ConfigDataEnvironmentPostProcessor,\</span><br><span class="line">org.springframework.boot.env.RandomValuePropertySourceEnvironmentPostProcessor,\</span><br><span class="line">org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor,\</span><br><span class="line">org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor,\</span><br><span class="line">org.springframework.boot.reactor.DebugAgentEnvironmentPostProcessor</span><br></pre></td></tr></table></figure><p>SpringBoot 中读取 META-INF&#x2F;spring.factories 配置文件初始化环境后置处理器，再执行处理逻辑的功能由 EnvironmentPostProcessorApplicationListener 完成。它是一个事件监听器，同样是在 META-INF&#x2F;spring.factories 配置文件中读取并初始化的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.ClearCachesApplicationListener,\</span><br><span class="line">org.springframework.boot.builder.ParentContextCloserApplicationListener,\</span><br><span class="line">org.springframework.boot.context.FileEncodingApplicationListener,\</span><br><span class="line">org.springframework.boot.context.config.AnsiOutputApplicationListener,\</span><br><span class="line">org.springframework.boot.context.config.DelegatingApplicationListener,\</span><br><span class="line">org.springframework.boot.context.logging.LoggingApplicationListener,\</span><br><span class="line">org.springframework.boot.env.EnvironmentPostProcessorApplicationListener</span><br></pre></td></tr></table></figure><p>要想该监听器成功监听到事件，需要在第五步中发布一个事件，而事件的发布由第一步获取的事件发布器完成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SpringApplication</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>();</span><br><span class="line">    app.addListeners(<span class="keyword">new</span> <span class="title class_">EnvironmentPostProcessorApplicationListener</span>());</span><br><span class="line">    <span class="type">ApplicationEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationEnvironment</span>();</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; names = SpringFactoriesLoader.loadFactoryNames(EnvironmentPostProcessor.class, Step5.class.getClassLoader());</span><br><span class="line">    names.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="type">EventPublishingRunListener</span> <span class="variable">publisher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventPublishingRunListener</span>(app, args);</span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 增强前&quot;</span>);</span><br><span class="line">    env.getPropertySources().forEach(System.out::println);</span><br><span class="line">    publisher.environmentPrepared(<span class="keyword">new</span> <span class="title class_">DefaultBootstrapContext</span>(), env);</span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 增强后&quot;</span>);</span><br><span class="line">    env.getPropertySources().forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor</span><br><span class="line">org.springframework.boot.context.config.ConfigDataEnvironmentPostProcessor</span><br><span class="line">org.springframework.boot.env.RandomValuePropertySourceEnvironmentPostProcessor</span><br><span class="line">org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor</span><br><span class="line">org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor</span><br><span class="line">org.springframework.boot.reactor.DebugAgentEnvironmentPostProcessor</span><br><span class="line">org.springframework.boot.autoconfigure.integration.IntegrationPropertiesEnvironmentPostProcessor</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 增强前</span><br><span class="line">PropertiesPropertySource &#123;name=<span class="string">&#x27;systemProperties&#x27;</span>&#125;</span><br><span class="line">SystemEnvironmentPropertySource &#123;name=<span class="string">&#x27;systemEnvironment&#x27;</span>&#125;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 增强后</span><br><span class="line">PropertiesPropertySource &#123;name=<span class="string">&#x27;systemProperties&#x27;</span>&#125;</span><br><span class="line">OriginAwareSystemEnvironmentPropertySource &#123;name=<span class="string">&#x27;systemEnvironment&#x27;</span>&#125;</span><br><span class="line">RandomValuePropertySource &#123;name=<span class="string">&#x27;random&#x27;</span>&#125;</span><br><span class="line">OriginTrackedMapPropertySource &#123;name=<span class="string">&#x27;Config resource &#x27;</span><span class="keyword">class</span> <span class="title class_">path</span> resource [application.properties]<span class="string">&#x27; via location &#x27;</span>optional:classpath:/<span class="string">&#x27;&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>配置文件中 EnvironmentPostProcessor 的实现有很多，但根据上述打印出的信息，生效的并不多，是否生效与项目的依赖配置有关。</p><p>第六步：绑定 spring.main 前缀的配置信息到 SpringApplication 对象</p><p>使用 @ConfigurationProperties 注解可以指定一个前缀，SpringBoot 将根据指定的前缀和属性名称在配置文件中寻找对应的信息并完成注入，其底层是利用 Binder 实现的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SpringApplication</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>();</span><br><span class="line">    <span class="type">ApplicationEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationEnvironment</span>();</span><br><span class="line">    env.getPropertySources().addLast(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ResourcePropertySource</span>(<span class="string">&quot;step4&quot;</span>, <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;step4.properties&quot;</span>))</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> Binder.get(env).bind(<span class="string">&quot;user&quot;</span>, User.class).get();</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">existUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    Binder.get(env).bind(<span class="string">&quot;user&quot;</span>, Bindable.ofInstance(existUser));</span><br><span class="line">    System.out.println(existUser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String middleName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">&#125;</span><br><span class="line">Step6.User(firstName=George, middleName=Walker, lastName=Bush)</span><br><span class="line">Step6.User(firstName=George, middleName=Walker, lastName=Bush)</span><br></pre></td></tr></table></figure><p>在第六步中，绑定 spring.main 前缀的配置信息到 SpringApplication 对象也是利用了 Binder。</p><p>假设 step6.properties 配置文件的信息如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.main.banner-mode=off</span><br><span class="line">spring.main.lazy-initialization=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>绑定 spring.main 开头的配置信息到 SpringApplication 对象中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SpringApplication</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>();</span><br><span class="line">    <span class="type">ApplicationEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationEnvironment</span>();</span><br><span class="line">    env.getPropertySources().addLast(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ResourcePropertySource</span>(<span class="string">&quot;step6&quot;</span>, <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;step6.properties&quot;</span>))</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">SpringApplication</span>&gt; clazz = app.getClass();</span><br><span class="line">    <span class="type">Field</span> <span class="variable">bannerMode</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;bannerMode&quot;</span>);</span><br><span class="line">    bannerMode.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">lazyInitialization</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;lazyInitialization&quot;</span>);</span><br><span class="line">    lazyInitialization.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    System.out.println(bannerMode.get(app));</span><br><span class="line">    System.out.println(lazyInitialization.get(app));</span><br><span class="line">    Binder.get(env).bind(<span class="string">&quot;spring.main&quot;</span>, Bindable.ofInstance(app));</span><br><span class="line">    System.out.println(bannerMode.get(app));</span><br><span class="line">    System.out.println(lazyInitialization.get(app));</span><br><span class="line">&#125;</span><br><span class="line">CONSOLE</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">OFF</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>第七步：打印 Banner</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationEnvironment</span>();</span><br><span class="line">    <span class="type">SpringApplicationBannerPrinter</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplicationBannerPrinter</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DefaultResourceLoader</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SpringBootBanner</span>()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    printer.print(env, Step7.class, System.out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外还可以自定义文字和图片 Banner，文字 Banner 的文件类型需要是 txt，图片 Banner 的文件类型需要是 gif。</p><p>文字 Banner：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试文字 banner</span></span><br><span class="line">    env.getPropertySources().addLast(<span class="keyword">new</span> <span class="title class_">MapPropertySource</span>(</span><br><span class="line">        <span class="string">&quot;custom&quot;</span>,</span><br><span class="line">        Collections.singletonMap(<span class="string">&quot;spring.banner.location&quot;</span>, <span class="string">&quot;banner1.txt&quot;</span>)</span><br><span class="line">    ));</span><br><span class="line">    printer.print(env, Step7.class, System.out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文字 Banner 可以从 网站 上自定义。</p><p>图片 Banner：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试图片 banner</span></span><br><span class="line">    env.getPropertySources().addLast(<span class="keyword">new</span> <span class="title class_">MapPropertySource</span>(</span><br><span class="line">        <span class="string">&quot;custom&quot;</span>,</span><br><span class="line">        Collections.singletonMap(<span class="string">&quot;spring.banner.image.location&quot;</span>, <span class="string">&quot;banner2.gif&quot;</span>)</span><br><span class="line">    ));</span><br><span class="line">    printer.print(env, Step7.class, System.out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 Spring 或 SpringBoot 的版本号可以使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;SpringBoot: &quot;</span> + SpringBootVersion.getVersion());</span><br><span class="line">System.out.println(<span class="string">&quot;Spring: &quot;</span> + SpringVersion.getVersion());</span><br></pre></td></tr></table></figure><p>步骤总结</p><ol><li>得到 SpringApplicationRunListeners 事件发布器</li></ol><ul><li>发布 Application Starting 事件</li></ul><ol><li>封装启动 args</li><li>准备 Environment 添加命令行参数</li><li>ConfigurationPropertySources 处理</li></ol><ul><li>发布 Application Environment 已准备事件</li></ul><ol><li>通过 EnvironmentPostProcessorApplicationListener 进行 env 后处理</li></ol><ul><li>application.properties 由 StandardConfigDataLocationResolver 解析</li><li>spring.application.json</li></ul><ol><li>绑定 spring.main 到 SpringApplication 对象</li><li>打印 Banner</li><li>创建容器</li><li>准备容器</li></ol><ul><li>发布 Application Context 已初始化事件</li></ul><ol><li>加载 Bean 定义</li></ol><ul><li>发布 Application Prepared 事件</li></ul><ol><li>refresh 容器</li></ol><ul><li>发布 Application Started 事件</li></ul><ol><li>执行 Runner</li></ol><ul><li>发布 Application Ready 事件 </li><li>这其中有异常，发布 Application Failed 事件</li></ul><h1 id="Tomcat-内嵌容器"><a href="#Tomcat-内嵌容器" class="headerlink" title="Tomcat 内嵌容器"></a>Tomcat 内嵌容器</h1><p>Tomcat 基本结构：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Server</span><br><span class="line">└───Service</span><br><span class="line">    ├───Connector (协议, 端口)</span><br><span class="line">    └───Engine</span><br><span class="line">        └───Host(虚拟主机 localhost)</span><br><span class="line">            ├───Context1 (应用 <span class="number">1</span>, 可以设置虚拟路径, / 即 url 起始路径; 项目磁盘路径, 即 docBase)</span><br><span class="line">            │   │   index.html</span><br><span class="line">            │   └───WEB-INF</span><br><span class="line">            │       │   web.xml (servlet, filter, listener) <span class="number">3.0</span></span><br><span class="line">            │       ├───classes (servlet, controller, service ...)</span><br><span class="line">            │       ├───jsp</span><br><span class="line">            │       └───lib (第三方 jar 包)</span><br><span class="line">            └───Context2 (应用 <span class="number">2</span>)</span><br><span class="line">                │   index.html</span><br><span class="line">                └───WEB-INF</span><br><span class="line">                        web.xml</span><br></pre></td></tr></table></figure><h2 id="40-1-内嵌-Tomcat-的使用"><a href="#40-1-内嵌-Tomcat-的使用" class="headerlink" title="40.1 内嵌 Tomcat 的使用"></a>40.1 内嵌 Tomcat 的使用</h2><p>内嵌 Tomcat 的使用分为 6 步：</p><ol><li>创建 Tomcat</li><li>创建项目文件夹，即 docBase 文件夹</li><li>创建 Tomcat 项目，在 Tomcat 中称为 Context</li><li>编程添加 Servlet</li><li>启动 Tomcat</li><li>创建连接器，设置监听端口</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 Tomcat</span></span><br><span class="line">    <span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line">    tomcat.setBaseDir(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 创建项目文件夹，即 docBase 文件夹</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">docBase</span> <span class="operator">=</span> Files.createTempDirectory(<span class="string">&quot;boot.&quot;</span>).toFile();</span><br><span class="line">    docBase.deleteOnExit();</span><br><span class="line">    <span class="comment">// 3. 创建 tomcat 项目，在 tomcat 中称为 Context</span></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> tomcat.addContext(<span class="string">&quot;&quot;</span>, docBase.getAbsolutePath());</span><br><span class="line">    <span class="comment">// 4. 编程添加 Servlet</span></span><br><span class="line">    context.addServletContainerInitializer((set, servletContext) -&gt; &#123;</span><br><span class="line">        <span class="type">HelloServlet</span> <span class="variable">servlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloServlet</span>();</span><br><span class="line">        <span class="comment">// 还要设置访问 Servlet 的路径</span></span><br><span class="line">        servletContext.addServlet(<span class="string">&quot;hello&quot;</span>, servlet).addMapping(<span class="string">&quot;/hello&quot;</span>);</span><br><span class="line">    &#125;, Collections.emptySet());</span><br><span class="line">    <span class="comment">// 5. 启动 tomcat</span></span><br><span class="line">    tomcat.start();</span><br><span class="line">    <span class="comment">// 6. 创建连接器，设置监听端口</span></span><br><span class="line">    <span class="type">Connector</span> <span class="variable">connector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Connector</span>(<span class="keyword">new</span> <span class="title class_">Http11Nio2Protocol</span>());</span><br><span class="line">    connector.setPort(<span class="number">8080</span>);</span><br><span class="line">    tomcat.setConnector(connector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自行实现的 Servlet 需要继承 HttpServlet，并重写 doGet() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8117441197359625079L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req,</span></span><br><span class="line"><span class="params">                         HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        resp.getWriter().print(<span class="string">&quot;&lt;h3&gt;hello&lt;/h3&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，在浏览器访问 localhost:8080&#x2F;hello，页面显示 hello。</p><h2 id="40-2-与-Spring-整合"><a href="#40-2-与-Spring-整合" class="headerlink" title="40.2 与 Spring 整合"></a>40.2 与 Spring 整合</h2><p>首先肯定需要一个 Spring 容器，选择不支持内嵌 Tomcat 的 Spring 容器，使其使用前文中的 Tomcat：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> WebApplicationContext <span class="title function_">getApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 使用不支持内嵌 Tomcat 的 Spring 容器</span></span><br><span class="line">    <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">    context.register(Config.class);</span><br><span class="line">    context.refresh();</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器中注册了 Config Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">registrationBean</span><span class="params">(DispatcherServlet dispatcherServlet)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">(WebApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 必须为 DispatcherServlet 提供 AnnotationConfigWebApplicationContext，</span></span><br><span class="line"><span class="comment">         * 否则会选择 XmlWebApplicationContext 实现</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>(applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RequestMappingHandlerAdapter <span class="title function_">requestMappingHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RequestMappingHandlerAdapter</span> <span class="variable">handlerAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerAdapter</span>();</span><br><span class="line">        handlerAdapter.setMessageConverters(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>()));</span><br><span class="line">        <span class="keyword">return</span> handlerAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RestController</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">        <span class="meta">@GetMapping(&quot;hello2&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.singletonMap(<span class="string">&quot;hello2&quot;</span>, <span class="string">&quot;hello2, spring!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tomcat 在添加 Servlet 时，添加 DispatcherServlet：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">springContext</span> <span class="operator">=</span> getApplicationContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 编程添加 Servlet</span></span><br><span class="line">    context.addServletContainerInitializer((set, servletContext) -&gt; &#123;</span><br><span class="line">        <span class="type">HelloServlet</span> <span class="variable">servlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloServlet</span>();</span><br><span class="line">        <span class="comment">// 还要设置访问 Servlet 的路径</span></span><br><span class="line">        servletContext.addServlet(<span class="string">&quot;hello&quot;</span>, servlet).addMapping(<span class="string">&quot;/hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DispatcherServlet</span> <span class="variable">dispatcherServlet</span> <span class="operator">=</span> springContext.getBean(DispatcherServlet.class);</span><br><span class="line">        servletContext.addServlet(<span class="string">&quot;dispatcherServlet&quot;</span>, dispatcherServlet).addMapping(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;, Collections.emptySet());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法，在浏览器中访问 localhost:8080&#x2F;hello2，页面上显示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;hello2&quot;</span>:<span class="string">&quot;hello2, spring!&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>添加 Servlet 时只添加了一个 DispatcherServlet，但 Spring 容器中可能存在多个 Servlet，这些 Servlet 也应该被添加，因此可以获取 ServletRegistrationBean 类型的 Bean 并执行 &#96;&#96; 方法，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">springContext</span> <span class="operator">=</span> getApplicationContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 编程添加 Servlet</span></span><br><span class="line">    context.addServletContainerInitializer((set, servletContext) -&gt; &#123;</span><br><span class="line">        <span class="type">HelloServlet</span> <span class="variable">servlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloServlet</span>();</span><br><span class="line">        <span class="comment">// 还要设置访问 Servlet 的路径</span></span><br><span class="line">        servletContext.addServlet(<span class="string">&quot;hello&quot;</span>, servlet).addMapping(<span class="string">&quot;/hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring 容器中可能存在多个 Servlet</span></span><br><span class="line">        <span class="keyword">for</span> (ServletRegistrationBean registrationBean : springContext.getBeansOfType(ServletRegistrationBean.class).values()) &#123;</span><br><span class="line">            registrationBean.onStartup(servletContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, Collections.emptySet());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法，在浏览器中访问 localhost:8080&#x2F;hello2，页面显示同样的内容。</p><h1 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h1><h2 id="41-1-自动配置类原理"><a href="#41-1-自动配置类原理" class="headerlink" title="41.1 自动配置类原理"></a>41.1 自动配置类原理</h2><p>有以下四个类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 模拟第三方配置类</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration1</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟第三方配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration2</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>其中 AutoConfiguration1 和 AutoConfiguration2 用来模拟第三方配置类，注意它们并没有被 @Configuration 注解标记，因此在未进行其他操作时，不会被添加到 Spring 容器中。</p><p>然后编写自己的配置类，使用 @Import 注解将第三方配置类添加到 Spring 容器中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfiguration1.class, AutoConfiguration2.class&#125;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">config</span><br><span class="line">org.springframework.context.annotation.ConfigurationClassPostProcessor</span><br><span class="line">indi.lcp.a41.A41$AutoConfiguration1</span><br><span class="line">bean1</span><br><span class="line">indi.lcp.a41.A41$AutoConfiguration2</span><br><span class="line">bean2</span><br></pre></td></tr></table></figure><p>如果有多个第三方配置类，难不成到一个个地导入？</p><p>可以使用导入选择器 ImportSelector，重写 selectImports() 方法，返回需要自动装配的 Bean 的全限定类名数组：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;AutoConfiguration1.class.getName(), AutoConfiguration2.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样的方式相比最初的方式并没有本质区别，甚至更麻烦，还多了一个类。如果 selectImports() 方法返回的全限定类名可以从文件中读取，就更方便了。</p><p>在当前项目的类路径下创建 META-INF&#x2F;spring.factories 文件，约定一个 key，对应的 value 即为需要指定装配的 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 内部类作为 key 时，最后以 $ 符号分割</span><br><span class="line">indi.lcp.a41.A41$MyImportSelector=\</span><br><span class="line">  indi.lcp.a41.A41.AutoConfiguration1, \</span><br><span class="line">  indi.lcp.a41.A41.AutoConfiguration2</span><br></pre></td></tr></table></figure><p>修改 selectImports() 方法实现逻辑：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        List&lt;String&gt; names = SpringFactoriesLoader.loadFactoryNames(MyImportSelector.class, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> names.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出同样的结果。</p><p>SpringFactoriesLoader.loadFactoryNames() 不仅只扫描当前项目类型路径下的 META-INF&#x2F;spring.factories 文件，而是会扫描包括 Jar 包里类路径下的 META-INF&#x2F;spring.factories 文件。</p><p>针对 SpringBoot 来说，自动装配的 Bean 使用如下语句加载：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>SpringBoot 2.7.0 及其以后版本的自动装配</p><p>在 SpringBoot 2.7.0 及其以后的版本中，SpringBoot 不再通过读取 META-INF&#x2F;spring.factories 文件中 key 为 org.springframework.boot.autoconfigure.EnableAutoConfiguration 的 values 来实现自动装配。</p><p>为了更贴合 SPI 机制，SpringBoot 将读取 META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件中的内容，该文件中每一行都表示需要自动装配的 Bean 的全限定类名，可以使用 # 作为注释。其加载方式使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader());</span><br></pre></td></tr></table></figure><p>其中 AutoConfiguration 是一个注解，它的全限定类名为 org.springframework.boot.autoconfigure.AutoConfiguration。</p><p>也就是说可以自定义一个注解，创建 META-INF&#x2F;spring&#x2F;full-qualified-annotation-name.imports 文件，在文件里声明需要自动装配的类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.lcp.a41;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAutoConfiguration &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> indi.lcp.a41;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A41</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean3</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 META-INF&#x2F;spring&#x2F;indi.lcp.a41.MyAutoConfiguration.imports 文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.a41.A41$Bean3</span><br></pre></td></tr></table></figure><p>修改 selectImports() 方法实现逻辑：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(MyImportSelector.class, <span class="literal">null</span>));</span><br><span class="line">        <span class="comment">// 读取新版自动装配文件</span></span><br><span class="line">        ImportCandidates.load(MyAutoConfiguration.class, <span class="literal">null</span>).forEach(names::add);</span><br><span class="line">        <span class="keyword">return</span> names.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，Spring 容器中的 Bean 多了 一个：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.a41.A41$Bean3</span><br></pre></td></tr></table></figure><p>定义了冲突的 Bean</p><p>第三方装配了 Bean1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration1</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>(<span class="string">&quot;第三方&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户又自行定义了 Bean1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>(<span class="string">&quot;本项目&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改测试的 main() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    System.out.println(context.getBean(Bean1.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终谁会生效呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">A41.Bean1(name=本项目)</span><br></pre></td></tr></table></figure><p>用户自行定义的 Bean 生效了，这是因为：@Import 导入的 Bean 先于配置类中 @Bean 定义的 Bean 执行，后者覆盖前者，使得用户自定义的 Bean 生效。</p><p>但在 SpringBoot 中不是这样的，当后续添加的 Bean 想覆盖先前添加的 Bean，会出现错误。模拟 SpringBoot 的设置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    <span class="comment">// 默认是 true，SpringBoot 修改为 false，使得无法进行覆盖</span></span><br><span class="line">    context.getDefaultListableBeanFactory().setAllowBeanDefinitionOverriding(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> org.springframework.beans.factory.support.BeanDefinitionOverrideException: Invalid bean definition with name <span class="string">&#x27;bean1&#x27;</span> defined in indi.lcp.a41.A41$Config: Cannot register bean definition [Root bean: class [<span class="literal">null</span>]; scope=; <span class="keyword">abstract</span>=<span class="literal">false</span>; lazyInit=<span class="literal">null</span>; autowireMode=<span class="number">3</span>; dependencyCheck=<span class="number">0</span>; autowireCandidate=<span class="literal">true</span>; primary=<span class="literal">false</span>; factoryBeanName=config; factoryMethodName=bean1; initMethodName=<span class="literal">null</span>; destroyMethodName=(inferred); defined in indi.lcp.a41.A41$Config] <span class="keyword">for</span> bean <span class="string">&#x27;bean1&#x27;</span>: There is already [Root bean: class [<span class="literal">null</span>]; scope=; <span class="keyword">abstract</span>=<span class="literal">false</span>; lazyInit=<span class="literal">null</span>; autowireMode=<span class="number">3</span>; dependencyCheck=<span class="number">0</span>; autowireCandidate=<span class="literal">true</span>; primary=<span class="literal">false</span>; factoryBeanName=indi.lcp.a41.A41$AutoConfiguration1; factoryMethodName=bean1; initMethodName=<span class="literal">null</span>; destroyMethodName=(inferred); defined in <span class="keyword">class</span> <span class="title class_">path</span> resource [indi/lcp/a41/A41$AutoConfiguration1.class]] bound.</span><br></pre></td></tr></table></figure><p>那这样是合理的吗？</p><p>显然不是。比如 SpringBoot 默认的数据连接池是 Hikari，如果用户想换成 Druid，岂不是做不到？</p><p>实际情况下是能做到的，这又是怎么做到的呢？</p><p>首先需要使用户的配置类中定义的 Bean 先于 @Import 导入的 Bean 添加到 Spring 容器中，只需将选择器 MyImportSelector 实现的 ImportSelector 接口更换成其子接口 DeferredImportSelector 即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行 main() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> org.springframework.beans.factory.support.BeanDefinitionOverrideException: Invalid bean definition with name <span class="string">&#x27;bean1&#x27;</span> defined in <span class="keyword">class</span> <span class="title class_">path</span> resource [indi/lcp/a41/A41$AutoConfiguration1.class]: Cannot register bean definition [Root bean: class [<span class="literal">null</span>]; scope=; <span class="keyword">abstract</span>=<span class="literal">false</span>; lazyInit=<span class="literal">null</span>; autowireMode=<span class="number">3</span>; dependencyCheck=<span class="number">0</span>; autowireCandidate=<span class="literal">true</span>; primary=<span class="literal">false</span>; factoryBeanName=indi.lcp.a41.A41$AutoConfiguration1; factoryMethodName=bean1; initMethodName=<span class="literal">null</span>; destroyMethodName=(inferred); defined in <span class="keyword">class</span> <span class="title class_">path</span> resource [indi/lcp/a41/A41$AutoConfiguration1.class]] <span class="keyword">for</span> bean <span class="string">&#x27;bean1&#x27;</span>: There is already [Root bean: class [<span class="literal">null</span>]; scope=; <span class="keyword">abstract</span>=<span class="literal">false</span>; lazyInit=<span class="literal">null</span>; autowireMode=<span class="number">3</span>; dependencyCheck=<span class="number">0</span>; autowireCandidate=<span class="literal">true</span>; primary=<span class="literal">false</span>; factoryBeanName=config; factoryMethodName=bean1; initMethodName=<span class="literal">null</span>; destroyMethodName=(inferred); defined in indi.lcp.a41.A41$Config] bound.</span><br></pre></td></tr></table></figure><p>尽管还是出现了异常，但异常信息中显示的是在配置类定义的 Bean 已存在，第三方装配的 Bean 无法再添加，这表明 Bean 的添加顺序修改成功。</p><p>最后在第三方定义的 Bean 上添加 @ConditionalOnMissingBean 注解，表示容器中存在同名的 Bean 时忽略该 Bean 的添加：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration1</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>(<span class="string">&quot;第三方&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行 main() 方法，不再出现异常：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">A41.Bean1(name=本项目)</span><br></pre></td></tr></table></figure><h2 id="41-2-Aop-自动配置"><a href="#41-2-Aop-自动配置" class="headerlink" title="41.2 Aop 自动配置"></a>41.2 Aop 自动配置</h2><p>确保当前模块下已导入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>使用 AopAutoConfiguration 自动装配与 AOP 相关的 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAopAuto</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        <span class="comment">// 注册常用后置处理器</span></span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">        context.registerBean(Config.class);</span><br><span class="line">        context.refresh();</span><br><span class="line">        Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;AopAutoConfiguration.class.getName()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">indi.lcp.a41.TestAopAuto$Config</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration$AspectJAutoProxyingConfiguration$CglibAutoProxyConfiguration</span><br><span class="line">org.springframework.aop.config.internalAutoProxyCreator</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration$AspectJAutoProxyingConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration</span><br></pre></td></tr></table></figure><p>以 indi.lcp.a41.TestAopAuto$Config 为分割线，上方是添加的一些后置处理器，下方就是 AOP 自动装配添加的 Bean。</p><p>在配置类 AopAutoConfiguration 中，使用注解判断配置类是否生效。首先是最外层的 AopAutoConfiguration：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfiguration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;auto&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopAutoConfiguration</span> &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 @ConditionalOnProperty 注解配置的信息：如果配置文件中存在 前缀 为 spring.aop，名称 为 auto 的 key，并且其对应的 value 是 true 时，配置类 AopAutoConfiguration 生效；如果配置文件中未显式配置，该配置类也生效。</p><p>不使用配置文件，使用 StandardEnvironment 指定 spring.aop.auto 的值为 false：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    <span class="type">StandardEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">    env.getPropertySources().addLast(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SimpleCommandLinePropertySource</span>(<span class="string">&quot;--spring.aop.auto=false&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">    context.setEnvironment(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">indi.lcp.a41.TestAopAuto$Config</span><br></pre></td></tr></table></figure><p>如果 spring.aop.auto 的值是 true，又会成功添加上 AOP 自动装配的 Bean。</p><p>再看 AopAutoConfiguration 的内部类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(Advice.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AspectJAutoProxyingConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass(&quot;org.aspectj.weaver.Advice&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClassProxyingConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其内部存在两个类：AspectJAutoProxyingConfiguration 和 ClassProxyingConfiguration。</p><p>使用了 @ConditionalOnClass 注解判断 Advice.class 存在时，AspectJAutoProxyingConfiguration 生效；使用 @ConditionalOnMissingClass 注解判断 org.aspectj.weaver.Advice 不存在时，ClassProxyingConfiguration 生效。</p><p>由于先前导入了 spring-boot-starter-aop 依赖，Advice.class 是存在的，AspectJAutoProxyingConfiguration 将生效。</p><p>AspectJAutoProxyingConfiguration 内部又有两个配置类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;false&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JdkDynamicAutoProxyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CglibAutoProxyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个配置类通过使用 @ConditionalOnProperty 注解判断配置文件中是否存在 spring.aop.proxy-target-class 配置来让对应的配置类生效。</p><p>由于并未显式 配置，因此 CglibAutoProxyConfiguration 将生效。</p><p>无论哪个配置类生效，它们都被 @EnableAspectJAutoProxy 标记，这个注解相当于是添加了些配置的 @Import 注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(&#123;AspectJAutoProxyRegistrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向 Spring 容器中添加 AspectJAutoProxyRegistrar 类型的 Bean。</p><p>AspectJAutoProxyRegistrar 实现了 ImportBeanDefinitionRegistrar 接口，可以使用编程的方式来注册一些 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary() 方法是注册 Bean 的主要逻辑：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title function_">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry, (Object)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title function_">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终注册了 AnnotationAwareAspectJAutoProxyCreator。</p><p>使用 org.springframework.aop.config.internalAutoProxyCreator 作为名称，获取 AnnotationAwareAspectJAutoProxyCreator 类型的 Bean，并查看其 proxyTargetClass 属性是否为 true：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    <span class="type">AnnotationAwareAspectJAutoProxyCreator</span> <span class="variable">creator</span> <span class="operator">=</span></span><br><span class="line">        context.getBean(<span class="string">&quot;org.springframework.aop.config.internalAutoProxyCreator&quot;</span>, AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line">    System.out.println(creator.isProxyTargetClass()); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【补充】ImportBeanDefinitionRegistrar 接口</p><p>将 Bean 注入到 Spring 的大致流程是：</p><p>利用 BeanDefinitionReader 读取配置文件或注解信息，为每一个 Bean 生成一个 BeanDefinition</p><p>将 BeanDefinition 注册到 BeanDefinitionRegistry 中</p><p>当需要创建 Bean 对象时，从 BeanDefinitionRegistry 中取出对应的 BeanDefinition，利用这个 BeanDefinition 来创建 Bean</p><p>如果创建的 Bean 是单例的，Spring 会将这个 Bean 保存到 SingletonBeanRegistry 中，即三级缓存中的第一级缓存，需要时直接从这里获取，而不是重复创建</p><p>也就是说 Spring 是通过 BeanDefinition 去创建 Bean 的，而 BeanDefinition 会被注册到 BeanDefinitionRegistry 中，因此可以拿到 BeanDefinitionRegistry 直接向里面注册 BeanDefinition 达到将 Bean 注入到 Spring 的目标。</p><p>ImportBeanDefinitionRegistrar 接口就可以直接拿到 BeanDefinitionRegistry：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitions(importingClassMetadata, registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口需要搭配 @Import 注解使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();</span></span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    <span class="comment">// AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span></span><br><span class="line"></span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">    context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">    System.out.println(context.getBean(User.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;MyImportBeanDefinitionRegistrar.class&#125;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 构建 BeanDefinition</span></span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(User.class)</span><br><span class="line">                .addPropertyValue(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lcp&quot;</span>)</span><br><span class="line">                .addPropertyValue(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>)</span><br><span class="line">                .getBeanDefinition();</span><br><span class="line">        <span class="comment">// 注册构建好的 BeanDefinition</span></span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;user&quot;</span>, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： 使用时一定要确保 Spring 容器中存在 ConfigurationClassPostProcessor 类型的 Bean。</p><p>除此之外，使用 BeanDefinitionRegistryPostProcessor 接口也能拿到 BeanDefinitionRegistry：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry var1)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="41-3-数据库相关的自动配置"><a href="#41-3-数据库相关的自动配置" class="headerlink" title="41.3 数据库相关的自动配置"></a>41.3 数据库相关的自动配置</h2><p>确保当前模块下已导入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.3</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>DataSource 自动配置</p><p>自行实现导入选择器，并使用 @Import 注解进行导入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">                DataSourceAutoConfiguration.class.getName(),</span><br><span class="line">                MybatisAutoConfiguration.class.getName(),</span><br><span class="line">                DataSourceTransactionManagerAutoConfiguration.class.getName(),</span><br><span class="line">                TransactionAutoConfiguration.class.getName()</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main() 方法中打印导入的 Bean 信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    <span class="type">StandardEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">    env.getPropertySources().addLast(<span class="keyword">new</span> <span class="title class_">SimpleCommandLinePropertySource</span>(</span><br><span class="line">        <span class="string">&quot;--spring.datasource.url=jdbc:mysql://localhost:3306/advanced_spring&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--spring.datasource.username=root&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--spring.datasource.password=123456&quot;</span></span><br><span class="line">    ));</span><br><span class="line">    context.setEnvironment(env);</span><br><span class="line">    AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">    context.registerBean(Config.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resourceDescription</span> <span class="operator">=</span> context.getBeanDefinition(name).getResourceDescription();</span><br><span class="line">        <span class="keyword">if</span> (resourceDescription != <span class="literal">null</span>)</span><br><span class="line">            System.out.println(name + <span class="string">&quot; 来源: &quot;</span> + resourceDescription);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未使用配置文件，而是使用 StandardEnvironment 设置了一些数据库连接信息。</p><p>最后只打印有明确来源的 Bean 信息，其中有一条：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataSource 来源: <span class="keyword">class</span> <span class="title class_">path</span> resource [org/springframework/boot/autoconfigure/jdbc/DataSourceConfiguration$Hikari.class]</span><br></pre></td></tr></table></figure><p>名叫 dataSource 的 Bean 的来源为什么是 DataSourceConfiguration，而不是 DataSourceAutoConfiguration 呢？</p><p>查看 DataSourceAutoConfiguration 的源码，实现与 AopAutoConfiguration 类似，都是通过注解来判断需要导入哪些 Bean，有两个关键的内部类 EmbeddedDatabaseConfiguration 和 PooledDataSourceConfiguration：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfiguration(before = SqlInitializationAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; DataSource.class, EmbeddedDatabaseType.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(type = &quot;io.r2dbc.spi.ConnectionFactory&quot;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(DataSourceProperties.class)</span></span><br><span class="line"><span class="meta">@Import(DataSourcePoolMetadataProvidersConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="meta">@Conditional(EmbeddedDatabaseCondition.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;)</span></span><br><span class="line">    <span class="meta">@Import(EmbeddedDataSourceConfiguration.class)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EmbeddedDatabaseConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="meta">@Conditional(PooledDataSourceCondition.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;)</span></span><br><span class="line">    <span class="meta">@Import(&#123; DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,</span></span><br><span class="line"><span class="meta">             DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.OracleUcp.class,</span></span><br><span class="line"><span class="meta">             DataSourceConfiguration.Generic.class, DataSourceJmxConfiguration.class &#125;)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PooledDataSourceConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们都被 @Conditional 注解标记。当项目支持内嵌数据源时，EmbeddedDatabaseConfiguration 生效；当项目支持基于数据库连接池的数据源时，PooledDataSourceConfiguration 生效。</p><p>SpringBoot 默认的数据库连接池是 Hikari，因此 PooledDataSourceConfiguration 生效，最终使用 @Import 导入一系列 Bean，导入的这些 Bean 都是 DataSourceConfiguration 的内部类，因此dataSource 的 Bean 的来源是 DataSourceConfiguration。</p><p>在 DataSourceConfiguration 中，通过 @ConditionalOnClass 注解判断某些 Class 是否存在来使某种数据库连接池生效。</p><p>由于导入了 mybatis-spring-boot-starter，其内部依赖 mybatis-spring-boot-jdbc，而它又依赖了 HikariCP，因此最终数据库连接池 Hikari 生效：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(HikariDataSource.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(DataSource.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;, havingValue = &quot;com.zaxxer.hikari.HikariDataSource&quot;,</span></span><br><span class="line"><span class="meta">      matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Hikari</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.hikari&quot;)</span></span><br><span class="line">   HikariDataSource <span class="title function_">dataSource</span><span class="params">(DataSourceProperties properties)</span> &#123;</span><br><span class="line">      <span class="type">HikariDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> createDataSource(properties, HikariDataSource.class);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(properties.getName())) &#123;</span><br><span class="line">         dataSource.setPoolName(properties.getName());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dataSource;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Hikari#dataSource() 方法中，接受一个 DataSourceProperties 类型的参数，这要求 Spring 容器中存在 DataSourceProperties 类型的 Bean。</p><p>在最初的 DataSourceAutoConfiguration 自动配置类上有个 @EnableConfigurationProperties 注解，它将 DataSourceProperties 添加到容器中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(DataSourceProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// --snip-=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 DataSourceProperties 中会绑定配置文件中以 spring.datasource 为前缀的配置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceProperties</span> <span class="keyword">implements</span> <span class="title class_">BeanClassLoaderAware</span>, InitializingBean &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 DataSourceProperties 类型的 Bean，并打印其 url、username 和 password：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    <span class="type">StandardEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">    env.getPropertySources().addLast(<span class="keyword">new</span> <span class="title class_">SimpleCommandLinePropertySource</span>(</span><br><span class="line">        <span class="string">&quot;--spring.datasource.url=jdbc:mysql://localhost:3306/advanced_spring&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--spring.datasource.username=root&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--spring.datasource.password=123456&quot;</span></span><br><span class="line">    ));</span><br><span class="line">    context.setEnvironment(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">DataSourceProperties</span> <span class="variable">properties</span> <span class="operator">=</span> context.getBean(DataSourceProperties.class);</span><br><span class="line">    System.out.println(properties.getUrl());</span><br><span class="line">    System.out.println(properties.getUsername());</span><br><span class="line">    System.out.println(properties.getPassword());</span><br><span class="line">&#125;</span><br><span class="line">jdbc:mysql:<span class="comment">//localhost:3306/advanced_spring</span></span><br><span class="line">root</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>MyBatis 自动配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;SqlSessionFactory.class, SqlSessionFactoryBean.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(DataSource.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;MybatisProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123;DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisAutoConfiguration</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionTemplate <span class="title function_">sqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@Import(&#123;MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar.class&#125;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(&#123;MapperFactoryBean.class, MapperScannerConfigurer.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MapperScannerRegistrarNotFoundConfiguration</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MybatisAutoConfiguration 生效的条件有两个：</p><p>类路径下存在 SqlSessionFactory 和 SqlSessionFactoryBean</p><p>Spring 容器中有且仅有一个 DataSource 类型的 Bean</p><p>它还添加了 MybatisProperties 类型的 Bean 到 Spring 容器中，并与配置文件中以 mybatis 为前缀的信息绑定。</p><p>@AutoConfigureAfter 注解指定了当前自动配置类在 DataSourceAutoConfiguration 和 MybatisLanguageDriverAutoConfiguration 两个自动配置类解析完成之后再解析。</p><p>接下来遇到 sqlSessionFactory() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖 Spring 容器中的 DataSource，当容器中不存在 SqlSessionFactory 时，将其添加到 Spring 容器中。</p><p>然后是 sqlSessionTemplate() 方法，它与添加 SqlSessionFactory 到 Spring 容器的逻辑一样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionTemplate <span class="title function_">sqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SqlSessionTemplate 也是 SqlSession 的实现，提供了与当前线程绑定的 SqlSession。针对多个方法调用，如果它们来自同一个线程，那么获取到的 SqlSession 对象是同一个。这也是为什么有了 DefaultSqlSession 作为 SqlSession 的实现了，还需要 SqlSessionTemplate。</p><p>在 MyBatis 中，使用 MapperFactoryBean 将接口转换为对象，其核心是 getObject() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getSqlSession().getMapper(<span class="built_in">this</span>.mapperInterface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法中获取了 sqlSession 对象，而获取的就是 SqlSessionTemplate 对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSession <span class="title function_">getSqlSession</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后来到 MapperScannerRegistrarNotFoundConfiguration 内部类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(&#123;MapperFactoryBean.class, MapperScannerConfigurer.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MapperScannerRegistrarNotFoundConfiguration</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 @ConditionalOnMissingBean 判断 Spring 容器中缺失 MapperFactoryBean 和 MapperScannerConfigurer 时，该配置类生效。生效时利用 @Import 导入 AutoConfiguredMapperScannerRegistrar：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguredMapperScannerRegistrar</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span>, EnvironmentAware, ImportBeanDefinitionRegistrar &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AutoConfiguredMapperScannerRegistrar 实现了 ImportBeanDefinitionRegistrar 接口，允许通过编程的方式加 Bean 添加到 Spring 容器中，而这里是去扫描 Mapper 接口，将其转换为对象添加到 Spring 容器中。</p><p>在 main() 所在类的包路径下创建 mapper 包，并新建三个接口，其中两个被 @Mapper 注解标记：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mapper1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mapper2</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mapper3</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法，查看 Mapper1 和 Mapper2 是否被添加到 Spring 容器中。</p><p>结果是否定的。因为 没有设置要扫描的包路径 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">packageName</span> <span class="operator">=</span> TestDataSourceAuto.class.getPackage().getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;当前包名: &quot;</span> + packageName);</span><br><span class="line">    AutoConfigurationPackages.register(context.getDefaultListableBeanFactory(),</span><br><span class="line">            packageName);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resourceDescription</span> <span class="operator">=</span> context.getBeanDefinition(name).getResourceDescription();</span><br><span class="line">        <span class="keyword">if</span> (resourceDescription != <span class="literal">null</span>)</span><br><span class="line">            System.out.println(name + <span class="string">&quot; 来源: &quot;</span> + resourceDescription);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">当前包名: indi.lcp.a41</span><br><span class="line">mapper1 来源: file [D:\Code\IdeaCode\advanced-spring\boot\target\classes\indi\lcp\a41\mapper\Mapper1.class]</span><br><span class="line">mapper2 来源: file [D:\Code\IdeaCode\advanced-spring\boot\target\classes\indi\lcp\a41\mapper\Mapper2.class]</span><br></pre></td></tr></table></figure><p>@MapperScan 注解与 MybatisAutoConfiguration 在功能上很类似，只不过：</p><p>@MapperScan 可以指定具体的扫描路径，未指定时会把引导类范围内的所有接口当做 Mapper 接口；</p><p>MybatisAutoConfiguration 关注所有被 @Mapper 注解标记的接口，忽略未被 @Mapper 标记的接口。</p><p>事务自动配置</p><p>事务自动配置与 DataSourceTransactionManagerAutoConfiguration、TransactionAutoConfiguration 有关。</p><p>DataSourceTransactionManagerAutoConfiguration 配置了 DataSourceTransactionManager 用来执行事务的提交、回滚操作。</p><p>TransactionAutoConfiguration 在功能上对标 @EnableTransactionManagement，包含以下三个 Bean：</p><p>BeanFactoryTransactionAttributeSourceAdvisor：事务切面类，包含通知和切点</p><p>TransactionInterceptor：事务通知类，由它在目标方法调用前后加入事务操作</p><p>AnnotationTransactionAttributeSource：解析 @Transactional 及事务属性，还包含了切点功能</p><p>如果自定义了 DataSourceTransactionManager 或是在引导类加了 @EnableTransactionManagement，则以自定义为准。</p><h2 id="41-4-MVC-自动配置"><a href="#41-4-MVC-自动配置" class="headerlink" title="41.4 MVC 自动配置"></a>41.4 MVC 自动配置</h2><p>MVC 的自动配置需要用到四个类：</p><p>配置内嵌 Tomcat 服务器工厂：ServletWebServerFactoryAutoConfiguration</p><p>配置 DispatcherServlet：DispatcherServletAutoConfiguration</p><p>配置 WebMVC 各种组件：WebMvcAutoConfiguration</p><p>配置 MVC 的错误处理：ErrorMvcAutoConfiguration</p><p>查看自动配置与 MVC 相关的 Bean 的信息、来源：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMvcAuto</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigServletWebServerApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>();</span><br><span class="line">        context.registerBean(Config.class);</span><br><span class="line">        context.refresh();</span><br><span class="line">        <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> context.getBeanDefinition(name).getResourceDescription();</span><br><span class="line">            <span class="keyword">if</span> (source != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot; 来源:&quot;</span> + source);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">                    <span class="comment">// 配置内嵌 Tomcat 服务器工厂</span></span><br><span class="line">                    ServletWebServerFactoryAutoConfiguration.class.getName(),</span><br><span class="line">                    <span class="comment">// 配置 DispatcherServlet</span></span><br><span class="line">                    DispatcherServletAutoConfiguration.class.getName(),</span><br><span class="line">                    <span class="comment">// 配置 WebMVC 各种组件</span></span><br><span class="line">                    WebMvcAutoConfiguration.class.getName(),</span><br><span class="line">                    <span class="comment">// 配置 MVC 的错误处理</span></span><br><span class="line">                    ErrorMvcAutoConfiguration.class.getName()</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="41-5-自定义自动配置类"><a href="#41-5-自定义自动配置类" class="headerlink" title="41.5 自定义自动配置类"></a>41.5 自定义自动配置类</h2><p>在 SpringBoot 自动装配时添加自定义组件分为两步：</p><p>在类路径下自定义 META-INF&#x2F;spring.factories 文件，以 org.springframework.boot.autoconfigure.EnableAutoConfiguration 为 key，设置需要自动装配的自定义组件的全限定类名为 value</p><p>编写配置类，在配置类上使用 @EnableAutoConfiguration 注解，并将其添加到 Spring 容器中</p><p>在实际项目开发中，省略第二步，SpringBoot 的会自动扫描。</p><p>SpringBoot 2.7.0 及其以后版本</p><p>在类路径下自定义 META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件，文件中 每一行 表示需要进行自动装配的类的全限定类名，因此不能随意换行。</p><p>在这个文件中，以 # 开头的行表示注释。</p><h1 id="条件装配底层"><a href="#条件装配底层" class="headerlink" title="条件装配底层"></a>条件装配底层</h1><h2 id="42-1-Conditional"><a href="#42-1-Conditional" class="headerlink" title="42.1 @Conditional"></a>42.1 @Conditional</h2><p>在 SpringBoot 的自动配置中，经常看到 @Conditional 注解的使用，使用该注解可以按条件加载配置类。</p><p>@Conditional 注解并不具备条件判断功能，而是通过指定的 Class 列表来进行判断，指定的 Class 需要实现 Condition 接口。</p><p>假设有这样一个需求：通过判断类路径下是否存在 com.alibaba.druid.pool.DruidDataSource 类来加载不同的配置类，当存在 DruidDataSource 时，加载 AutoConfiguration1，反之加载 AutoConfiguration2。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;AutoConfiguration1.class.getName(), AutoConfiguration2.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyCondition1</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        <span class="comment">// 存在 Druid 依赖</span></span><br><span class="line">        <span class="keyword">return</span> ClassUtils.isPresent(<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyCondition2</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        <span class="comment">// 不存在 Druid 依赖</span></span><br><span class="line">        <span class="keyword">return</span> !ClassUtils.isPresent(<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟第三方的配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Conditional(MyCondition1.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration1</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟第三方的配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Conditional(MyCondition2.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration2</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时并未导入 druid 依赖，AutoConfiguration2 应该生效，运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">config</span><br><span class="line">org.springframework.context.annotation.ConfigurationClassPostProcessor</span><br><span class="line">indi.lcp.a42.A42$AutoConfiguration1</span><br><span class="line">bean1</span><br></pre></td></tr></table></figure><p>导入 druid 依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.2</span><span class="number">.15</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>再次运行 main() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">config</span><br><span class="line">org.springframework.context.annotation.ConfigurationClassPostProcessor</span><br><span class="line">indi.lcp.a42.A42$AutoConfiguration1</span><br><span class="line">bean1</span><br></pre></td></tr></table></figure><h2 id="42-2-ConditionalOnXxx"><a href="#42-2-ConditionalOnXxx" class="headerlink" title="42.2 @ConditionalOnXxx"></a>42.2 @ConditionalOnXxx</h2><p>在 SpringBoot 的自动配置中，经常看到 @ConditionalOnXxx 注解的使用，这种注解是将某个 @Conditional 的判断进行了封装，比如 ConditionalOnClass 就是用于判断某个 Class 是否存在。</p><p>因此针对上文中的代码可以做出修改：</p><p>自定义 @ConditionalOnClass 注解，填入需要判断的全限定类名和判断条件；</p><p>移除模拟的第三方配置上的 @Conditional 注解，而是使用自定义的 @ConditionalOnClass；</p><p>Condition 接口的使用类重写的 matches() 方法利用 @ConditionalOnClass 注解进行条件判断。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;AutoConfiguration1.class.getName(), AutoConfiguration2.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; attributes = metadata.getAnnotationAttributes(ConditionalOnClass.class.getName());</span><br><span class="line">        Optional&lt;Map&lt;String, Object&gt;&gt; optional = Optional.ofNullable(attributes);</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> optional.map(i -&gt; String.valueOf(i.get(<span class="string">&quot;className&quot;</span>))).orElse(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> optional.map(i -&gt; i.get(<span class="string">&quot;exists&quot;</span>))</span><br><span class="line">            .map(String::valueOf)</span><br><span class="line">            .map(Boolean::parseBoolean).orElse(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">present</span> <span class="operator">=</span> ClassUtils.isPresent(className, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> exists == present;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Conditional(MyCondition.class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="meta">@interface</span> ConditionalOnClass &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * true 判断存在 false 判断不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要判断的类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">className</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(className = &quot;com.alibaba.druid.pool.DruidDataSource&quot;, exists = true)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration1</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(className = &quot;com.alibaba.druid.pool.DruidDataSource&quot;, exists = false)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration2</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在导入 druid 依赖或未导入 druid 依赖的情况下运行 main() 方法，控制台打印结果与【42.1 @Conditional】一样。</p><h1 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h1><p>FactoryBean 是一个接口，可以实现该接口，并指定一个泛型，在重写的方法指定泛型类型对象的创建，然后将实现类交由 Spring 管理，最后 Spring 容器中会增加泛型类型的 Bean。这个 Bean 并不是完全受 Spring 管理，或者说部分受 Spring 管理。</p><p>为什么这么说呢？</p><p>首先定义一个 Bean2，交由 Spring 管理，但它不是重点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义 Bean1，它未交由 Spring 管理，但是在其内部注入了 Bean2、定义初始化方法、实现 Aware 接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean2</span><span class="params">(Bean2 bean2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bean2 = bean2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">getBean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.bean2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;setBeanFactory(&#123;&#125;)&quot;</span>, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义 Bean1FactoryBean，实现 FactoryBean 接口，指定泛型为 Bean1，将其交由 Spring 管理，Bean 的名称是 bean1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component(&quot;bean1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1FactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Bean1&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Bean1</span> <span class="variable">bean1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">        log.debug(<span class="string">&quot;create bean: &#123;&#125;&quot;</span>, bean1);</span><br><span class="line">        <span class="keyword">return</span> bean1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Bean1.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种方式添加到 Spring 容器中的 Bean 的名称是 bean1，但 Bean 的类型不是 Bean1FactoryBean，或者 FactoryBean，而是 Bean1。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A43</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A43.class);</span><br><span class="line">        <span class="type">Bean1</span> <span class="variable">bean1</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;bean1&quot;</span>, Bean1.class);</span><br><span class="line">        System.out.println(bean1);</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.a43.Bean1FactoryBean     - create bean: indi.lcp.a43.Bean1@2667f029 </span><br><span class="line">indi.lcp.a43.Bean1@2667f029</span><br></pre></td></tr></table></figure><p>Bean1 类型的 Bean 被成功添加到 Spring 容器中，但根据打印的日志信息可以看出这个 Bean 没有经历依赖注入阶段、没有回调 Aware 接口、没有经历初始化阶段，其创建是由重写的 getObject() 方法完成的。</p><p>这个 Bean 就真的没有经历 Spring Bean 的生命周期中的任何阶段吗？</p><p>定义 Bean1PostProcessor，实现 BeanPostProcessor 接口，在 bean1 初始化前后打印日志信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1PostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;bean1&quot;</span>.equals(beanName) &amp;&amp; bean <span class="keyword">instanceof</span> Bean1) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;before [&#123;&#125;] init&quot;</span>, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;bean1&quot;</span>.equals(beanName) &amp;&amp; bean <span class="keyword">instanceof</span> Bean1) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;after [&#123;&#125;] init&quot;</span>, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.a43.Bean1FactoryBean     - create bean: indi.lcp.a43.Bean1@6a28ffa4 </span><br><span class="line">indi.lcp.a43.Bean1PostProcessor   - after [bean1] init </span><br><span class="line">indi.lcp.a43.Bean1@6a28ffa4</span><br></pre></td></tr></table></figure><p>bean1 进行了初始化后的增强逻辑，但未进行初始化前的增强逻辑。</p><p>创建代理对象的时机就是在初始化后，因此由 FactoryBean 创建的 Bean 可以进行代理增强 。</p><p>FactoryBean 接口</p><p>FactoryBean 接口中有三个可以被重写的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">OBJECT_TYPE_ATTRIBUTE</span> <span class="operator">=</span> <span class="string">&quot;factoryBeanObjectType&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><p>getObject() 用于构造 Bean 对象</p><p>getObjectType() 用于返回 Bean 对象的类型，以便可以通过类型从容器中获取 Bean</p><p>isSingleton() 每次获取的 Bean 对象是否是单例的</p><p>从容器中获取 Bean 时可以通过名称获取、可以通过类型获取、也可以通过名称和类型一起获取。如果重写的 getObjectType() 方法返回了 null，那么 仅仅 类型从容器中获取 Bean 时，将抛出 NoSuchBeanDefinitionException 异常，并提示没有指定类型的 Bean。</p><p>如果重写的 isSingleton() 方法返回 true，那么每次从容器中获取 Bean 对象都是同一个，反之则不是。</p><p>注意： 由 FactoryBean 构造的单例 Bean 不会存放在 DefaultSingletonBeanRegistry 的 singletonFactories 中，而是在 AbstractAutowireCapableBeanFactory 的 factoryBeanInstanceCache 中。</p><p>获取 FactoryBean 类型的 Bean</p><p>肯定不能简单地通过名称获取，那会返回其泛型参数类型的 Bean，那通过类型获取呢？比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context.getBean(Bean1FactoryBean.class)</span><br></pre></td></tr></table></figure><p>答案是可行的。</p><p>除此之外，还可以在名称前添加 &amp;，然后通过名称来获取（有点指针的味道？）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context.getBean(<span class="string">&quot;&amp;bean1&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="Indexed"><a href="#Indexed" class="headerlink" title="@Indexed"></a>@Indexed</h1><p>Spring 在进行组件扫描时，会遍历项目中依赖的所有 Jar 包中类路径下所有的文件，找到被 @Component 及其衍生注解标记的类，然后把它们组装成 BeanDefinition 添加到 Spring 容器中。</p><p>如果扫描的返回过大，势必会大大地影响项目启动速度。</p><p>为了优化扫描速度，引入以下依赖，Spring 将扫描过程提前到编译期：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-context-indexer&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>现有如下类信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean3</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个类都与 A44 存放于同一包路径下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A44</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">        <span class="comment">// 组件扫描核心类</span></span><br><span class="line">        <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(beanFactory);</span><br><span class="line">        scanner.scan(A44.class.getPackage().getName());</span><br><span class="line"></span><br><span class="line">        Arrays.stream(beanFactory.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bean2</span><br><span class="line">bean3</span><br><span class="line">bean1</span><br><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br></pre></td></tr></table></figure><p>这没什么奇怪的，bean1、bean2 和 bean3 都被添加到 Spring 容器中。</p><p>在编译生成的 target 目录下的 classes&#x2F;META-INF&#x2F;spring.components 文件里有以下信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.a44.Bean1=org.springframework.stereotype.Component</span><br><span class="line">indi.lcp.a44.Bean2=org.springframework.stereotype.Component</span><br><span class="line">indi.lcp.a44.Bean3=org.springframework.stereotype.Component</span><br></pre></td></tr></table></figure><p>如果删除最后两条信息，再次运行 main() 方法呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bean1</span><br><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br></pre></td></tr></table></figure><p>此时只有 bean1 被添加到 Spring 容器中，也就是说会先以 spring.components 文件中的信息为主。</p><p>那 spring.components 是怎么什么的？</p><p>它是在引入 spring-context-indexer 依赖后，在编译期根据类是否被 @Indexed 注解标记，生成 spring.components 文件及内容。</p><p>到目前为止，虽然都没显式使用 @Indexed 注解，但它包含在 @Component 注解中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Component &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结</p><p>导入 spring-context-indexer 依赖后，在编译期根据 @Indexed 生成 META-INF&#x2F;spring.components 文件。</p><p>Spring 在扫描组件时，如果发现 META-INF&#x2F;spring.components 文件存在，以它为准加载 BeanDefinition，反之遍历包含 Jar 包类路径下所有 class 信息。</p><h1 id="代理进一步理解"><a href="#代理进一步理解" class="headerlink" title="代理进一步理解"></a>代理进一步理解</h1><p>在 Spring 的代理中，依赖注入和初始化针对的是目标对象，代理对象和目标对象是两个对象，两者的成员变量不会共享。</p><p>确保项目中已导入以下依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>依赖注入和初始化针对的是目标对象</p><p>现有如下类信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Bean2 bean2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> initialized;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean2</span><span class="params">(Bean2 bean2)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;setBean2(Bean2 bean2)&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.bean2 = bean2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">        initialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">getBean2</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;getBean2()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInitialized</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;isInitialized()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> initialized;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为 Bean1 中的每个方法定制一个前置通知：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 Bean1 中所有的方法进行匹配</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* indi.lcp.a45.Bean1.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一 SpringBoot 主启动类，它与 Bean1、Bean2 和 MyAspect 在同一包路径下，确保它们能被自动添加到 Spring 容器中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A45</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A45.class, args);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法，控制台输出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.a45.Bean1                - setBean2(Bean2 bean2) </span><br><span class="line">indi.lcp.a45.Bean1                - init </span><br></pre></td></tr></table></figure><p>Bean1 中的依赖注入和初始化被成功执行，但 并没有被增强。</p><p>由于 Bean1 被增强了，从 Spring 容器中获取的对象将是代理对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A45.class, args);</span><br><span class="line">    <span class="type">Bean1</span> <span class="variable">proxy</span> <span class="operator">=</span> context.getBean(Bean1.class);</span><br><span class="line"></span><br><span class="line">    proxy.setBean2(<span class="keyword">new</span> <span class="title class_">Bean2</span>());</span><br><span class="line">    proxy.init();</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">before</span><br><span class="line">indi.lcp.a45.Bean1                - setBean2(Bean2 bean2) </span><br><span class="line">before</span><br><span class="line">indi.lcp.a45.Bean1                - init </span><br></pre></td></tr></table></figure><p>主动调用的 setBean2() 和 init() 方法 都被增强。</p><p>代理对象与目标对象的成员变量不共享</p><p>尝试打印代理对象和目标对象的成员变量信息（直接访问，不使用方法）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A45.class, args);</span><br><span class="line">    <span class="type">Bean1</span> <span class="variable">proxy</span> <span class="operator">=</span> context.getBean(Bean1.class);</span><br><span class="line">    </span><br><span class="line">    showProxyAndTarget(proxy);</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showProxyAndTarget</span><span class="params">(Bean1 proxy)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; 代理中的成员变量&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;\tinitialized = &quot;</span> + proxy.initialized);</span><br><span class="line">    System.out.println(<span class="string">&quot;\tbean2 = &quot;</span> + proxy.bean2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (proxy <span class="keyword">instanceof</span> Advised) &#123;</span><br><span class="line">        <span class="type">Advised</span> <span class="variable">advised</span> <span class="operator">=</span> (Advised) proxy;</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; 目标中的成员变量&quot;</span>);</span><br><span class="line">        <span class="type">Bean1</span> <span class="variable">target</span> <span class="operator">=</span> (Bean1) advised.getTargetSource().getTarget();</span><br><span class="line">        System.out.println(<span class="string">&quot;\tinitialized = &quot;</span> + target.initialized);</span><br><span class="line">        System.out.println(<span class="string">&quot;\tbean2 = &quot;</span> + target.bean2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt; 代理中的成员变量</span><br><span class="line">        initialized = <span class="type">false</span></span><br><span class="line">        <span class="variable">bean2</span> <span class="operator">=</span> <span class="literal">null</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt; 目标中的成员变量</span><br><span class="line">        initialized = <span class="type">true</span></span><br><span class="line">        <span class="variable">bean2</span> <span class="operator">=</span> indi.lcp.a45.Bean2@771db12c</span><br></pre></td></tr></table></figure><p>由于依赖注入和初始化只针对目标对象，因此代理对象中的成员变量的值都是初始值。</p><p>在实际应用过程中，不会直接去访问成员变量，而是通过方法去访问：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A45.class, args);</span><br><span class="line">    <span class="type">Bean1</span> <span class="variable">proxy</span> <span class="operator">=</span> context.getBean(Bean1.class);</span><br><span class="line"></span><br><span class="line">    showProxyAndTarget(proxy);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    System.out.println(proxy.getBean2());</span><br><span class="line">    System.out.println(proxy.isInitialized());</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">before</span><br><span class="line">indi.lcp.a45.Bean1                - getBean2() </span><br><span class="line">indi.lcp.a45.Bean2@771db12c</span><br><span class="line">before</span><br><span class="line">indi.lcp.a45.Bean1                - isInitialized() </span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>通过方法访问代理对象的成员变量时，这些方法会被增强，同时代理对象中的方法又会去调用目标对象的方法，从而读取出正确的值。</p><p>只会对能被重写的方法进行增强</p><p>在 Bean1 中增加几个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1() 成员方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m2() final 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m3() static 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m4() private 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// static、final、private 修饰的方法不会被增强</span></span><br><span class="line">    proxy.m1();</span><br><span class="line">    proxy.m2();</span><br><span class="line">    Bean1.m3();</span><br><span class="line">    <span class="type">Method</span> <span class="variable">m4</span> <span class="operator">=</span> Bean1.class.getDeclaredMethod(<span class="string">&quot;m4&quot;</span>);</span><br><span class="line">    m4.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    m4.invoke(proxy);</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">before</span><br><span class="line"><span class="title function_">m1</span><span class="params">()</span> 成员方法</span><br><span class="line">m2() <span class="keyword">final</span> 方法</span><br><span class="line">m3() <span class="keyword">static</span> 方法</span><br><span class="line">m4() <span class="keyword">private</span> 方法</span><br></pre></td></tr></table></figure><p>能被重写的成员方法成功被增强，但被 final 修饰的、被 static 修饰的方法和私有方法由于无法被重写，因此它们不能被增强。如果想增强这些方法，可以使用 AspectJ 编译器增强或者 Agent 类加载。</p><h1 id="Value-注入底层"><a href="#Value-注入底层" class="headerlink" title="@Value 注入底层"></a>@Value 注入底层</h1><p>现有一 Bean1 类如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;JAVA_HOME&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String home;</span><br><span class="line">    <span class="meta">@Value(&quot;18&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要解析 @Value(“${JAVA_HOME}”) 和 @Value(“18”) 的值，其中 JAVA_HOME 以系统环境变量填充，18 为整型。</p><p>解析分为两步：</p><ol><li>获取 @Value 注解中 value 属性值；</li><li>解析属性值</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A46</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A46.class);</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getDefaultListableBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="type">ContextAnnotationAutowireCandidateResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>();</span><br><span class="line">        resolver.setBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        test1(context, resolver);</span><br><span class="line">        test2(context, resolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(AnnotationConfigApplicationContext context,</span></span><br><span class="line"><span class="params">                              ContextAnnotationAutowireCandidateResolver resolver)</span> &#123;</span><br><span class="line">        <span class="type">DependencyDescriptor</span> <span class="variable">dd1</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;home&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 获取 @Value 的内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> resolver.getSuggestedValue(dd1).toString();</span><br><span class="line">        System.out.println(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析 $&#123;&#125;</span></span><br><span class="line">        value = context.getEnvironment().resolvePlaceholders(value);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$&#123;JAVA_HOME&#125;</span><br><span class="line">D:\environment\JDK1<span class="number">.8</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">(AnnotationConfigApplicationContext context,</span></span><br><span class="line"><span class="params">                          ContextAnnotationAutowireCandidateResolver resolver)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd1</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;age&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 获取 @Value 的内容</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> resolver.getSuggestedValue(dd1).toString();</span><br><span class="line">    System.out.println(<span class="string">&quot;@Value 的 value 属性值: &quot;</span> + value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 $&#123;&#125;</span></span><br><span class="line">    value = context.getEnvironment().resolvePlaceholders(value);</span><br><span class="line">    System.out.println(<span class="string">&quot;解析得到的值: &quot;</span> + value);</span><br><span class="line">    System.out.println(<span class="string">&quot;解析得到的值的类型: &quot;</span> + value.getClass());</span><br><span class="line">    <span class="comment">// 转成字段的类型</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">age</span> <span class="operator">=</span> context.getBeanFactory()</span><br><span class="line">        .getTypeConverter()</span><br><span class="line">        .convertIfNecessary(value, dd1.getDependencyType());</span><br><span class="line">    System.out.println(<span class="string">&quot;转换后的类型: &quot;</span> + age.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Value</span> 的 value 属性值: <span class="number">18</span></span><br><span class="line">解析得到的值: <span class="number">18</span></span><br><span class="line">解析得到的值的类型: <span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">转换后的类型: <span class="keyword">class</span> <span class="title class_">java</span>.lang.Integer</span><br></pre></td></tr></table></figure><p>EL 表达式的解析</p><p>假设有如下几个类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;@bean3&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Bean3 bean3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;bean3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean3</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean4</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;&#x27;hello, &#x27; + &#x27;$&#123;JAVA_HOME&#125;&#x27;&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样要求解析 @Value 中的 value 属性值。</p><p>如果沿用 test2() 方法进行解析，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value</span> 的 value 属性值: #&#123;<span class="meta">@bean3</span>&#125;</span><br><span class="line">解析得到的值: #&#123;<span class="meta">@bean3</span>&#125;</span><br><span class="line">解析得到的值的类型: <span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> org.springframework.beans.ConversionNotSupportedException: Failed to convert value of type <span class="string">&#x27;java.lang.String&#x27;</span> to required type <span class="string">&#x27;indi.lcp.a46.A46$Bean3&#x27;</span>; nested exception is java.lang.IllegalStateException: Cannot convert value of type <span class="string">&#x27;java.lang.String&#x27;</span> to required type <span class="string">&#x27;indi.lcp.a46.A46$Bean3&#x27;</span>: no matching editors or conversion strategy found</span><br></pre></td></tr></table></figure><p>最后一步数据转换出了问题，无法将 String 转换成 A46$Bean3 类型，也就是说解析 @bean3 失败了，程序仍然把它当成字符串，而不是注入的 Bean。</p><p>为了解析成功，需要在转换前解析 #{}：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    test3(context, resolver, Bean2.class.getDeclaredField(<span class="string">&quot;bean3&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    test3(context, resolver, Bean4.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">(AnnotationConfigApplicationContext context,</span></span><br><span class="line"><span class="params">                          ContextAnnotationAutowireCandidateResolver resolver,</span></span><br><span class="line"><span class="params">                          Field field)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(field, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 获取 @Value 的内容</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> resolver.getSuggestedValue(dd1).toString();</span><br><span class="line">    System.out.println(<span class="string">&quot;@Value 的 value 属性值: &quot;</span> + value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 $&#123;&#125;</span></span><br><span class="line">    value = context.getEnvironment().resolvePlaceholders(value);</span><br><span class="line">    System.out.println(<span class="string">&quot;解析得到的值: &quot;</span> + value);</span><br><span class="line">    System.out.println(<span class="string">&quot;解析得到的值的类型: &quot;</span> + value.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 #&#123;&#125;</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean3</span> <span class="operator">=</span> context.getBeanFactory()</span><br><span class="line">        .getBeanExpressionResolver()</span><br><span class="line">        .evaluate(value, <span class="keyword">new</span> <span class="title class_">BeanExpressionContext</span>(context.getBeanFactory(), <span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型转换</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> context.getBeanFactory()</span><br><span class="line">        .getTypeConverter()</span><br><span class="line">        .convertIfNecessary(bean3, dd1.getDependencyType());</span><br><span class="line">    System.out.println(<span class="string">&quot;转换后的类型: &quot;</span> + result.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Value</span> 的 value 属性值: #&#123;<span class="meta">@bean3</span>&#125;</span><br><span class="line">解析得到的值: #&#123;<span class="meta">@bean3</span>&#125;</span><br><span class="line">解析得到的值的类型: <span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">转换后的类型: <span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a46.A46$Bean3</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"><span class="meta">@Value</span> 的 value 属性值: #&#123;<span class="string">&#x27;hello, &#x27;</span> + <span class="string">&#x27;$&#123;JAVA_HOME&#125;&#x27;</span>&#125;</span><br><span class="line">解析得到的值: #&#123;<span class="string">&#x27;hello, &#x27;</span> + <span class="string">&#x27;D:\environment\JDK1.8&#x27;</span>&#125;</span><br><span class="line">解析得到的值的类型: <span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">转换后的类型: <span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br></pre></td></tr></table></figure><h1 id="Autowired-注入底层"><a href="#Autowired-注入底层" class="headerlink" title="@Autowired 注入底层"></a>@Autowired 注入底层</h1><h2 id="47-1-注入方式"><a href="#47-1-注入方式" class="headerlink" title="47.1 注入方式"></a>47.1 注入方式</h2><p>按成员变量类型注入</p><p>现有一 Bean1 类如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要被注入的对象所在类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;bean2&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从容器中获取需要被注入的 Bean 对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A47_1</span>&#123;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A47_1.class);</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getDefaultListableBeanFactory();</span><br><span class="line">        </span><br><span class="line">        <span class="type">DependencyDescriptor</span> <span class="variable">dd1</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;bean2&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">        System.out.println(beanFactory.doResolveDependency(dd1, <span class="string">&quot;bean1&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.a47.A47_1$Bean2@222545dc</span><br></pre></td></tr></table></figure><p>按参数类型注入</p><p>对 Bean1 进行修改：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean2</span><span class="params">(Bean2 bean2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bean2 = bean2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 setBean2() 方法的 Bean2 类型参数进行注入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">setBean2</span> <span class="operator">=</span> Bean1.class.getDeclaredMethod(<span class="string">&quot;setBean2&quot;</span>, Bean2.class);</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd2</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(<span class="keyword">new</span> <span class="title class_">MethodParameter</span>(setBean2, <span class="number">0</span>), <span class="literal">false</span>);</span><br><span class="line">    System.out.println(beanFactory.doResolveDependency(dd2, <span class="string">&quot;bean1&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.a47.A47_1$Bean2@222545dc</span><br></pre></td></tr></table></figure><p>包装为 Optional<Bean2></p><p>对 Bean1 进行修改：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Optional&lt;Bean2&gt; bean3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接按照以下方式获取 DependencyDescriptor 对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DependencyDescriptor</span> <span class="variable">dd3</span> <span class="operator">=</span> </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;bean3&quot;</span>), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>其 dd3.getDependencyType() 方法将返回 Optional 的 Class 对象，这显然是不对的。</p><p>Spring 提供为 DependencyDescriptor 提供了解决这个问题的方法，即“增加嵌套等级”来获取内嵌类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dd3.increaseNestingLevel();</span><br></pre></td></tr></table></figure><p>执行 increaseNestingLevel() 方法后，dd3.getDependencyType() 方法返回的 Bean2 的 Class 对象。</p><p>因此注入 Optional<Bean2> 类型的成员变量应该按照：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd3</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;bean3&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (Optional.class.equals(dd3.getDependencyType())) &#123;</span><br><span class="line">        dd3.increaseNestingLevel();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> beanFactory.doResolveDependency(dd3, <span class="string">&quot;bean1&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(Optional.ofNullable(result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Optional[indi.lcp.a47.A47_1$Bean2@222545dc]</span><br></pre></td></tr></table></figure><p>注入 Optional 对象和使用 @Autowired(required &#x3D; false) 的作用是一样的，当容器中不存在目标 Bean 时，不会抛出 NoSuchBeanDefinitionException 异常。</p><p>包装为 ObjectFactory<Bean2></p><p>对 Bean1 进行修改：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectFactory&lt;Bean2&gt; bean4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入 ObjectFactory<Bean2> 类型的对象与注入 Optional<Bean2> 类型的对象类似，只不过 ObjectFactory 提供了 延迟注入 的能力，也就是说 Bean2 对象不会立即被注入，而是在需要时才被注入。</p><p>ObjectFactory 是一个函数式接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObjectFactory</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入的应该是 ObjectFactory 对象，在调用该对象的 getObject() 方法时，Bean2 对象才被注入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd4</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;bean4&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (ObjectFactory.class.equals(dd4.getDependencyType())) &#123;</span><br><span class="line">        dd4.increaseNestingLevel();</span><br><span class="line">        ObjectFactory&lt;Bean2&gt; objectFactory = () -&gt;</span><br><span class="line">            (Bean2) beanFactory.doResolveDependency(dd4, <span class="string">&quot;bean1&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(objectFactory.getObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.a47.A47_1$Bean2@222545dc</span><br></pre></td></tr></table></figure><p>与 ObjectFactory 类似的还有个名为 ObjectProvider 的接口，后者继承了前者。</p><p>与 ObjectFactory 相比，ObjectProvider 提供了类似于 Optional 的安全注入功能，当容器中不存在目标 Bean 时， 不会抛出 NoSuchBeanDefinitionException 异常。ObjectProvider 提供的 getIfAvailable() 在获取不存在的 Bean 时，不会抛出异常，而是返回 null。</p><p>对 @Lazy 的处理</p><p>对 Bean1 进行修改，在成员变量 bean2 上使用 @Lazy 注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 @Lazy 注解标记的成员变量，注入的对象不再是目标对象，而是其代理对象，因此不能使用 DefaultListableBeanFactory 对象的 doResolveDependency() 方法来获取注入的对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd5</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;bean2&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="type">ContextAnnotationAutowireCandidateResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>();</span><br><span class="line">    resolver.setBeanFactory(beanFactory);</span><br><span class="line">    <span class="comment">// 根据 @Lazy 创建代理对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> resolver.getLazyResolutionProxyIfNecessary(dd5, <span class="string">&quot;bean1&quot;</span>);</span><br><span class="line">    System.out.println(proxy);</span><br><span class="line">    System.out.println(proxy.getClass());</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.a47.A47_1$Bean2@222545dc</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a47.A47_1$Bean2$$EnhancerBySpringCGLIB$$d631a20c</span><br></pre></td></tr></table></figure><p>@Lazy 实现的 延迟注入 （前面讲的 ObjectFactory 和 ObjectProvider 也有延迟注入功能，但与 @Lazy 的实现不一样）不是不注入，而是注入目标对象的代理对象，当使用到代理对象中的方法时，代理对象就会去 Spring 容器中寻找真正的目标对象，然后调用目标对象对应的方法。</p><p>@Lazy 的实现细节可以在 ContextAnnotationAutowireCandidateResolver 中看到：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span> </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">QualifierAnnotationAutowireCandidateResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getLazyResolutionProxyIfNecessary</span><span class="params">(DependencyDescriptor descriptor, </span></span><br><span class="line"><span class="params">                                                    <span class="meta">@Nullable</span> String beanName)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果有 @Lazy 注解，就创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> (isLazy(descriptor) ? </span><br><span class="line">                buildLazyResolutionProxy(descriptor, beanName) : <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isLazy</span><span class="params">(DependencyDescriptor descriptor)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Annotation ann : descriptor.getAnnotations()) &#123;</span><br><span class="line">            <span class="comment">// 获取 @Lazy 注解信息</span></span><br><span class="line">            <span class="type">Lazy</span> <span class="variable">lazy</span> <span class="operator">=</span> AnnotationUtils.getAnnotation(ann, Lazy.class);</span><br><span class="line">            <span class="keyword">if</span> (lazy != <span class="literal">null</span> &amp;&amp; lazy.value()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">MethodParameter</span> <span class="variable">methodParam</span> <span class="operator">=</span> descriptor.getMethodParameter();</span><br><span class="line">        <span class="keyword">if</span> (methodParam != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// --snip--</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">buildLazyResolutionProxy</span><span class="params">(<span class="keyword">final</span> DependencyDescriptor descriptor, </span></span><br><span class="line"><span class="params">                                              <span class="keyword">final</span> <span class="meta">@Nullable</span> String beanName)</span> &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">        <span class="comment">// 获取代理对象</span></span><br><span class="line">        <span class="keyword">return</span> pf.getProxy(dlbf.getBeanClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：包装为 Provider<Bean2></p><p>Provider 接口是由 JSR-330 提出，要想使用此接口，需要导入以下依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.inject&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;</span><br><span class="line">    &lt;!--  不要惊讶，版本号就是 <span class="number">1</span>  --&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>对 Bean1 进行修改：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Provider&lt;Bean2&gt; bean5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入 Provider 类型的对象与注入 ObjectFactory<Bean2> 类型的对象极其相似，Provider 也提供了 延迟注入 的能力，注入的是 Provider 对象，在调用该对象的 get() 方法时，Bean2 对象才被注入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;bean5&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (Provider.class.equals(dd6.getDependencyType())) &#123;</span><br><span class="line">        dd6.increaseNestingLevel();</span><br><span class="line">        Provider&lt;Bean2&gt; provider = () -&gt;</span><br><span class="line">            (Bean2)  beanFactory.doResolveDependency(dd6, <span class="string">&quot;bean1&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(provider.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.a47.A47_1$Bean2@222545dc</span><br></pre></td></tr></table></figure><p>Optional 类型、ObjectFactory 类型、ObjectProvider 类型、JSR-330 提供的类型的注入逻辑可在 DefaultListableBeanFactory#resolveDependency() 方法中看到：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveDependency</span><span class="params">(DependencyDescriptor descriptor,</span></span><br><span class="line"><span class="params">                                <span class="meta">@Nullable</span> String requestingBeanName,</span></span><br><span class="line"><span class="params">                                <span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames,</span></span><br><span class="line"><span class="params">                                <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());</span><br><span class="line">    <span class="keyword">if</span> (Optional.class == descriptor.getDependencyType()) &#123;</span><br><span class="line">        <span class="comment">// 对 Optional 的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ObjectFactory.class == descriptor.getDependencyType() ||</span><br><span class="line">            ObjectProvider.class == descriptor.getDependencyType()) &#123;</span><br><span class="line">        <span class="comment">// 对 ObjectFactory、ObjectProvider 的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;</span><br><span class="line">        <span class="comment">// 对 JSR-330 提供的类型的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="47-2-类型匹配细节"><a href="#47-2-类型匹配细节" class="headerlink" title="47.2 类型匹配细节"></a>47.2 类型匹配细节</h2><p>无论是 @Value 注入，还是 @Autowired 注入，最终都会调用 DefaultListableBeanFactory#doResolveDependency() 方法。</p><p>现有如下几个类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Dao</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;dao1&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Dao1</span> <span class="keyword">implements</span> <span class="title class_">Dao</span>&lt;Student&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;dao2&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Dao2</span> <span class="keyword">implements</span> <span class="title class_">Dao</span>&lt;Teacher&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;service1&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service1</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;service2&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service2</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;service3&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service3</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一目标类 Target，对其进行依赖注入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Service[] serviceArray;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Service&gt; serviceList;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConfigurableApplicationContext applicationContext;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Dao&lt;Teacher&gt; dao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;service2&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组类型</p><p>Spring 容器中肯定不存在数组类型且元素类型为 Service 的 Bean 对象，因此注入的 Service 数组应当是容器中 Service 类型的 Bean 数组：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A47_2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A47_2.class);</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getDefaultListableBeanFactory();</span><br><span class="line"></span><br><span class="line">        testArray(beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testArray</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">        <span class="type">DependencyDescriptor</span> <span class="variable">dd1</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Target.class.getDeclaredField(<span class="string">&quot;serviceArray&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (dd1.getDependencyType().isArray()) &#123;</span><br><span class="line">            <span class="comment">// 获取数组中的元素类型</span></span><br><span class="line">            Class&lt;?&gt; componentType = dd1.getDependencyType().getComponentType();</span><br><span class="line">            System.out.println(componentType);</span><br><span class="line">            String[] names = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">                beanFactory, </span><br><span class="line">                componentType</span><br><span class="line">            );</span><br><span class="line">            List&lt;Object&gt; beans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> dd1.resolveCandidate(name, componentType, beanFactory);</span><br><span class="line">                beans.add(bean);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">array</span> <span class="operator">=</span> beanFactory.getTypeConverter()</span><br><span class="line">                .convertIfNecessary(beans, dd1.getDependencyType());</span><br><span class="line">            System.out.println(array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">indi</span>.lcp.a47.A47_2$Service</span><br><span class="line">service3</span><br><span class="line">service2</span><br><span class="line">service1</span><br><span class="line">[Lindi.lcp.a47.A47_2$Service;@<span class="number">49139829</span></span><br></pre></td></tr></table></figure><p>相关源码可在 DefaultListableBeanFactory#resolveMultipleBeans() 方法中看到。</p><p>List 类型</p><p>注入 List<Service> 类型数据的逻辑与注入 Service[] 类型数据的逻辑类似，只不过在容器中寻找目标 Bean 时不再通过数组元素类型，而是通过 List 的泛型类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd2</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Target.class.getDeclaredField(<span class="string">&quot;serviceList&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (List.class.equals(dd2.getDependencyType())) &#123;</span><br><span class="line">        <span class="comment">// 获取泛型信息</span></span><br><span class="line">        Class&lt;?&gt; resolve = dd2.getResolvableType().getGeneric().resolve();</span><br><span class="line">        System.out.println(resolve);</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        String[] names = </span><br><span class="line">            BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, resolve);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> dd2.resolveCandidate(name, resolve, beanFactory);</span><br><span class="line">            list.add(bean);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">indi</span>.lcp.a47.A47_2$Service</span><br><span class="line">[indi.lcp.a47.A47_2$Service3@35e2d654, indi.lcp.a47.A47_2$Service2@1bd4fdd, indi.lcp.a47.A47_2$Service1@55183b20]</span><br></pre></td></tr></table></figure><p>注意： 对于注入的集合类型数据，注入的类型必须是 Collection 及其 子接口，比如不支持直接注入 ArrayList 类型的数据。</p><p>相关源码可在 DefaultListableBeanFactory#resolveMultipleBeans() 方法中看到：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">resolveMultipleBeans</span><span class="params">(DependencyDescriptor descriptor, </span></span><br><span class="line"><span class="params">                                    <span class="meta">@Nullable</span> String beanName,</span></span><br><span class="line"><span class="params">                                    <span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, </span></span><br><span class="line"><span class="params">                                    <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line">    <span class="keyword">if</span> (descriptor <span class="keyword">instanceof</span> StreamDependencyDescriptor) &#123;</span><br><span class="line">                <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (type.isArray()) &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Collection.class.isAssignableFrom(type) &amp;&amp; type.isInterface()) &#123;</span><br><span class="line">        <span class="comment">// 就是这里的判断</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Map.class == type) &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看到，@Autowired 还支持 Map 类型数据的注入，此时注入的 Map 的 key 是 Bean 的名称，value 是 Bean 对象，这种方式常常配合策略模式使用。需要注意的是，只支持注入 Map 接口，不支持其子类。</p><p>特殊类型 ConfigurableApplicationContext</p><p>ConfigurableApplicationContext 是 ApplicationContext 接口的子接口。</p><p>需要注意的是，在 Spring 容器中并不存在 ConfigurableApplicationContext 类型、或 ApplicationContext 类型的 Bean。</p><p>Spring 容器中的所有单例 Bean 对象存放在 DefaultListableBeanFactory 中，在 DefaultListableBeanFactory 父类 DefaultSingletonBeanRegistry 中有一成员变量：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>singletonObjects 用于存放 Spring 容器中的所有单例 Bean 对象。</p><p>类似 ApplicationContext、BeanFactory 类型的对象则是放在 DefaultListableBeanFactory 中的 resolvableDependencies 中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractAutowireCapableBeanFactory</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ConfigurableListableBeanFactory</span>, BeanDefinitionRegistry, Serializable &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; resolvableDependencies = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些特殊对象是在调用 ApplicationContext 的 refresh() 方法时添加到 resolvableDependencies 中的。可在 AbstractApplicationContext 的 refresh() 方法中看到：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">    <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="built_in">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="built_in">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此在注入诸如 ConfigurableApplicationContext 特殊类型的对象时，不能直接使用 getBean() 方法获取，而是应该从 resolvableDependencies 集合中获取。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testApplicationContext</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(</span><br><span class="line">        Target.class.getDeclaredField(<span class="string">&quot;applicationContext&quot;</span>), </span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    );</span><br><span class="line">    <span class="type">Field</span> <span class="variable">resolvableDependencies</span> <span class="operator">=</span> </span><br><span class="line">        DefaultListableBeanFactory.class.getDeclaredField(<span class="string">&quot;resolvableDependencies&quot;</span>);</span><br><span class="line">    resolvableDependencies.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Object&gt; dependencies = </span><br><span class="line">        (Map&lt;Class&lt;?&gt;, Object&gt;) resolvableDependencies.get(beanFactory);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : dependencies.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 左边类型                      右边类型</span></span><br><span class="line">        <span class="keyword">if</span> (entry.getKey().isAssignableFrom(dd3.getDependencyType())) &#123;</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">org.springframework.beans.factory.support.DefaultListableBeanFactory@<span class="number">7364985f</span>: defining beans</span><br><span class="line"> [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor,</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor,</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor,</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory,</span><br><span class="line">a47_2,service3,service2,service1,dao2,dao1]; root of factory hierarchy</span><br></pre></td></tr></table></figure><p>泛型类型</p><p>容器中 Dao 类型的 Bean 有多个，而依赖注入的是 Dao<Teacher> 类型的对象，因此需要判断容器中的 Bean 对象泛型类型是否为指定类型。判断逻辑可以使用 ContextAnnotationAutowireCandidateResolver 的 isAutowireCandidate() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testGeneric</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd4</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Target.class.getDeclaredField(<span class="string">&quot;dao&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">    Class&lt;?&gt; type = dd4.getDependencyType();</span><br><span class="line">    <span class="type">ContextAnnotationAutowireCandidateResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>();</span><br><span class="line">    resolver.setBeanFactory(beanFactory);</span><br><span class="line">    <span class="comment">// 循环所有的目标类型 Bean 名称</span></span><br><span class="line">    <span class="keyword">for</span> (String name : BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, type)) &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> beanFactory.getMergedBeanDefinition(name);</span><br><span class="line">        <span class="comment">// 对比 BeanDefinition 的泛型与 DependencyDescriptor 的泛型是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (resolver.isAutowireCandidate(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(bd, name), dd4)) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(dd4.resolveCandidate(name, type, beanFactory));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dao2</span><br><span class="line">indi.lcp.a47.A47_2$Dao2@74f0ea28</span><br></pre></td></tr></table></figure><p>@Qualifier</p><p>当容器中存在多个相同类型的 Bean 对象，在执行依赖注入时可以使用 @Qualifier 注解来指定需要注入的 Bean 对象的名称。判断逻辑同样使用 ContextAnnotationAutowireCandidateResolver 的 isAutowireCandidate() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testQualifier</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd5</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Target.class.getDeclaredField(<span class="string">&quot;service&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">    Class&lt;?&gt; type = dd5.getDependencyType();</span><br><span class="line">    <span class="type">ContextAnnotationAutowireCandidateResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>();</span><br><span class="line">    resolver.setBeanFactory(beanFactory);</span><br><span class="line">    <span class="keyword">for</span> (String name : BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, type)) &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> beanFactory.getMergedBeanDefinition(name);</span><br><span class="line">        <span class="comment">// DependencyDescriptor 对象中包含了 @Qualifier 注解信息</span></span><br><span class="line">        <span class="keyword">if</span> (resolver.isAutowireCandidate(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(bd, name), dd5)) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(dd5.resolveCandidate(name, type, beanFactory));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">service2</span><br><span class="line">indi.lcp.a47.A47_2$Service2@1bd4fdd</span><br></pre></td></tr></table></figure><p>@Primary</p><p>当容器中存在多个相同类型的 Bean 对象时，在执行依赖注入时除了可以使用 @Qualifier 注解外，还可以在被注入的 Bean 对象所在类上使用 @Primary 注解，指定执行依赖注入时使用的主要 Bean 对象。</p><p>如果 Bean 对象的所在类 被 @Primary 注解标记，那么在构造 BeanDefinition 时就会记录这个信息。</p><p>通常情况下，@Primary 注解只有一个作用在同种类型的 Bean 上，存在多个时，Spring 依旧无法区分。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target1</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;service1&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service1</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@Component(&quot;service2&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service2</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;service3&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service3</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPrimary</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Target1.class.getDeclaredField(<span class="string">&quot;service&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    Class&lt;?&gt; type = dd.getDependencyType();</span><br><span class="line">    <span class="keyword">for</span> (String name : BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, type)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory.getMergedBeanDefinition(name).isPrimary()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;primary: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">primary: service2</span><br></pre></td></tr></table></figure><p>默认规则</p><p>当容器中存在多个相同类型的 Bean 对象时，除了使用 @Qualifier 或 @Primary 注解外，@Autowired 注解还支持按照成员变量名称进行匹配。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target2</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Service service3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;service1&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service1</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@Component(&quot;service2&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service2</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;service3&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service3</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testDefault</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Target2.class.getDeclaredField(<span class="string">&quot;service3&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    Class&lt;?&gt; type = dd.getDependencyType();</span><br><span class="line">    <span class="keyword">for</span> (String name : BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, type)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(dd.getDependencyName())) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;default: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: service3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE3学习总结</title>
      <link href="/2024/07/01/VUE3%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/07/01/VUE3%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>这个专栏主要是为了记录一下我学习vue3的的路程，因为现在对开发人员的要求更高了，所以后端开发也要必须掌握一些前端框架，之前学习过vue2,后来看到vue2停止更新了，选择学习vue3,学完后发现确实大部分新特性要比vue2更方便一些，虽然感觉有些地方不如vue2,最后赞叹一下发明vue框架的作者真是个天才。期待将来可以成为像他一样的人</p><p>这几篇老文章都是我之前用飞书云文档写的，因转换格式问题，本文之前已写完的文档图片太多了，不想一一转化了，大家可以访问我的飞书云文档来查看这些图片–<a href="https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e,%E4%B8%8D%E8%BF%87%E5%90%8E%E7%BB%AD%E8%A1%A5%E5%85%85%E7%9A%84%E9%83%BD%E4%BC%9A%E6%9C%89%E5%9B%BE%E7%89%87">https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e,不过后续补充的都会有图片</a></p><h1 id="1-Vue3简介"><a href="#1-Vue3简介" class="headerlink" title="1. Vue3简介"></a>1. Vue3简介</h1><ul><li>2020年9月18日，<code>Vue.js</code>发布版<code>3.0</code>版本，代号：<code>One Piece</code>（n</li><li>经历了：<a href="https://github.com/vuejs/core/commits/main">4800+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">40+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/core/graphs/contributors">300+贡献者</a></li><li>官方发版地址：<a href="https://github.com/vuejs/core/releases/tag/v3.0.0">Release v3.0.0 One Piece · vuejs&#x2F;core</a></li><li>截止2023年10月，最新的公开版本为：<code>3.3.4</code></li></ul><h2 id="1-1-【性能的提升】"><a href="#1-1-【性能的提升】" class="headerlink" title="1.1. 【性能的提升】"></a>1.1. 【性能的提升】</h2><ul><li>打包大小减少<code>41%</code>。</li><li>初次渲染快<code>55%</code>, 更新渲染快<code>133%</code>。</li><li>内存减少<code>54%</code>。</li></ul><h2 id="1-2-【-源码的升级】"><a href="#1-2-【-源码的升级】" class="headerlink" title="1.2.【 源码的升级】"></a>1.2.【 源码的升级】</h2><ul><li>使用<code>Proxy</code>代替<code>defineProperty</code>实现响应式。</li><li>重写虚拟<code>DOM</code>的实现和<code>Tree-Shaking</code>。</li></ul><h2 id="1-3-【拥抱TypeScript】"><a href="#1-3-【拥抱TypeScript】" class="headerlink" title="1.3. 【拥抱TypeScript】"></a>1.3. 【拥抱TypeScript】</h2><ul><li><code>Vue3</code>可以更好的支持<code>TypeScript</code>。</li></ul><h2 id="1-4-【新的特性】"><a href="#1-4-【新的特性】" class="headerlink" title="1.4. 【新的特性】"></a>1.4. 【新的特性】</h2><ol><li><code>Composition API</code>（组合<code>API</code>）：<ol><li><code>setup</code></li><li><code>ref</code>与<code>reactive</code></li><li><code>computed</code>与<code>watch</code></li><li>……</li></ol></li><li>新的内置组件：<ol><li><code>Fragment</code></li><li><code>Teleport</code></li><li><code>Suspense</code></li><li>……</li></ol></li><li>其他改变：<ol><li>新的生命周期钩子</li><li><code>data</code> 选项应始终被声明为一个函数</li><li>移除<code>keyCode</code>支持作为<code>v-on</code> 的修饰符</li><li>……</li></ol></li></ol><h1 id="2-创建Vue3工程"><a href="#2-创建Vue3工程" class="headerlink" title="2. 创建Vue3工程"></a>2. 创建Vue3工程</h1><h2 id="2-1-【基于-vue-cli-创建】"><a href="#2-1-【基于-vue-cli-创建】" class="headerlink" title="2.1. 【基于 vue-cli 创建】"></a>2.1. 【基于 vue-cli 创建】</h2><p>点击查看<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">官方文档</a></p><blockquote><p>备注：目前<code>vue-cli</code>已处于维护模式，官方推荐基于 <code>Vite</code> 创建项目。</p></blockquote><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span></span><br><span class="line">vue <span class="literal">--version</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装或者升级你的@vue/cli </span></span><br><span class="line">npm install <span class="literal">-g</span> @vue/<span class="built_in">cli</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 执行创建命令</span></span><br><span class="line">vue create vue_test</span><br><span class="line"></span><br><span class="line"><span class="comment">##  随后选择3.x</span></span><br><span class="line"><span class="comment">##  Choose a version of Vue.js that you want to start the project with (Use arrow keys)</span></span><br><span class="line"><span class="comment">##  &gt; 3.x</span></span><br><span class="line"><span class="comment">##    2.x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 启动</span></span><br><span class="line"><span class="built_in">cd</span> vue_test</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><h2 id="2-2-【基于-vite-创建】-推荐"><a href="#2-2-【基于-vite-创建】-推荐" class="headerlink" title="2.2. 【基于 vite 创建】(推荐)"></a>2.2. 【基于 vite 创建】(推荐)</h2><p><code>vite</code> 是新一代前端构建工具，官网地址：<a href="https://vitejs.cn/">https://vitejs.cn</a>，<code>vite</code>的优势如下：</p><ul><li>轻量快速的热重载（<code>HMR</code>），能实现极速的服务启动。</li><li>对 <code>TypeScript</code>、<code>JSX</code>、<code>CSS</code> 等支持开箱即用。</li><li>真正的按需编译，不再等待整个应用编译完成。</li><li><code>webpack</code>构建 与 <code>vite</code>构建对比图如下：</li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NzgzZWNiZGQ0OTFkZTVlYTYwYTQ4YTA2NDE3ZTJlZjVfbmdxYmdYS016VFBhWU9rREM4ZDI3WmtVQlgxelZiR0dfVG9rZW46Sml1VWI4ZFIzb2RPbVB4OUtlOWNseW5PbjNkXzE3MTk4MTA1ODE6MTcxOTgxNDE4MV9WNA" alt="img"></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YmQwZDFmZWM2OTczMTNkOTM0NDZiMjBlZmMyYzM0NWZfWHFUT1JHR211eEVtZExrVGltVVJKNEJXWWdBS1RCaHJfVG9rZW46UEpLSGJaS1Rvb0w0d0F4a3FoWWNWRlJMbmViXzE3MTk4MTA1ODE6MTcxOTgxNDE4MV9WNA" alt="img"></p><ul><li>具体操作如下（点击查看<a href="https://cn.vuejs.org/guide/quick-start.html#creating-a-vue-application">官方文档</a>）</li></ul><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 1.创建命令</span></span><br><span class="line">npm create vue@latest</span><br><span class="line"></span><br><span class="line"><span class="comment">## 2.具体配置</span></span><br><span class="line"><span class="comment">## 配置项目名称</span></span><br><span class="line">√ Project name: vue3_test</span><br><span class="line"><span class="comment">## 是否添加TypeScript支持</span></span><br><span class="line">√ Add TypeScript?  Yes</span><br><span class="line"><span class="comment">## 是否添加JSX支持</span></span><br><span class="line">√ Add JSX Support?  No</span><br><span class="line"><span class="comment">## 是否添加路由环境</span></span><br><span class="line">√ Add Vue Router <span class="keyword">for</span> Single Page Application development?  No</span><br><span class="line"><span class="comment">## 是否添加pinia环境</span></span><br><span class="line">√ Add Pinia <span class="keyword">for</span> state management?  No</span><br><span class="line"><span class="comment">## 是否添加单元测试</span></span><br><span class="line">√ Add Vitest <span class="keyword">for</span> Unit Testing?  No</span><br><span class="line"><span class="comment">## 是否添加端到端测试方案</span></span><br><span class="line">√ Add an <span class="keyword">End</span><span class="literal">-to-End</span> Testing Solution? » No</span><br><span class="line"><span class="comment">## 是否添加ESLint语法检查</span></span><br><span class="line">√ Add ESLint <span class="keyword">for</span> code quality?  Yes</span><br><span class="line"><span class="comment">## 是否添加Prettiert代码格式化</span></span><br><span class="line">√ Add Prettier <span class="keyword">for</span> code formatting?  No</span><br></pre></td></tr></table></figure><p>自己动手编写一个App组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h1&gt;你好啊！&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name:&#x27;App&#x27; //组件名</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .app &#123;</span><br><span class="line">    background-color: #ddd;</span><br><span class="line">    box-shadow: 0 0 10px;</span><br><span class="line">    border-radius: 10px;</span><br><span class="line">    padding: 20px;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><code>Vite</code> 项目中，<code>index.html</code> 是项目的入口文件，在项目最外层。</li><li>加载<code>index.html</code>后，<code>Vite</code> 解析 <code>&lt;script type=&quot;module&quot; src=&quot;xxx&quot;&gt;</code> 指向的<code>JavaScript</code>。</li><li><code>Vue3</code>**中是通过 **<code>createApp</code> 函数创建一个应用实例。</li></ul><h2 id="2-3-【一个简单的效果】"><a href="#2-3-【一个简单的效果】" class="headerlink" title="2.3. 【一个简单的效果】"></a>2.3. 【一个简单的效果】</h2><p><code>Vue3</code>向下兼容<code>Vue2</code>语法，且<code>Vue3</code>中的模板中可以没有根标签</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeAge&quot;&gt;年龄+1&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name:&#x27;App&#x27;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        name:&#x27;张三&#x27;,</span><br><span class="line">        age:18,</span><br><span class="line">        tel:&#x27;13888888888&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">      changeName()&#123;</span><br><span class="line">        this.name = &#x27;zhang-san&#x27;</span><br><span class="line">      &#125;,</span><br><span class="line">      changeAge()&#123;</span><br><span class="line">        this.age += 1</span><br><span class="line">      &#125;,</span><br><span class="line">      showTel()&#123;</span><br><span class="line">        alert(this.tel)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="3-Vue3核心语法"><a href="#3-Vue3核心语法" class="headerlink" title="3. Vue3核心语法"></a>3. Vue3核心语法</h1><h2 id="3-1-【OptionsAPI-与-CompositionAPI】"><a href="#3-1-【OptionsAPI-与-CompositionAPI】" class="headerlink" title="3.1. 【OptionsAPI 与 CompositionAPI】"></a>3.1. 【OptionsAPI 与 CompositionAPI】</h2><ul><li><code>Vue2</code>的<code>API</code>设计是<code>Options</code>（配置）风格的。</li><li><code>Vue3</code>的<code>API</code>设计是<code>Composition</code>（组合）风格的。</li></ul><h3 id="Options-API-的弊端"><a href="#Options-API-的弊端" class="headerlink" title="Options API 的弊端"></a>Options API 的弊端</h3><p><code>Options</code>类型的 <code>API</code>，数据、方法、计算属性等，是分散在：<code>data</code>、<code>methods</code>、<code>computed</code>中的，若想新增或者修改一个需求，就需要分别修改：<code>data</code>、<code>methods</code>、<code>computed</code>，不便于维护和复用。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MGE5MTkwYmVjMjA0YzI5NTVhZTA5MjJkZmQ0MTg3ZjFfdkRqMTRiWUxSTFg1bFR2aWR6MElkQ3l6dmZFNjNlakNfVG9rZW46Rmo3WmJ0TTRpbzl1TU54Y2ZEd2N4dnJQbnlkXzE3MTk4MTA1ODE6MTcxOTgxNDE4MV9WNA" alt="img"><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NTM0YjI4OGIzYzRhODBkOTBlNmNjMzU5M2M0YWRjODhfbWlFQURLOXc5S3AzM2I3T2hCM2pDMzVjVlZONVFKdG9fVG9rZW46V0dpVGI1S1NOb3hsOXR4Qk5RcWNNSkd5bjFiXzE3MTk4MTA1ODE6MTcxOTgxNDE4MV9WNA" alt="img"></p><h3 id="Composition-API-的优势"><a href="#Composition-API-的优势" class="headerlink" title="Composition API 的优势"></a>Composition API 的优势</h3><p>可以用函数的方式，更加优雅的组织代码，让相关功能的代码更加有序的组织在一起。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MGI5MmQ4ZjVkOWMxYzQ3NDM4MDZmNDVkNzQ0MGFmMDlfelFRRGkwcHBjSXltZXhRbzcwNkg1YWFnSjJhaURMSmtfVG9rZW46RjFUdmJaVjRlb3MwY1R4cVM1SGM1Qk5GblJjXzE3MTk4MTA1ODE6MTcxOTgxNDE4MV9WNA" alt="img"><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MDk4OWJiMTY1YzI1OWZhZTIwNzVhMmIyZGVlNTk0OGVfb0hUUENiOWhDdmlPNmwyQmF0cGJLYW11akt2cFVBbjNfVG9rZW46WmpmRWJuWndlb0Rhbmp4dkhuTmNJRVBCbmFkXzE3MTk4MTA1ODE6MTcxOTgxNDE4MV9WNA" alt="img"></p><blockquote><p>说明：以上四张动图原创作者：大帅老猿</p></blockquote><h2 id="3-2-【拉开序幕的-setup】"><a href="#3-2-【拉开序幕的-setup】" class="headerlink" title="3.2. 【拉开序幕的 setup】"></a>3.2. 【拉开序幕的 setup】</h2><h3 id="setup-概述"><a href="#setup-概述" class="headerlink" title="setup 概述"></a>setup 概述</h3><p><code>setup</code>是<code>Vue3</code>中一个新的配置项，值是一个函数，它是 <code>Composition API</code> <strong>“表演的舞台</strong><em><strong>”</strong></em>，组件中所用到的：数据、方法、计算属性、监视……等等，均配置在<code>setup</code>中。</p><p>特点如下：</p><ul><li><code>setup</code>函数返回的对象中的内容，可直接在模板中使用。</li><li><code>setup</code>中访问<code>this</code>是<code>undefined</code>。</li><li><code>setup</code>函数会在<code>beforeCreate</code>之前调用，它是“领先”所有钩子执行的。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeAge&quot;&gt;年龄+1&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name:&#x27;Person&#x27;,</span><br><span class="line">    setup()&#123;</span><br><span class="line">      // 数据，原来写在data中（注意：此时的name、age、tel数据都不是响应式数据）</span><br><span class="line">      let name = &#x27;张三&#x27;</span><br><span class="line">      let age = 18</span><br><span class="line">      let tel = &#x27;13888888888&#x27;</span><br><span class="line"></span><br><span class="line">      // 方法，原来写在methods中</span><br><span class="line">      function changeName()&#123;</span><br><span class="line">        name = &#x27;zhang-san&#x27; //注意：此时这么修改name页面是不变化的</span><br><span class="line">        console.log(name)</span><br><span class="line">      &#125;</span><br><span class="line">      function changeAge()&#123;</span><br><span class="line">        age += 1 //注意：此时这么修改age页面是不变化的</span><br><span class="line">        console.log(age)</span><br><span class="line">      &#125;</span><br><span class="line">      function showTel()&#123;</span><br><span class="line">        alert(tel)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 返回一个对象，对象中的内容，模板中可以直接使用</span><br><span class="line">      return &#123;name,age,tel,changeName,changeAge,showTel&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="setup-的返回值"><a href="#setup-的返回值" class="headerlink" title="setup 的返回值"></a>setup 的返回值</h3><ul><li>若返回一个<strong>对象</strong>：则对象中的：属性、方法等，在模板中均可以直接使用<strong>（重点关注）。</strong></li><li>若返回一个<strong>函数</strong>：则可以自定义渲染内容，代码如下：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">()=&gt;</span> <span class="string">&#x27;你好啊！&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="setup-与-Options-API-的关系"><a href="#setup-与-Options-API-的关系" class="headerlink" title="setup 与 Options API 的关系"></a>setup 与 Options API 的关系</h3><ul><li><code>Vue2</code> 的配置（<code>data</code>、<code>methos</code>……）中<strong>可以访问到</strong> <code>setup</code>中的属性、方法。</li><li>但在<code>setup</code>中<strong>不能访问到</strong><code>Vue2</code>的配置（<code>data</code>、<code>methos</code>……）。</li><li>如果与<code>Vue2</code>冲突，则<code>setup</code>优先。</li></ul><h3 id="setup-语法糖"><a href="#setup-语法糖" class="headerlink" title="setup 语法糖"></a>setup 语法糖</h3><p><code>setup</code>函数有一个语法糖，这个语法糖，可以让我们把<code>setup</code>独立出去，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changAge&quot;&gt;年龄+1&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name:&#x27;Person&#x27;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 下面的写法是setup语法糖 --&gt;</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">  console.log(this) //undefined</span><br><span class="line">  </span><br><span class="line">  // 数据（注意：此时的name、age、tel都不是响应式数据）</span><br><span class="line">  let name = &#x27;张三&#x27;</span><br><span class="line">  let age = 18</span><br><span class="line">  let tel = &#x27;13888888888&#x27;</span><br><span class="line"></span><br><span class="line">  // 方法</span><br><span class="line">  function changName()&#123;</span><br><span class="line">    name = &#x27;李四&#x27;//注意：此时这么修改name页面是不变化的</span><br><span class="line">  &#125;</span><br><span class="line">  function changAge()&#123;</span><br><span class="line">    console.log(age)</span><br><span class="line">    age += 1 //注意：此时这么修改age页面是不变化的</span><br><span class="line">  &#125;</span><br><span class="line">  function showTel()&#123;</span><br><span class="line">    alert(tel)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>扩展：上述代码，还需要编写一个不写<code>setup</code>的<code>script</code>标签，去指定组件名字，比较麻烦，我们可以借助<code>vite</code>中的插件简化</p><ol><li>第一步：<code>npm i vite-plugin-vue-setup-extend -D</code></li><li>第二步：<code>vite.config.ts</code></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueSetupExtend</span> <span class="keyword">from</span> <span class="string">&#x27;vite-plugin-vue-setup-extend&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [ <span class="title class_">VueSetupExtend</span>() ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>第三步：<code>&lt;script setup lang=&quot;ts&quot; name=&quot;Person&quot;&gt;</code></li></ol><h2 id="3-3-【ref-创建：基本类型的响应式数据】"><a href="#3-3-【ref-创建：基本类型的响应式数据】" class="headerlink" title="3.3. 【ref 创建：基本类型的响应式数据】"></a>3.3. 【ref 创建：基本类型的响应式数据】</h2><ul><li><strong>作用：</strong>定义响应式变量。</li><li><strong>语法：</strong><code>let xxx = ref(初始值)</code>。</li><li><strong>返回值：</strong>一个<code>RefImpl</code>的实例对象，简称<code>ref对象</code>或<code>ref</code>，<code>ref</code>对象的<code>value</code><strong>属性是响应式的</strong>。</li><li><strong>注意点：</strong><ul><li><code>JS</code>中操作数据需要：<code>xxx.value</code>，但模板中不需要<code>.value</code>，直接使用即可。</li><li>对于<code>let name = ref(&#39;张三&#39;)</code>来说，<code>name</code>不是响应式的，<code>name.value</code>是响应式的。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h2&gt;姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeAge&quot;&gt;年龄+1&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;showTel&quot;&gt;点我查看联系方式&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123;ref&#125; from &#x27;vue&#x27;</span><br><span class="line">  // name和age是一个RefImpl的实例对象，简称ref对象，它们的value属性是响应式的。</span><br><span class="line">  let name = ref(&#x27;张三&#x27;)</span><br><span class="line">  let age = ref(18)</span><br><span class="line">  // tel就是一个普通的字符串，不是响应式的</span><br><span class="line">  let tel = &#x27;13888888888&#x27;</span><br><span class="line"></span><br><span class="line">  function changeName()&#123;</span><br><span class="line">    // JS中操作ref对象时候需要.value</span><br><span class="line">    name.value = &#x27;李四&#x27;</span><br><span class="line">    console.log(name.value)</span><br><span class="line"></span><br><span class="line">    // 注意：name不是响应式的，name.value是响应式的，所以如下代码并不会引起页面的更新。</span><br><span class="line">    // name = ref(&#x27;zhang-san&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  function changeAge()&#123;</span><br><span class="line">    // JS中操作ref对象时候需要.value</span><br><span class="line">    age.value += 1 </span><br><span class="line">    console.log(age.value)</span><br><span class="line">  &#125;</span><br><span class="line">  function showTel()&#123;</span><br><span class="line">    alert(tel)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-4-【reactive-创建：对象类型的响应式数据】"><a href="#3-4-【reactive-创建：对象类型的响应式数据】" class="headerlink" title="3.4. 【reactive 创建：对象类型的响应式数据】"></a>3.4. 【reactive 创建：对象类型的响应式数据】</h2><ul><li><strong>作用：定义一个响应式对象</strong>（基本类型不要用它，要用<code>ref</code>，否则报错）</li><li><strong>语法：</strong><code>let 响应式对象= reactive(源对象)</code>。</li><li><strong>返回值：</strong>一个<code>Proxy</code>的实例对象，简称：响应式对象。</li><li><strong>注意点：</strong><code>reactive</code>定义的响应式数据是“深层次”的。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h2&gt;汽车信息：一台&#123;&#123; car.brand &#125;&#125;汽车，价值&#123;&#123; car.price &#125;&#125;万&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;游戏列表：&lt;/h2&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;h2&gt;测试：&#123;&#123;obj.a.b.c.d&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeCarPrice&quot;&gt;修改汽车价格&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeFirstGame&quot;&gt;修改第一游戏&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;test&quot;&gt;测试&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">import &#123; reactive &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">// 数据</span><br><span class="line">let car = reactive(&#123; brand: &#x27;奔驰&#x27;, price: 100 &#125;)</span><br><span class="line">let games = reactive([</span><br><span class="line">  &#123; id: &#x27;ahsgdyfa01&#x27;, name: &#x27;英雄联盟&#x27; &#125;,</span><br><span class="line">  &#123; id: &#x27;ahsgdyfa02&#x27;, name: &#x27;王者荣耀&#x27; &#125;,</span><br><span class="line">  &#123; id: &#x27;ahsgdyfa03&#x27;, name: &#x27;原神&#x27; &#125;</span><br><span class="line">])</span><br><span class="line">let obj = reactive(&#123;</span><br><span class="line">  a:&#123;</span><br><span class="line">    b:&#123;</span><br><span class="line">      c:&#123;</span><br><span class="line">        d:666</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function changeCarPrice() &#123;</span><br><span class="line">  car.price += 10</span><br><span class="line">&#125;</span><br><span class="line">function changeFirstGame() &#123;</span><br><span class="line">  games[0].name = &#x27;流星蝴蝶剑&#x27;</span><br><span class="line">&#125;</span><br><span class="line">function test()&#123;</span><br><span class="line">  obj.a.b.c.d = 999</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-5-【ref-创建：对象类型的响应式数据】"><a href="#3-5-【ref-创建：对象类型的响应式数据】" class="headerlink" title="3.5. 【ref 创建：对象类型的响应式数据】"></a>3.5. 【ref 创建：对象类型的响应式数据】</h2><ul><li>其实<code>ref</code>接收的数据可以是：<strong>基本类型</strong>、<strong>对象类型</strong>。</li><li>若<code>ref</code>接收的是对象类型，内部其实也是调用了<code>reactive</code>函数。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h2&gt;汽车信息：一台&#123;&#123; car.brand &#125;&#125;汽车，价值&#123;&#123; car.price &#125;&#125;万&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;游戏列表：&lt;/h2&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;h2&gt;测试：&#123;&#123;obj.a.b.c.d&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeCarPrice&quot;&gt;修改汽车价格&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeFirstGame&quot;&gt;修改第一游戏&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;test&quot;&gt;测试&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">// 数据</span><br><span class="line">let car = ref(&#123; brand: &#x27;奔驰&#x27;, price: 100 &#125;)</span><br><span class="line">let games = ref([</span><br><span class="line">  &#123; id: &#x27;ahsgdyfa01&#x27;, name: &#x27;英雄联盟&#x27; &#125;,</span><br><span class="line">  &#123; id: &#x27;ahsgdyfa02&#x27;, name: &#x27;王者荣耀&#x27; &#125;,</span><br><span class="line">  &#123; id: &#x27;ahsgdyfa03&#x27;, name: &#x27;原神&#x27; &#125;</span><br><span class="line">])</span><br><span class="line">let obj = ref(&#123;</span><br><span class="line">  a:&#123;</span><br><span class="line">    b:&#123;</span><br><span class="line">      c:&#123;</span><br><span class="line">        d:666</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(car)</span><br><span class="line"></span><br><span class="line">function changeCarPrice() &#123;</span><br><span class="line">  car.value.price += 10</span><br><span class="line">&#125;</span><br><span class="line">function changeFirstGame() &#123;</span><br><span class="line">  games.value[0].name = &#x27;流星蝴蝶剑&#x27;</span><br><span class="line">&#125;</span><br><span class="line">function test()&#123;</span><br><span class="line">  obj.value.a.b.c.d = 999</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-6-【ref-对比-reactive】"><a href="#3-6-【ref-对比-reactive】" class="headerlink" title="3.6. 【ref 对比 reactive】"></a>3.6. 【ref 对比 reactive】</h2><p>宏观角度看：</p><ol><li><code>ref</code>用来定义：<strong>基本类型数据</strong>、<strong>对象类型数据</strong>；</li><li><code>reactive</code>用来定义：<strong>对象类型数据</strong>。</li></ol><ul><li>区别：</li></ul><ol><li><code>ref</code>创建的变量必须使用<code>.value</code>（可以使用<code>volar</code>插件自动添加<code>.value</code>）。</li><li><code>reactive</code>重新分配一个新对象，会<strong>失去</strong>响应式（可以使用<code>Object.assign</code>去整体替换）。</li></ol><ul><li>使用原则：</li></ul><ol><li>若需要一个基本类型的响应式数据，必须使用<code>ref</code>。</li><li>若需要一个响应式对象，层级不深，<code>ref</code>、<code>reactive</code>都可以。</li><li>若需要一个响应式对象，且层级较深，推荐使用<code>reactive</code>。</li></ol><h2 id="3-7-【toRefs-与-toRef】"><a href="#3-7-【toRefs-与-toRef】" class="headerlink" title="3.7. 【toRefs 与 toRef】"></a>3.7. 【toRefs 与 toRef】</h2><ul><li>作用：将一个响应式对象中的每一个属性，转换为<code>ref</code>对象。</li><li>备注：<code>toRefs</code>与<code>toRef</code>功能一致，但<code>toRefs</code>可以批量转换。</li><li>语法如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h2&gt;姓名：&#123;&#123;person.name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;年龄：&#123;&#123;person.age&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;性别：&#123;&#123;person.gender&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeGender&quot;&gt;修改性别&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123;ref,reactive,toRefs,toRef&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  // 数据</span><br><span class="line">  let person = reactive(&#123;name:&#x27;张三&#x27;, age:18, gender:&#x27;男&#x27;&#125;)</span><br><span class="line">        </span><br><span class="line">  // 通过toRefs将person对象中的n个属性批量取出，且依然保持响应式的能力</span><br><span class="line">  let &#123;name,gender&#125; =  toRefs(person)</span><br><span class="line">        </span><br><span class="line">  // 通过toRef将person对象中的gender属性取出，且依然保持响应式的能力</span><br><span class="line">  let age = toRef(person,&#x27;age&#x27;)</span><br><span class="line"></span><br><span class="line">  // 方法</span><br><span class="line">  function changeName()&#123;</span><br><span class="line">    name.value += &#x27;~&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  function changeAge()&#123;</span><br><span class="line">    age.value += 1</span><br><span class="line">  &#125;</span><br><span class="line">  function changeGender()&#123;</span><br><span class="line">    gender.value = &#x27;女&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-8-【computed】"><a href="#3-8-【computed】" class="headerlink" title="3.8. 【computed】"></a>3.8. 【computed】</h2><p>作用：根据已有数据计算出新数据（和<code>Vue2</code>中的<code>computed</code>作用一致）。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br&gt;</span><br><span class="line">    名：&lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;br&gt;</span><br><span class="line">    全名：&lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;br&gt;</span><br><span class="line">    &lt;button @click=&quot;changeFullName&quot;&gt;全名改为：li-si&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;App&quot;&gt;</span><br><span class="line">  import &#123;ref,computed&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  let firstName = ref(&#x27;zhang&#x27;)</span><br><span class="line">  let lastName = ref(&#x27;san&#x27;)</span><br><span class="line"></span><br><span class="line">  // 计算属性——只读取，不修改</span><br><span class="line">  /* let fullName = computed(()=&gt;&#123;</span><br><span class="line">    return firstName.value + &#x27;-&#x27; + lastName.value</span><br><span class="line">  &#125;) */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 计算属性——既读取又修改</span><br><span class="line">  let fullName = computed(&#123;</span><br><span class="line">    // 读取</span><br><span class="line">    get()&#123;</span><br><span class="line">      return firstName.value + &#x27;-&#x27; + lastName.value</span><br><span class="line">    &#125;,</span><br><span class="line">    // 修改</span><br><span class="line">    set(val)&#123;</span><br><span class="line">      console.log(&#x27;有人修改了fullName&#x27;,val)</span><br><span class="line">      firstName.value = val.split(&#x27;-&#x27;)[0]</span><br><span class="line">      lastName.value = val.split(&#x27;-&#x27;)[1]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  function changeFullName()&#123;</span><br><span class="line">    fullName.value = &#x27;li-si&#x27;</span><br><span class="line">  &#125; </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-9-【watch】"><a href="#3-9-【watch】" class="headerlink" title="3.9.【watch】"></a>3.9.【watch】</h2><ul><li>作用：监视数据的变化（和<code>Vue2</code>中的<code>watch</code>作用一致）</li><li>特点：<code>Vue3</code>中的<code>watch</code>只能监视以下<strong>四种数据</strong>：</li></ul><ol><li><code>ref</code>定义的数据。</li><li><code>reactive</code>定义的数据。</li><li>函数返回一个值（<code>getter</code>函数）。</li><li>一个包含上述内容的数组。</li></ol><p>我们在<code>Vue3</code>中使用<code>watch</code>的时候，通常会遇到以下几种情况：</p><h3 id="情况一"><a href="#情况一" class="headerlink" title="* 情况一"></a>* 情况一</h3><p>监视<code>ref</code>定义的【基本类型】数据：直接写数据名即可，监视的是其<code>value</code>值的改变。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h1&gt;情况一：监视【ref】定义的【基本类型】数据&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeSum&quot;&gt;点我sum+1&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123;ref,watch&#125; from &#x27;vue&#x27;</span><br><span class="line">  // 数据</span><br><span class="line">  let sum = ref(0)</span><br><span class="line">  // 方法</span><br><span class="line">  function changeSum()&#123;</span><br><span class="line">    sum.value += 1</span><br><span class="line">  &#125;</span><br><span class="line">  // 监视，情况一：监视【ref】定义的【基本类型】数据</span><br><span class="line">  const stopWatch = watch(sum,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;sum变化了&#x27;,newValue,oldValue)</span><br><span class="line">    if(newValue &gt;= 10)&#123;</span><br><span class="line">      stopWatch()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="情况二"><a href="#情况二" class="headerlink" title="* 情况二"></a>* 情况二</h3><p>监视<code>ref</code>定义的【对象类型】数据：直接写数据名，监视的是对象的【地址值】，若想监视对象内部的数据，要手动开启深度监视。</p><blockquote><p>注意：</p></blockquote><ul><li>若修改的是<code>ref</code>定义的对象中的属性，<code>newValue</code> 和 <code>oldValue</code> 都是新值，因为它们是同一个对象。</li><li>若修改整个<code>ref</code>定义的对象，<code>newValue</code> 是新值， <code>oldValue</code> 是旧值，因为不是同一个对象了。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h1&gt;情况二：监视【ref】定义的【对象类型】数据&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changePerson&quot;&gt;修改整个人&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123;ref,watch&#125; from &#x27;vue&#x27;</span><br><span class="line">  // 数据</span><br><span class="line">  let person = ref(&#123;</span><br><span class="line">    name:&#x27;张三&#x27;,</span><br><span class="line">    age:18</span><br><span class="line">  &#125;)</span><br><span class="line">  // 方法</span><br><span class="line">  function changeName()&#123;</span><br><span class="line">    person.value.name += &#x27;~&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  function changeAge()&#123;</span><br><span class="line">    person.value.age += 1</span><br><span class="line">  &#125;</span><br><span class="line">  function changePerson()&#123;</span><br><span class="line">    person.value = &#123;name:&#x27;李四&#x27;,age:90&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  /* </span><br><span class="line">    监视，情况一：监视【ref】定义的【对象类型】数据，监视的是对象的地址值，若想监视对象内部属性的变化，需要手动开启深度监视</span><br><span class="line">    watch的第一个参数是：被监视的数据</span><br><span class="line">    watch的第二个参数是：监视的回调</span><br><span class="line">    watch的第三个参数是：配置对象（deep、immediate等等.....） </span><br><span class="line">  */</span><br><span class="line">  watch(person,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;person变化了&#x27;,newValue,oldValue)</span><br><span class="line">  &#125;,&#123;deep:true&#125;)</span><br><span class="line">  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="情况三"><a href="#情况三" class="headerlink" title="* 情况三"></a>* 情况三</h3><p>监视<code>reactive</code>定义的【对象类型】数据，且默认开启了深度监视。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h1&gt;情况三：监视【reactive】定义的【对象类型】数据&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changePerson&quot;&gt;修改整个人&lt;/button&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;h2&gt;测试：&#123;&#123;obj.a.b.c&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;test&quot;&gt;修改obj.a.b.c&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123;reactive,watch&#125; from &#x27;vue&#x27;</span><br><span class="line">  // 数据</span><br><span class="line">  let person = reactive(&#123;</span><br><span class="line">    name:&#x27;张三&#x27;,</span><br><span class="line">    age:18</span><br><span class="line">  &#125;)</span><br><span class="line">  let obj = reactive(&#123;</span><br><span class="line">    a:&#123;</span><br><span class="line">      b:&#123;</span><br><span class="line">        c:666</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  // 方法</span><br><span class="line">  function changeName()&#123;</span><br><span class="line">    person.name += &#x27;~&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  function changeAge()&#123;</span><br><span class="line">    person.age += 1</span><br><span class="line">  &#125;</span><br><span class="line">  function changePerson()&#123;</span><br><span class="line">    Object.assign(person,&#123;name:&#x27;李四&#x27;,age:80&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  function test()&#123;</span><br><span class="line">    obj.a.b.c = 888</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 监视，情况三：监视【reactive】定义的【对象类型】数据，且默认是开启深度监视的</span><br><span class="line">  watch(person,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;person变化了&#x27;,newValue,oldValue)</span><br><span class="line">  &#125;)</span><br><span class="line">  watch(obj,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;Obj变化了&#x27;,newValue,oldValue)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="情况四"><a href="#情况四" class="headerlink" title="* 情况四"></a>* 情况四</h3><p>监视<code>ref</code>或<code>reactive</code>定义的【对象类型】数据中的<strong>某个属性</strong>，注意点如下：</p><ol><li>若该属性值<strong>不是</strong>【对象类型】，需要写成函数形式。</li><li>若该属性值是<strong>依然</strong>是【对象类型】，可直接编，也可写成函数，建议写成函数。</li></ol><p>结论：监视的要是对象里的属性，那么最好写函数式，注意点：若是对象监视的是地址值，需要关注对象内部，需要手动开启深度监视。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h1&gt;情况四：监视【ref】或【reactive】定义的【对象类型】数据中的某个属性&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;汽车：&#123;&#123; person.car.c1 &#125;&#125;、&#123;&#123; person.car.c2 &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeC1&quot;&gt;修改第一台车&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeC2&quot;&gt;修改第二台车&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeCar&quot;&gt;修改整个车&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123;reactive,watch&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  // 数据</span><br><span class="line">  let person = reactive(&#123;</span><br><span class="line">    name:&#x27;张三&#x27;,</span><br><span class="line">    age:18,</span><br><span class="line">    car:&#123;</span><br><span class="line">      c1:&#x27;奔驰&#x27;,</span><br><span class="line">      c2:&#x27;宝马&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  // 方法</span><br><span class="line">  function changeName()&#123;</span><br><span class="line">    person.name += &#x27;~&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  function changeAge()&#123;</span><br><span class="line">    person.age += 1</span><br><span class="line">  &#125;</span><br><span class="line">  function changeC1()&#123;</span><br><span class="line">    person.car.c1 = &#x27;奥迪&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  function changeC2()&#123;</span><br><span class="line">    person.car.c2 = &#x27;大众&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  function changeCar()&#123;</span><br><span class="line">    person.car = &#123;c1:&#x27;雅迪&#x27;,c2:&#x27;爱玛&#x27;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 监视，情况四：监视响应式对象中的某个属性，且该属性是基本类型的，要写成函数式</span><br><span class="line">  /* watch(()=&gt; person.name,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;person.name变化了&#x27;,newValue,oldValue)</span><br><span class="line">  &#125;) */</span><br><span class="line"></span><br><span class="line">  // 监视，情况四：监视响应式对象中的某个属性，且该属性是对象类型的，可以直接写，也能写函数，更推荐写函数</span><br><span class="line">  watch(()=&gt;person.car,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;person.car变化了&#x27;,newValue,oldValue)</span><br><span class="line">  &#125;,&#123;deep:true&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="情况五"><a href="#情况五" class="headerlink" title="* 情况五"></a>* 情况五</h3><p>监视上述的多个数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h1&gt;情况五：监视上述的多个数据&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;年龄：&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;汽车：&#123;&#123; person.car.c1 &#125;&#125;、&#123;&#123; person.car.c2 &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;修改名字&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeC1&quot;&gt;修改第一台车&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeC2&quot;&gt;修改第二台车&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeCar&quot;&gt;修改整个车&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123;reactive,watch&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  // 数据</span><br><span class="line">  let person = reactive(&#123;</span><br><span class="line">    name:&#x27;张三&#x27;,</span><br><span class="line">    age:18,</span><br><span class="line">    car:&#123;</span><br><span class="line">      c1:&#x27;奔驰&#x27;,</span><br><span class="line">      c2:&#x27;宝马&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  // 方法</span><br><span class="line">  function changeName()&#123;</span><br><span class="line">    person.name += &#x27;~&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  function changeAge()&#123;</span><br><span class="line">    person.age += 1</span><br><span class="line">  &#125;</span><br><span class="line">  function changeC1()&#123;</span><br><span class="line">    person.car.c1 = &#x27;奥迪&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  function changeC2()&#123;</span><br><span class="line">    person.car.c2 = &#x27;大众&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  function changeCar()&#123;</span><br><span class="line">    person.car = &#123;c1:&#x27;雅迪&#x27;,c2:&#x27;爱玛&#x27;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 监视，情况五：监视上述的多个数据</span><br><span class="line">  watch([()=&gt;person.name,person.car],(newValue,oldValue)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;person.car变化了&#x27;,newValue,oldValue)</span><br><span class="line">  &#125;,&#123;deep:true&#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-10-【watchEffect】"><a href="#3-10-【watchEffect】" class="headerlink" title="3.10. 【watchEffect】"></a>3.10. 【watchEffect】</h2><ul><li>官网：立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行该函数。</li><li><code>watch</code>对比<code>watchEffect</code><ul><li>都能监听响应式数据的变化，不同的是监听数据变化的方式不同</li><li><code>watch</code>：要明确指出监视的数据</li><li><code>watchEffect</code>：不用明确指出监视的数据（函数中用到哪些属性，那就监视哪些属性）。</li></ul></li><li>示例代码：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h1&gt;需求：水温达到50℃，或水位达到20cm，则联系服务器&lt;/h1&gt;</span><br><span class="line">    &lt;h2 id=&quot;demo&quot;&gt;水温：&#123;&#123;temp&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;水位：&#123;&#123;height&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changePrice&quot;&gt;水温+1&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeSum&quot;&gt;水位+10&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123;ref,watch,watchEffect&#125; from &#x27;vue&#x27;</span><br><span class="line">  // 数据</span><br><span class="line">  let temp = ref(0)</span><br><span class="line">  let height = ref(0)</span><br><span class="line"></span><br><span class="line">  // 方法</span><br><span class="line">  function changePrice()&#123;</span><br><span class="line">    temp.value += 10</span><br><span class="line">  &#125;</span><br><span class="line">  function changeSum()&#123;</span><br><span class="line">    height.value += 1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 用watch实现，需要明确的指出要监视：temp、height</span><br><span class="line">  watch([temp,height],(value)=&gt;&#123;</span><br><span class="line">    // 从value中获取最新的temp值、height值</span><br><span class="line">    const [newTemp,newHeight] = value</span><br><span class="line">    // 室温达到50℃，或水位达到20cm，立刻联系服务器</span><br><span class="line">    if(newTemp &gt;= 50 || newHeight &gt;= 20)&#123;</span><br><span class="line">      console.log(&#x27;联系服务器&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // 用watchEffect实现，不用</span><br><span class="line">  const stopWtach = watchEffect(()=&gt;&#123;</span><br><span class="line">    // 室温达到50℃，或水位达到20cm，立刻联系服务器</span><br><span class="line">    if(temp.value &gt;= 50 || height.value &gt;= 20)&#123;</span><br><span class="line">      console.log(document.getElementById(&#x27;demo&#x27;)?.innerText)</span><br><span class="line">      console.log(&#x27;联系服务器&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    // 水温达到100，或水位达到50，取消监视</span><br><span class="line">    if(temp.value === 100 || height.value === 50)&#123;</span><br><span class="line">      console.log(&#x27;清理了&#x27;)</span><br><span class="line">      stopWtach()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-11-【标签的-ref-属性】"><a href="#3-11-【标签的-ref-属性】" class="headerlink" title="3.11. 【标签的 ref 属性】"></a>3.11. 【标签的 ref 属性】</h2><p>作用：用于注册模板引用。</p><ul><li>用在普通<code>DOM</code>标签上，获取的是<code>DOM</code>节点。</li><li>用在组件标签上，获取的是组件实例对象。</li></ul><p>用在普通<code>DOM</code>标签上：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h1 ref=&quot;title1&quot;&gt;尚硅谷&lt;/h1&gt;</span><br><span class="line">    &lt;h2 ref=&quot;title2&quot;&gt;前端&lt;/h2&gt;</span><br><span class="line">    &lt;h3 ref=&quot;title3&quot;&gt;Vue&lt;/h3&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; ref=&quot;inpt&quot;&gt; &lt;br&gt;&lt;br&gt;</span><br><span class="line">    &lt;button @click=&quot;showLog&quot;&gt;点我打印内容&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123;ref&#125; from &#x27;vue&#x27;</span><br><span class="line">        </span><br><span class="line">  let title1 = ref()</span><br><span class="line">  let title2 = ref()</span><br><span class="line">  let title3 = ref()</span><br><span class="line"></span><br><span class="line">  function showLog()&#123;</span><br><span class="line">    // 通过id获取元素</span><br><span class="line">    const t1 = document.getElementById(&#x27;title1&#x27;)</span><br><span class="line">    // 打印内容</span><br><span class="line">    console.log((t1 as HTMLElement).innerText)</span><br><span class="line">    console.log((&lt;HTMLElement&gt;t1).innerText)</span><br><span class="line">    console.log(t1?.innerText)</span><br><span class="line">    </span><br><span class="line">                /************************************/</span><br><span class="line">                </span><br><span class="line">    // 通过ref获取元素</span><br><span class="line">    console.log(title1.value)</span><br><span class="line">    console.log(title2.value)</span><br><span class="line">    console.log(title3.value)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>用在组件标签上：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 父组件App.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Person ref=&quot;ren&quot;/&gt;</span><br><span class="line">  &lt;button @click=&quot;test&quot;&gt;测试&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;</span><br><span class="line">  import Person from &#x27;./components/Person.vue&#x27;</span><br><span class="line">  import &#123;ref&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  let ren = ref()</span><br><span class="line"></span><br><span class="line">  function test()&#123;</span><br><span class="line">    console.log(ren.value.name)</span><br><span class="line">    console.log(ren.value.age)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 子组件Person.vue中要使用defineExpose暴露内容 --&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123;ref,defineExpose&#125; from &#x27;vue&#x27;</span><br><span class="line">        // 数据</span><br><span class="line">  let name = ref(&#x27;张三&#x27;)</span><br><span class="line">  let age = ref(18)</span><br><span class="line">  /****************************/</span><br><span class="line">  /****************************/</span><br><span class="line">  // 使用defineExpose将组件中的数据交给外部</span><br><span class="line">  defineExpose(&#123;name,age&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-12-【props】"><a href="#3-12-【props】" class="headerlink" title="3.12. 【props】"></a>3.12. 【props】</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个接口，限制每个Person对象的格式</span></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">PersonInter</span> &#123;</span><br><span class="line"> <span class="attr">id</span>:string,</span><br><span class="line"> <span class="attr">name</span>:string,</span><br><span class="line">    <span class="attr">age</span>:number</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 定义一个自定义类型Persons</span></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">Persons</span> = <span class="title class_">Array</span>&lt;<span class="title class_">PersonInter</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p><code>App.vue</code>中代码：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">        &lt;Person :list=&quot;persons&quot;/&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">  </span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;</span><br><span class="line">  import Person from &#x27;./components/Person.vue&#x27;</span><br><span class="line">  import &#123;reactive&#125; from &#x27;vue&#x27;</span><br><span class="line">    import &#123;type Persons&#125; from &#x27;./types&#x27;</span><br><span class="line">  </span><br><span class="line">    let persons = reactive&lt;Persons&gt;([</span><br><span class="line">     &#123;id:&#x27;e98219e12&#x27;,name:&#x27;张三&#x27;,age:18&#125;,</span><br><span class="line">      &#123;id:&#x27;e98219e13&#x27;,name:&#x27;李四&#x27;,age:19&#125;,</span><br><span class="line">       &#123;id:&#x27;e98219e14&#x27;,name:&#x27;王五&#x27;,age:20&#125;</span><br><span class="line">     ])</span><br><span class="line">   &lt;/script&gt;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><blockquote><p><code>Person.vue</code>中代码：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;person&quot;&gt;</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line">     &lt;li v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt;</span><br><span class="line">        &#123;&#123;item.name&#125;&#125;--&#123;&#123;item.age&#125;&#125;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">   &lt;/template&gt;</span><br><span class="line">  </span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">import &#123;defineProps&#125; from &#x27;vue&#x27;</span><br><span class="line">import &#123;type PersonInter&#125; from &#x27;@/types&#x27;</span><br><span class="line">  </span><br><span class="line">  // 第一种写法：仅接收</span><br><span class="line">// const props = defineProps([&#x27;list&#x27;])</span><br><span class="line">  </span><br><span class="line">  // 第二种写法：接收+限制类型</span><br><span class="line">// defineProps&lt;&#123;list:Persons&#125;&gt;()</span><br><span class="line">  </span><br><span class="line">  // 第三种写法：接收+限制类型+指定默认值+限制必要性</span><br><span class="line">let props = withDefaults(defineProps&lt;&#123;list?:Persons&#125;&gt;(),&#123;</span><br><span class="line">     list:()=&gt;[&#123;id:&#x27;asdasg01&#x27;,name:&#x27;小猪佩奇&#x27;,age:18&#125;]</span><br><span class="line">  &#125;)</span><br><span class="line">   console.log(props)</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-13-【生命周期】"><a href="#3-13-【生命周期】" class="headerlink" title="3.13. 【生命周期】"></a>3.13. 【生命周期】</h2><ul><li>概念：<code>Vue</code>组件实例在创建时要经历一系列的初始化步骤，在此过程中<code>Vue</code>会在合适的时机，调用特定的函数，从而让开发者有机会在特定阶段运行自己的代码，这些特定的函数统称为：生命周期钩子</li><li>规律：</li><li>生命周期整体分为四个阶段，分别是：<strong>创建、挂载、更新、销毁</strong>，每个阶段都有两个钩子，一前一后。</li><li><code>Vue2</code>的生命周期</li><li>创建阶段：<code>beforeCreate</code>、<code>created</code></li><li>挂载阶段：<code>beforeMount</code>、<code>mounted</code></li><li>更新阶段：<code>beforeUpdate</code>、<code>updated</code></li><li>销毁阶段：<code>beforeDestroy</code>、<code>destroyed</code></li><li><code>Vue3</code>的生命周期</li><li>创建阶段：<code>setup</code></li><li>挂载阶段：<code>onBeforeMount</code>、<code>onMounted</code></li><li>更新阶段：<code>onBeforeUpdate</code>、<code>onUpdated</code></li><li>卸载阶段：<code>onBeforeUnmount</code>、<code>onUnmounted</code></li><li>常用的钩子：<code>onMounted</code>(挂载完毕)、<code>onUpdated</code>(更新完毕)、<code>onBeforeUnmount</code>(卸载之前)</li><li>示例代码：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;person&quot;&gt;</span><br><span class="line">    &lt;h2&gt;当前求和为：&#123;&#123; sum &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeSum&quot;&gt;点我sum+1&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- vue3写法 --&gt;</span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt;</span><br><span class="line">  import &#123; </span><br><span class="line">    ref, </span><br><span class="line">    onBeforeMount, </span><br><span class="line">    onMounted, </span><br><span class="line">    onBeforeUpdate, </span><br><span class="line">    onUpdated, </span><br><span class="line">    onBeforeUnmount, </span><br><span class="line">    onUnmounted </span><br><span class="line">  &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  // 数据</span><br><span class="line">  let sum = ref(0)</span><br><span class="line">  // 方法</span><br><span class="line">  function changeSum() &#123;</span><br><span class="line">    sum.value += 1</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&#x27;setup&#x27;)</span><br><span class="line">  // 生命周期钩子</span><br><span class="line">  onBeforeMount(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;挂载之前&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  onMounted(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;挂载完毕&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  onBeforeUpdate(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;更新之前&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  onUpdated(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;更新完毕&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  onBeforeUnmount(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;卸载之前&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">  onUnmounted(()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;卸载完毕&#x27;)</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="3-14-【自定义hook】"><a href="#3-14-【自定义hook】" class="headerlink" title="3.14. 【自定义hook】"></a>3.14. 【自定义hook】</h2><ul><li>什么是<code>hook</code>？—— 本质是一个函数，把<code>setup</code>函数中使用的<code>Composition API</code>进行了封装，类似于<code>vue2.x</code>中的<code>mixin</code>。</li><li>自定义<code>hook</code>的优势：复用代码, 让<code>setup</code>中的逻辑更清楚易懂。</li></ul><p>示例代码：</p><ul><li><code>useSum.ts</code>中内容如下：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ref,onMounted&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    sum.<span class="property">value</span> += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">    sum.<span class="property">value</span> -= <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">increment</span>()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向外部暴露数据</span></span><br><span class="line">  <span class="keyword">return</span> &#123;sum,increment,decrement&#125;</span><br><span class="line">&#125;                </span><br></pre></td></tr></table></figure><ul><li><code>useDog.ts</code>中内容如下：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;reactive,onMounted&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios,&#123;<span class="title class_">AxiosError</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> dogList = reactive&lt;string[]&gt;([])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getDog</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 发请求</span></span><br><span class="line">      <span class="keyword">let</span> &#123;data&#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;https://dog.ceo/api/breed/pembroke/images/random&#x27;</span>)</span><br><span class="line">      <span class="comment">// 维护数据</span></span><br><span class="line">      dogList.<span class="title function_">push</span>(data.<span class="property">message</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// 处理错误</span></span><br><span class="line">      <span class="keyword">const</span> err = &lt;<span class="title class_">AxiosError</span>&gt;error</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 挂载钩子</span></span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">getDog</span>()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向外部暴露数据</span></span><br><span class="line">  <span class="keyword">return</span> &#123;dogList,getDog&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>组件中具体使用：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;button @click=&quot;increment&quot;&gt;点我+1&lt;/button&gt;</span><br><span class="line">  &lt;button @click=&quot;decrement&quot;&gt;点我-1&lt;/button&gt;</span><br><span class="line">  &lt;hr&gt;</span><br><span class="line">  &lt;img v-for=&quot;(u,index) in dogList.urlList&quot; :key=&quot;index&quot; :src=&quot;(u as string)&quot;&gt; </span><br><span class="line">  &lt;span v-show=&quot;dogList.isLoading&quot;&gt;加载中......&lt;/span&gt;&lt;br&gt;</span><br><span class="line">  &lt;button @click=&quot;getDog&quot;&gt;再来一只狗&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot;&gt;</span><br><span class="line">  import &#123;defineComponent&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">  export default defineComponent(&#123;</span><br><span class="line">    name:&#x27;App&#x27;,</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">  import useSum from &#x27;./hooks/useSum&#x27;</span><br><span class="line">  import useDog from &#x27;./hooks/useDog&#x27;</span><br><span class="line"></span><br><span class="line">  let &#123;sum,increment,decrement&#125; = useSum()</span><br><span class="line">  let &#123;dogList,getDog&#125; = useDog()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="4-路由"><a href="#4-路由" class="headerlink" title="4. 路由"></a>4. 路由</h1><h2 id="4-1-【对路由的理解】"><a href="#4-1-【对路由的理解】" class="headerlink" title="4.1. 【对路由的理解】"></a>4.1. 【对路由的理解】</h2><h2 id="4-2-【基本切换效果】"><a href="#4-2-【基本切换效果】" class="headerlink" title="4.2. 【基本切换效果】"></a>4.2. 【基本切换效果】</h2><ul><li><code>Vue3</code>中要使用<code>vue-router</code>的最新版本，目前是<code>4</code>版本。</li><li>路由配置文件代码如下：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createRouter,createWebHistory&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;@/pages/Home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">News</span> <span class="keyword">from</span> <span class="string">&#x27;@/pages/News.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;@/pages/About.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">        <span class="attr">history</span>:<span class="title function_">createWebHistory</span>(),</span><br><span class="line">        <span class="attr">routes</span>:[</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">                        <span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">                        <span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">                &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><ul><li><code>main.ts</code>代码如下：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router/index&#x27;</span></span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><code>App.vue</code>代码如下</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h2 class=&quot;title&quot;&gt;Vue路由测试&lt;/h2&gt;</span><br><span class="line">    &lt;!-- 导航区 --&gt;</span><br><span class="line">    &lt;div class=&quot;navigate&quot;&gt;</span><br><span class="line">      &lt;RouterLink to=&quot;/home&quot; active-class=&quot;active&quot;&gt;首页&lt;/RouterLink&gt;</span><br><span class="line">      &lt;RouterLink to=&quot;/news&quot; active-class=&quot;active&quot;&gt;新闻&lt;/RouterLink&gt;</span><br><span class="line">      &lt;RouterLink to=&quot;/about&quot; active-class=&quot;active&quot;&gt;关于&lt;/RouterLink&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;!-- 展示区 --&gt;</span><br><span class="line">    &lt;div class=&quot;main-content&quot;&gt;</span><br><span class="line">      &lt;RouterView&gt;&lt;/RouterView&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup name=&quot;App&quot;&gt;</span><br><span class="line">  import &#123;RouterLink,RouterView&#125; from &#x27;vue-router&#x27;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="4-3-【两个注意点】"><a href="#4-3-【两个注意点】" class="headerlink" title="4.3. 【两个注意点】"></a>4.3. 【两个注意点】</h2><ol><li>路由组件通常存放在<code>pages</code> 或 <code>views</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li><li>通过点击导航，视觉效果上“消失” 了的路由组件，默认是被<strong>卸载</strong>掉的，需要的时候再去<strong>挂载</strong>。</li></ol><h2 id="4-4-【路由器工作模式】"><a href="#4-4-【路由器工作模式】" class="headerlink" title="4.4.【路由器工作模式】"></a>4.4.【路由器工作模式】</h2><ol><li><code>history</code>模式</li><li>优点：<code>URL</code>更加美观，不带有<code>#</code>，更接近传统的网站<code>URL</code>。</li><li>缺点：后期项目上线，需要服务端配合处理路径问题，否则刷新会有<code>404</code>错误。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">          <span class="attr">history</span>:<span class="title function_">createWebHistory</span>(), <span class="comment">//history模式</span></span><br><span class="line">          <span class="comment">/******/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li><code>hash</code>模式</li><li>优点：兼容性更好，因为不需要服务器端处理路径。</li><li>缺点：<code>URL</code>带有<code>#</code>不太美观，且在<code>SEO</code>优化方面相对较差。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">          <span class="attr">history</span>:<span class="title function_">createWebHashHistory</span>(), <span class="comment">//hash模式</span></span><br><span class="line">          <span class="comment">/******/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="4-5-【to的两种写法】"><a href="#4-5-【to的两种写法】" class="headerlink" title="4.5. 【to的两种写法】"></a>4.5. 【to的两种写法】</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 第一种：to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link active-class=&quot;active&quot; to=&quot;/home&quot;&gt;主页&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 第二种：to的对象写法 --&gt;</span><br><span class="line">&lt;router-link active-class=&quot;active&quot; :to=&quot;&#123;path:&#x27;/home&#x27;&#125;&quot;&gt;Home&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><h2 id="4-6-【命名路由】"><a href="#4-6-【命名路由】" class="headerlink" title="4.6. 【命名路由】"></a>4.6. 【命名路由】</h2><p>作用：可以简化路由跳转及传参（后面就讲）。</p><p>给路由规则命名：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;zhuye&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;xinwen&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/news&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">News</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;guanyu&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>跳转路由：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--简化前：需要写完整的路径（to的字符串写法） --&gt;</span><br><span class="line">&lt;router-link to=&quot;/news/detail&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化后：直接通过名字跳转（to的对象写法配合name属性） --&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123;name:&#x27;guanyu&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><h2 id="4-7-【嵌套路由】"><a href="#4-7-【嵌套路由】" class="headerlink" title="4.7. 【嵌套路由】"></a>4.7. 【嵌套路由】</h2><ol><li>编写<code>News</code>的子路由：<code>Detail.vue</code></li><li>配置路由规则，使用<code>children</code>配置项：</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">  <span class="attr">history</span>:<span class="title function_">createWebHistory</span>(),</span><br><span class="line">        <span class="attr">routes</span>:[</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="attr">name</span>:<span class="string">&#x27;zhuye&#x27;</span>,</span><br><span class="line">                        <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">                        <span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="attr">name</span>:<span class="string">&#x27;xinwen&#x27;</span>,</span><br><span class="line">                        <span class="attr">path</span>:<span class="string">&#x27;/news&#x27;</span>,</span><br><span class="line">                        <span class="attr">component</span>:<span class="title class_">News</span>,</span><br><span class="line">                        <span class="attr">children</span>:[</span><br><span class="line">                                &#123;</span><br><span class="line">                                        <span class="attr">name</span>:<span class="string">&#x27;xiang&#x27;</span>,</span><br><span class="line">                                        <span class="attr">path</span>:<span class="string">&#x27;detail&#x27;</span>,</span><br><span class="line">                                        <span class="attr">component</span>:<span class="title class_">Detail</span></span><br><span class="line">                                &#125;</span><br><span class="line">                        ]</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="attr">name</span>:<span class="string">&#x27;guanyu&#x27;</span>,</span><br><span class="line">                        <span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">                        <span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">                &#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><ol><li>跳转路由（记得要加完整路径）：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=&quot;/news/detail&quot;&gt;xxxx&lt;/router-link&gt;</span><br><span class="line">&lt;!-- 或 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123;path:&#x27;/news/detail&#x27;&#125;&quot;&gt;xxxx&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><ol><li>记得去<code>Home</code>组件中预留一个<code>&lt;router-view&gt;</code></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;news&quot;&gt;</span><br><span class="line">    &lt;nav class=&quot;news-list&quot;&gt;</span><br><span class="line">      &lt;RouterLink v-for=&quot;news in newsList&quot; :key=&quot;news.id&quot; :to=&quot;&#123;path:&#x27;/news/detail&#x27;&#125;&quot;&gt;</span><br><span class="line">        &#123;&#123;news.name&#125;&#125;</span><br><span class="line">      &lt;/RouterLink&gt;</span><br><span class="line">    &lt;/nav&gt;</span><br><span class="line">    &lt;div class=&quot;news-detail&quot;&gt;</span><br><span class="line">      &lt;RouterView/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="4-8-【路由传参】"><a href="#4-8-【路由传参】" class="headerlink" title="4.8. 【路由传参】"></a>4.8. 【路由传参】</h2><h3 id="query参数"><a href="#query参数" class="headerlink" title="query参数"></a>query参数</h3><ol><li>传递参数</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 跳转并携带query参数（to的字符串写法） --&gt;</span><br><span class="line">&lt;router-link to=&quot;/news/detail?a=1&amp;b=2&amp;content=欢迎你&quot;&gt;</span><br><span class="line">        跳转</span><br><span class="line">&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带query参数（to的对象写法） --&gt;</span><br><span class="line">&lt;RouterLink </span><br><span class="line">  :to=&quot;&#123;</span><br><span class="line">    //name:&#x27;xiang&#x27;, //用name也可以跳转</span><br><span class="line">    path:&#x27;/news/detail&#x27;,</span><br><span class="line">    query:&#123;</span><br><span class="line">      id:news.id,</span><br><span class="line">      title:news.title,</span><br><span class="line">      content:news.content</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &#123;&#123;news.title&#125;&#125;</span><br><span class="line">&lt;/RouterLink&gt;</span><br></pre></td></tr></table></figure><ol><li>接收参数：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useRoute&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"><span class="comment">// 打印query参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">query</span>)</span><br></pre></td></tr></table></figure><h3 id="params参数"><a href="#params参数" class="headerlink" title="params参数"></a>params参数</h3><ol><li>传递参数</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 跳转并携带params参数（to的字符串写法） --&gt;</span><br><span class="line">&lt;RouterLink :to=&quot;`/news/detail/001/新闻001/内容001`&quot;&gt;&#123;&#123;news.title&#125;&#125;&lt;/RouterLink&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带params参数（to的对象写法） --&gt;</span><br><span class="line">&lt;RouterLink </span><br><span class="line">  :to=&quot;&#123;</span><br><span class="line">    name:&#x27;xiang&#x27;, //用name跳转</span><br><span class="line">    params:&#123;</span><br><span class="line">      id:news.id,</span><br><span class="line">      title:news.title,</span><br><span class="line">      content:news.title</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&quot;</span><br><span class="line">&gt;</span><br><span class="line">  &#123;&#123;news.title&#125;&#125;</span><br><span class="line">&lt;/RouterLink&gt;</span><br></pre></td></tr></table></figure><ol><li>接收参数：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useRoute&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"><span class="comment">// 打印params参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">params</span>)</span><br></pre></td></tr></table></figure><blockquote><p>备注1：传递<code>params</code>参数时，若使用<code>to</code>的对象写法，必须使用<code>name</code>配置项，不能用<code>path</code>。</p></blockquote><blockquote><p>备注2：传递<code>params</code>参数时，需要提前在规则中占位。</p></blockquote><h2 id="4-9-【路由的props配置】"><a href="#4-9-【路由的props配置】" class="headerlink" title="4.9. 【路由的props配置】"></a>4.9. 【路由的props配置】</h2><p>作用：让路由组件更方便的收到参数（可以将路由参数作为<code>props</code>传给组件）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">name</span>:<span class="string">&#x27;xiang&#x27;</span>,</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title/:content&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>:<span class="title class_">Detail</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// props的对象写法，作用：把对象中的每一组key-value作为props传给Detail组件</span></span><br><span class="line">  <span class="comment">// props:&#123;a:1,b:2,c:3&#125;, </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// props的布尔值写法，作用：把收到了每一组params参数，作为props传给Detail组件</span></span><br><span class="line">  <span class="comment">// props:true</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// props的函数写法，作用：把返回的对象中每一组key-value作为props传给Detail组件</span></span><br><span class="line">  <span class="title function_">props</span>(<span class="params">route</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> route.<span class="property">query</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-10-【-replace属性】"><a href="#4-10-【-replace属性】" class="headerlink" title="4.10. 【 replace属性】"></a>4.10. 【 replace属性】</h2><ol><li>作用：控制路由跳转时操作浏览器历史记录的模式。</li><li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>：<ol><li><code>push</code>是追加历史记录（默认值）。</li><li><code>replace</code>是替换当前记录。</li></ol></li><li>开启<code>replace</code>模式：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;RouterLink replace .......&gt;News&lt;/RouterLink&gt;</span><br></pre></td></tr></table></figure><h2 id="4-11-【编程式导航】"><a href="#4-11-【编程式导航】" class="headerlink" title="4.11. 【编程式导航】"></a>4.11. 【编程式导航】</h2><p>路由组件的两个重要的属性：<code>$route</code>和<code>$router</code>变成了两个<code>hooks</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useRoute,useRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> route = <span class="title function_">useRoute</span>()</span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">useRouter</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">query</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">parmas</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(router.<span class="property">push</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(router.<span class="property">replace</span>)</span><br></pre></td></tr></table></figure><h2 id="4-12-【重定向】"><a href="#4-12-【重定向】" class="headerlink" title="4.12. 【重定向】"></a>4.12. 【重定向】</h2><ol><li>作用：将特定的路径，重新定向到已有路由。</li><li>具体编码：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">redirect</span>:<span class="string">&#x27;/about&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-pinia"><a href="#5-pinia" class="headerlink" title="5. pinia"></a>5. pinia</h1><h2 id="5-1【准备一个效果】"><a href="#5-1【准备一个效果】" class="headerlink" title="5.1【准备一个效果】"></a>5.1【准备一个效果】</h2><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MWQzYWUyNjY1YzE1ODM3OGNlYWY2ZjZkODk1Y2M3NWVfMEljTXRXSXE0b2hqZFJvQVE1MVFuVmdIOUFMd2pEZXJfVG9rZW46QVhxV2J4eVlHbzBZMkp4RVNEd2NFQjNPblpkXzE3MTk4MTA1ODE6MTcxOTgxNDE4MV9WNA" alt="img"></p><h2 id="5-2【搭建-pinia-环境】"><a href="#5-2【搭建-pinia-环境】" class="headerlink" title="5.2【搭建 pinia 环境】"></a>5.2【搭建 pinia 环境】</h2><p>第一步：<code>npm install pinia</code></p><p>第二步：操作<code>src/main.ts</code></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 引入createPinia，用于创建pinia */</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建pinia */</span></span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>()</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用插件 */</span>&#123;&#125;</span><br><span class="line">app.<span class="title function_">use</span>(pinia)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>此时开发者工具中已经有了<code>pinia</code>选项</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NDM3ZTgzYjU2OWFhNTk2NDQ0OTBlN2E1YjY2YzM4ODBfWnoxeUFmeTdYVldaMDhrOFBYeGE1UVRBMzB6UHVUNmNfVG9rZW46VUhLZmIyQ0s3b0JpM0Z4N09sSGNMSnBHbm9iXzE3MTk4MTA1ODE6MTcxOTgxNDE4MV9WNA" alt="img"></p><h2 id="5-3【存储-读取数据】"><a href="#5-3【存储-读取数据】" class="headerlink" title="5.3【存储+读取数据】"></a>5.3【存储+读取数据】</h2><ol><li><code>Store</code>是一个保存：<strong>状态</strong>、<strong>业务逻辑</strong> 的实体，每个组件都可以<strong>读取</strong>、<strong>写入</strong>它。</li><li>它有三个概念：<code>state</code>、<code>getter</code>、<code>action</code>，相当于组件中的： <code>data</code>、 <code>computed</code> 和 <code>methods</code>。</li><li>具体编码：<code>src/store/count.ts</code></li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入defineStore用于创建store</span></span><br><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并暴露一个store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCountStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;count&#x27;</span>,&#123;</span><br><span class="line">  <span class="comment">// 动作</span></span><br><span class="line">  <span class="attr">actions</span>:&#123;&#125;,</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">sum</span>:<span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 计算</span></span><br><span class="line">  <span class="attr">getters</span>:&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>具体编码：<code>src/store/talk.ts</code></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入defineStore用于创建store</span></span><br><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并暴露一个store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useTalkStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;talk&#x27;</span>,&#123;</span><br><span class="line">  <span class="comment">// 动作</span></span><br><span class="line">  <span class="attr">actions</span>:&#123;&#125;,</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">talkList</span>:[</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;yuysada01&#x27;</span>,<span class="attr">content</span>:<span class="string">&#x27;你今天有点怪，哪里怪？怪好看的！&#x27;</span>&#125;,</span><br><span class="line">                     &#123;<span class="attr">id</span>:<span class="string">&#x27;yuysada02&#x27;</span>,<span class="attr">content</span>:<span class="string">&#x27;草莓、蓝莓、蔓越莓，你想我了没？&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">id</span>:<span class="string">&#x27;yuysada03&#x27;</span>,<span class="attr">content</span>:<span class="string">&#x27;心里给你留了一块地，我的死心塌地&#x27;</span>&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 计算</span></span><br><span class="line">  <span class="attr">getters</span>:&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>组件中使用<code>state</code>中的数据</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;当前求和为：&#123;&#123; sumStore.sum &#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Count&quot;&gt;</span><br><span class="line">  // 引入对应的useXxxxxStore        </span><br><span class="line">  import &#123;useSumStore&#125; from &#x27;@/store/sum&#x27;</span><br><span class="line"></span><br><span class="line">  // 调用useXxxxxStore得到对应的store</span><br><span class="line">  const sumStore = useSumStore()</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;talk in talkStore.talkList&quot; :key=&quot;talk.id&quot;&gt;</span><br><span class="line">      &#123;&#123; talk.content &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Count&quot;&gt;</span><br><span class="line">  import axios from &#x27;axios&#x27;</span><br><span class="line">  import &#123;useTalkStore&#125; from &#x27;@/store/talk&#x27;</span><br><span class="line"></span><br><span class="line">  const talkStore = useTalkStore()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="5-4-【修改数据】-三种方式"><a href="#5-4-【修改数据】-三种方式" class="headerlink" title="5.4.【修改数据】(三种方式)"></a>5.4.【修改数据】(三种方式)</h2><ol><li>第一种修改方式，直接修改</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">countStore.<span class="property">sum</span> = <span class="number">666</span></span><br></pre></td></tr></table></figure><ol><li>第二种修改方式：批量修改</li></ol><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">countStore.$patch(&#123;</span><br><span class="line">  <span class="attr">sum</span>:<span class="number">999</span>,</span><br><span class="line">  <span class="attr">school</span>:<span class="string">&#x27;lcp&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>第三种修改方式：借助<code>action</code>修改（<code>action</code>中可以编写一些业务逻辑）</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCountStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">/*************/</span></span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="comment">//加</span></span><br><span class="line">    <span class="title function_">increment</span>(<span class="params">value:number</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">sum</span> &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">//操作countStore中的sum</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sum</span> += value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//减</span></span><br><span class="line">    <span class="title function_">decrement</span>(<span class="params">value:number</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">sum</span> &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sum</span> -= value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/*************/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>组件中调用<code>action</code>即可</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用countStore</span></span><br><span class="line"><span class="keyword">const</span> countStore = <span class="title function_">useCountStore</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用对应action</span></span><br><span class="line">countStore.<span class="title function_">incrementOdd</span>(n.<span class="property">value</span>)</span><br></pre></td></tr></table></figure><h2 id="5-5-【storeToRefs】"><a href="#5-5-【storeToRefs】" class="headerlink" title="5.5.【storeToRefs】"></a>5.5.【storeToRefs】</h2><ul><li>借助<code>storeToRefs</code>将<code>store</code>中的数据转为<code>ref</code>对象，方便在模板中使用。</li><li>注意：<code>pinia</code>提供的<code>storeToRefs</code>只会将数据做转换，而<code>Vue</code>的<code>toRefs</code>会转换<code>store</code>中数据。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">        &lt;div class=&quot;count&quot;&gt;</span><br><span class="line">                &lt;h2&gt;当前求和为：&#123;&#123;sum&#125;&#125;&lt;/h2&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Count&quot;&gt;</span><br><span class="line">  import &#123; useCountStore &#125; from &#x27;@/store/count&#x27;</span><br><span class="line">  /* 引入storeToRefs */</span><br><span class="line">  import &#123; storeToRefs &#125; from &#x27;pinia&#x27;</span><br><span class="line"></span><br><span class="line">        /* 得到countStore */</span><br><span class="line">  const countStore = useCountStore()</span><br><span class="line">  /* 使用storeToRefs转换countStore，随后解构 */</span><br><span class="line">  const &#123;sum&#125; = storeToRefs(countStore)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="5-6-【getters】"><a href="#5-6-【getters】" class="headerlink" title="5.6.【getters】"></a>5.6.【getters】</h2><ol><li>概念：当<code>state</code>中的数据，需要经过处理后再使用时，可以使用<code>getters</code>配置。</li><li>追加<code>getters</code>配置。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入defineStore用于创建store</span></span><br><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并暴露一个store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCountStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;count&#x27;</span>,&#123;</span><br><span class="line">  <span class="comment">// 动作</span></span><br><span class="line">  <span class="attr">actions</span>:&#123;</span><br><span class="line">    <span class="comment">/************/</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 状态</span></span><br><span class="line">  <span class="title function_">state</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">sum</span>:<span class="number">1</span>,</span><br><span class="line">      <span class="attr">school</span>:<span class="string">&#x27;lcp&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 计算</span></span><br><span class="line">  <span class="attr">getters</span>:&#123;</span><br><span class="line">    <span class="attr">bigSum</span>:(state):<span class="function"><span class="params">number</span> =&gt;</span> state.<span class="property">sum</span> *<span class="number">10</span>,</span><br><span class="line">    <span class="title function_">upperSchool</span>():string&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>. school.<span class="title function_">toUpperCase</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>组件中读取数据：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;increment,decrement&#125; = countStore</span><br><span class="line"><span class="keyword">let</span> &#123;sum,school,bigSum,upperSchool&#125; = <span class="title function_">storeToRefs</span>(countStore)</span><br></pre></td></tr></table></figure><h2 id="5-7-【-subscribe】"><a href="#5-7-【-subscribe】" class="headerlink" title="5.7.【$subscribe】"></a>5.7.【$subscribe】</h2><p>通过 store 的 <code>$subscribe()</code> 方法侦听 <code>state</code> 及其变化</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">talkStore.$subscribe(<span class="function">(<span class="params">mutate,state</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;LoveTalk&#x27;</span>,mutate,state)</span><br><span class="line">  <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;talk&#x27;</span>,<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(talkList.<span class="property">value</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="5-8-【store组合式写法】"><a href="#5-8-【store组合式写法】" class="headerlink" title="5.8. 【store组合式写法】"></a>5.8. 【store组合式写法】</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;nanoid&#125; <span class="keyword">from</span> <span class="string">&#x27;nanoid&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useTalkStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;talk&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// talkList就是state</span></span><br><span class="line">  <span class="keyword">const</span> talkList = <span class="title function_">reactive</span>(</span><br><span class="line">    <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;talkList&#x27;</span>) <span class="keyword">as</span> <span class="built_in">string</span>) || []</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getATalk函数相当于action</span></span><br><span class="line">  <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getATalk</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 发请求，下面这行的写法是：连续解构赋值+重命名</span></span><br><span class="line">    <span class="keyword">let</span> &#123;<span class="attr">data</span>:&#123;<span class="attr">content</span>:title&#125;&#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;https://api.uomg.com/api/rand.qinghua?format=json&#x27;</span>)</span><br><span class="line">    <span class="comment">// 把请求回来的字符串，包装成一个对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;<span class="attr">id</span>:<span class="title function_">nanoid</span>(),title&#125;</span><br><span class="line">    <span class="comment">// 放到数组中</span></span><br><span class="line">    talkList.<span class="title function_">unshift</span>(obj)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;talkList,getATalk&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="6-组件通信"><a href="#6-组件通信" class="headerlink" title="6. 组件通信"></a>6. 组件通信</h1><p>**<code>Vue3</code><strong><strong>组件通信和</strong></strong><code>Vue2</code>**<strong>的区别：</strong></p><ul><li>移出事件总线，使用<code>mitt</code>代替。</li><li><code>vuex</code>换成了<code>pinia</code>。</li><li>把<code>.sync</code>优化到了<code>v-model</code>里面了。</li><li>把<code>$listeners</code>所有的东西，合并到<code>$attrs</code>中了。</li><li><code>$children</code>被砍掉了。</li></ul><p><strong>常见搭配形式：</strong></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2IxNjlkNGU5MmM3MTJiZGQxNDQ3M2Y0OWYxNWYxZWRfdU9QanRYWm02WndLWkdnVXh0eUs0UDR1T3lvejRGY0ZfVG9rZW46Q0JXSWJLQ05ab0c3dVB4YW42RGNJaEhEbmNoXzE3MTk4MTA1ODE6MTcxOTgxNDE4MV9WNA" alt="img"></p><h2 id="6-1-【props】"><a href="#6-1-【props】" class="headerlink" title="6.1. 【props】"></a>6.1. 【props】</h2><p>概述：<code>props</code>是使用频率最高的一种通信方式，常用与 ：<strong>父 ↔ 子</strong>。</p><ul><li>若 <strong>父传子</strong>：属性值是<strong>非函数</strong>。</li><li>若 <strong>子传父</strong>：属性值是<strong>函数</strong>。</li></ul><p>父组件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;father&quot;&gt;</span><br><span class="line">    &lt;h3&gt;父组件，&lt;/h3&gt;</span><br><span class="line">                &lt;h4&gt;我的车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;</span><br><span class="line">                &lt;h4&gt;儿子给的玩具：&#123;&#123; toy &#125;&#125;&lt;/h4&gt;</span><br><span class="line">                &lt;Child :car=&quot;car&quot; :getToy=&quot;getToy&quot;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;</span><br><span class="line">        import Child from &#x27;./Child.vue&#x27;</span><br><span class="line">        import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">        // 数据</span><br><span class="line">        const car = ref(&#x27;奔驰&#x27;)</span><br><span class="line">        const toy = ref()</span><br><span class="line">        // 方法</span><br><span class="line">        function getToy(value:string)&#123;</span><br><span class="line">                toy.value = value</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>子组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;</span><br><span class="line">    &lt;h3&gt;子组件&lt;/h3&gt;</span><br><span class="line">                &lt;h4&gt;我的玩具：&#123;&#123; toy &#125;&#125;&lt;/h4&gt;</span><br><span class="line">                &lt;h4&gt;父给我的车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;</span><br><span class="line">                &lt;button @click=&quot;getToy(toy)&quot;&gt;玩具给父亲&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Child&quot;&gt;</span><br><span class="line">        import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">        const toy = ref(&#x27;奥特曼&#x27;)</span><br><span class="line">        </span><br><span class="line">        defineProps([&#x27;car&#x27;,&#x27;getToy&#x27;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="6-2-【自定义事件】"><a href="#6-2-【自定义事件】" class="headerlink" title="6.2. 【自定义事件】"></a>6.2. 【自定义事件】</h2><ol><li>概述：自定义事件常用于：<strong>子 &#x3D;&gt; 父。</strong></li><li>注意区分好：原生事件、自定义事件。</li></ol><ul><li>原生事件：<ul><li>事件名是特定的（<code>click</code>、<code>mosueenter</code>等等）</li><li>事件对象<code>$event</code>: 是包含事件相关信息的对象（<code>pageX</code>、<code>pageY</code>、<code>target</code>、<code>keyCode</code>）</li></ul></li><li>自定义事件：<ul><li>事件名是任意名称</li><li><strong>事件对象</strong><strong><code>$event</code>****: 是调用**</strong><code>emit</code>**<strong>时所提供的数据，可以是任意类型！！！</strong></li></ul></li></ul><ol><li>示例：</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在父组件中，给子组件绑定自定义事件：--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Child</span> @<span class="attr">send-toy</span>=<span class="string">&quot;toy = $event&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--注意区分原生事件与自定义事件中的$event--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;toy = $event&quot;</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">//子组件中，触发事件：</span><br><span class="line">this.$emit(&#x27;send-toy&#x27;, 具体数据)</span><br></pre></td></tr></table></figure><h2 id="6-3-【mitt】"><a href="#6-3-【mitt】" class="headerlink" title="6.3. 【mitt】"></a>6.3. 【mitt】</h2><p>概述：与消息订阅与发布（<code>pubsub</code>）功能类似，可以实现任意组件间通信。</p><p>安装<code>mitt</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i mitt</span><br></pre></td></tr></table></figure><p>新建文件：<code>src\utils\emitter.ts</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入mitt </span></span><br><span class="line"><span class="keyword">import</span> mitt <span class="keyword">from</span> <span class="string">&quot;mitt&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建emitter</span></span><br><span class="line"><span class="keyword">const</span> emitter = <span class="title function_">mitt</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  // 绑定事件</span></span><br><span class="line"><span class="comment">  emitter.on(&#x27;abc&#x27;,(value)=&gt;&#123;</span></span><br><span class="line"><span class="comment">    console.log(&#x27;abc事件被触发&#x27;,value)</span></span><br><span class="line"><span class="comment">  &#125;)</span></span><br><span class="line"><span class="comment">  emitter.on(&#x27;xyz&#x27;,(value)=&gt;&#123;</span></span><br><span class="line"><span class="comment">    console.log(&#x27;xyz事件被触发&#x27;,value)</span></span><br><span class="line"><span class="comment">  &#125;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">    // 触发事件</span></span><br><span class="line"><span class="comment">    emitter.emit(&#x27;abc&#x27;,666)</span></span><br><span class="line"><span class="comment">    emitter.emit(&#x27;xyz&#x27;,777)</span></span><br><span class="line"><span class="comment">  &#125;, 1000);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">    // 清理事件</span></span><br><span class="line"><span class="comment">    emitter.all.clear()</span></span><br><span class="line"><span class="comment">  &#125;, 3000); </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并暴露mitt</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> emitter</span><br></pre></td></tr></table></figure><p>接收数据的组件中：绑定事件、同时在销毁前解绑事件：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">&quot;@/utils/emitter&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; onUnmounted &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定事件</span></span><br><span class="line">emitter.<span class="title function_">on</span>(<span class="string">&#x27;send-toy&#x27;</span>,<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;send-toy事件被触发&#x27;</span>,value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 解绑事件</span></span><br><span class="line">  emitter.<span class="title function_">off</span>(<span class="string">&#x27;send-toy&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>【第三步】：提供数据的组件，在合适的时候触发事件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> emitter <span class="keyword">from</span> <span class="string">&quot;@/utils/emitter&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sendToy</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 触发事件</span></span><br><span class="line">  emitter.<span class="title function_">emit</span>(<span class="string">&#x27;send-toy&#x27;</span>,toy.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意这个重要的内置关系，总线依赖着这个内置关系</strong></p><h2 id="6-4-【v-model】"><a href="#6-4-【v-model】" class="headerlink" title="6.4.【v-model】"></a>6.4.【v-model】</h2><ol><li>概述：实现 <strong>父↔子</strong> 之间相互通信。</li><li>前序知识 —— <code>v-model</code>的本质</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用v-model指令 --&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;userName&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- v-model的本质是下面这行代码 --&gt;</span><br><span class="line">&lt;input </span><br><span class="line">  type=&quot;text&quot; </span><br><span class="line">  :value=&quot;userName&quot; </span><br><span class="line">  @input=&quot;userName =(&lt;HTMLInputElement&gt;$event.target).value&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><ol><li>组件标签上的<code>v-model</code>的本质：<code>:moldeValue</code> ＋ <code>update:modelValue</code>事件。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 组件标签上使用v-model指令 --&gt;</span><br><span class="line">&lt;lcpInput v-model=&quot;userName&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 组件标签上v-model的本质 --&gt;</span><br><span class="line">&lt;lcpInput :modelValue=&quot;userName&quot; @update:model-value=&quot;userName = $event&quot;/&gt;</span><br></pre></td></tr></table></figure><ol><li><code>lcpInput</code>组件中：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;!--将接收的value值赋给input元素的value属性，目的是：为了呈现数据 --&gt;</span><br><span class="line">                &lt;!--给input元素绑定原生input事件，触发input事件时，进而触发update:model-value事件--&gt;</span><br><span class="line">    &lt;input </span><br><span class="line">       type=&quot;text&quot; </span><br><span class="line">       :value=&quot;modelValue&quot; </span><br><span class="line">       @input=&quot;emit(&#x27;update:model-value&#x27;,$event.target.value)&quot;</span><br><span class="line">    &gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;lcpInput&quot;&gt;</span><br><span class="line">  // 接收props</span><br><span class="line">  defineProps([&#x27;modelValue&#x27;])</span><br><span class="line">  // 声明事件</span><br><span class="line">  const emit = defineEmits([&#x27;update:model-value&#x27;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol><li>也可以更换<code>value</code>，例如改成<code>abc</code></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 也可以更换value，例如改成abc--&gt;</span><br><span class="line">&lt;lcpInput v-model:abc=&quot;userName&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 上面代码的本质如下 --&gt;</span><br><span class="line">&lt;lcpInput :abc=&quot;userName&quot; @update:abc=&quot;userName = $event&quot;/&gt;</span><br></pre></td></tr></table></figure><ol><li><code>lcpInput</code>组件中：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;input </span><br><span class="line">       type=&quot;text&quot; </span><br><span class="line">       :value=&quot;abc&quot; </span><br><span class="line">       @input=&quot;emit(&#x27;update:abc&#x27;,$event.target.value)&quot;</span><br><span class="line">    &gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;lcpInput&quot;&gt;</span><br><span class="line">  // 接收props</span><br><span class="line">  defineProps([&#x27;abc&#x27;])</span><br><span class="line">  // 声明事件</span><br><span class="line">  const emit = defineEmits([&#x27;update:abc&#x27;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol><li>如果<code>value</code>可以更换，那么就可以在组件标签上多次使用<code>v-model</code></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;lcpInput v-model:abc=&quot;userName&quot; v-model:xyz=&quot;password&quot;/&gt;</span><br></pre></td></tr></table></figure><h2 id="6-5-【-attrs-】"><a href="#6-5-【-attrs-】" class="headerlink" title="6.5.【$attrs 】"></a>6.5.【$attrs 】</h2><ol><li>概述：<code>$attrs</code>用于实现<strong>当前组件的父组件</strong>，向<strong>当前组件的子组件</strong>通信（<strong>祖→孙</strong>）。</li><li>具体说明：<code>$attrs</code>是一个对象，包含所有父组件传入的标签属性。</li><li>注意：<code>$attrs</code>会自动排除<code>props</code>中声明的属性(可以认为声明过的 <code>props</code> 被子组件自己“消费”了)</li></ol><p>父组件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;father&quot;&gt;</span><br><span class="line">    &lt;h3&gt;父组件&lt;/h3&gt;</span><br><span class="line">                &lt;Child :a=&quot;a&quot; :b=&quot;b&quot; :c=&quot;c&quot; :d=&quot;d&quot; v-bind=&quot;&#123;x:100,y:200&#125;&quot; :updateA=&quot;updateA&quot;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;</span><br><span class="line">        import Child from &#x27;./Child.vue&#x27;</span><br><span class="line">        import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">        let a = ref(1)</span><br><span class="line">        let b = ref(2)</span><br><span class="line">        let c = ref(3)</span><br><span class="line">        let d = ref(4)</span><br><span class="line"></span><br><span class="line">        function updateA(value)&#123;</span><br><span class="line">                a.value = value</span><br><span class="line">        &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>子组件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">        &lt;div class=&quot;child&quot;&gt;</span><br><span class="line">                &lt;h3&gt;子组件&lt;/h3&gt;</span><br><span class="line">                &lt;GrandChild v-bind=&quot;$attrs&quot;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Child&quot;&gt;</span><br><span class="line">        import GrandChild from &#x27;./GrandChild.vue&#x27;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>孙组件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">        &lt;div class=&quot;grand-child&quot;&gt;</span><br><span class="line">                &lt;h3&gt;孙组件&lt;/h3&gt;</span><br><span class="line">                &lt;h4&gt;a：&#123;&#123; a &#125;&#125;&lt;/h4&gt;</span><br><span class="line">                &lt;h4&gt;b：&#123;&#123; b &#125;&#125;&lt;/h4&gt;</span><br><span class="line">                &lt;h4&gt;c：&#123;&#123; c &#125;&#125;&lt;/h4&gt;</span><br><span class="line">                &lt;h4&gt;d：&#123;&#123; d &#125;&#125;&lt;/h4&gt;</span><br><span class="line">                &lt;h4&gt;x：&#123;&#123; x &#125;&#125;&lt;/h4&gt;</span><br><span class="line">                &lt;h4&gt;y：&#123;&#123; y &#125;&#125;&lt;/h4&gt;</span><br><span class="line">                &lt;button @click=&quot;updateA(666)&quot;&gt;点我更新A&lt;/button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;GrandChild&quot;&gt;</span><br><span class="line">        defineProps([&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;x&#x27;,&#x27;y&#x27;,&#x27;updateA&#x27;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="6-6-【-refs-parent】"><a href="#6-6-【-refs-parent】" class="headerlink" title="6.6. 【$$refs$$parent】"></a>6.6. 【$$refs$$parent】</h2><ol><li>概述：<ol><li><code>$refs</code>用于 ：<strong>父→子。</strong></li><li><code>$parent</code>用于：<strong>子→父。</strong></li></ol></li><li>原理如下：</li></ol><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><code>$refs</code></td><td>值为对象，包含所有被<code>ref</code>属性标识的<code>DOM</code>元素或组件实例。</td></tr><tr><td><code>$parent</code></td><td>值为对象，当前组件的父组件实例对象。</td></tr></tbody></table><h2 id="6-7-【provide、inject】"><a href="#6-7-【provide、inject】" class="headerlink" title="6.7. 【provide、inject】"></a>6.7. 【provide、inject】</h2><ol><li>概述：实现<strong>祖孙组件</strong>直接通信</li><li>具体使用：<ol><li>在祖先组件中通过<code>provide</code>配置向后代组件提供数据</li><li>在后代组件中通过<code>inject</code>配置来声明接收数据</li></ol></li><li>具体编码：</li><li>【第一步】父组件中，使用<code>provide</code>提供数据</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;father&quot;&gt;</span><br><span class="line">    &lt;h3&gt;父组件&lt;/h3&gt;</span><br><span class="line">    &lt;h4&gt;资产：&#123;&#123; money &#125;&#125;&lt;/h4&gt;</span><br><span class="line">    &lt;h4&gt;汽车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;</span><br><span class="line">    &lt;button @click=&quot;money += 1&quot;&gt;资产+1&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;car.price += 1&quot;&gt;汽车价格+1&lt;/button&gt;</span><br><span class="line">    &lt;Child/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;Father&quot;&gt;</span><br><span class="line">  import Child from &#x27;./Child.vue&#x27;</span><br><span class="line">  import &#123; ref,reactive,provide &#125; from &quot;vue&quot;;</span><br><span class="line">  // 数据</span><br><span class="line">  let money = ref(100)</span><br><span class="line">  let car = reactive(&#123;</span><br><span class="line">    brand:&#x27;奔驰&#x27;,</span><br><span class="line">    price:100</span><br><span class="line">  &#125;)</span><br><span class="line">  // 用于更新money的方法</span><br><span class="line">  function updateMoney(value:number)&#123;</span><br><span class="line">    money.value += value</span><br><span class="line">  &#125;</span><br><span class="line">  // 提供数据</span><br><span class="line">  provide(&#x27;moneyContext&#x27;,&#123;money,updateMoney&#125;)</span><br><span class="line">  provide(&#x27;car&#x27;,car)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol><li>注意：子组件中不用编写任何东西，是不受到任何打扰的</li><li>【第二步】孙组件中使用<code>inject</code>配置项接受数据。</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;grand-child&quot;&gt;</span><br><span class="line">    &lt;h3&gt;我是孙组件&lt;/h3&gt;</span><br><span class="line">    &lt;h4&gt;资产：&#123;&#123; money &#125;&#125;&lt;/h4&gt;</span><br><span class="line">    &lt;h4&gt;汽车：&#123;&#123; car &#125;&#125;&lt;/h4&gt;</span><br><span class="line">    &lt;button @click=&quot;updateMoney(6)&quot;&gt;点我&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot; name=&quot;GrandChild&quot;&gt;</span><br><span class="line">  import &#123; inject &#125; from &#x27;vue&#x27;;</span><br><span class="line">  // 注入数据</span><br><span class="line"> let &#123;money,updateMoney&#125; = inject(&#x27;moneyContext&#x27;,&#123;money:0,updateMoney:(x:number)=&gt;&#123;&#125;&#125;)</span><br><span class="line">  let car = inject(&#x27;car&#x27;)</span><br><span class="line">## 6.8. 【pinia】</span><br><span class="line"></span><br><span class="line">参考之前`pinia`部分的讲解</span><br><span class="line"></span><br><span class="line">## 6.9. 【slot】</span><br><span class="line"></span><br><span class="line">### 1. 默认插槽</span><br><span class="line"></span><br><span class="line">![img](http://49.232.112.44/images/default_slot.png)</span><br><span class="line"></span><br><span class="line">```vue</span><br><span class="line">父组件中：</span><br><span class="line">     &lt;Category title=&quot;今日热门游戏&quot;&gt;</span><br><span class="line">       &lt;ul&gt;</span><br><span class="line">         &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;</span><br><span class="line">       &lt;/ul&gt;</span><br><span class="line">     &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">     &lt;template&gt;</span><br><span class="line">       &lt;div class=&quot;item&quot;&gt;</span><br><span class="line">         &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;</span><br><span class="line">         &lt;!-- 默认插槽 --&gt;</span><br><span class="line">         &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">     &lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="2-具名插槽"><a href="#2-具名插槽" class="headerlink" title="2. 具名插槽"></a>2. 具名插槽</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category title=&quot;今日热门游戏&quot;&gt;</span><br><span class="line">          &lt;template v-slot:s1&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">              &lt;li v-for=&quot;g in games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">          &lt;template #s2&gt;</span><br><span class="line">            &lt;a href=&quot;&quot;&gt;更多&lt;/a&gt;</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">          &lt;div class=&quot;item&quot;&gt;</span><br><span class="line">            &lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;</span><br><span class="line">            &lt;slot name=&quot;s1&quot;&gt;&lt;/slot&gt;</span><br><span class="line">            &lt;slot name=&quot;s2&quot;&gt;&lt;/slot&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="3-作用域插槽"><a href="#3-作用域插槽" class="headerlink" title="3. 作用域插槽"></a>3. 作用域插槽</h3><ol><li>理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。（新闻数据在<code>News</code>组件中，但使用数据所遍历出来的结构由<code>App</code>组件决定）</li><li>具体编码：</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">      &lt;Game v-slot=&quot;params&quot;&gt;</span><br><span class="line">      &lt;!-- &lt;Game v-slot:default=&quot;params&quot;&gt; --&gt;</span><br><span class="line">      &lt;!-- &lt;Game #default=&quot;params&quot;&gt; --&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &lt;li v-for=&quot;g in params.games&quot; :key=&quot;g.id&quot;&gt;&#123;&#123; g.name &#125;&#125;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      &lt;/Game&gt;</span><br><span class="line"></span><br><span class="line">子组件中：</span><br><span class="line">      &lt;template&gt;</span><br><span class="line">        &lt;div class=&quot;category&quot;&gt;</span><br><span class="line">          &lt;h2&gt;今日游戏榜单&lt;/h2&gt;</span><br><span class="line">          &lt;slot :games=&quot;games&quot; a=&quot;哈哈&quot;&gt;&lt;/slot&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">      &lt;script setup lang=&quot;ts&quot; name=&quot;Category&quot;&gt;</span><br><span class="line">        import &#123;reactive&#125; from &#x27;vue&#x27;</span><br><span class="line">        let games = reactive([</span><br><span class="line">          &#123;id:&#x27;asgdytsa01&#x27;,name:&#x27;英雄联盟&#x27;&#125;,</span><br><span class="line">          &#123;id:&#x27;asgdytsa02&#x27;,name:&#x27;王者荣耀&#x27;&#125;,</span><br><span class="line">          &#123;id:&#x27;asgdytsa03&#x27;,name:&#x27;红色警戒&#x27;&#125;,</span><br><span class="line">          &#123;id:&#x27;asgdytsa04&#x27;,name:&#x27;斗罗大陆&#x27;&#125;</span><br><span class="line">        ])</span><br><span class="line">      &lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="7-其它-API"><a href="#7-其它-API" class="headerlink" title="7. 其它 API"></a>7. 其它 API</h1><h2 id="7-1-【shallowRef-与-shallowReactive-】"><a href="#7-1-【shallowRef-与-shallowReactive-】" class="headerlink" title="7.1.【shallowRef 与 shallowReactive 】"></a>7.1.【shallowRef 与 shallowReactive 】</h2><h3 id="shallowRef"><a href="#shallowRef" class="headerlink" title="shallowRef"></a><code>shallowRef</code></h3><ol><li>作用：创建一个响应式数据，但只对顶层属性进行响应式处理。</li><li>用法：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myVar = <span class="title function_">shallowRef</span>(initialValue);</span><br></pre></td></tr></table></figure><ol><li>特点：只跟踪引用值的变化，不关心值内部的属性变化。</li></ol><h3 id="shallowReactive"><a href="#shallowReactive" class="headerlink" title="shallowReactive"></a><code>shallowReactive</code></h3><ol><li>作用：创建一个浅层响应式对象，只会使对象的最顶层属性变成响应式的，对象内部的嵌套属性则不会变成响应式的</li><li>用法：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = <span class="title function_">shallowReactive</span>(&#123; ... &#125;);</span><br></pre></td></tr></table></figure><ol><li>特点：对象的顶层属性是响应式的，但嵌套对象的属性不是。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>通过使用 <code>shallowRef()</code> 和 <code>shallowReactive()</code> 来绕开深度响应。浅层式 <code>API</code> 创建的状态只在其顶层是响应式的，对所有深层的对象不会做任何处理，避免了对每一个内部属性做响应式所带来的性能成本，这使得属性的访问变得更快，可提升性能。</p></blockquote><h2 id="7-2-【readonly-与-shallowReadonly】"><a href="#7-2-【readonly-与-shallowReadonly】" class="headerlink" title="7.2.【readonly 与 shallowReadonly】"></a>7.2.【readonly 与 shallowReadonly】</h2><h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a><strong><code>readonly</code></strong></h3><ol><li>作用：用于创建一个对象的深只读副本。</li><li>用法：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> original = <span class="title function_">reactive</span>(&#123; ... &#125;);</span><br><span class="line"><span class="keyword">const</span> readOnlyCopy = <span class="title function_">readonly</span>(original);</span><br></pre></td></tr></table></figure><ol><li>特点：<ol><li>对象的所有嵌套属性都将变为只读。</li><li>任何尝试修改这个对象的操作都会被阻止（在开发模式下，还会在控制台中发出警告）。</li></ol></li><li>应用场景：<ol><li>创建不可变的状态快照。</li><li>保护全局状态或配置不被修改。</li></ol></li></ol><h3 id="shallowReadonly"><a href="#shallowReadonly" class="headerlink" title="shallowReadonly"></a><strong><code>shallowReadonly</code></strong></h3><ol><li>作用：与 <code>readonly</code> 类似，但只作用于对象的顶层属性。</li><li>用法：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> original = <span class="title function_">reactive</span>(&#123; ... &#125;);</span><br><span class="line"><span class="keyword">const</span> shallowReadOnlyCopy = <span class="title function_">shallowReadonly</span>(original);</span><br></pre></td></tr></table></figure><ol><li>特点：<ol><li>只将对象的顶层属性设置为只读，对象内部的嵌套属性仍然是可变的。</li><li>适用于只需保护对象顶层属性的场景。</li></ol></li></ol><h2 id="7-3-【toRaw-与-markRaw】"><a href="#7-3-【toRaw-与-markRaw】" class="headerlink" title="7.3.【toRaw 与 markRaw】"></a>7.3.【toRaw 与 markRaw】</h2><h3 id="toRaw"><a href="#toRaw" class="headerlink" title="toRaw"></a><code>toRaw</code></h3><ol><li>作用：用于获取一个响应式对象的原始对象， <code>toRaw</code> 返回的对象不再是响应式的，不会触发视图更新。</li><li>官网描述：这是一个可以用于临时读取而不引起代理访问&#x2F;跟踪开销，或是写入而不触发更改的特殊方法。不建议保存对原始对象的持久引用，请谨慎使用。</li><li>何时使用？ —— 在需要将响应式对象传递给非 <code>Vue</code> 的库或外部系统时，使用 <code>toRaw</code> 可以确保它们收到的是普通对象</li><li>具体编码：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive,toRaw,markRaw,isReactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* toRaw */</span></span><br><span class="line"><span class="comment">// 响应式对象</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;tony&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;)</span><br><span class="line"><span class="comment">// 原始对象</span></span><br><span class="line"><span class="keyword">let</span> rawPerson = <span class="title function_">toRaw</span>(person)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* markRaw */</span></span><br><span class="line"><span class="keyword">let</span> citysd = <span class="title function_">markRaw</span>([</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda01&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;北京&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda02&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;上海&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda03&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;天津&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda04&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;重庆&#x27;</span>&#125;</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了</span></span><br><span class="line"><span class="keyword">let</span> citys2 = <span class="title function_">reactive</span>(citys)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(person))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(rawPerson))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(citys))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">isReactive</span>(citys2))</span><br></pre></td></tr></table></figure><h3 id="markRaw"><a href="#markRaw" class="headerlink" title="markRaw"></a><code>markRaw</code></h3><ol><li>作用：标记一个对象，使其<strong>永远不会</strong>变成响应式的。</li><li>例如使用<code>mockjs</code>时，为了防止误把<code>mockjs</code>变为响应式对象，可以使用 <code>markRaw</code> 去标记<code>mockjs</code></li><li>编码：</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* markRaw */</span></span><br><span class="line"><span class="keyword">let</span> citys = <span class="title function_">markRaw</span>([</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda01&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;北京&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda02&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;上海&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda03&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;天津&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="string">&#x27;asdda04&#x27;</span>,<span class="attr">name</span>:<span class="string">&#x27;重庆&#x27;</span>&#125;</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 根据原始对象citys去创建响应式对象citys2 —— 创建失败，因为citys被markRaw标记了</span></span><br><span class="line"><span class="keyword">let</span> citys2 = <span class="title function_">reactive</span>(citys)</span><br></pre></td></tr></table></figure><h2 id="7-4-【customRef】"><a href="#7-4-【customRef】" class="headerlink" title="7.4.【customRef】"></a>7.4.【customRef】</h2><p>作用：创建一个自定义的<code>ref</code>，并对其依赖项跟踪和更新触发进行逻辑控制。</p><p>实现防抖效果（<code>useSumRef.ts</code>）：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;customRef &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">initValue:<span class="built_in">string</span>,delay:<span class="built_in">number</span></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> msg = <span class="title function_">customRef</span>(<span class="function">(<span class="params">track,trigger</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">timer</span>:<span class="built_in">number</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">track</span>() <span class="comment">// 告诉Vue数据msg很重要，要对msg持续关注，一旦变化就更新</span></span><br><span class="line">        <span class="keyword">return</span> initValue</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          initValue = value</span><br><span class="line">          <span class="title function_">trigger</span>() <span class="comment">//通知Vue数据msg变化了</span></span><br><span class="line">        &#125;, delay);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;) </span><br><span class="line">  <span class="keyword">return</span> &#123;msg&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件中使用：</p><h1 id="8-Vue3新组件"><a href="#8-Vue3新组件" class="headerlink" title="8. Vue3新组件"></a>8. Vue3新组件</h1><h2 id="8-1-【Teleport】"><a href="#8-1-【Teleport】" class="headerlink" title="8.1. 【Teleport】"></a>8.1. 【Teleport】</h2><ul><li>什么是Teleport？—— Teleport 是一种能够将我们的<strong>组件html结构</strong>移动到指定位置的技术。</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&#x27;body&#x27;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;modal&quot;</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是一个弹窗<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是弹窗中的一些内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;isShow = false&quot;</span>&gt;</span>关闭弹窗<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="8-2-【Suspense】"><a href="#8-2-【Suspense】" class="headerlink" title="8.2. 【Suspense】"></a>8.2. 【Suspense】</h2><ul><li>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</li><li>使用步骤：<ul><li>异步引入组件</li><li>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent,<span class="title class_">Suspense</span> &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;./Child.vue&#x27;</span>))</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是App组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Child</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:fallback</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">h3</span>&gt;</span>加载中.......<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="8-3-【全局API转移到应用对象】"><a href="#8-3-【全局API转移到应用对象】" class="headerlink" title="8.3.【全局API转移到应用对象】"></a>8.3.【全局API转移到应用对象】</h2><ul><li><code>app.component</code></li><li><code>app.config</code></li><li><code>app.directive</code></li><li><code>app.mount</code></li><li><code>app.unmount</code></li><li><code>app.use</code></li></ul><h2 id="8-4-【其他】"><a href="#8-4-【其他】" class="headerlink" title="8.4.【其他】"></a>8.4.【其他】</h2><ul><li>过渡类名 <code>v-enter</code> 修改为 <code>v-enter-from</code>、过渡类名 <code>v-leave</code> 修改为 <code>v-leave-from</code>。</li><li><code>keyCode</code> 作为 <code>v-on</code> 修饰符的支持。</li><li><code>v-model</code> 指令在组件上的使用已经被重新设计，替换掉了 <code>v-bind.sync。</code></li><li><code>v-if</code> 和 <code>v-for</code> 在同一个元素身上使用时的优先级发生了变化。</li><li>移除了<code>$on</code>、<code>$off</code> 和 <code>$once</code> 实例方法。</li><li>移除了过滤器 <code>filter</code>。</li><li>移除了<code>$children</code> 实例 <code>propert</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 应用 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用 </tag>
            
            <tag> 前端 </tag>
            
            <tag> vue3 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
