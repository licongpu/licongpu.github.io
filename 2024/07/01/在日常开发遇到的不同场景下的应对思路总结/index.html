<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>在日常开发遇到的不同场景下的应对思路总结 | 青山入我怀</title><meta name="author" content="李从浦"><meta name="copyright" content="李从浦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="​    作为一名开发人员，要知道我们每天都会面对很多场景，我们要想着如何去解决它们，因此，开展此专栏主要是想记录一下我日常开发遇到的一些场景以及和各种大佬交流时谈及的场景，以期日后如果能遇到类似场景，能够快速定位问题。 如果某天我不更新的，两种可能：我无所不能了&#x2F;我无了 这几篇老文章都是我之前用飞书云文档写的，因转换格式问题，之前已写完的文档图片太多了，不想一一转化了，大家可以访问我的"><meta property="og:type" content="article"><meta property="og:title" content="在日常开发遇到的不同场景下的应对思路总结"><meta property="og:url" content="http://licongpu.github.io/2024/07/01/%E5%9C%A8%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%BA%94%E5%AF%B9%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/index.html"><meta property="og:site_name" content="青山入我怀"><meta property="og:description" content="​    作为一名开发人员，要知道我们每天都会面对很多场景，我们要想着如何去解决它们，因此，开展此专栏主要是想记录一下我日常开发遇到的一些场景以及和各种大佬交流时谈及的场景，以期日后如果能遇到类似场景，能够快速定位问题。 如果某天我不更新的，两种可能：我无所不能了&#x2F;我无了 这几篇老文章都是我之前用飞书云文档写的，因转换格式问题，之前已写完的文档图片太多了，不想一一转化了，大家可以访问我的"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://licongpu.github.io/img/img02.jpg"><meta property="article:published_time" content="2024-07-01T05:39:45.572Z"><meta property="article:modified_time" content="2024-07-01T14:02:59.815Z"><meta property="article:author" content="李从浦"><meta property="article:tag" content="JAVA"><meta property="article:tag" content="应用"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://licongpu.github.io/img/img02.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://licongpu.github.io/2024/07/01/%E5%9C%A8%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%BA%94%E5%AF%B9%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:50},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体中文",cht_to_chs:"你已切换为简体中文",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#a29bfe",bgDark:"#7f8fa6",position:"bottom-left"},infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"在日常开发遇到的不同场景下的应对思路总结",isPost:!0,isHome:!1,isHighlightShrink:!0,isToc:!0,postUpdate:"2024-07-01 22:02:59"}</script><script>(e=>{e.saveToLocal={set:(e,t,o)=>{if(0===o)return;const a={value:t,expiry:Date.now()+864e5*o};localStorage.setItem(e,JSON.stringify(a))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!(Date.now()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=(e,t={})=>new Promise(((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},Object.keys(t).forEach((e=>{n.setAttribute(e,t[e])})),document.head.appendChild(n)})),e.getCSS=(e,t=!1)=>new Promise(((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},document.head.appendChild(n)})),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('/img/img02.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="青山入我怀"><span class="site-name">青山入我怀</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">在日常开发遇到的不同场景下的应对思路总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-07-01T05:39:45.572Z" title="发表于 2024-07-01 13:39:45">2024-07-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/">JAVA</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JAVA/%E5%BA%94%E7%94%A8/">应用</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">39.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>138分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>​ 作为一名开发人员，要知道我们每天都会面对很多场景，我们要想着如何去解决它们，因此，开展此专栏主要是想记录一下我日常开发遇到的一些场景以及和各种大佬交流时谈及的场景，以期日后如果能遇到类似场景，能够快速定位问题。</p><p>如果某天我不更新的，两种可能：我无所不能了&#x2F;我无了</p><p>这几篇老文章都是我之前用飞书云文档写的，因转换格式问题，之前已写完的文档图片太多了，不想一一转化了，大家可以访问我的飞书云文档来查看这些图片–<a target="_blank" rel="noopener" href="https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e">https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e</a></p><h1 id="基于Redis实现短信验证码的登录并解决登陆状态刷新的问题。"><a href="#基于Redis实现短信验证码的登录并解决登陆状态刷新的问题。" class="headerlink" title="基于Redis实现短信验证码的登录并解决登陆状态刷新的问题。"></a>基于<strong>Redis</strong>实现短信验证码的登录并解决登陆状态刷新的问题。</h1><h2 id="1-1-设计key的结构"><a href="#1-1-设计key的结构" class="headerlink" title="1.1 设计key的结构"></a>1.1 设计key的结构</h2><p>​ 我们需要保存在redis中的数据一共有两种，第一种是验证码，第二种是用户信息。那么针对这两种不同的信息，我们应该分别设计怎样的key呢？Redis中的key应该满足两点：</p><ol><li>唯一性</li><li>方便携带</li></ol><p>​ 针对验证码，我们可以用手机号来做key，这样的话就可以很好的保证key的唯一性</p><p>​ 针对用户信息，我们同样可以使用手机号作为key，但是有一个问题需要考虑，就是此时我们已经不用session进行用户校验了，那么服务器在做登录拦截时使用什么作为校验凭证呢？最好的方案就是使用redis中用户信息的key，前端在访问时通过访问头携带key来访问，如果通过key能在redis中找到数据，说明用户已登录。那么这种情况下我们最好不要使用手机号作为key，这毕竟属于用户比较隐私的信息，我们在后台生成一个随机串token，用这个token来作为key就比较合适了。</p><h2 id="1-2-设计整体访问流程"><a href="#1-2-设计整体访问流程" class="headerlink" title="1.2 设计整体访问流程"></a>1.2 设计整体访问流程</h2><ol><li>发送短信验证码：将手机号作为key，生成的验证码作为value存到redis中，等登录的时候，再去校验验证码是否一致。</li><li>验证码登录、注册：将用户发过来的手机号和验证码进行校验，查询redis对应的验证码，检验是否和发送过来的验证码是否一致，如果一致查询是否存在用户信息，如果不存在则去创建用户信息，最后将该用户信息存入redis中，以token作为key，用户信息作为value。为了后续的校验登录状态。</li><li>校验登录状态：根据请求携带的token去redis查询对应的用户信息，如果没有则拦截，如果有则保存到Threadlocal中，并且放行。</li></ol><p>代码实现：</p><ul><li>UserController层：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送手机验证码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;code&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(<span class="meta">@RequestParam(&quot;phone&quot;)</span> String phone)</span> &#123;</span><br><span class="line">    <span class="comment">// 发送短信验证码并保存验证码</span></span><br><span class="line">    <span class="keyword">return</span> userService.sendCode(phone);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录功能</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> loginForm 登录参数，包含手机号、验证码；或者手机号、密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> LoginFormDTO loginForm)</span>&#123;</span><br><span class="line">    <span class="comment">// 实现登录功能</span></span><br><span class="line">    <span class="keyword">return</span> userService.login(loginForm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前登录的用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/me&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">me</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 通过ThreadLocal获取当前登录的用户信息并返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(UserHolder.getUser());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>新建 LoginInterceptor拦截器</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里stringRedisTemplate并不能直接在ioc容器中获取，因为本类并没有交给spring容器管理。但是MvcConfig会创造本类的对象，我们只需要通过构造器让MvcConfig传入即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate redisTemplate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        log.info(<span class="string">&quot;拦截到请求：&#123;&#125;&quot;</span>,uri);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//前端是通过请求头&quot;authorization&quot;携带token令牌的，我们需要先判断token令牌是否携带</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断token是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isBlank(token))&#123;</span><br><span class="line">            <span class="comment">//token为空直接返回</span></span><br><span class="line">            log.info(<span class="string">&quot;用户未登录，请求已被拦截：&#123;&#125;&quot;</span>,uri);</span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//组装key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.LOGIN_USER_KEY + token;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过key获取redis中的用户信息</span></span><br><span class="line">        Map&lt;Object, Object&gt; map = redisTemplate.opsForHash().entries(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(map == <span class="literal">null</span>||map.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//map为null说明令牌是瞎编的，直接返回</span></span><br><span class="line">            log.info(<span class="string">&quot;key不正确，请求已被拦截：&#123;&#125;&quot;</span>,uri);</span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将map集合转化为userDto对象</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存用户信息到ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//刷新token有效期，用户每访问一次服务器都需要刷新一次token有效期，避免用户在一直活跃的情况下令牌失效</span></span><br><span class="line">        redisTemplate.expire(key,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;用户已登录，id为&#123;&#125;&quot;</span>,user.getId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//在请求结束后销毁ThreadLocal中的用户信息</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>新建MvcConfig配置类，让拦截器生效</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//在创建对象时将stringRedisTemplate传给拦截器使用</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>(stringRedisTemplate))</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span></span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>UserService层</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phone</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="comment">//校验手机号是否正确</span></span><br><span class="line">        <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomNumbers(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将验证码存放在redis中</span></span><br><span class="line">        <span class="comment">//这里使用String类型，key使用固定前缀+手机号码，值为验证码，并设置有效期为两分钟</span></span><br><span class="line">        redisTemplate.opsForValue().set(RedisConstants.LOGIN_CODE_KEY+phone,code,RedisConstants.LOGIN_CODE_TTL,TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送短信验证码成功</span></span><br><span class="line">        log.info(<span class="string">&quot;短信验证码发送成功：&#123;&#125;&quot;</span>,code);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录验证</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loginForm</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> loginForm.getPhone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从redis中获取验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> redisTemplate.opsForValue().get(RedisConstants.LOGIN_CODE_KEY+phone);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断手机号是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(phone == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断验证码是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(code == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//校验手机号是否合法</span></span><br><span class="line">        <span class="keyword">if</span>(RegexUtils.isPhoneInvalid(phone))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;手机号格式不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断验证码是否正确</span></span><br><span class="line">        <span class="keyword">if</span>(!code.equals(loginForm.getCode()))&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;验证码不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断用户是否存在</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> query().eq(<span class="string">&quot;phone&quot;</span>, phone).one();</span><br><span class="line">        <span class="keyword">if</span>(user == <span class="literal">null</span>)&#123;</span><br><span class="line">            log.info(<span class="string">&quot;用户不存在，创建新用户：&#123;&#125;&quot;</span>,phone);</span><br><span class="line">            <span class="comment">//调用创建用户方法</span></span><br><span class="line">           user =  createNewUser(phone);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用redis保存用户信息</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里使用uuid随机生成redis的key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userToken</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里为了避免不同业务的key冲突，给key加上前缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userTokenKey</span> <span class="operator">=</span> RedisConstants.LOGIN_USER_KEY+userToken;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Hash类型存储用户信息，存储数据前，需要先将对象转换成map集合</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">userDTO</span> <span class="operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//转换成map集合的过程中还需要做处理，因为StringRedisTemplate只能只针对字符串进行序列化，因此我们要将userDTO中每个 属性都转换成字符串</span></span><br><span class="line">        Map&lt;String, Object&gt; map = BeanUtil.beanToMap(</span><br><span class="line">                userDTO,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(),</span><br><span class="line">                CopyOptions.create() <span class="comment">//自定义拷贝选项</span></span><br><span class="line">                        .ignoreNullValue() <span class="comment">//允许属性为null</span></span><br><span class="line">                        .setFieldValueEditor((fileName,fileValue)-&gt;fileValue.toString()) <span class="comment">//对属性值进行编辑，把所有属性值转换成字符串</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存数据到redis</span></span><br><span class="line">        redisTemplate.opsForHash().putAll(userTokenKey,map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置redis有效期</span></span><br><span class="line">        redisTemplate.expire(userTokenKey,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里需要将token信息返回给前端，前端需要token令牌来访问</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(userToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phone</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">createNewUser</span><span class="params">(String phone)</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setNickName(SystemConstants.USER_NICK_NAME_PREFIX+RandomUtil.randomString(<span class="number">10</span>));</span><br><span class="line">        user.setPhone(phone);</span><br><span class="line">        save(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-解决状态登录刷新问题"><a href="#1-3-解决状态登录刷新问题" class="headerlink" title="1.3 解决状态登录刷新问题"></a>1.3 解决状态登录刷新问题</h2><p>初始方案思路总结：</p><p>在这个方案中，他确实可以使用对应路径的拦截，同时刷新登录token令牌的存活时间，但是现在这个拦截器他只是拦截需要被拦截的路径，假设当前用户访问了一些不需要拦截的路径，那么这个拦截器就不会生效，所以此时令牌刷新的动作实际上就不会执行，所以这个方案他是存在问题的</p><p>优化方案</p><p>既然之前的拦截器无法对不需要拦截的路径生效，那么我们可以添加一个拦截器，在第一个拦截器中拦截所有的路径，把第二个拦截器做的事情放入到第一个拦截器中，同时刷新令牌，因为第一个拦截器有了threadLocal的数据，所以此时第二个拦截器只需要判断拦截器中的user对象是否存在即可，完成整体刷新功能。</p><p>代码实现:</p><ul><li>新建一个RefreshTokenInterceptor拦截器，负责刷新令牌和保存用户信息等工作</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefreshTokenInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里stringRedisTemplate并不能直接在ioc容器中获取，因为本类并没有交给spring容器管理。但是MvcConfig会创造本类的对象，我们只需要通过构造器让MvcConfig传入即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RefreshTokenInterceptor</span><span class="params">(StringRedisTemplate redisTemplate)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        log.info(<span class="string">&quot;RefreshTokenInterceptor拦截到请求：&#123;&#125;&quot;</span>,uri);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//前端是通过请求头&quot;authorization&quot;携带token令牌的，我们需要先判断token令牌是否携带</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断token是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(StrUtil.isBlank(token))&#123;</span><br><span class="line">            <span class="comment">//令牌不存在是不需要刷新的，直接放给下一个拦截器处理</span></span><br><span class="line">            log.info(<span class="string">&quot;令牌不存在，RefreshTokenInterceptor已放行请求：&#123;&#125;&quot;</span>,uri);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//组装key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.LOGIN_USER_KEY + token;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过key获取redis中的用户信息</span></span><br><span class="line">        Map&lt;Object, Object&gt; map = redisTemplate.opsForHash().entries(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(map == <span class="literal">null</span>||map.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//用户不存在的话也不需要刷新令牌，直接放行给下一个拦截器处理</span></span><br><span class="line">            log.info(<span class="string">&quot;令牌不存在，RefreshTokenInterceptor已放行请求：&#123;&#125;&quot;</span>,uri);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将map集合转化为userDto对象</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">UserDTO</span>(), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存用户信息到ThreadLocal</span></span><br><span class="line">        UserHolder.saveUser(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//刷新token有效期</span></span><br><span class="line">        redisTemplate.expire(key,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;用户已登录，RefreshTokenInterceptor已放行请求，用户为&#123;&#125;&quot;</span>,user.getId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//在请求结束后销毁ThreadLocal中的用户信息</span></span><br><span class="line">        UserHolder.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改LoginInterceptor的代码，因为很多工作我们已经在RefreshTokenInterceptor中做了，因此在LoginInterceptor我们只需要判断ThreadLocal中有没有用户信息即可</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        log.info(<span class="string">&quot;LoginInterceptor拦截到请求：&#123;&#125;&quot;</span>,uri);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(UserHolder.getUser() == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//说明用户未登录,直接拦截</span></span><br><span class="line">            log.info(<span class="string">&quot;用户未登录，LoginInterceptor未放行请求&#123;&#125;&quot;</span>,uri);</span><br><span class="line">            response.setStatus(<span class="number">401</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        log.info(<span class="string">&quot;LoginInterceptor已放行请求：&#123;&#125;&quot;</span>,uri);</span><br><span class="line">        <span class="comment">//说明用户已登录，直接放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>还需要在MvcConfig中修改拦截器配置</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 添加拦截器并排除不需要拦截的路径，即不用登录也可以访问的页面</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .excludePathPatterns(</span><br><span class="line">                        <span class="string">&quot;/shop/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/voucher/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/user/code&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/shop-type/**&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;/upload/**&quot;</span></span><br><span class="line">                ).order(<span class="number">1</span>);<span class="comment">//</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">RefreshTokenInterceptor</span>(stringRedisTemplate)).order(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Mongodb实现评论的功能"><a href="#Mongodb实现评论的功能" class="headerlink" title="Mongodb实现评论的功能"></a>Mongodb实现评论的功能</h1><p>为什么用mongdb存储内推信息的评论</p><p>1.文档存储模型：MongoDB是一个面向文档的数据库，这意味着它存储数据的方式更接近于JSON格</p><p>式。对于文章评论，这意味着可以将评论作为一个整体文档进行存储，而不需要像关系型数据库那样将其分解为多个表和字段。这种灵活性使得MongoDB在处理复杂的数据结构时更加方便。</p><p>2.动态模式：MongoDB不需要预先定义数据结构，可以存储不同格式的文档。这对于文章评论来说非常有用，因为不同的评论可能有不同的字段和格式。相比之下，MySQL等传统关系型数据库需要预先定义表结构，这可能会限制灵活性。</p><p>3.水平扩展：MongoDB的分布式架构使其能够轻松地在多个服务器之间进行数据分区和复制，从而实现水平扩展。这对于处理大量文章评论非常有用，因为可以很容易地增加更多的服务器来处理更高的负载。而MySQL等传统关系型数据库在扩展方面可能面临更多的挑战。</p><p>4.查询性能：MongoDB的查询性能通常优于传统关系型数据库，尤其是在处理大量数据时。MongoDB</p><p>使用BSON(Binary JSON)格式存储数据，这使得它能够更高效地执行复杂查询和索引操作。这对于</p><p>文章评论系统来说非常重要，因为它们通常需要支持高效的查询和搜索功能。</p><p>5.实时更新：MongoDB支持实时更新和插入操作，这使得它非常适合处理实时评论。相比之下，传</p><p>统关系型数据库可能需要在更新数据时执行更多的锁定和事务操作，这可能会影响性能：</p><p>​ 当然，MongoDB也有其局限性，例如在处理复杂的事务和连接操作方面可能不如MySQL等传统关系型数据库。因此，在选择数据库时，需要根据具体需求和场景进行权衡。</p><ol><li><h2 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a><strong>表结构</strong></h2></li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ODI4YTUxODhjOWQyOTBkNDY1MWEzMTFmOGFhOTcwZGRfa1RoaGxpWUdrZml2N2h2R0d3YXNMZ0ZYbXhhR0VhWGtfVG9rZW46UkMzZWJ5cXZWb2FiOHd4RVd5VWNqNXlEbndnXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h2 id="2-使用技术SpringDataMongoDB"><a href="#2-使用技术SpringDataMongoDB" class="headerlink" title="2.使用技术SpringDataMongoDB"></a>2.<strong>使用技术SpringDataMongoDB</strong></h2><p>SpringData家族成员之一，用于操作MongoDB的持久层框架，封装了底层的mongodb-driver。</p><h2 id="3-搭建工程-pom-xml引入依赖："><a href="#3-搭建工程-pom-xml引入依赖：" class="headerlink" title="3.搭建工程,pom.xml引入依赖："></a>3.<strong>搭建工程,pom.xml引入依赖：</strong></h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>article<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-application-yml中配置mongodb"><a href="#4-application-yml中配置mongodb" class="headerlink" title="4.application.yml中配置mongodb"></a><strong>4.application.yml中配置mongodb</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">#数据源配置</span><br><span class="line">data:</span><br><span class="line">mongodb:</span><br><span class="line"># 主机地址</span><br><span class="line">host: <span class="number">192.168</span><span class="number">.40</span><span class="number">.141</span></span><br><span class="line"># 数据库</span><br><span class="line">database: articledb</span><br><span class="line"># 默认端口是<span class="number">27017</span></span><br><span class="line">port: <span class="number">27017</span></span><br><span class="line">#也可以使用uri连接</span><br><span class="line">#uri: mongodb:<span class="comment">//192.168.40.134:27017/</span></span><br></pre></td></tr></table></figure><h2 id="5-文章评论实体类的编写-根据数据库表生成"><a href="#5-文章评论实体类的编写-根据数据库表生成" class="headerlink" title="5.文章评论实体类的编写(根据数据库表生成)"></a><strong>5.文章评论实体类的编写(根据数据库表生成)</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.article.po;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.annotation.Id;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.index.Indexed;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.mapping.Document;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.mapping.Field;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 文章评论实体类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//把一个java类声明为mongodb的文档，可以通过collection参数指定这个类对应的文档。</span></span><br><span class="line"><span class="comment">//@Document(collection=&quot;mongodb 对应 collection 名&quot;)</span></span><br><span class="line"><span class="comment">// 若未加 @Document ，该 bean save 到 mongo 的 comment collection</span></span><br><span class="line"><span class="comment">// 若添加 @Document ，则 save 到 comment collection</span></span><br><span class="line"><span class="meta">@Document(collection=&quot;comment&quot;)</span><span class="comment">//可以省略，如果省略，则默认使用类名小写映射集合</span></span><br><span class="line"><span class="comment">//复合索引</span></span><br><span class="line"><span class="comment">// @CompoundIndex( def = &quot;&#123;&#x27;userid&#x27;: 1, &#x27;nickname&#x27;: -1&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Comment</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"><span class="comment">//主键标识，该属性的值会自动对应mongodb的主键字段&quot;_id&quot;，如果该属性名就叫“id”,则该注解可以省略，否则必须写</span></span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="keyword">private</span> String id;<span class="comment">//主键</span></span><br><span class="line"><span class="comment">//该属性对应mongodb的字段的名字，如果一致，则无需该注解</span></span><br><span class="line"><span class="meta">@Field(&quot;content&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String content;<span class="comment">//吐槽内容</span></span><br><span class="line"><span class="keyword">private</span> Date publishtime;<span class="comment">//发布日期</span></span><br><span class="line"><span class="comment">//添加了一个单字段的索引</span></span><br><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">private</span> String userid;<span class="comment">//发布人ID</span></span><br><span class="line"><span class="keyword">private</span> String nickname;<span class="comment">//昵称</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime createdatetime;<span class="comment">//评论的日期时间</span></span><br><span class="line"><span class="keyword">private</span> Integer likenum;<span class="comment">//点赞数</span></span><br><span class="line"><span class="keyword">private</span> Integer replynum;<span class="comment">//回复数</span></span><br><span class="line"><span class="keyword">private</span> String state;<span class="comment">//状态</span></span><br><span class="line"><span class="keyword">private</span> String parentid;<span class="comment">//上级ID</span></span><br><span class="line"><span class="keyword">private</span> String articleid;</span><br><span class="line"><span class="comment">//getter and setter.....</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.content = content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Date <span class="title function_">getPublishtime</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> publishtime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPublishtime</span><span class="params">(Date publishtime)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.publishtime = publishtime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserid</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> userid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserid</span><span class="params">(String userid)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.userid = userid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getNickname</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nickname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNickname</span><span class="params">(String nickname)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> LocalDateTime <span class="title function_">getCreatedatetime</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createdatetime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCreatedatetime</span><span class="params">(LocalDateTime createdatetime)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.createdatetime = createdatetime;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">getLikenum</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> likenum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLikenum</span><span class="params">(Integer likenum)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.likenum = likenum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">getReplynum</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> replynum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setReplynum</span><span class="params">(Integer replynum)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.replynum = replynum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(String state)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.state = state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getParentid</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> parentid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParentid</span><span class="params">(String parentid)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.parentid = parentid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getArticleid</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> articleid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setArticleid</span><span class="params">(String articleid)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.articleid = articleid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Comment&#123;&quot;</span> +</span><br><span class="line"><span class="string">&quot;id=&#x27;&quot;</span> + id + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&quot;, content=&#x27;&quot;</span> + content + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&quot;, publishtime=&quot;</span> + publishtime +</span><br><span class="line"><span class="string">&quot;, userid=&#x27;&quot;</span> + userid + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&quot;, nickname=&#x27;&quot;</span> + nickname + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&quot;, createdatetime=&quot;</span> + createdatetime +</span><br><span class="line"><span class="string">&quot;, likenum=&quot;</span> + likenum +</span><br><span class="line"><span class="string">&quot;, replynum=&quot;</span> + replynum +</span><br><span class="line"><span class="string">&quot;, state=&#x27;&quot;</span> + state + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&quot;, parentid=&#x27;&quot;</span> + parentid + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&quot;, articleid=&#x27;&quot;</span> + articleid + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line"><span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-为合适字段建立索引"><a href="#6-为合适字段建立索引" class="headerlink" title="6.为合适字段建立索引"></a>6.为合适字段建立索引</h2><p>索引可以大大提升查询效率，一般在查询字段上添加索引，索引的添加可以通过Mongo的命令来添加，也可以在Java的实体类中通过注解添加。</p><p>1）单字段索引注解@Indexed</p><p>org.springframework.data.mongodb.core.index.Indexed.class</p><p>声明该字段需要索引，建索引可以大大的提高查询效率。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">db.comment.createIndex(&#123;<span class="string">&quot;userid&quot;</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>2）复合索引注解@CompoundIndex</p><p>org.springframework.data.mongodb.core.index.CompoundIndex.class</p><p>复合索引的声明，建复合索引可以有效地提高多字段的查询效率。</p><p>Mongo命令参考：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">db.comment.createIndex(&#123;<span class="string">&quot;userid&quot;</span>:<span class="number">1</span>,<span class="string">&quot;nickname&quot;</span>:-<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="7-创建controller、sevice、mapper层"><a href="#7-创建controller、sevice、mapper层" class="headerlink" title="7.创建controller、sevice、mapper层"></a><strong>7.创建controller、sevice、mapper层</strong></h2><p>mapper层的CommentRepository要继承自MongoRepository并指定实体类和id</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.article.dao;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.article.po.Comment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Pageable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.repository.MongoRepository;</span><br><span class="line"><span class="comment">//评论的持久层接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommentRepository</span> <span class="keyword">extends</span> <span class="title class_">MongoRepository</span>&lt;Comment,String&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service里面的评论的增删改查方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.article.service;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.article.dao.CommentRepository;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.article.po.Comment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">//评论的业务层</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommentService</span> &#123;</span><br><span class="line"><span class="comment">//注入dao</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CommentRepository commentRepository;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 保存一个评论</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> comment</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveComment</span><span class="params">(Comment comment)</span>&#123;</span><br><span class="line"><span class="comment">//如果需要自定义主键，可以在这里指定主键；如果不指定主键，MongoDB会自动生成主键</span></span><br><span class="line"><span class="comment">//设置一些默认初始值。。。</span></span><br><span class="line"><span class="comment">//调用dao</span></span><br><span class="line">commentRepository.save(comment);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 更新评论</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> comment</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateComment</span><span class="params">(Comment comment)</span>&#123;</span><br><span class="line"><span class="comment">//调用dao</span></span><br><span class="line">commentRepository.save(comment);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据id删除评论</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteCommentById</span><span class="params">(String id)</span>&#123;</span><br><span class="line"><span class="comment">//调用dao</span></span><br><span class="line">commentRepository.deleteById(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查询所有评论</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Comment&gt; <span class="title function_">findCommentList</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//调用dao</span></span><br><span class="line"><span class="keyword">return</span> commentRepository.findAll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据id查询评论</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Comment <span class="title function_">findCommentById</span><span class="params">(String id)</span>&#123;</span><br><span class="line"><span class="comment">//调用dao</span></span><br><span class="line"><span class="keyword">return</span> commentRepository.findById(id).get();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-根据上级ID查询内推评论的分页列表"><a href="#8-根据上级ID查询内推评论的分页列表" class="headerlink" title="8.根据上级ID查询内推评论的分页列表"></a><strong>8.根据上级ID查询内推评论的分页列表</strong></h2><ol><li><h3 id="CommentRepository新增方法定义"><a href="#CommentRepository新增方法定义" class="headerlink" title="CommentRepository新增方法定义"></a>CommentRepository新增方法定义</h3></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据父id，查询子评论的分页列表</span></span><br><span class="line">Page&lt;Comment&gt; <span class="title function_">findByParentid</span><span class="params">(String parentid, Pageable pageable)</span>;</span><br></pre></td></tr></table></figure><ol><li><h3 id="CommentService新增方法"><a href="#CommentService新增方法" class="headerlink" title="CommentService新增方法"></a>CommentService新增方法</h3></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据父id查询分页列表</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> parentid</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> page</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> size</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;Comment&gt; <span class="title function_">findCommentListPageByParentid</span><span class="params">(String parentid,<span class="type">int</span> page ,<span class="type">int</span> size)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> commentRepository.findByParentid(parentid, PageRequest.of(page-<span class="number">1</span>,size));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-MongoTemplate实现评论点赞"><a href="#9-MongoTemplate实现评论点赞" class="headerlink" title="9.MongoTemplate实现评论点赞"></a><strong>9.MongoTemplate实现评论点赞</strong></h2><p>我们一开始用的是根据id查出来评论的点赞数，然后+1，但是后面觉得这么做效率太低了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 点赞-效率低</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateCommentThumbupToIncrementingOld</span><span class="params">(String id)</span>&#123;</span><br><span class="line"><span class="type">Comment</span> <span class="variable">comment</span> <span class="operator">=</span> CommentRepository.findById(id).get();</span><br><span class="line">comment.setLikenum(comment.getLikenum()+<span class="number">1</span>);</span><br><span class="line">CommentRepository.save(comment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以后面用MongoTemplate类来实现对某列的操作从而进行了优化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 点赞数+1</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateCommentLikenum</span><span class="params">(String id)</span>&#123;</span><br><span class="line"><span class="comment">//查询对象</span></span><br><span class="line">Query query=Query.query(Criteria.where(<span class="string">&quot;_id&quot;</span>).is(id));</span><br><span class="line"><span class="comment">//更新对象</span></span><br><span class="line">Update update=<span class="keyword">new</span> <span class="title class_">Update</span>();</span><br><span class="line"><span class="comment">//局部更新，相当于$set</span></span><br><span class="line"><span class="comment">// update.set(key,value)</span></span><br><span class="line"><span class="comment">//递增$inc</span></span><br><span class="line"><span class="comment">// update.inc(&quot;likenum&quot;,1);</span></span><br><span class="line">update.inc(<span class="string">&quot;likenum&quot;</span>);</span><br><span class="line"><span class="comment">//参数1：查询对象</span></span><br><span class="line"><span class="comment">//参数2：更新对象</span></span><br><span class="line"><span class="comment">//参数3：集合的名字或实体类的类型Comment.class</span></span><br><span class="line">mongoTemplate.updateFirst(query,update,<span class="string">&quot;comment&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一个版本</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户点赞与取消点赞评论根据评论id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> commentId 被点赞评论id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isThumbup true : 点赞 ； false : 取消点赞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">thumbup</span><span class="params">(String commentId, Boolean isThumbup)</span> &#123;</span><br><span class="line">        <span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Query</span>(Criteria.where(<span class="string">&quot;cid&quot;</span>).is(commentId)); <span class="comment">//设置修改条件</span></span><br><span class="line">        <span class="type">Update</span> <span class="variable">update</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Update</span>();</span><br><span class="line">        <span class="keyword">if</span>(isThumbup)&#123; <span class="comment">//点赞操作</span></span><br><span class="line">            update.inc(<span class="string">&quot;thumbup&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//取消点赞操作</span></span><br><span class="line">            update.inc(<span class="string">&quot;thumbup&quot;</span>,-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mongoTemplate.updateFirst(query,update,<span class="string">&quot;comment&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="印象最深-解决深分页问题"><a href="#印象最深-解决深分页问题" class="headerlink" title="印象最深-解决深分页问题"></a>印象最深-解决深分页问题</h1><p>先说一下背景吧:遇到的问题:因为我们用的是Navicat模拟了十万的假数据，数据量比较大，把数据录入MySQL表之后，在前后端联调时发现了翻页越到后面显示的越慢，起初不知道深度分页这个问题，以为只是网络的原因，就一直搁置着这个问题，但是心里总是感觉不得劲，后来我在刷抖音时刚好刷到有大佬聊这个问题，于是我就尝试在我们的系统上进行了修改，最后解决了这个问题，虽然说这个只是一个小优化，但是解了我心里的一个结，所以我对这个确实印象深刻。</p><p>​ 然后我说一下什么是深分页吧，深分页就是 mysql的limit关键字 ，它需要设置偏移量和它查询的条数进行分页，如果limit的偏移量数值设置的比较大，它还要扫描偏移量的全部数据然后舍弃掉。比如 limit 1000 10,它需要扫描1010条数据并且丢弃掉前面的1000条，只返回最后的10条，了解到它的解决方法，</p><ul><li>首先是可以设置避免直接查询太深的页码，让偏移量少一点，就是不设置跳转的功能，但是我觉得这种可能会减少用户的体验感。</li></ul><p>所以就想着从sql上做优化，上网搜索了一下，主要有两种方法</p><ul><li>一种就是要记录上一次查询到哪了，这一次就筛选掉之前的数据，减少limit的丢弃量，那么知道上次分页的最后一个数据的id并且id是自增的，那就可以根据id筛选掉不需要的数据，偏移量直接不写，只需要具体的条数就可以了，比如：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select from table where id&gt;? and 其他条件 limit ?</span><br></pre></td></tr></table></figure><ul><li>第二种就是id不是自增的，就利用子查询，只查询id作为外部查询的id in的条件，通过索引覆盖减少回表，从而尽可能提升查询效率 比如：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select from table where id <span class="title function_">in</span> <span class="params">(select id from (select id from table where 条件 limit ?,?)</span>t)</span><br></pre></td></tr></table></figure><p>我们这个项目用的是第二种方式。</p><h1 id="采用CompletableFuture异步编程实现数据汇总"><a href="#采用CompletableFuture异步编程实现数据汇总" class="headerlink" title="采用CompletableFuture异步编程实现数据汇总"></a>采用<strong>CompletableFuture</strong>异步编程实现数据汇总</h1><p>传统的Future异步编程实现起来非常复杂，它需要实现FutureTask方法并实现Callable内部类，再结合Thread或者线程池的方式实现，获得返回值要调用FutureTask的get方法，他会阻塞后面的代码，但是如果后面的代码不依赖返回值的话，我们希望它们能以并行的方式去执行，那我们就能结合<strong>CompletableFuture去改造</strong></p><p>它提供了两种异步任务：</p><ul><li>runAsync(),方法执行任务是没有返回值的</li><li>supplyAsync()方法执行任务则支持返回值</li></ul><p>两种组合处理：</p><ul><li>anyOf返回跑的最快的那个future。最快的如果异常都玩完</li><li>allOf全部并行执行，如果需要获得返回值，需要配合thenApply,异常会抛出不影响其他任何任务</li></ul><p>异步回调方法：不会阻碍后面的任务执行</p><ul><li>whenComplete()没有返回值，且返回的CompletableFuture为任务结果，而非回调结果</li><li>handle()有返回值，且返回的CompletableFuture为回调结果</li></ul><p>上面两个方法出现异常不会中断throwable:参数会接收前面的任务的异常异常会通过get抛出到主线程</p><ul><li>链式处理：–出现异常后面的任务会中断处理任务中感知不到异常异常会通过get抛出到主线程</li></ul><ol><li>thenRun(Runnable runnable): 对异步任务的结果进行操作，不能传入参，也没有返回值</li><li>thenAccept(Consumer consumer):可传入参数</li><li>thenApply(Function function）:可传入参数，并返回结果</li></ol><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span><span class="keyword">throws</span> ExecutionException,InterruptedException&#123;</span><br><span class="line">CompletableFuture&lt;Integer&gt;future1 CompletableFuture.supplyAsync(()-&gt;<span class="number">15</span>);</span><br><span class="line">CompletableFuture&lt;Integer&gt;future2 CompletableFuture.supplyAsync(()-&gt;<span class="number">10</span>);</span><br><span class="line">CompletableFuture&lt;Integer&gt;allFutures CompletableFuture.allOf(future1,future2)</span><br><span class="line">thenApply(res -&gt;&#123;</span><br><span class="line"><span class="keyword">return</span> future1.join()+future2.join();</span><br><span class="line"><span class="comment">//TODO....</span></span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(allFutures.join());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后看一下我采用CompletableFuture异步编程后的思路(简单展示思路，并非项目真实代码)</p><p>controller层</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/surveys&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SurveyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SurveyService surveyService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SurveyController</span><span class="params">(SurveyService surveyService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.surveyService = surveyService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/process&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">processSurveyConcurrently</span><span class="params">(<span class="meta">@RequestBody</span> SurveyData data,</span></span><br><span class="line"><span class="params">                                                            <span class="meta">@RequestParam</span> SurveyStatus newStatus)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> surveyService.processSurveyConcurrentlyAsync(data, newStatus);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service层</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SurveyService.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SurveyServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SurveyService</span> &#123;</span><br><span class="line">    <span class="comment">//先用一个mapper实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SurveyMapper surveyMapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SurveyServiceImpl</span><span class="params">(SurveyMapper surveyMapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.surveyMapper = surveyMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">saveSurveyDataAsync</span><span class="params">(SurveyData data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.runAsync(() -&gt; surveyMapper.saveSurveyData(data), executorService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">updateSurveyStatusAsync</span><span class="params">(String surveyId, SurveyStatus status)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.runAsync(() -&gt; surveyMapper.updateSurveyStatus(surveyId, status), executorService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;AnalysisResult&gt; <span class="title function_">analyzeSurveyResultsAsync</span><span class="params">(SurveyData data)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里只是一个示例，实际的数据处理更复杂</span></span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnalysisResult</span>();</span><br><span class="line">        &#125;, executorService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;Void&gt; <span class="title function_">processSurveyConcurrentlyAsync</span><span class="params">(SurveyData data, SurveyStatus newStatus)</span> &#123;</span><br><span class="line">        CompletableFuture&lt;Void&gt; saveFuture = saveSurveyDataAsync(data);</span><br><span class="line">        CompletableFuture&lt;AnalysisResult&gt; analyzeFuture = analyzeSurveyResultsAsync(data);</span><br><span class="line">        CompletableFuture&lt;Void&gt; updateFuture = updateSurveyStatusAsync(data.getSurveyId(), newStatus);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.allOf(saveFuture, analyzeFuture, updateFuture)</span><br><span class="line">            .thenRun(() -&gt; System.out.println(<span class="string">&quot;All operations completed successfully!&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapper层</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SurveyMapper.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SurveyMapper</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">saveSurveyData</span><span class="params">(SurveyData data)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">updateSurveyStatus</span><span class="params">(String surveyId, SurveyStatus status)</span>;</span><br><span class="line">    SurveyData <span class="title function_">getSurveyDataById</span><span class="params">(String surveyId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于Spring-Task定时任务调度实现定期清理回访问卷数据"><a href="#基于Spring-Task定时任务调度实现定期清理回访问卷数据" class="headerlink" title="基于Spring Task定时任务调度实现定期清理回访问卷数据"></a>基于<strong>Spring Task</strong>定时任务调度实现定期清理回访问卷数据</h1><p>这个场景呢，也是我在开发学院科研项目时遇到的场景，主要呢就是实现两个功能，一是超时的问卷，二是每天凌晨触发一次清理一直处于未审核通过的问卷。</p><p>具体做法（涉及到项目内部，所以这里只展示一下大体实现）</p><p>首先呢，要在启动类上加上 @EnableScheduling &#x2F;&#x2F;开启任务调度</p><p>然后创建一个定时任务类QuestionnaireTask ，并注入QuestionnaireMapper</p><h2 id="5-1-处理超时问卷"><a href="#5-1-处理超时问卷" class="headerlink" title="5.1. 处理超时问卷"></a>5.1. 处理超时问卷</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0 * * * * ? &quot;)</span><span class="comment">//每分钟触发一次</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processTimeoutQuestionnaire</span><span class="params">()</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;定时处理超时问卷,&#123;&#125;&quot;</span>, LocalDateTime.now());</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime .now().plusMinutes(-<span class="number">15</span>);</span><br><span class="line">    <span class="comment">//获取已超时的问卷</span></span><br><span class="line">    List&lt;questionnaires&gt; questionnaireList = QuestionnaireMapper.getByStatusAndQuestionnaireTimeLT(Questionnaires.COLLECT,time);</span><br><span class="line">    <span class="keyword">if</span> (questionnaireList!=<span class="literal">null</span>&amp;&amp;questionnaireList .size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (Questionnaires questionnaires: questionnaireList ) &#123;</span><br><span class="line">            <span class="comment">//问卷处理(此处为演示，具体逻辑在mapper层实现)</span></span><br><span class="line">            QuestionnaireMapper.update(questionnaires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-每天凌晨触发一次清理一直处于未发布状态的问卷"><a href="#5-2-每天凌晨触发一次清理一直处于未发布状态的问卷" class="headerlink" title="5.2 每天凌晨触发一次清理一直处于未发布状态的问卷"></a>5.2 每天凌晨触发一次清理一直处于未发布状态的问卷</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0 0 1 * * ?&quot;)</span> <span class="comment">//每天凌晨一点触发一次</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processAuditQuestionnaires</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalDateTime.now().plusMinutes(-<span class="number">60</span>);</span><br><span class="line">    List&lt;Questionnaires&gt; questionnairesList = questionnaireMapper.getByStatusAndOrderTimeLT(Questionnaires.UNPUBLISH, time);</span><br><span class="line">    <span class="keyword">if</span> (questionnairesList !=<span class="literal">null</span>&amp;&amp;questionnairesList .size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (Questionnaires questionnaires : questionnairesList ) &#123;</span><br><span class="line">            <span class="comment">//演示</span></span><br><span class="line">            questionnaireMapper.delete(questionnaires);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于SpringData-Elasticsearch操纵Elasticsearch的实现检索中药材sku信息、热销药材"><a href="#基于SpringData-Elasticsearch操纵Elasticsearch的实现检索中药材sku信息、热销药材" class="headerlink" title="基于SpringData Elasticsearch操纵Elasticsearch的实现检索中药材sku信息、热销药材"></a>基于<strong>SpringData</strong> <strong>Elasticsearch</strong>操纵<strong>Elasticsearch</strong>的实现检索中药材<strong>sku</strong>信息、热销药材</h1><p>此项目是微服务项目，不同的功能分成了不同的模块，通过feign相互调用，下面只针对service-search模块做介绍，远程调用其他模块不做详细介绍。（search模块还完成上下架的功能，此处不做具体介绍，在rabbitMQ功能使用时具体介绍）</p><p>先在service-search引入<strong>SpringData</strong> <strong>Elasticsearch</strong> 的依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</span><span class="comment">//取消数据源自动配置</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceSearchApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ServiceSearchApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>application-dev.yml中进行配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">elasticsearch:</span><br><span class="line">  rest:</span><br><span class="line">    uris: http:<span class="comment">//localhost:9201</span></span><br></pre></td></tr></table></figure><p>controller层</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;api/search/sku&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SkuApiController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SkuService skuService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;inner/findHotSkuList&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;SkuEs&gt; <span class="title function_">findHotSkuList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> skuService.findHotSkuList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;&#123;page&#125;/&#123;limit&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">listSku</span><span class="params">(<span class="meta">@PathVariable(&quot;page&quot;)</span> Integer page, <span class="meta">@PathVariable(&quot;limit&quot;)</span> Integer limit, SkuEsQueryVo skuEsQueryVo)</span> &#123;</span><br><span class="line">    <span class="comment">//0代表第一页</span></span><br><span class="line">    <span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> PageRequest.of(page - <span class="number">1</span>, limit);</span><br><span class="line">    Page&lt;SkuEs&gt; pageModel = skuService.search(pageable, skuEsQueryVo);</span><br><span class="line">    <span class="keyword">return</span>  Result.ok(pageModel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新热度</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;inner/incrHotScore/&#123;skuId&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">incrHotScore</span><span class="params">(<span class="meta">@PathVariable(&quot;skuId&quot;)</span> Long skuId)</span>&#123;</span><br><span class="line">    skuService.incrHotScore(skuId);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service层</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SkuServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SkuService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SkuRepository skuRepository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ProductFeignClient productFeignClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ActivityFeignClient activityFeignClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取热度高的中药</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;SkuEs&gt; <span class="title function_">findHotSkuList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Pageable</span> <span class="variable">pageable</span> <span class="operator">=</span> PageRequest.of(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    Page&lt;SkuEs&gt; pageModel = skuRepository.findByOrderByHotScoreDesc(pageable);</span><br><span class="line">    List&lt;SkuEs&gt; skuEsList = pageModel.getContent();</span><br><span class="line">    <span class="keyword">return</span> skuEsList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询中药</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Page&lt;SkuEs&gt; <span class="title function_">search</span><span class="params">(Pageable pageable, SkuEsQueryVo skuEsQueryVo)</span> &#123;</span><br><span class="line">    Page&lt;SkuEs&gt; pageModel=<span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//向vo里面设置wareId</span></span><br><span class="line">    skuEsQueryVo.setWareId(AuthContextHolder.getWareId());</span><br><span class="line">    <span class="comment">//根据springData命名规范定义方法查询</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keyword</span> <span class="operator">=</span> skuEsQueryVo.getKeyword();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(keyword))&#123;</span><br><span class="line">        pageModel=skuRepository.findByCategoryIdAndWareId(skuEsQueryVo.getCategoryId(),skuEsQueryVo.getWareId(),pageable);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pageModel=skuRepository.findByKeywordAndWareId(skuEsQueryVo.getKeyword(),skuEsQueryVo.getWareId(),pageable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询中药参加的优惠活动</span></span><br><span class="line">    List&lt;SkuEs&gt; skuEsList = pageModel.getContent();</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(skuEsList))&#123;</span><br><span class="line">        List&lt;Long&gt; skuIdList = skuEsList.stream().map(SkuEs::getId).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">//远程调用service-activity</span></span><br><span class="line">        <span class="comment">//返回Map&lt;Long,List&lt;String&gt;&gt;</span></span><br><span class="line">        Map&lt;Long,List&lt;String&gt;&gt; skuIdToRuleListMap=activityFeignClient.findActivity(skuIdList);</span><br><span class="line">        <span class="comment">//封装获取数据到skuEs里面ruleList</span></span><br><span class="line">        <span class="keyword">if</span> (skuIdToRuleListMap!=<span class="literal">null</span>)&#123;</span><br><span class="line">            skuEsList.forEach(skuEs -&gt; &#123;</span><br><span class="line">                skuEs.setRuleList(skuIdToRuleListMap.get(skuEs.getId()));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pageModel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新中药热度</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incrHotScore</span><span class="params">(Long skuId)</span> &#123;</span><br><span class="line">    String key=<span class="string">&quot;hotScore&quot;</span>;</span><br><span class="line">    <span class="type">Double</span> <span class="variable">hotScore</span> <span class="operator">=</span> redisTemplate.opsForZSet().incrementScore(key, <span class="string">&quot;skuId&quot;</span> + skuId, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//规则</span></span><br><span class="line">    <span class="keyword">if</span> (hotScore%<span class="number">10</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        Optional&lt;SkuEs&gt; optionalSkuEs = skuRepository.findById(skuId);</span><br><span class="line">        SkuEs skuEs=optionalSkuEs.get();</span><br><span class="line">        skuEs.setHotScore(Math.round(hotScore));</span><br><span class="line">        skuRepository.save(skuEs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>repository层</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SkuRepository</span> <span class="keyword">extends</span> <span class="title class_">ElasticsearchRepository</span>&lt;SkuEs,Long&gt; &#123;</span><br><span class="line"></span><br><span class="line">    Page&lt;SkuEs&gt; <span class="title function_">findByOrderByHotScoreDesc</span><span class="params">(Pageable pageable)</span>;</span><br><span class="line"></span><br><span class="line">    Page&lt;SkuEs&gt; <span class="title function_">findByCategoryIdAndWareId</span><span class="params">(Long categoryId, Long wareId, Pageable pageable)</span>;</span><br><span class="line"></span><br><span class="line">    Page&lt;SkuEs&gt; <span class="title function_">findByKeywordAndWareId</span><span class="params">(String keyword, Long wareId, Pageable pageable)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于Redisson的分布式锁生成订单，锁定库存"><a href="#基于Redisson的分布式锁生成订单，锁定库存" class="headerlink" title="基于Redisson的分布式锁生成订单，锁定库存"></a>基于<strong>Redisson<strong><strong>的</strong></strong>分布式锁</strong>生成订单，锁定库存</h1><p>因为在分布式环境下，多个服务不能靠普通锁进行锁定，索引就用到了Redission分布式锁，</p><p>Redisson分布式锁解决分布式环境下并发安全问题，完全实现了juc的功能，不仅有锁，还都是分布式锁</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YTBlZWNhMmY4YmI5MjIwNDE1NTFhNTZkMzVlZjg0YmFfaDl1cGE3UzVkbHpqcndPQTNOTkJ4Q2ZwNjhCSVNZSW1fVG9rZW46R3dFVWJQbWNWb2t2UEN4TGJDUWNncHh6bmljXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">假设此时两个用户的请求同时到来，但是落在了不同的机器上，那么这两个请求是可以同时执行了，还是会出现库存超卖的问题。为什么呢？因为上图中的两个A系统，运行在两个不同的JVM里面，他们加的锁只对属于自己JVM里面的线程有效，对于其他JVM的线程是无效的。因此，这里的问题是Java提供的原生锁机制在多机部署场景下失效了这是因为两台机器加的锁不是同一个锁(两个锁在不同的JVM里面)。那么，我们只要保证两台机器加的锁是同一个锁，问题不就解决了吗？此时，就该分布式锁登场了，分布式锁的思路是：在整个系统提供一个全局、唯一的获取锁的“东西”，然后每个系统在需要加锁时，都去问这个“东西”拿到一把锁，这样不同的系统拿到的就可以认为是同一把锁。至于这个“东西”，可以是Redis、Zookeeper，也可以是数据库</span><br></pre></td></tr></table></figure><p>Redisson分布式锁解决分布式环境下并发安全问题，完全实现了juc的功能，不仅有锁，还都是分布式锁</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YTJmZGU2YWViN2FmY2VmM2FjYjAxYzdlNmYyMzk5ODJfN3FKUHlpenJ0OVMzMk9PQ3cxRmhTVFpyWmxvUEhsTVNfVG9rZW46TksyUmJCTkt0b2JRQ2p4ODJpN2NVZ0lYbk5kXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p>步骤</p><ol><li>添加Redisson配置类</li></ol><p><strong>service-util模块添加Redisson配置类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;spring.redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String addresses;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="number">3000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">connectionPoolSize</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionMinimumIdleSize=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">pingConnectionInterval</span> <span class="operator">=</span> <span class="number">60000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">ADDRESS_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;redis://&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动装配</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    RedissonClient <span class="title function_">redissonSingle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">//  判断redis 的host是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(host))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;host is  empty&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  配置host，port等参数</span></span><br><span class="line">        <span class="type">SingleServerConfig</span> <span class="variable">serverConfig</span> <span class="operator">=</span> config.useSingleServer()</span><br><span class="line">                <span class="comment">//redis://127.0.0.1:7181</span></span><br><span class="line">                .setAddress(ADDRESS_PREFIX + <span class="built_in">this</span>.host + <span class="string">&quot;:&quot;</span> + port)</span><br><span class="line">                .setTimeout(<span class="built_in">this</span>.timeout)</span><br><span class="line">                .setPingConnectionInterval(pingConnectionInterval)</span><br><span class="line">                .setConnectionPoolSize(<span class="built_in">this</span>.connectionPoolSize)</span><br><span class="line">                .setConnectionMinimumIdleSize(<span class="built_in">this</span>.connectionMinimumIdleSize);</span><br><span class="line">        <span class="comment">//  判断进入redis 是否密码</span></span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(<span class="built_in">this</span>.password)) &#123;</span><br><span class="line">            serverConfig.setPassword(<span class="built_in">this</span>.password);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// RedissonClient redisson = Redisson.create(config);</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>添加OrderApiController方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(value = &quot;Order管理&quot;, tags = &quot;Order管理&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/api/order&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderApiController</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Resource</span></span><br><span class="line">        <span class="keyword">private</span> OrderInfoService orderService;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@ApiOperation(&quot;确认订单&quot;)</span></span><br><span class="line">        <span class="meta">@GetMapping(&quot;auth/confirmOrder&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> Result <span class="title function_">confirm</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.ok(orderService.confirmOrder());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@ApiOperation(&quot;生成订单&quot;)</span></span><br><span class="line">        <span class="meta">@PostMapping(&quot;auth/submitOrder&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> Result <span class="title function_">submitOrder</span><span class="params">(<span class="meta">@RequestBody</span> OrderSubmitVo orderParamVo, HttpServletRequest request)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取到用户Id</span></span><br><span class="line">                <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> AuthContextHolder.getUserId();</span><br><span class="line">                <span class="keyword">return</span> Result.ok(orderService.submitOrder(orderParamVo));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ApiOperation(&quot;获取订单详情&quot;)</span></span><br><span class="line">        <span class="meta">@GetMapping(&quot;auth/getOrderInfoById/&#123;orderId&#125;&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> Result <span class="title function_">getOrderInfoById</span><span class="params">(<span class="meta">@PathVariable(&quot;orderId&quot;)</span> Long orderId)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Result.ok(orderService.getOrderInfoById(orderId));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>添加OrderInfoService方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderInfoService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;OrderInfo&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 确认订单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    OrderConfirmVo <span class="title function_">confirmOrder</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成订单</span></span><br><span class="line">    Long <span class="title function_">submitOrder</span><span class="params">(OrderSubmitVo orderParamVo)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//订单详情</span></span><br><span class="line">    OrderInfo <span class="title function_">getOrderInfoById</span><span class="params">(Long orderId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>添加OrderInfoServiceImpl方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">submitOrder</span><span class="params">(OrderSubmitVo orderSubmitVo)</span> &#123;</span><br><span class="line">        <span class="comment">//添加当前用户</span></span><br><span class="line">        orderSubmitVo.setUserId(AuthContextHolder.getUserId());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.防重：redis</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">orderNo</span> <span class="operator">=</span> orderSubmitVo.getOrderNo();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(orderNo))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">YYJJException</span>(ResultCodeEnum.ILLEGAL_REQUEST);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if(redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1]) then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (Boolean)redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(RedisConst.ORDER_REPEAT + orderNo), orderNo);</span><br><span class="line">        <span class="comment">//                if (!flag)&#123;</span></span><br><span class="line">        <span class="comment">//                        throw new GmallException(ResultCodeEnum.REPEAT_SUBMIT);</span></span><br><span class="line">        <span class="comment">//                &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.验库存并锁定库存</span></span><br><span class="line">        <span class="comment">// List&lt;Long&gt; skuIdList = orderSubmitVo.getSkuIdList();</span></span><br><span class="line">        List&lt;CartInfo&gt; cartInfoList = cartFeignClient.getCartCheckedList(AuthContextHolder.getUserId());</span><br><span class="line">        List&lt;CartInfo&gt; commonSkuList = cartInfoList.stream().filter(cartInfo -&gt; cartInfo.getSkuType() == SkuType.COMMON.getCode()).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(commonSkuList)) &#123;</span><br><span class="line">                List&lt;SkuStockLockVo&gt; commonStockLockVoList = commonSkuList.stream().map(item -&gt; &#123;</span><br><span class="line">                        <span class="type">SkuStockLockVo</span> <span class="variable">skuStockLockVo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkuStockLockVo</span>();</span><br><span class="line">                        skuStockLockVo.setSkuId(item.getSkuId());</span><br><span class="line">                        skuStockLockVo.setSkuNum(item.getSkuNum());</span><br><span class="line">                        <span class="keyword">return</span> skuStockLockVo;</span><br><span class="line">                &#125;).collect(Collectors.toList());</span><br><span class="line">                <span class="comment">//是否锁定</span></span><br><span class="line">                <span class="type">Boolean</span> <span class="variable">isLockCommon</span> <span class="operator">=</span> productFeignClient.checkAndLock(commonStockLockVoList, orderSubmitVo.getOrderNo());</span><br><span class="line">                <span class="keyword">if</span> (!isLockCommon)&#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">YYJJException</span>(ResultCodeEnum.ORDER_STOCK_FALL);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;CartInfo&gt; seckillSkuList = cartInfoList.stream().filter(cartInfo -&gt; cartInfo.getSkuType() == SkuType.SECKILL.getCode()).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(seckillSkuList)) &#123;</span><br><span class="line">                List&lt;SkuStockLockVo&gt; seckillStockLockVoList = seckillSkuList.stream().map(item -&gt; &#123;</span><br><span class="line">                        <span class="type">SkuStockLockVo</span> <span class="variable">skuStockLockVo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkuStockLockVo</span>();</span><br><span class="line">                        skuStockLockVo.setSkuId(item.getSkuId());</span><br><span class="line">                        skuStockLockVo.setSkuNum(item.getSkuNum());</span><br><span class="line">                        <span class="keyword">return</span> skuStockLockVo;</span><br><span class="line">                &#125;).collect(Collectors.toList());</span><br><span class="line">                <span class="comment">//是否锁定</span></span><br><span class="line">                <span class="type">Boolean</span> <span class="variable">isLockSeckill</span> <span class="operator">=</span> seckillFeignClient.checkAndMinusStock(seckillStockLockVoList, orderSubmitVo.getOrderNo());</span><br><span class="line">                <span class="keyword">if</span> (!isLockSeckill)&#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">YYJJException</span>(ResultCodeEnum.ORDER_STOCK_FALL);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.下单</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">orderId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                orderId = <span class="built_in">this</span>.saveOrder(orderSubmitVo, cartInfoList);</span><br><span class="line">        </span><br><span class="line">                <span class="comment">// 订单正常创建成功的情况下，发送消息定时关单</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">normalOrderOvertime</span> <span class="operator">=</span> orderSetService.getNormalOrderOvertime();</span><br><span class="line">                <span class="comment">//rabbitService.sendDelayMessage(MqConst.EXCHANGE_ORDER_DIRECT, MqConst.ROUTING_CANCEL_ORDER, orderSubmitVo.getOrderNo(), normalOrderOvertime);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">// 出现异常立马解锁库存 标记订单时无效订单</span></span><br><span class="line">                <span class="comment">//rabbitService.sendMessage(MqConst.EXCHANGE_ORDER_DIRECT, MqConst.ROUTING_ROLLBACK_STOCK, orderSubmitVo.getOrderNo());</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">GmallException</span>(ResultCodeEnum.CREATE_ORDER_FAIL);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5.异步删除购物车中对应的记录。不应该影响下单的整体流程</span></span><br><span class="line">        rabbitService.sendMessage(MqConst.EXCHANGE_ORDER_DIRECT, MqConst.ROUTING_DELETE_CART, orderSubmitVo.getUserId())</span><br><span class="line">        <span class="keyword">return</span> orderId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;Exception.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">saveOrder</span><span class="params">(OrderSubmitVo orderSubmitVo, List&lt;CartInfo&gt; cartInfoList)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> AuthContextHolder.getUserId();</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isEmpty(cartInfoList)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">YYJJException</span>(ResultCodeEnum.DATA_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LeaderAddressVo</span> <span class="variable">leaderAddressVo</span> <span class="operator">=</span> userFeignClient.getLeaderAddressVoByUserId(userId);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == leaderAddressVo) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">YYJJException</span>(ResultCodeEnum.DATA_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算购物项分摊的优惠减少金额，按比例分摊，退款时按实际支付金额退款</span></span><br><span class="line">        Map&lt;String, BigDecimal&gt; activitySplitAmountMap = <span class="built_in">this</span>.computeActivitySplitAmount(cartInfoList);</span><br><span class="line">        Map&lt;String, BigDecimal&gt; couponInfoSplitAmountMap = <span class="built_in">this</span>.computeCouponInfoSplitAmount(cartInfoList, orderSubmitVo.getCouponId());</span><br><span class="line">        <span class="comment">//sku对应的订单明细</span></span><br><span class="line">        List&lt;OrderItem&gt; orderItemList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 保存订单明细</span></span><br><span class="line">        <span class="keyword">for</span> (CartInfo cartInfo : cartInfoList) &#123;</span><br><span class="line">                <span class="type">OrderItem</span> <span class="variable">orderItem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderItem</span>();</span><br><span class="line">                orderItem.setId(<span class="literal">null</span>);</span><br><span class="line">                orderItem.setCategoryId(cartInfo.getCategoryId());</span><br><span class="line">                <span class="keyword">if</span>(cartInfo.getSkuType() == SkuType.COMMON.getCode()) &#123;</span><br><span class="line">                        orderItem.setSkuType(SkuType.COMMON);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        orderItem.setSkuType(SkuType.SECKILL);</span><br><span class="line">                &#125;</span><br><span class="line">                orderItem.setSkuId(cartInfo.getSkuId());</span><br><span class="line">                orderItem.setSkuName(cartInfo.getSkuName());</span><br><span class="line">                orderItem.setSkuPrice(cartInfo.getCartPrice());</span><br><span class="line">                orderItem.setImgUrl(cartInfo.getImgUrl());</span><br><span class="line">                orderItem.setSkuNum(cartInfo.getSkuNum());</span><br><span class="line">                orderItem.setLeaderId(orderSubmitVo.getLeaderId());</span><br><span class="line"></span><br><span class="line">                <span class="comment">//促销活动分摊金额</span></span><br><span class="line">                <span class="type">BigDecimal</span> <span class="variable">splitActivityAmount</span> <span class="operator">=</span> activitySplitAmountMap.get(<span class="string">&quot;activity:&quot;</span>+orderItem.getSkuId());</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">null</span> == splitActivityAmount) &#123;</span><br><span class="line">                        splitActivityAmount = <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                orderItem.setSplitActivityAmount(splitActivityAmount);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//优惠券分摊金额</span></span><br><span class="line">                <span class="type">BigDecimal</span> <span class="variable">splitCouponAmount</span> <span class="operator">=</span> couponInfoSplitAmountMap.get(<span class="string">&quot;coupon:&quot;</span>+orderItem.getSkuId());</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">null</span> == splitCouponAmount) &#123;</span><br><span class="line">                        splitCouponAmount = <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                orderItem.setSplitCouponAmount(splitCouponAmount);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//优惠后的总金额</span></span><br><span class="line">                <span class="type">BigDecimal</span> <span class="variable">skuTotalAmount</span> <span class="operator">=</span> orderItem.getSkuPrice().multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(orderItem.getSkuNum()));</span><br><span class="line">                <span class="type">BigDecimal</span> <span class="variable">splitTotalAmount</span> <span class="operator">=</span> skuTotalAmount.subtract(splitActivityAmount).subtract(splitCouponAmount);</span><br><span class="line">                orderItem.setSplitTotalAmount(splitTotalAmount);</span><br><span class="line">                orderItemList.add(orderItem);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存订单</span></span><br><span class="line">        <span class="type">OrderInfo</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderInfo</span>();</span><br><span class="line">        order.setUserId(userId);</span><br><span class="line"><span class="comment">//                private String nickName;</span></span><br><span class="line">        order.setOrderNo(orderSubmitVo.getOrderNo());</span><br><span class="line">        order.setOrderStatus(OrderStatus.UNPAID);</span><br><span class="line">        order.setProcessStatus(ProcessStatus.UNPAID);</span><br><span class="line">        order.setCouponId(orderSubmitVo.getCouponId());</span><br><span class="line">        order.setLeaderId(orderSubmitVo.getLeaderId());</span><br><span class="line">        order.setLeaderName(leaderAddressVo.getLeaderName());</span><br><span class="line">        order.setLeaderPhone(leaderAddressVo.getLeaderPhone());</span><br><span class="line">        order.setTakeName(leaderAddressVo.getTakeName());</span><br><span class="line">        order.setReceiverName(orderSubmitVo.getReceiverName());</span><br><span class="line">        order.setReceiverPhone(orderSubmitVo.getReceiverPhone());</span><br><span class="line">        order.setReceiverProvince(leaderAddressVo.getProvince());</span><br><span class="line">        order.setReceiverCity(leaderAddressVo.getCity());</span><br><span class="line">        order.setReceiverDistrict(leaderAddressVo.getDistrict());</span><br><span class="line">        order.setReceiverAddress(leaderAddressVo.getDetailAddress());</span><br><span class="line">        order.setWareId(cartInfoList.get(<span class="number">0</span>).getWareId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算订单金额</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">originalTotalAmount</span> <span class="operator">=</span> <span class="built_in">this</span>.computeTotalAmount(cartInfoList);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">activityAmount</span> <span class="operator">=</span> activitySplitAmountMap.get(<span class="string">&quot;activity:total&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == activityAmount) activityAmount = <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">couponAmount</span> <span class="operator">=</span> couponInfoSplitAmountMap.get(<span class="string">&quot;coupon:total&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == couponAmount) couponAmount = <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">totalAmount</span> <span class="operator">=</span> originalTotalAmount.subtract(activityAmount).subtract(couponAmount);</span><br><span class="line">        <span class="comment">//计算订单金额</span></span><br><span class="line">        order.setOriginalTotalAmount(originalTotalAmount);</span><br><span class="line">        order.setActivityAmount(activityAmount);</span><br><span class="line">        order.setCouponAmount(couponAmount);</span><br><span class="line">        order.setTotalAmount(totalAmount);</span><br><span class="line">        </span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">profitRate</span> <span class="operator">=</span> orderSetService.getProfitRate();</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">commissionAmount</span> <span class="operator">=</span> order.getTotalAmount().multiply(profitRate);</span><br><span class="line">        order.setCommissionAmount(commissionAmount);</span><br><span class="line"></span><br><span class="line">        orderInfoMapper.insert(order);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存订单项</span></span><br><span class="line">        <span class="keyword">for</span>(OrderItem orderItem : orderItemList) &#123;</span><br><span class="line">                orderItem.setOrderId(order.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        orderItemService.saveBatch(orderItemList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新优惠券使用状态</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> != order.getCouponId()) &#123;</span><br><span class="line">                activityFeignClient.updateCouponInfoUseStatus(order.getCouponId(), userId, order.getId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下单成功，记录用户商品购买个数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">orderSkuKey</span> <span class="operator">=</span> RedisConst.ORDER_SKU_MAP + orderSubmitVo.getUserId();</span><br><span class="line">        BoundHashOperations&lt;String, String, Integer&gt; hashOperations = redisTemplate.boundHashOps(orderSkuKey);</span><br><span class="line">        cartInfoList.forEach(cartInfo -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span>(hashOperations.hasKey(cartInfo.getSkuId().toString())) &#123;</span><br><span class="line">                        <span class="type">Integer</span> <span class="variable">orderSkuNum</span> <span class="operator">=</span> hashOperations.get(cartInfo.getSkuId().toString()) + cartInfo.getSkuNum();</span><br><span class="line">                        hashOperations.put(cartInfo.getSkuId().toString(), orderSkuNum);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        redisTemplate.expire(orderSkuKey, DateUtil.getCurrentExpireTimes(), TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        <span class="keyword">return</span> order.getId();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BigDecimal <span class="title function_">computeTotalAmount</span><span class="params">(List&lt;CartInfo&gt; cartInfoList)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">total</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (CartInfo cartInfo : cartInfoList) &#123;</span><br><span class="line">                <span class="type">BigDecimal</span> <span class="variable">itemTotal</span> <span class="operator">=</span> cartInfo.getCartPrice().multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(cartInfo.getSkuNum()));</span><br><span class="line">                total = total.add(itemTotal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算购物项分摊的优惠减少金额</span></span><br><span class="line"><span class="comment"> * 打折：按折扣分担</span></span><br><span class="line"><span class="comment"> * 现金：按比例分摊</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cartInfoParamList</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, BigDecimal&gt; <span class="title function_">computeActivitySplitAmount</span><span class="params">(List&lt;CartInfo&gt; cartInfoParamList)</span> &#123;</span><br><span class="line">        Map&lt;String, BigDecimal&gt; activitySplitAmountMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//促销活动相关信息</span></span><br><span class="line">        List&lt;CartInfoVo&gt; cartInfoVoList = activityFeignClient.findCartActivityList(cartInfoParamList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//活动总金额</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">activityReduceAmount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(!CollectionUtils.isEmpty(cartInfoVoList)) &#123;</span><br><span class="line">                <span class="keyword">for</span>(CartInfoVo cartInfoVo : cartInfoVoList) &#123;</span><br><span class="line">                        <span class="type">ActivityRule</span> <span class="variable">activityRule</span> <span class="operator">=</span> cartInfoVo.getActivityRule();</span><br><span class="line">                        List&lt;CartInfo&gt; cartInfoList = cartInfoVo.getCartInfoList();</span><br><span class="line">                        <span class="keyword">if</span>(<span class="literal">null</span> != activityRule) &#123;</span><br><span class="line">                                <span class="comment">//优惠金额， 按比例分摊</span></span><br><span class="line">                                <span class="type">BigDecimal</span> <span class="variable">reduceAmount</span> <span class="operator">=</span> activityRule.getReduceAmount();</span><br><span class="line">                                activityReduceAmount = activityReduceAmount.add(reduceAmount);</span><br><span class="line">                                <span class="keyword">if</span>(cartInfoList.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                                        activitySplitAmountMap.put(<span class="string">&quot;activity:&quot;</span>+cartInfoList.get(<span class="number">0</span>).getSkuId(), reduceAmount);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        <span class="comment">//总金额</span></span><br><span class="line">                                        <span class="type">BigDecimal</span> <span class="variable">originalTotalAmount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0</span>);</span><br><span class="line">                                        <span class="keyword">for</span>(CartInfo cartInfo : cartInfoList) &#123;</span><br><span class="line">                                                <span class="type">BigDecimal</span> <span class="variable">skuTotalAmount</span> <span class="operator">=</span> cartInfo.getCartPrice().multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(cartInfo.getSkuNum()));</span><br><span class="line">                                                originalTotalAmount = originalTotalAmount.add(skuTotalAmount);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="comment">//记录除最后一项是所有分摊金额， 最后一项=总的 - skuPartReduceAmount</span></span><br><span class="line">                                        <span class="type">BigDecimal</span> <span class="variable">skuPartReduceAmount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0</span>);</span><br><span class="line">                                        <span class="keyword">if</span> (activityRule.getActivityType() == ActivityType.FULL_REDUCTION) &#123;</span><br><span class="line">                                                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, len=cartInfoList.size(); i&lt;len; i++) &#123;</span><br><span class="line">                                                        <span class="type">CartInfo</span> <span class="variable">cartInfo</span> <span class="operator">=</span> cartInfoList.get(i);</span><br><span class="line">                                                        <span class="keyword">if</span>(i &lt; len -<span class="number">1</span>) &#123;</span><br><span class="line">                                                                <span class="type">BigDecimal</span> <span class="variable">skuTotalAmount</span> <span class="operator">=</span> cartInfo.getCartPrice().multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(cartInfo.getSkuNum()));</span><br><span class="line">                                                                <span class="comment">//sku分摊金额</span></span><br><span class="line">                                                                <span class="type">BigDecimal</span> <span class="variable">skuReduceAmount</span> <span class="operator">=</span> skuTotalAmount.divide(originalTotalAmount, <span class="number">2</span>, RoundingMode.HALF_UP).multiply(reduceAmount);</span><br><span class="line">                                                                activitySplitAmountMap.put(<span class="string">&quot;activity:&quot;</span>+cartInfo.getSkuId(), skuReduceAmount);</span><br><span class="line"></span><br><span class="line">                                                                skuPartReduceAmount = skuPartReduceAmount.add(skuReduceAmount);</span><br><span class="line">                                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                                <span class="type">BigDecimal</span> <span class="variable">skuReduceAmount</span> <span class="operator">=</span> reduceAmount.subtract(skuPartReduceAmount);</span><br><span class="line">                                                                activitySplitAmountMap.put(<span class="string">&quot;activity:&quot;</span>+cartInfo.getSkuId(), skuReduceAmount);</span><br><span class="line">                                                        &#125;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, len=cartInfoList.size(); i&lt;len; i++) &#123;</span><br><span class="line">                                                        <span class="type">CartInfo</span> <span class="variable">cartInfo</span> <span class="operator">=</span> cartInfoList.get(i);</span><br><span class="line">                                                        <span class="keyword">if</span>(i &lt; len -<span class="number">1</span>) &#123;</span><br><span class="line">                                                                <span class="type">BigDecimal</span> <span class="variable">skuTotalAmount</span> <span class="operator">=</span> cartInfo.getCartPrice().multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(cartInfo.getSkuNum()));</span><br><span class="line"></span><br><span class="line">                                                                <span class="comment">//sku分摊金额</span></span><br><span class="line">                                                                <span class="type">BigDecimal</span> <span class="variable">skuDiscountTotalAmount</span> <span class="operator">=</span> skuTotalAmount.multiply(activityRule.getBenefitDiscount().divide(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;10&quot;</span>)));</span><br><span class="line">                                                                <span class="type">BigDecimal</span> <span class="variable">skuReduceAmount</span> <span class="operator">=</span> skuTotalAmount.subtract(skuDiscountTotalAmount);</span><br><span class="line">                                                                activitySplitAmountMap.put(<span class="string">&quot;activity:&quot;</span>+cartInfo.getSkuId(), skuReduceAmount);</span><br><span class="line"></span><br><span class="line">                                                                skuPartReduceAmount = skuPartReduceAmount.add(skuReduceAmount);</span><br><span class="line">                                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                                <span class="type">BigDecimal</span> <span class="variable">skuReduceAmount</span> <span class="operator">=</span> reduceAmount.subtract(skuPartReduceAmount);</span><br><span class="line">                                                                activitySplitAmountMap.put(<span class="string">&quot;activity:&quot;</span>+cartInfo.getSkuId(), skuReduceAmount);</span><br><span class="line">                                                        &#125;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        activitySplitAmountMap.put(<span class="string">&quot;activity:total&quot;</span>, activityReduceAmount);</span><br><span class="line">        <span class="keyword">return</span> activitySplitAmountMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, BigDecimal&gt; <span class="title function_">computeCouponInfoSplitAmount</span><span class="params">(List&lt;CartInfo&gt; cartInfoList, Long couponId)</span> &#123;</span><br><span class="line">        Map&lt;String, BigDecimal&gt; couponInfoSplitAmountMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> == couponId) <span class="keyword">return</span> couponInfoSplitAmountMap;</span><br><span class="line">        <span class="type">CouponInfo</span> <span class="variable">couponInfo</span> <span class="operator">=</span> activityFeignClient.findRangeSkuIdList(cartInfoList, couponId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> != couponInfo) &#123;</span><br><span class="line">                <span class="comment">//sku对应的订单明细</span></span><br><span class="line">                Map&lt;Long, CartInfo&gt; skuIdToCartInfoMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">for</span> (CartInfo cartInfo : cartInfoList) &#123;</span><br><span class="line">                        skuIdToCartInfoMap.put(cartInfo.getSkuId(), cartInfo);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//优惠券对应的skuId列表</span></span><br><span class="line">                List&lt;Long&gt; skuIdList = couponInfo.getSkuIdList();</span><br><span class="line">                <span class="keyword">if</span>(CollectionUtils.isEmpty(skuIdList)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> couponInfoSplitAmountMap;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//优惠券优化总金额</span></span><br><span class="line">                <span class="type">BigDecimal</span> <span class="variable">reduceAmount</span> <span class="operator">=</span> couponInfo.getAmount();</span><br><span class="line">                <span class="keyword">if</span>(skuIdList.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">//sku的优化金额</span></span><br><span class="line">                        couponInfoSplitAmountMap.put(<span class="string">&quot;coupon:&quot;</span>+skuIdToCartInfoMap.get(skuIdList.get(<span class="number">0</span>)).getSkuId(), reduceAmount);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//总金额</span></span><br><span class="line">                        <span class="type">BigDecimal</span> <span class="variable">originalTotalAmount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">for</span> (Long skuId : skuIdList) &#123;</span><br><span class="line">                                <span class="type">CartInfo</span> <span class="variable">cartInfo</span> <span class="operator">=</span> skuIdToCartInfoMap.get(skuId);</span><br><span class="line">                                <span class="type">BigDecimal</span> <span class="variable">skuTotalAmount</span> <span class="operator">=</span> cartInfo.getCartPrice().multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(cartInfo.getSkuNum()));</span><br><span class="line">                                originalTotalAmount = originalTotalAmount.add(skuTotalAmount);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//记录除最后一项是所有分摊金额， 最后一项=总的 - skuPartReduceAmount</span></span><br><span class="line">                        <span class="type">BigDecimal</span> <span class="variable">skuPartReduceAmount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">if</span> (couponInfo.getCouponType() == CouponType.CASH || couponInfo.getCouponType() == CouponType.FULL_REDUCTION) &#123;</span><br><span class="line">                                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, len=skuIdList.size(); i&lt;len; i++) &#123;</span><br><span class="line">                                        <span class="type">CartInfo</span> <span class="variable">cartInfo</span> <span class="operator">=</span> skuIdToCartInfoMap.get(skuIdList.get(i));</span><br><span class="line">                                        <span class="keyword">if</span>(i &lt; len -<span class="number">1</span>) &#123;</span><br><span class="line">                                                <span class="type">BigDecimal</span> <span class="variable">skuTotalAmount</span> <span class="operator">=</span> cartInfo.getCartPrice().multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(cartInfo.getSkuNum()));</span><br><span class="line">                                                <span class="comment">//sku分摊金额</span></span><br><span class="line">                                                <span class="type">BigDecimal</span> <span class="variable">skuReduceAmount</span> <span class="operator">=</span> skuTotalAmount.divide(originalTotalAmount, <span class="number">2</span>, RoundingMode.HALF_UP).multiply(reduceAmount);</span><br><span class="line">                                                couponInfoSplitAmountMap.put(<span class="string">&quot;coupon:&quot;</span>+cartInfo.getSkuId(), skuReduceAmount);</span><br><span class="line"></span><br><span class="line">                                                skuPartReduceAmount = skuPartReduceAmount.add(skuReduceAmount);</span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                <span class="type">BigDecimal</span> <span class="variable">skuReduceAmount</span> <span class="operator">=</span> reduceAmount.subtract(skuPartReduceAmount);</span><br><span class="line">                                                couponInfoSplitAmountMap.put(<span class="string">&quot;coupon:&quot;</span>+cartInfo.getSkuId(), skuReduceAmount);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                couponInfoSplitAmountMap.put(<span class="string">&quot;coupon:total&quot;</span>, couponInfo.getAmount());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> couponInfoSplitAmountMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>service-product模块创建方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value = &quot;锁定库存&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;inner/checkAndLock/&#123;orderNo&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">checkAndLock</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;SkuStockLockVo&gt; skuStockLockVoList, <span class="meta">@PathVariable</span> String orderNo)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> skuInfoService.checkAndLock(skuStockLockVoList, orderNo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>SkuInfoService实现锁定库存方法</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;Exception.class&#125;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">checkAndLock</span><span class="params">(List&lt;SkuStockLockVo&gt; skuStockLockVoList,</span></span><br><span class="line"><span class="params">                                                        String orderToken)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(skuStockLockVoList))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">GmallException</span>(ResultCodeEnum.DATA_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有，验库存并锁库存，要具备原子性</span></span><br><span class="line">        skuStockLockVoList.forEach(skuStockLockVo -&gt; &#123;</span><br><span class="line">                checkLock(skuStockLockVo);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要有一个锁定失败，所有锁定成功的商品要解锁库存</span></span><br><span class="line">        <span class="keyword">if</span> (skuStockLockVoList.stream().anyMatch(skuStockLockVo -&gt; !skuStockLockVo.getIsLock())) &#123;</span><br><span class="line">                <span class="comment">// 获取所有锁定成功的，遍历解锁库存</span></span><br><span class="line">                skuStockLockVoList.stream().filter(SkuStockLockVo::getIsLock).forEach(skuStockLockVo -&gt; &#123;</span><br><span class="line">                        skuInfoMapper.unlockStock(skuStockLockVo.getSkuId(), skuStockLockVo.getSkuNum());</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 响应锁定状态</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果所有都锁定成功的情况下，需要缓存锁定信息到redis。以方便将来解锁库存 或者 减库存</span></span><br><span class="line">        <span class="comment">// 以orderToken作为key，以lockVos锁定信息作为value</span></span><br><span class="line">        <span class="built_in">this</span>.redisTemplate.opsForValue().set(RedisConst.SROCK_INFO + orderToken, skuStockLockVoList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 锁定库存成功之后，定时解锁库存。</span></span><br><span class="line">        <span class="comment">//this.rabbitTemplate.convertAndSend(&quot;ORDER_EXCHANGE&quot;, &quot;stock.ttl&quot;, orderToken);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkLock</span><span class="params">(SkuStockLockVo skuStockLockVo)</span>&#123;</span><br><span class="line">        <span class="comment">//公平锁，就是保证客户端获取锁的顺序，跟他们请求获取锁的顺序，是一样的。</span></span><br><span class="line">        <span class="comment">// 公平锁需要排队</span></span><br><span class="line">        <span class="comment">// ，谁先申请获取这把锁，</span></span><br><span class="line">        <span class="comment">// 谁就可以先获取到这把锁，是按照请求的先后顺序来的。</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">rLock</span> <span class="operator">=</span> <span class="built_in">this</span>.redissonClient</span><br><span class="line">                        .getFairLock(RedisConst.SKUKEY_PREFIX + skuStockLockVo.getSkuId());</span><br><span class="line">        rLock.lock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 验库存：查询，返回的是满足要求的库存列表</span></span><br><span class="line">                <span class="type">SkuInfo</span> <span class="variable">skuInfo</span> <span class="operator">=</span> skuInfoMapper.checkStock(skuStockLockVo.getSkuId(), skuStockLockVo.getSkuNum());</span><br><span class="line">                <span class="comment">// 如果没有一个仓库满足要求，这里就验库存失败</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">null</span> == skuInfo) &#123;</span><br><span class="line">                        skuStockLockVo.setIsLock(<span class="literal">false</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 锁库存：更新</span></span><br><span class="line">                <span class="type">Integer</span> <span class="variable">row</span> <span class="operator">=</span> skuInfoMapper.lockStock(skuStockLockVo.getSkuId(), skuStockLockVo.getSkuNum());</span><br><span class="line">                <span class="keyword">if</span> (row == <span class="number">1</span>) &#123;</span><br><span class="line">                        skuStockLockVo.setIsLock(<span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                rLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于RabbitMQ实现中药材上下架、生成订单完成，删除采购车数据、支付完成之后，更新订单状态和扣减库存等。"><a href="#基于RabbitMQ实现中药材上下架、生成订单完成，删除采购车数据、支付完成之后，更新订单状态和扣减库存等。" class="headerlink" title="基于RabbitMQ实现中药材上下架、生成订单完成，删除采购车数据、支付完成之后，更新订单状态和扣减库存等。"></a>基于<strong>RabbitMQ</strong>实现中药材上下架、生成订单完成，删除采购车数据、支付完成之后，更新订单状态和扣减库存等。</h1><p>rabbitMQ是我这个项目中大量用到的消息中间件，一是我觉得它是专门做这个消息中</p><p>消息队列提供一个异步通信机制，消息的发送者不必一直等待到消息被成功处理才返回，而是立即返回。消息中间件负责处理网络通信，如果网络连接不可用，消息被暂存于队列当中，当网络畅通的时候在将消息转发给相应的应用程序或者服务，当然前提是这些服务订阅了该队列。如果在商品服务和订单服务之间使用消息中间件，既可以提高并发量，又降低服务之间的耦合度。</p><p>RabbitMQ就是这样一款消息队列。RabbitMQ是一个开源的消息代理的队列服务器，用来通过普通协议在完全不同的应用之间共享数据。</p><p>使用步骤：</p><p><strong>安装rabbitMQ</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">#拉取镜像</span><br><span class="line">docker pull rabbitmq:<span class="number">3.8</span>-management</span><br><span class="line">#创建容器启动</span><br><span class="line">docker run -d --restart=always -p <span class="number">5672</span>:<span class="number">5672</span> -p <span class="number">15672</span>:<span class="number">15672</span> --name rabbitmq rabbitmq:<span class="number">3.8</span>-management</span><br></pre></td></tr></table></figure><p><strong>rabbitMQ服务后台</strong></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MmVlOGYxYjJjNjg4ZDMzOWM2MTBlZTM0M2ZlYWFhYTVfa1Vub1M5ekhFbUV5S1AySmVJeFJPdE5iSWQwY2VsMk1fVG9rZW46Uk5LOWJ6aFBCb0ZyNlp4OThOVWNXQTNqbmRoXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p><strong>在common搭建rabbit_util模块，在rabbit_util引入依赖</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--rabbitmq消息队列--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p><strong>添加service方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  引入操作rabbitmq 的模板</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange  交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routingKey    路由键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message   消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessage</span><span class="params">(String exchange,String routingKey, Object message)</span>&#123;</span><br><span class="line">        <span class="comment">//  调用发送数据的方法</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchange,routingKey,message);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送延迟消息的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange  交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routingKey    路由键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message   消息内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delayTime 延迟时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendDelayMessage</span><span class="params">(String exchange,String routingKey, Object message, <span class="type">int</span> delayTime)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  在发送消息的时候设置延迟时间</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, routingKey, message, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">                <span class="comment">//  设置一个延迟时间</span></span><br><span class="line">                message.getMessageProperties().setDelay(delayTime*<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">return</span> message;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置mq消息转换器</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MQConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加消息的确认配置</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MQProducerAckConfig</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ReturnCallback,RabbitTemplate.ConfirmCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  我们发送消息使用的是 private RabbitTemplate rabbitTemplate; 对象</span></span><br><span class="line">    <span class="comment">//  如果不做设置的话 当前的rabbitTemplate 与当前的配置类没有任何关系！</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  设置 表示修饰一个非静态的void方法，在服务器加载Servlet的时候运行。并且只执行一次！</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="built_in">this</span>);</span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示消息是否正确发送到了交换机上</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData   消息的载体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack   判断是否发送到交换机上</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause 原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ack)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送成功！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息发送失败！&quot;</span>+cause);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息如果没有正确发送到队列中，则会走这个方法！如果消息被正常处理，则这个方法不会走！</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replyCode</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replyText</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routingKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(Message message, <span class="type">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;消息主体: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">        System.out.println(<span class="string">&quot;应答码: &quot;</span> + replyCode);</span><br><span class="line">        System.out.println(<span class="string">&quot;描述：&quot;</span> + replyText);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息使用的交换器 exchange : &quot;</span> + exchange);</span><br><span class="line">        System.out.println(<span class="string">&quot;消息使用的路由键 routing : &quot;</span> + routingKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里举例上下架功能，其他的功能用法都是相似的</p><p><strong>service-product添加发送MQ消息方法</strong></p><p>引入依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.YYJJ&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rabbit-util&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>service-product配置文件添加MQ配置</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rabbitmq:</span><br><span class="line">  host: <span class="number">192.168</span><span class="number">.56</span><span class="number">.101</span></span><br><span class="line">  port: <span class="number">5672</span></span><br><span class="line">  username: guest</span><br><span class="line">  password: guest</span><br><span class="line">  publisher-confirm-type: CORRELATED  #发布确认模式，消息是否被成功发送到交换机</span><br><span class="line">  publisher-returns: <span class="literal">true</span></span><br><span class="line">  listener:</span><br><span class="line">    simple:</span><br><span class="line">      prefetch: <span class="number">1</span></span><br><span class="line">      concurrency: <span class="number">3</span></span><br><span class="line">      acknowledge-mode: manual   #消费端手动确认</span><br></pre></td></tr></table></figure><p><strong>SkuInfoServiceImpl的publish方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitService rabbitService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;Exception.class&#125;)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publish</span><span class="params">(Long skuId, Integer status)</span> &#123;</span><br><span class="line">        <span class="comment">// 更改发布状态</span></span><br><span class="line">        <span class="keyword">if</span>(status == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">SkuInfo</span> <span class="variable">skuInfoUp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkuInfo</span>();</span><br><span class="line">                skuInfoUp.setId(skuId);</span><br><span class="line">                skuInfoUp.setPublishStatus(<span class="number">1</span>);</span><br><span class="line">                skuInfoMapper.updateById(skuInfoUp);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//上架：发送mq消息同步es</span></span><br><span class="line">                rabbitService.sendMessage(MqConst.EXCHANGE_GOODS_DIRECT, MqConst.ROUTING_GOODS_UPPER, skuId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">SkuInfo</span> <span class="variable">skuInfoUp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkuInfo</span>();</span><br><span class="line">                skuInfoUp.setId(skuId);</span><br><span class="line">                skuInfoUp.setPublishStatus(<span class="number">0</span>);</span><br><span class="line">                skuInfoMapper.updateById(skuInfoUp);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//下架：发送mq消息同步es</span></span><br><span class="line">                rabbitService.sendMessage(MqConst.EXCHANGE_GOODS_DIRECT, MqConst.ROUTING_GOODS_LOWER, skuId);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>service-search添加接收MQ消息方法</strong></p><p><strong>service-search引入依赖</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.YYJJ&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;rabbit-util&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><strong>添加SkuReceiver接收MQ消息方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SkuReceiver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SkuService skuService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上架</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> skuId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(value = MqConst.QUEUE_GOODS_UPPER, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(value = MqConst.EXCHANGE_GOODS_DIRECT),</span></span><br><span class="line"><span class="meta">            key = &#123;MqConst.ROUTING_GOODS_UPPER&#125;</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">upperSku</span><span class="params">(Long skuId, Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != skuId) &#123;</span><br><span class="line">            skuService.upperSku(skuId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 第一个参数：表示收到的消息的标号</span></span><br><span class="line"><span class="comment">             * 第二个参数：如果为true表示可以签收多个消息</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下架</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> skuId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">            value = @Queue(value = MqConst.QUEUE_GOODS_LOWER, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">            exchange = @Exchange(value = MqConst.EXCHANGE_GOODS_DIRECT),</span></span><br><span class="line"><span class="meta">            key = &#123;MqConst.ROUTING_GOODS_LOWER&#125;</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lowerSku</span><span class="params">(Long skuId, Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != skuId) &#123;</span><br><span class="line">            skuService.lowerSku(skuId);</span><br><span class="line">        &#125;</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扫码登录到底是怎么实现的？"><a href="#扫码登录到底是怎么实现的？" class="headerlink" title="扫码登录到底是怎么实现的？"></a><strong>扫码登录到底是怎么实现的？</strong></h1><p>​ 扫码登录的本质是，通过已经登录过的 App 应用，扫描未登录的 Web 端程序中的二维</p><p>码， 通过某种机制触发登录凭证的写入从而实现 Web 端自动登录的过程。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MzUwYTg2NWI3MDMwMjdjODlkMjM0YzgzNWIzODBiN2FfVWVVV29RcDBOdzU0a3UxeGdwWlZEY1VYV0lvMzhrQUZfVG9rZW46VER4dWJUUmFTb2RyQ2Z4ZDlRRmNuV1dKblFoXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p>​ （图是网上找的，思路和图片都出自XX科技）</p><ul><li>首先，在网页端打开登录页面，展示一个二维码，这个二维码有一个唯一编号是服</li></ul><p>务端生成的。然后浏览器定时轮询这个二维码的状态</p><ul><li>接着，APP 扫描这个二维码，把 APP 的 token 信息、二维码 ID 发送给 Server 端，</li></ul><p>Server 收到请求后修改二维码的扫码状态，并生成一个临时 token</p><ul><li>此时，网页端展示的二维码状态会提示已扫码，待确认。 而 APP 端扫码之后，会</li></ul><p>提示确认授权的操作。</p><ul><li>于是，用户确认登录后，携带临时 token 给到 server，server 端修改二维码状态</li></ul><p>并为网页端生成授权 token</p><ul><li>最后，网页端轮询到状态变化并获取到 token，从而完成扫码授权。</li></ul><h1 id="订单超时自动取消功能如何设计"><a href="#订单超时自动取消功能如何设计" class="headerlink" title="订单超时自动取消功能如何设计"></a><strong>订单超时自动取消功能如何设计</strong></h1><p>这个功能和我做的问卷超时功能有异曲同工之妙，但是在网上看，发现这样的场景有多种不同的解决方案，并且还添加了很多优化，这里我要做一下记录，之后可能还要优化我们的项目:</p><p>直接写个定时任务去轮询数据库，根据订单时间找到超时的订单把它取消就行了</p><ol><li>轮询会存在延迟时间，也就是没办法准时实现订单的取消</li><li>轮询数据库，会给数据库造成很大的压力，如果订单表的数据量比较大的情况下，</li></ol><p>轮询的效率也会比较低。</p><p>如果要考虑到性能、又要考虑到实时性，有没有更好的方案呢？</p><p>当然有，比如</p><ol><li>时间轮算法（如图），这种算法是采用了一个环状数组+链表的方式来管理延迟任</li></ol><p>务，我们只需要计算这个订单的超时时间，再加入到时间轮里面即可。</p><p>时间轮算法唯一的缺点就是无法持久化，所以需要在服务重启后做一次数据预热。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YzZiZmM0NzQ0Nzg4NGFkYTYwNWRhMDc1NmIxMjVjMjlfN0VmVFVoSDVmemdJMU1JaVdLNEUwQ0NnYkRZZHNCd2tfVG9rZW46QTV3Y2I0RWM3b29QQWV4QVdQM2NzNmdMbnZiXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><ol><li>利用主流 MQ 中的延迟消息功能，消息发送到 Broker 上以后并不会立刻投递，而</li></ol><p>是根据消息中设置的延迟时间去投递。我们只需要把新的订单并计算这个订单的超</p><p>时时间发送到 MQ 中即可。</p><p>MQ 这种实现方式在性能、可扩展性、稳定性上都比较好，是一个不错的选择。</p><h1 id="项目中如何保证的接口幂等"><a href="#项目中如何保证的接口幂等" class="headerlink" title="项目中如何保证的接口幂等"></a><strong>项目中如何保证的接口幂等</strong></h1><p>这个概念是我第一次接触，认真学习了一下，了解了一下如何保证接口幂等</p><p>首先，什么是幂等？</p><p>简单来说，就是一个接口，使用相同的参数重复执行的情况下，对数据造成的改变只发生一次。 比如支付操作，如果支付接口被重复调了 N 次，那资金的扣减只发生一次，这就是幂等</p><p>然后说问题，</p><p>在分布式架构中，由于引入了网络通信导致一个请求，除了成功&#x2F;失败以外，还多了一个未知状态。</p><p>也就是如果一次远程接口调用失败，有可能这个请求在服务端执行成功了。而客户端为了确保本次请求执行成功，可能会发起重试的操作，导致同一个接口被重复调用了多次</p><p>为了保证服务端接口的幂等性，我们就需要在服务端的接口中去识别当前请求是重复请求，从而不再进行数据的变更操作。</p><p>通常的解决方案有几种:</p><ul><li>使用数据库唯一索引的方式实现， 我们可以专门创建一个消息表，里面有一个消息内容的字段并且设置为唯一索引，每次收到消息以后生成 md5 值插入到这个消息表里面。一旦出现重复消息，就会抛异常，我们可以捕获这个异常来避免重复对数据做变更</li><li>使用 Redis 里面的 setNx 命令，我们可以把当前请求中带有唯一标识的信息存储到Redis 里面，根据 setNx 命令返回的结果来判断是否是重复执行，如果是则丢弃该请求。</li><li>使用状态机的方式来实现幂等，在很多的业务场景中，都会存在业务状态的流转，并且这些状态流转只会前进，所以我们在对数据进行修改的时候，只需要在条件里面带上状态，就能避免数据被重复修改的问题</li></ul><p>不管采用哪种方案，核心本质都是需要去识别当前请求是重复请求。</p><h1 id="消息推送中的已读消息和未读消息设计"><a href="#消息推送中的已读消息和未读消息设计" class="headerlink" title="消息推送中的已读消息和未读消息设计"></a><strong>消息推送中的已读消息和未读消息设计</strong></h1><p>(方案来自于咕泡科技)</p><p>“站内信”有两个基本功能：</p><p><strong>点到点的消息传送。</strong>用户给用户发送站内信，管理员给用户发送站内信。</p><p><strong>点到面的消息传送。</strong>管理员给用户（指定满足某一条件的用户群）群发消息</p><p>只需要设计一个消息内容表和一个用户通知表，当创建一条系统通知后，数据插入到消息内容表。消息内容包含了发送渠道，根据发送渠道决定后续动作。如果是站内渠道，在插入消息内容后异步地插入记录到用户通知表。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ODljMzcwZjhlNjY1MzcwZGRiMTQ5OWJmZWE5NmNjZmNfcm5pMlpXNTBmWnZjWWFrcFdmdG1VWXFzZmVOUVA1dHlfVG9rZW46UGowZmJjMHcwb0lndkN4SDZaZGM1elRUblBjXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p>这个方案看起来没什么问题，但实际上，我们把所有用户通知的消息全部放在一个表里</p><p>面，如果有 10W 个用户，那么同样的消息需要存储 10W 条很明显，会带来两个问题：</p><ol><li>随着用户量的增加，发送一次消息需要插入到数据库中的数据量会越来越大，导致</li></ol><p>耗时会越来越长</p><ol><li>用户通知表的数据量会非常大，对未读消息的查询效率会严重下降</li></ol><p>所以上面这种方案很明显行不通，要解决这两个问题，有两个参考解决思路。</p><p>第一个方式（如图），先取消用户通知表， 避免在发送平台消息的时候插入大量重复数据问题。其次增加一个“message_offset”站内消息进度表，每个用户维护一个消息消费的进度 Offset。每个用户去获取未读消息的时候，只需要查询大于当前维护的 msg_id_offset的数据即可。在这种设计方式中，即便我们发送给 10W 人，也只需要在消息内容表里面插入一条记录即可。</p><p>在性能上和数据量上都有较大的提升。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MzUwNzE1ZGViOWMxYjc2ZjZjNTk1ZTExMGViZjEzM2VfVE1sbHg5WnVod01nQ2tGQjh6c09kbjd5ZGc2Zmd5OE1fVG9rZW46S0c1dmJJYUsyb1dYVEt4VlJZOWNLUVFCbmxkXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p>第二种方式，和第一种方式类似，使用 Redis 中的 Set 集合来保存已经读取过的消息 id。使用 userid_read_message 作为 key，这样就可以为每个用户保存已经读取过的所有消息的 id。当用户读取了未读消息后， 就直接在 redis 的已读消息 id 的 set 中新增一条记录。这样，在已经得知到已读消息的数量和具体消息 id 的情况下，我们可以直接使用消息id 来查询没有消费过的数据</p><h1 id="布隆过滤器到底是什么东西？它有什么用"><a href="#布隆过滤器到底是什么东西？它有什么用" class="headerlink" title="布隆过滤器到底是什么东西？它有什么用"></a><strong>布隆过滤器到底是什么东西？它有什么用</strong></h1><p>首先想一个问题？如果想判断一个元素是否存在某个集合里面该怎么做？</p><p>一般的解决方案是先把所有元素保存起来，然后通过循环比较来确定。但是如果我们有几千万甚至上亿的数据的时候，虽然可以通过不同的数据结构来优化数据检索的时间复杂度，但是整体的效率依然很慢，而且会占用非常多的内存空间，这个问题该怎么解决呢？</p><p>这个时候，位图就派上了用场， BitMap 的基本原理就是用一个 bit 位来存储当前数据是否存在的状态值，也就是把一个数据通过 hash 运算取模后落在 bit 位组成的数组中，通过 1 对该位置进行标记。这种方式适用于大规模数据，但数据状态又不是很多的情况，通常是用来判断某个数据存不存在的。</p><p>布隆过滤器就是在位图的基础上做的一个优化设计</p><p>它的原理是，当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。检索的时候，使用同样的方式去映射，只要看到每个映射的位置的值是不是 1，就可以大概知道该元素是否存在集合中了。如果这些点有任何一个 0，则被检查的元素一定不在；如果都是 1，则被检查的元素很可能存在。</p><h1 id="会员批量过期的方案怎么实现？"><a href="#会员批量过期的方案怎么实现？" class="headerlink" title="会员批量过期的方案怎么实现？"></a><strong>会员批量过期的方案怎么实现？</strong></h1><p>​ 有一张 200W 数据量的会员表，每个会员会有长短不一的到期时间，现在想在快到</p><p>期之前发送邮件通知提醒续费，该怎么实现？</p><p>首先把握住场景的核心问题:</p><ul><li>200W 数据意味着数据量比较大</li><li>每个会员都有过期时间，需要能够筛选出快过期的会员</li></ul><p>四种解决方案：</p><ol><li>第一种，系统不主动轮询，而是等用户登录到系统以后，触发一次检查。如果发现会员的过期时间小于设定的阈值，就触发一次弹窗和邮件提醒。这种方式规避了轮询问题，不会对数据库和后端应用程序造成任何压力。 缺点是，如果用户一直不登陆，就一直无法实现会员过期，并且也无法提前去根据运营策略发送续期的提醒消息。</li><li>第二种，我们可以使用搜索引擎，比如 Solr、或者 Elasticsearch。把会员表里面的会员 id 和会员到期时间存储一份到搜索引擎中。搜索引擎的优势在于大数据量的快速检索，并且具有高可扩展性和高可靠性，非常适合大规模数据的处理。</li><li>第三种，可以使用 Redis 来实现。用户开通会员以后，在 Redis 里面存储这个会员 id，以及设置这个 id 的过期时间。然后可以使用 redis 的过期提醒功能，把配置项 notify-keyspace-events 改为 notify-keyspace-events “Ex”当 Redis 里面的 key 过期以后，会触发一个 key 过期事件，我们可以在应用程序中监听这个事件来处理。</li><li>第四种，可以直接使用 MQ 提供的延迟队列，当用户开通会员以后，直接计算这个会员的过期时间，然后发送一个延迟消息到 MQ 上，一旦消息达到过期时间，消费者就可以消费这个消息来触发会员过期的提醒。</li></ol><h1 id="日常开发中常见的限流算法"><a href="#日常开发中常见的限流算法" class="headerlink" title="日常开发中常见的限流算法"></a>日常开发中<strong>常见的限流算法</strong></h1><p>限流算法是一种系统保护策略，主要是避免在流量高峰导致系统被压垮，造成系统不可用的问题</p><p>日常开发中常见的限流算法有 4 种。</p><ol><li>计数器限流，一般用在单一维度的访问频率限制上，比如短信验证码每隔 60s 只能发送一次，或者接口调用次数等，它的实现方法很简单，每调用一次就加 1，处理结束以后减一。</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MmVhYTBiZjY1MzkxODQ1ZDJjNjg0MjViMTBiMjFlMTFfVzljVU1jVm9LenMxdlhVTFZZckR4MGFPWlNPeHI5RXBfVG9rZW46WEhOUGJJUmRob2hGQWd4UXNlNmNZMUNzbjFiXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><ol><li>滑动窗口限流，本质上也是一种计数器，只是通过以时间为维度的可滑动窗口设计，来减少了临界值带来的并发超过阈值的问题。每次进行数据统计的时候，只需要统计这个窗口内每个时间刻度的访问量就可以了。Spring Cloud里面的熔断框架Hystrix ，以及Spring Cloud Alibaba里面的Sentinel都采用了滑动窗口来做数据统计</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OTY5YTcyN2QxMDkxNGVkMDE1OTgxNjhjZGU4OWI3YjVfcHJuSW1zU3QwRWNpWnIzMFVhdjA2cmNXRGIzdUxNOGJfVG9rZW46VFFxb2JQdHhlb1VEUGl4bWQ1SWNFU3NzblF1XzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><ol><li>漏桶算法，它是一种恒定速率的限流算法，不管请求量是多少，服务端的处理效率是恒定的。基于 MQ 来实现的生产者消费者模型，其实算是一种漏桶限流算法</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MjJjMTUwMjAxM2RlNmU5MjJjZGZlYTZhNmZlNDRlYzZfcmpvbjhOMGdsQjlDZmhmZW5WdVMzMnc2SUhzak4xbWJfVG9rZW46UnNQcGJHNnpOb2p5NWt4ZDlwZGNiWktIbk5mXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><ol><li>令牌桶算法，相对漏桶算法来说，它可以处理突发流量的问题。它的核心思想是，令牌桶以恒定速率去生成令牌保存到令牌桶里面，桶的大小是固定的，令牌桶满了以后就不再生成令牌。每个客户端请求进来的时候，必须要从令牌桶获得一个令牌才能访问，否则排队等待。 在流量低峰的时候，令牌桶会出现堆积，因此当出现瞬时高峰的时候，有足够多的令牌可以获取，因此令牌桶能够允许瞬时流量的处理。网关层面的限流、或者接口调用的限流，都可以使用令牌桶算法，像Google 的 Guava，和 Redisson 的限流，都用到了令牌桶算法 在我看来，限流的本质是实现系统保护，最终选择什么样的算法，一方面取决于统计的精准度，另一方面考虑限流维度和场景的需求。</li></ol><h1 id="一致性-Hash-算法出现的场景和如何解决"><a href="#一致性-Hash-算法出现的场景和如何解决" class="headerlink" title="一致性 Hash 算法出现的场景和如何解决"></a><strong>一致性 Hash 算法出现的场景和如何解决</strong></h1><p>一致性 hash，是一种比较特殊的 hash 算法，它的核心思想是解决在分布式环境下，hash 表中可能存在的动态扩容和缩容的问题</p><ul><li>那么为什么会出现一致性 hash?</li></ul><p>一般情况下，我们会使用 hash 表的方式以 key-value 的方式来存储数据，但是当数据量比较大的时候，我们就会把数据存储到多个节点上，然后通过 hash 取模的方法来决定当前 key 存储到哪个节点上。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NjZjMDM4ODYxZmI4OGY3MTc4ZjgyNGU1NzFjNmVjMzZfbmt0MjdjeXJCcEozeFN3Ujk5ZERKM05qS0FYa1p1cU1fVG9rZW46VW1YZGJJRkpobzBsRUJ4bUJqRGNsc3I1bkNRXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p>这种方式有一个非常明显的问题，就是当存储节点增加或者减少的时候，原本的映射关系就会发生变化。也就是需要对所有数据按照新的节点数量重新映射一遍，这个涉及到大量的数据迁移和重新映射，迁移代价很大</p><ul><li>一致性 hash 的工作原理</li></ul><p>一致性 hash 就是用来优化这种动态变化场景的算法，它的具体工作原理也很简单。</p><p>首先，一致性 Hash 是通过一个 Hash 环的数据结构来实现的，（如图），这个环的起点是 0，终点是 2^32-1。</p><p>也就是这个环的数据分布范围是[0,2^32-1]</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=N2IxN2VlMDBiYzVhMWNhNjg1MDIxZjcyYTE2MGNjNjNfczVvZEd0bW41OEprekVFRUxFV0c1QjlUQ1prTFc5bWlfVG9rZW46SkF5bGJIU1Bkb3lXWVp4VzNXeGNPR1E3bjllXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p>然后我们把存储节点的 ip 地址作为 key 进行 hash 之后，会在 Hash 环上确定一个位置。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MDJmN2EwMjBhMjYyZDhjNGIzYzgwYjc2NzE2MjhjOGFfQUZKVWowNThjT1NwRHBVbVJOS0g2b1EwaHR4bzI4aHdfVG9rZW46UlJCcmJpOFh1b0JiRjF4R2wyRGNXdnJ2bnRiXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p>接下来，就是把需要存储的目标 key 使用 hash 算法计算后得到一个 hash 值，同样也会落到 hash 环的某个位置上。然后这个目标 key 会按照顺时针的方向找到离自己最近的一个节点进行数据存储。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NmIxZGU3YTA2YTJjMjEwOTk4ODgyYjNkNTdiZjI5YjZfTEs0Wm9iejE1dGk0UDczYVA0cWhrRERrVmJ4N3Y1TXpfVG9rZW46WWNFd2JVbGJPb29YRFF4TmtNc2N3UjQ1blpiXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><ul><li>为什么一致性 Hash 比普通 hash 算法好</li></ul><p>假设现在需要新增一个节点node4，那数据的映射关系的影响范围只限于node3和 node1，只有少部分的数据需要重新映射迁移就行了,如果是已经存在的节点 node1 因为故障下线了，只那只需要把原本分配在 node1 上的数据重新分配到 node2 上就行了。 同样对数据影响的范围非常小,所以，在我看来，一致性 hash 算法的好处是扩展性很强，在增加或者减少服务器的时候，数据迁移范围比较小。 另外，在一致性 Hash 算范里面，为了避免 hash 倾斜导致数据分配不均匀的情况，我们可以使用虚拟节点的方式来解决</p><h1 id="设计一个秒杀系统"><a href="#设计一个秒杀系统" class="headerlink" title="设计一个秒杀系统"></a><strong>设计一个秒杀系统</strong></h1><p>秒杀场景中有三个核心要素：</p><ol><li><strong>高性能</strong></li><li><strong>一致性</strong></li><li><strong>高可用性</strong></li></ol><h2 id="如何提高性能？"><a href="#如何提高性能？" class="headerlink" title="如何提高性能？"></a><strong>如何提高性能？</strong></h2><p>秒杀场景核心的问题是如何解决海量请求带来的性能问题，那么我们如何在有限的资源下，尽最大的限度去提高服务器访问性能？总结有这几点：热点数据处理、流量削峰、资源隔离、服务器优化。</p><h2 id="热点数据处理"><a href="#热点数据处理" class="headerlink" title="热点数据处理"></a><strong>热点数据处理</strong></h2><p><strong>1、什么是热点数据？</strong></p><p>我理解的热点数据指的是用户请求量非常高的那些数据，在秒杀场景中，热点数据就是那些要被秒杀的商品数据。</p><p>这些热点请求会大量占用服务器的资源，如果不对这些数据进行处理，那么会严重占用资源，进而影响系统的性能，导致其他业务也受影响。</p><p>热点数据又可以分为“静态热点数据”和“动态热点数据”。</p><p><strong>2、静态热点数据</strong></p><p>静态热点数据指的是可以提前预知的热点数据，比如秒杀场景，需要参与本次秒杀的商家提前报名，并将秒杀的商品录入热点分析系统中。业务系统通过这次提前录入的热点数据，进行预加载，甚至可以将数据放入本地缓存中，这样做的好处可以有效缓解避缓存集群的压力，避免流量集中时压垮缓存集群。</p><p>如何更新本地缓存？</p><p>可用做法是将热点数据录入热点分析平台，本地对热点数据进行订阅，并根据订阅规则去更新本地缓存即可。</p><p><strong>3、动态热点数据</strong></p><p>动态指的就是不能提前预知哪些数据是热点的，需要通过数据收集与分析，或者通过大数据平台预测。</p><p>做法可以是通过在网关平台中做一个用于收集日志的异步日志收集系统，通过采集商品请求的日志，处理后发送到热点分析平台，热点分析平台通过一些列的分析计算将这些热点商品进行热点数据处理，后端通过订阅这些热点数据就可以识别哪些商品是热点数据了。</p><h2 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a><strong>流量削峰</strong></h2><p>在服务器资源固定的情况下，说明处理能力是有峰值存在的，如果不对请求处理进行处理的话，很可能会在流量峰值的瞬间压垮服务器，但流量峰值存在的时间不长，其实服务器的处理能力大部分时间都是处于闲置状态，那么我们可不可以将峰值集中的请求分散到其他时间呢？</p><ol><li>消息队列</li></ol><p>消息队列除了在解耦、异步场景之外，最大的作用场景是用于流量削峰，面对海量流量请求，可以将这些请求数据用异步的方式先存放在消息队列中，而消息队列一般都能够存储大量消息，消息会被消费端订阅消费，这样就有效地将峰值均摊到其他时间进行处理了。</p><p>如上，消息队列就像我们平常见到的水库一样，当洪水来临时，拦住并对其进行储蓄，以减少对下游的冲击，避免了洪水的灾害。</p><p>目前有大量优秀的开源消息队列框架，如 RocketMQ、Kafka 等，而我之前在中通时主要负责消息平台的建设与维护工作，中通每天面对几千万的订单流量依然那么稳固，其中消息队列起了很大的“防洪”作用！</p><ol><li>答题</li></ol><p>除了利用消息队列对请求进行“储蓄”达到削峰的目的之外，还可以通过在用户发起请求前，对用户进行一些校验操作，比如答题、输入验证码等等，这种答题机制，除了可以防止买家在秒杀过程中使用作弊脚本之外，在秒杀场景中最主要的作还是将请求分散到各个时间点，秒杀场景一般都是集中在某个点进行，比如 0 点时刻，如果没有答题机制，几乎所有的流量都在 0 点时刻涌入服务器中，如果有答题机制，就能延缓用户的请求，从而达到请求分散到各个时间点的目的。</p><h2 id="如何保持一致性？"><a href="#如何保持一致性？" class="headerlink" title="如何保持一致性？"></a><strong>如何保持一致性？</strong></h2><p>秒杀场景，本质上就是在海量买家同时请求购买时，能够准确并将商品卖出去。</p><p>在秒杀的高并发读写请求过程中，需要保证商品不会发生“超卖”现象，因为秒杀的商品是数量一定的，但会有成千上万个用户在同一时间下单购买，在减扣库存过程中如何保证商品数量的准确性至关重要。</p><h3 id="减扣库存方案分析"><a href="#减扣库存方案分析" class="headerlink" title="减扣库存方案分析"></a><strong>减扣库存方案分析</strong></h3><p>1、下单减扣库存</p><p>买家只要完成下单，立即减扣商品库存，这种方式实现是最简单而且也是最精准的，通常可以在下单时利用数据库事务能力即可保证减扣库存的准确性，但需要考虑买家下单后不付款的情况。</p><p>2、付款减扣库存</p><p>即买家下单后，并不立即减库存，而是等到有用户付款后才真正减库存，否则库存一直保留给其他买家。但因为付款时才减库存，如果并发比较高，有可能出现买家下单后付不了款的情况，因为可能商品已经被其他人买走了。</p><p>当只有买家下单后，并且已完成付款，才执行库存的减扣，这种方式好处是避免了买家不付款导致实际没有卖出这么多商品的情况，但这种方式会造成用户体验不好，因为这会导致有些用户付款时商品有可能被人买走了导致付款失败的问题。</p><p>3、预扣库存</p><p>这种方式结合以上两种方式的优点，当买家下单后，预扣库存，只会其保留一定的时间，比如 10 分钟，在这段时间内如果买家不付款，则将库存自动释放，其它买家可以继续抢购。这种做法需要买家付款前，再做一次商品库是否还有保留，如果没有保留，则再次尝试预扣，预扣失败则不允许继续付款；如果有保留，付款完成后执行真正的减扣库存动作。</p><p>但预扣库存依然没有彻底解决减扣库存链路中存在的问题，比如有些买家可以在释放的瞬间立马又重新下单一次，相当于将库存无限地保留下去，因此我们还需要将记录用户下单次数，如果连续下单超过一定次数，或者超过下单并不付款次数，就拦截用户下单请求。</p><p>总结：</p><p>一般最简单的做法就是使用下单减库存的方式，因为在秒杀场景中，商品的性价比通常很高，秒杀就是创造一种只有少量买家能买到的场景，一般来说买家只要“秒”到商品了，极少情况会出现退款的，即使发生了少量退款，造成实际卖出去的商品会比数据上少，也是可以通过候补来解决。</p><h3 id="如何减扣库存？"><a href="#如何减扣库存？" class="headerlink" title="如何减扣库存？"></a><strong>如何减扣库存？</strong></h3><p>减扣库存动作应该放在哪里执行？</p><p>下面具体分析一下减扣库存的几种实现方式：</p><ol><li>如果链路涉及的逻辑比较简单的，比如下单减库存这种方式，最简单的做法就是在下单时，利用数据库的本地事务机制进行对库存的减扣，比如使用 where 库存 &gt;0不满足就回滚；</li><li>将库存数量值放在缓存中，比如 Redis，并做持久化处理。</li></ol><p>需要注意的是，如果遇到减扣库存的逻辑很复杂，比如减扣库存之后需要在同一个事务中做一些其他事情，那么就不能使用第二种方式了，只能使用第一种方式在数据库层面上面操作，以保证同在一个事务中。面对这种情况，你可以将热点数据进行数据库隔离，把这些热点商品单独放在一个数据库中。</p><h2 id="如何实现高可用性？"><a href="#如何实现高可用性？" class="headerlink" title="如何实现高可用性？"></a><strong>如何实现高可用性？</strong></h2><p>最后，为了保证秒杀系统的高可用性，必须要对系统进行兜底处理，以便遇到极端的情况系统依然能够运转，通常的做法有服务降级、服务限流、拒绝请求等方式处理。</p><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a><strong>服务降级</strong></h3><p>当请求量达到系统承受的能力时，需要对系统的一些非核心功能进行关闭操作，尽可能将资源留给秒杀核心链路。</p><p>比如在秒杀系统中，还存在其他非核心的功能，我们可以在系统中设计一些动态开关，比如在网关层在路由开关，将这些非核心的请求直接在最外层拒掉。</p><p>还有就是对页面展示的数据进行精简化，用降低用户体验换取核心链路的稳定运行。</p><h3 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a><strong>服务限流</strong></h3><p>限流的目的是通过对并发访问&#x2F;请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，常用的有 QPS 限流，用户请求排队限流，需要设置过期时间，一旦超过过期时间则丢弃，这样做是为了用户请求可以做到快速失败的效果，这种机制在 RocketMQ 中也有相关的应用，RocketMQ broker 会对客户端请求进行排队限流处理，当请求在队列中超过了过期时间，则丢弃，客户端快速失败进行第二轮重试。</p><h3 id="拒绝请求"><a href="#拒绝请求" class="headerlink" title="拒绝请求"></a><strong>拒绝请求</strong></h3><p>如果服务降级、服务限流都不能解决问题，最后的兜底，那就是直接拒绝用户请求，比如直接给用户返回 “服务器繁忙，请稍后再试”等提示文案。只会发生在服务器负载过载时会启动，因此只会发生短暂不可用时刻，由于此时服务依然还在稳定运行中，等负载下降时，可以快速恢复正常服务。</p><h1 id="在-2G-大小的文件中，找出高频-top100-的单词"><a href="#在-2G-大小的文件中，找出高频-top100-的单词" class="headerlink" title="在 2G 大小的文件中，找出高频 top100 的单词"></a><strong>在 2G 大小的文件中，找出高频 top100 的单词</strong></h1><ol><li>把 2G 的文件进行分割成大小为 512KB 小文件，总共得到 2048 个小文件，避免一</li></ol><p>次性读入整个文件造成内存不足。</p><ol><li>定义一个长度为 2048 的 hash 表数组，用来统计每个小文件中单词出现的频率。</li><li>使用多线程并行遍历 2048 个小文件，针对每个单词进行 hash 取模运算分别存储</li></ol><p>到长度为 2048 的 hash 表数组中</p><p>inthash&#x3D;Math.abs(word.hashCode() %hashTableSize);</p><p>hashTables[hash].merge(word, 1, Integer::sum);</p><ol><li>接着再遍历这 2048 个 hash 表，把频率前 100 的单词存入小顶堆中</li><li>最后，小顶堆中最终得到的 100 个单词，就是 top 100 了。</li></ol><p>这种解决方案的核心思想是将大文件分割为多个小文件，然后采用分治和堆的算法，来</p><p>解决这个问题</p><h1 id="设计一个发红包的API"><a href="#设计一个发红包的API" class="headerlink" title="设计一个发红包的API"></a>设计一个发红包的API</h1><p>让你设计一个微信发红包API，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。</p><p>如果是随机红包，根据发红包的人输入的钱数，默认精确到分，也就是0.01元。</p><p>最小的不可再分的单元就是0.01元。</p><p>如果红包的分数是10份，那么就把红包比如50元，那么可以生成1-4991的随机整数。</p><p>极端案例，一个人分得49.91元，剩余九个人每人分得0.01元。</p><p>第一个人分完，剩下的按照这个规则继续。</p><p>微信红包的规则为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">红包金额的区间为 <span class="number">0.01</span> - 平均值的<span class="number">2</span>倍</span><br></pre></td></tr></table></figure><p>该规则为 微信团队公布的算法。</p><p>这也就是说，假设给10个人发送100元的红包，那么：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第一个人得到金额的区间为[<span class="number">0.01</span>,<span class="number">20</span>]</span><br></pre></td></tr></table></figure><p>假设前三个人领到的红包为50元，那么此时红包还剩下 7个人 没有领取红包，红包还剩下 50元 ，那么下一个人可以得到的最大金额为：</p><p>(100-50)&#x2F;(10-3)*2&#x3D;14.29</p><p>第四个人得到的金额的区间为[0.01,14.29]</p><h1 id="实现一个登录拉黑功能，给你一批要拉黑的用户名和手机号，实现拉黑和把已经登陆的被拉黑的用户踢下线。"><a href="#实现一个登录拉黑功能，给你一批要拉黑的用户名和手机号，实现拉黑和把已经登陆的被拉黑的用户踢下线。" class="headerlink" title="实现一个登录拉黑功能，给你一批要拉黑的用户名和手机号，实现拉黑和把已经登陆的被拉黑的用户踢下线。"></a>实现一个登录拉黑功能，给你一批要拉黑的用户名和手机号，实现拉黑和把已经登陆的被拉黑的用户踢下线。</h1><p>在Spring Boot项目中实现登录拉黑功能，可以采用以下一些思路和步骤：</p><h2 id="1-黑名单数据模型设计"><a href="#1-黑名单数据模型设计" class="headerlink" title="1. 黑名单数据模型设计"></a>1. 黑名单数据模型设计</h2><p>首先，需要设计一个数据模型来存储黑名单中的用户名和手机号。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blacklist</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String phoneNumber;</span><br><span class="line">    <span class="comment">// 省略其他字段和getter/setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-黑名单管理接口"><a href="#2-黑名单管理接口" class="headerlink" title="2. 黑名单管理接口"></a>2. 黑名单管理接口</h2><p>提供一个管理接口，允许管理员添加和删除黑名单中的用户名和手机号。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/blacklist&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlacklistController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BlacklistService blacklistService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; addBlacklist(<span class="meta">@RequestBody</span> Blacklist blacklist) &#123;</span><br><span class="line">        blacklistService.addBlacklist(blacklist);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/remove/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; removeBlacklist(<span class="meta">@PathVariable</span> Long id) &#123;</span><br><span class="line">        blacklistService.removeBlacklist(id);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-用户认证拦截"><a href="#3-用户认证拦截" class="headerlink" title="3. 用户认证拦截"></a>3. 用户认证拦截</h2><p>在用户登录时，通过拦截器或过滤器检查用户是否在黑名单中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlacklistAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BlacklistService blacklistService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> ...; <span class="comment">// 获取用户名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">phoneNumber</span> <span class="operator">=</span> ...; <span class="comment">// 获取手机号</span></span><br><span class="line">        <span class="keyword">if</span> (blacklistService.isBlacklisted(username, phoneNumber)) &#123;</span><br><span class="line">            <span class="comment">// 用户在黑名单中，拒绝访问</span></span><br><span class="line">            response.sendError(HttpServletResponse.SC_FORBIDDEN, <span class="string">&quot;账号已被拉黑&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-在线用户管理"><a href="#4-在线用户管理" class="headerlink" title="4. 在线用户管理"></a>4. 在线用户管理</h2><p>对于已经登录的用户，需要有一种机制来检查他们是否被添加到黑名单中，并在必要时将其踢下线。</p><h3 id="使用WebSocket"><a href="#使用WebSocket" class="headerlink" title="使用WebSocket"></a>使用WebSocket</h3><ul><li>通过WebSocket与在线用户保持连接。</li><li>定时检查黑名单，如果发现在线用户被拉黑，则通过WebSocket发送下线通知。</li></ul><h3 id="使用轮询"><a href="#使用轮询" class="headerlink" title="使用轮询"></a>使用轮询</h3><ul><li>用户端定时发送请求到服务器，检查是否被拉黑。</li><li>如果检测到用户被拉黑，服务器返回特定的响应，前端据此进行下线处理。</li></ul><h2 id="5-用户会话管理"><a href="#5-用户会话管理" class="headerlink" title="5. 用户会话管理"></a>5. 用户会话管理</h2><ul><li>使用Spring Session来管理用户会话。</li><li>当用户被拉黑时，可以清除其会话。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlacklistSessionListener</span> <span class="keyword">implements</span> <span class="title class_">SessionDestroyedEvent</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SessionRepository sessionRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(SessionDestroyedEvent event)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">principalName</span> <span class="operator">=</span> (String) event.getPrincipal();</span><br><span class="line">        <span class="comment">// 根据用户名查找会话并清除</span></span><br><span class="line">        sessionRepository.deleteById(principalName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-事件驱动"><a href="#6-事件驱动" class="headerlink" title="6. 事件驱动"></a>6. 事件驱动</h2><ul><li>使用事件发布&#x2F;订阅模式，当黑名单更新时，发布事件。</li><li>订阅者监听事件，如果发现有在线用户被拉黑，执行下线操作。</li></ul><h2 id="7-前端交互"><a href="#7-前端交互" class="headerlink" title="7. 前端交互"></a>7. 前端交互</h2><ul><li>前端页面需要处理来自后端的拉黑通知。</li><li>可以设计一个提示框或弹窗，告知用户账号已被拉黑，并引导用户退出。</li></ul><h2 id="8-安全性考虑"><a href="#8-安全性考虑" class="headerlink" title="8. 安全性考虑"></a>8. 安全性考虑</h2><ul><li>确保黑名单数据的安全性，避免未授权访问。</li><li>对敏感操作（如添加&#x2F;删除黑名单）进行权限验证。</li></ul><h2 id="9-性能优化"><a href="#9-性能优化" class="headerlink" title="9. 性能优化"></a>9. 性能优化</h2><ul><li>考虑黑名单查询的性能，可能需要对数据库进行优化，如建立索引。</li><li>对于大规模用户，考虑使用缓存来减少数据库访问。</li></ul><h2 id="10-测试"><a href="#10-测试" class="headerlink" title="10. 测试"></a>10. 测试</h2><ul><li>对所有新增的功能进行单元测试和集成测试，确保功能的正确性和稳定性。</li></ul><h1 id="怎么判断一个手机号是否为新用户"><a href="#怎么判断一个手机号是否为新用户" class="headerlink" title="怎么判断一个手机号是否为新用户"></a>怎么判断一个手机号是否为新用户</h1><p>在Java面试中，判断一个手机号是否为新用户的问题通常涉及到数据库查询和用户管理的知识。以下是几种可能的解决方案：</p><h2 id="1-数据库查询"><a href="#1-数据库查询" class="headerlink" title="1. 数据库查询"></a>1. 数据库查询</h2><p>最直接的方法是在用户数据库中查询这个手机号是否存在。如果不存在，那么这个手机号就是新用户。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNewUser</span><span class="params">(String phoneNumber)</span> &#123;</span><br><span class="line">    <span class="comment">// 假设有一个UserRepository来访问数据库</span></span><br><span class="line">    <span class="keyword">return</span> !userRepository.existsByPhoneNumber(phoneNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-缓存检查"><a href="#2-缓存检查" class="headerlink" title="2. 缓存检查"></a>2. 缓存检查</h2><p>如果系统对性能要求较高，可以使用缓存来存储已注册的手机号。首先检查缓存，如果缓存中没有这个手机号，再查询数据库。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNewUser</span><span class="params">(String phoneNumber)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cache.containsKey(phoneNumber)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存中没有，查询数据库</span></span><br><span class="line">    <span class="keyword">return</span> !userRepository.existsByPhoneNumber(phoneNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-散列集合"><a href="#3-散列集合" class="headerlink" title="3. 散列集合"></a>3. 散列集合</h2><p>在某些情况下，如果用户数据量不是非常大，可以在内存中使用HashSet来存储所有已注册的手机号。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegistry</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; registeredPhoneNumbers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNewUser</span><span class="params">(String phoneNumber)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !registeredPhoneNumbers.contains(phoneNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法，比如注册用户时更新HashSet</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-异步检查"><a href="#4-异步检查" class="headerlink" title="4. 异步检查"></a>4. 异步检查</h2><p>如果注册流程对实时性要求不高，可以采用异步的方式来检查手机号是否为新用户，以减少对主线程的阻塞。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;Boolean&gt; <span class="title function_">isNewUserAsync</span><span class="params">(String phoneNumber)</span> &#123;</span><br><span class="line">    <span class="comment">// 异步执行数据库查询</span></span><br><span class="line">    <span class="keyword">return</span> executor.submit(() -&gt; !userRepository.existsByPhoneNumber(phoneNumber));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-批量检查"><a href="#5-批量检查" class="headerlink" title="5. 批量检查"></a>5. 批量检查</h2><p>如果需要同时检查多个手机号，可以设计一个批量查询的方法，以减少数据库的访问次数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;String, Boolean&gt; <span class="title function_">isNewUsers</span><span class="params">(Collection&lt;String&gt; phoneNumbers)</span> &#123;</span><br><span class="line">    Map&lt;String, Boolean&gt; isNewUserMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 批量查询数据库</span></span><br><span class="line">    List&lt;User&gt; users = userRepository.findAllByPhoneNumberIn(phoneNumbers);</span><br><span class="line">    <span class="keyword">for</span> (String phoneNumber : phoneNumbers) &#123;</span><br><span class="line">        isNewUserMap.put(phoneNumber, !users.stream().anyMatch(user -&gt; user.getPhoneNumber().equals(phoneNumber)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isNewUserMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-利用分布式系统"><a href="#6-利用分布式系统" class="headerlink" title="6. 利用分布式系统"></a>6. 利用分布式系统</h2><p>在分布式系统中，可以使用分布式缓存或分布式数据库来存储和查询手机号，以提高系统的扩展性和可用性。</p><h2 id="7-考虑数据一致性"><a href="#7-考虑数据一致性" class="headerlink" title="7. 考虑数据一致性"></a>7. 考虑数据一致性</h2><p>在设计解决方案时，需要考虑数据一致性问题。例如，如果用户刚刚注册，但是数据还没有同步到所有的数据库副本或缓存节点，可能会错误地判断为新用户。</p><h1 id="平台系统，好几个业务线，其中一个业务线消息生产过多，消息队列积压大量消息，去只想任务时大量操作在A业务里面获取，读取消息要很久，导致其他业务不能使用，如何快速处理"><a href="#平台系统，好几个业务线，其中一个业务线消息生产过多，消息队列积压大量消息，去只想任务时大量操作在A业务里面获取，读取消息要很久，导致其他业务不能使用，如何快速处理" class="headerlink" title="平台系统，好几个业务线，其中一个业务线消息生产过多，消息队列积压大量消息，去只想任务时大量操作在A业务里面获取，读取消息要很久，导致其他业务不能使用，如何快速处理"></a>平台系统，好几个业务线，其中一个业务线消息生产过多，消息队列积压大量消息，去只想任务时大量操作在A业务里面获取，读取消息要很久，导致其他业务不能使用，如何快速处理</h1><ol><li>增加消费者线程数：</li></ol><p>分析当前消费者线程的处理能力，适当增加消费者线程数，以加快消息的消费速度。</p><ol><li>并发优化：</li></ol><p>对A业务中的消息处理逻辑进行并发优化，如使用线程池、并行流等，提高消息处理的并发度。</p><ol><li>批量获取与处理：</li></ol><p>修改消息处理逻辑，使其能够批量获取消息并进行处理，减少每次获取和处理消息的开销。</p><ol><li>消息过滤与优先级：</li></ol><p>在消息队列中增加过滤机制，只处理重要或紧急的消息，暂时忽略非关键消息。</p><p>使用优先级队列，确保重要消息优先被处理。</p><ol><li>异步处理：</li></ol><p>如果A业务的处理逻辑不是实时性要求非常高的，可以考虑将其异步化处理，使用如Spig的</p><p>@Asyc注解或其他异步处理框架。</p><ol><li>缓存策略：</li></ol><p>如果八业务中存在频繁查询数据库或其他服务的操作，可以考虑使用缓存来减少查询次数，提高处</p><p>理速度。</p><ol><li>限流与降级：</li></ol><p>在消息生产者端实施限流策略，控制消息的生产速度。</p><p>对A业务进行降级处理，如暂时关闭一些非核心功能，确保系统整体稳定性。</p><ol><li>队列拆分与扩容：</li></ol><p>如果可能，将消息队列按业务线或消息类型进行拆分，降低单一队列的压力。</p><p>根据需要增加消息队列实例或调整其配置，提高队列的处理能力。</p><ol><li>监控与告警：</li></ol><p>加强消息队列和A业务的监控，实时观察队列长度、处理速度等指标。</p><p>设置合理的告警阈值，当出现异常时及时通知相关人员进行处理。</p><ol><li>错误处理与重试：</li></ol><p>完善错误处理逻辑，当消息处理失败时记录错误信息，并进行合理重试。</p><p>设置重试间隔和最大重试次数，避免无限重试导致的资源浪费和性能问题。</p><h1 id="大型Excel上传到服务器解析到数据库的系统设计"><a href="#大型Excel上传到服务器解析到数据库的系统设计" class="headerlink" title="大型Excel上传到服务器解析到数据库的系统设计"></a>大型Excel上传到服务器解析到数据库的系统设计</h1><p>设计一个用于大型Excel文件上传到服务器并解析到数据库的系统涉及多个步骤，需要仔细规划以确保性能和准确性。</p><p>需求分析</p><p>文件大小限制：确定系统能处理的最大文件大小。</p><p>文件格式：明确支持的Xcel文件格式（如.xs,Xsx)。</p><p>解析需求：确定需要解析的Excel内容（如特定的工作表、单元格范围等）。</p><p>数据库设计：根据Excel内容设计数据库表结构。</p><p>系统架构设计</p><p>总体流程：用户上传Ecl文件→后端接收并存储制临时文件一解析Excel内容→将数据写入数据库→清</p><p>理临时文件。</p><p>文件上传</p><p>前端：提供文件选择和上传的U界面。</p><p>后端：</p><p>接收前端上传的文件。</p><p>将文件保存到临时存储位置。</p><p>返回上传成功的响应给前端。</p><p>Excel解析</p><p>读取文件：使用Apache POI读取临时存储的Excel文件,使用easyExcel解析：利用easyExcel的流式读取特性，逐行解析Ecel内容，而不是一次性加载整个文件到内存。</p><p>解析内容：遍历工作表、行和单元格，提取需要的数据。</p><p>数据校验：对提取的数据讲行校验，确保数据的有效性和完整性</p><p>数据库写入</p><p>连接数据库：建立与数据库的连接。</p><p>批量写入：使用批处理技术将数据批量写入数据库，提高性能。</p><p>错误处理：捕获并处理数据库写入过程中可能出现的错误。</p><p>清理到临时文件</p><p>解析并写入数据库成功后，删除临时存储的Excel文件。</p><h1 id="wx加好友怎么实时同步到好友列表"><a href="#wx加好友怎么实时同步到好友列表" class="headerlink" title="wx加好友怎么实时同步到好友列表"></a>wx加好友怎么实时同步到好友列表</h1><p>涉及到数据库操作、WebSocket、HTTP轮询或者Server-Sent Events等技术。</p><p>1.数据库模型：</p><p>首先，我们需要一个数据库来存储用户信息和好友关系。</p><p>2.添加好友请求：</p><p>当用户发起添加好友请求时，后端需要记录这个请求。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/friends&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriendController</span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> FriendshipService friendshipService;</span><br><span class="line"><span class="meta">@PostMapping(&quot;/add&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;?&gt;addFriend(<span class="meta">@RequestBody</span> AddFriendRequest request)&#123;</span><br><span class="line">/验证请求参数</span><br><span class="line">/发起添加好友请求</span><br><span class="line">friendshipService.addFriendRequest(request.getFromUserId(),request.getToU</span><br><span class="line"><span class="keyword">return</span> ResponseEntity.ok(“请求已发送<span class="string">&quot;)：</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">@Service</span></span><br><span class="line"><span class="string">public class FriendshipService&#123;</span></span><br><span class="line"><span class="string">@Autowired</span></span><br><span class="line"><span class="string">private FriendshipRepository friendshipRepository;</span></span><br><span class="line"><span class="string">public void addFriendRequest (int fromUserId,int toUserId)&#123;</span></span><br><span class="line"><span class="string">Friendship friendship new Friendship(fromUserId,toUserId,&quot;</span>pending<span class="string">&quot;);</span></span><br><span class="line"><span class="string">friendshipRepository.save(friendship);</span></span><br><span class="line"><span class="string">//这里可以发送通知给被请求方，或者通过WebSocket推送消息</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>3.实时更新好友列表：</p><p>为了实时更新好友列表，可以使用VebSocketi进行双向通信。下面是一个简化的WebSocket实现：</p><p>VebSocket配置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">EnableWebSocketMessageBroker</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketMessageBrokerConfigurer</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerStompEndpoints</span><span class="params">(StompEndpointRegistry registry)</span>&#123;</span><br><span class="line">registry.addEndpoint(<span class="string">&quot;/ws&quot;</span>).withSockJS();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureMessageBroker</span> <span class="params">(MessageBrokerRegistry config)</span>&#123;</span><br><span class="line">config.enableSimpleBroker (<span class="string">&quot;/topic&quot;</span>);</span><br><span class="line">config.setApplicationDestinationPrefixes(<span class="string">&quot;/app&quot;</span>):</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置WebSocket消息处理器</p><p>前端需要使用WebSocket客户端来连接到服务器，并监听&#x2F;topic&#x2F;friendsl以接收实时更新的好友列表。</p><p>1.用户发起好友请求</p><p>前端用户可以通过一个界面选择并发送好友请求给另一个用户。这个请求会发送到后端服务。</p><p>2.后端处理好友请求</p><p>后端服务接收到好友请求后，需要进行一系列的验证和处理，包括检查用户是否存在、是否已经发送过好友请求等。</p><p>3.存储好友请求</p><p>一旦好友请求被验证和处理，它应该被存储在数据库中，等待对方用户的确认。</p><p>4.通知对方用户</p><p>可以通过推送通知、邮件或其他方式通知对方用户收到了好友请求。</p><p>5.对方用户确认或拒绝好友请求</p><p>对方用户可以通过前端界面确认或拒绝好友请求。这一操作同样会发送到后端服务进行处理</p><p>6.更新好友关系</p><p>如果对方用户确认了好友请求，后端服务需要更新数据库中的好友关系，并可能需要触发一些额外的逻辑，比如通知新好友、发送欢迎消息等。</p><p>7.实时同步好友列表</p><p>为了实现好友列表的实时更新，可以使用WebSocket或Server–Sent Events(SSE)等技术。当好友关系发生变化时，后端服务可以主动向前端推送更新。</p><h1 id="wx头像更换怎么实时同步更新给所有好友"><a href="#wx头像更换怎么实时同步更新给所有好友" class="headerlink" title="wx头像更换怎么实时同步更新给所有好友"></a>wx头像更换怎么实时同步更新给所有好友</h1><p>在微信这样的社交应用中，当某个用户更换头像时，需要实时地将这个更新同步给该用户的所有好友。为了实现这一功能，通常需要采用以下几种关键技术：</p><p>1.消息队列：用于异步处理头像更新事件，并通知相关的服务进行同步。</p><p>2.缓存：为了减轻数据库压力和提高响应速度，通常会将好友关系和头像信息存储在缓存中。</p><p>3.WebSocket或长轮询：用于实时地将头像更新推送给好友。</p><p>以下是一个简化的实现方案：</p><ol><li>用户上传新头像</li></ol><p>用户通过前端界面选择并上传新的头像。前端将头像数据发送给后端。</p><ol><li>后端处理头像更新</li></ol><ul><li>后端接收到头像数据后，先存储到对象存储服务(如AWSS3、阿里云OSS等)或本地文件系统中，并获取头像的访问URL。</li><li>更新数据库中该用户的头像URL。</li><li>将头像更新事件发送到消息队列（如Kafka、RabbitMQ等)。</li></ul><ol><li>消息队列消费者处理头像更新事件</li></ol><ul><li>消息队列的消费者监听头像更新事件</li><li>当接收到头像更新事件时，从数据库中或缓存中获取该用户的好友列表。</li><li>对于每个好友，生成一个包含新头像URL的更新消息。</li></ul><ol><li>将头像更新消息推送给好友</li></ol><ul><li>如果系统使用WebSocket,则可以通过WebSocket连接将更新消息推送给在线的好友。</li><li>如果好友不在线或WebSocket连接不可用，可以将更新消息存储在消息存储服务（如Redis)中，等待好友下次上线时拉取。</li><li>对于使用长轮询的方式，可以在轮询请求中返回最新的更新消息</li></ul><ol><li>好友接收并显示新头像</li></ol><ul><li>好友收到头像更新消息后，根据消息中的新头像URL加载并显示新头像。</li><li>如果使用了缓存机制，可能还需要清理旧的头像缓存，确保显示的是最新的头像。</li></ul><p>注意事项：</p><p>安全性：确保头像上传和处理的安全性，防止恶意文件上传和SQL注入等安全问题。</p><p>性能优化：对于大量用户和频繁的头像更新，需要优化数据库和缓存的读写性能，以及消息队列的处理速度。</p><p>容错处理：考虑在各个环节中添加适当的容错处理机制，如重试、降级等，以确保系统的稳定性和可用性。隐私保护：在处理用户头像等个人信息时，雲要尊守相关的隐私政策和法律法规</p><h1 id="wx不同设备登录怎么保持消息一致性"><a href="#wx不同设备登录怎么保持消息一致性" class="headerlink" title="wx不同设备登录怎么保持消息一致性"></a>wx不同设备登录怎么保持消息一致性</h1><ol><li>用户登录与设备管理</li></ol><ul><li>设备识别：当用户在新设备上登录时，系统应记录该设备与用户的绑定关系。可以使用设备D(如手机的MEI号、UUID等)作为唯一标识符。</li><li>登录验证：确保使用安全的登录验证机制，如OAuh2.0或WT,以验证用户身份和设备合法性。</li></ul><ol><li>消息存储与同步</li></ol><ul><li>消息存储：所有消息应存储在可靠的消息存储服务中，如数据库或消息队列（如Kafka、RabbitMQ等)。每条消息都应包含发送者、接收者、内容、时间戳等关键信息。</li><li>消息同步机制：</li></ul><p>当用户在新设备上登录时，系统应检查该用户的未读消息，并通过WebSocket、HTTP长轮询或推</p><p>送通知等方式将这些消息推送到新设备上。</p><p>对于实时消息，可以使用WebSocket建立持久连接，以便实时推送新消息到所有登录设备。</p><ol><li>消息状态管理</li></ol><ul><li>消息状态更新：当用户阅读消息时，系统应更新消息的状态（如“已读”状态）。这可以通过调用后端API来实现，API将更新数据库中消息的状态。</li><li>状态同步：当消息状态更新后，系统应通知其他登录设备同步更新消息状态。这可以通过WebSocket的实时通信功能实现。</li></ul><ol><li>安全性考虑</li></ol><ul><li>数据加密：传输和存储的消息应进行加密处理，以防止数据泄露。</li><li>访问控制：确保只有授权的设备可以访问和接收用户的消息。使用访问令牌或身份验证机制来验证设备的合法性。</li></ul><ol><li>辅助措施</li></ol><ul><li>冲突解决：在多个设备同时操作时（如同时标记消息为已读），需要实现冲突解决机制，确保数据的一致性。</li><li>日志记录：记录所有与消息同步相关的操作日志，以便在出现问题时进行排查和审计。</li></ul><ol><li>技术和工具选择</li></ol><ul><li>消息队列：使用高性能的消息队列服务来处理消息的存储和同步，确保消息的可靠性和实时性。</li><li>WebSocket:利用VebSockets实现实时通信和消息推送，确保消息的及时到达和同步。</li><li>数据库：选择适合业务需求的数据库系统来存储消息和用户状态信息，确保数据的安全性和一致性</li></ul><p>注意事项</p><ul><li>在实现过程中，需要考虑到不同网络环境和设备性能的差异，确保方案的健壮性和可扩展性。</li><li>对于大量用户和高并发场景，需要进行充分的性能叙测试和优化，以确保系统的稳定性和性能。</li></ul><h1 id="拿一个身份信息去请求多个不同服务的积分接口，需要快速求出平均积分，如何实现？"><a href="#拿一个身份信息去请求多个不同服务的积分接口，需要快速求出平均积分，如何实现？" class="headerlink" title="拿一个身份信息去请求多个不同服务的积分接口，需要快速求出平均积分，如何实现？"></a>拿一个身份信息去请求多个不同服务的积分接口，需要快速求出平均积分，如何实现？</h1><ol><li>定义积分接口：首先，我们需要定义各个服务提供的积分接口。这些接口应该有统一的请求和响应格</li></ol><p>式，以便我们可以统一处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">PointService</span> t</span><br><span class="line">CompletableFuture&lt;Double&gt;getPoints(String identity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了CompletableFuture来代表一个异步的积分获取操作。</p><ol><li>实现并发请求：接下来，我们可以使用Java的并发工具，如CompletableFuture或ExecutorService,来并发地请求各个服务的积分接口。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;CompletableFuture&lt;Double&gt;&gt;futures <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (PointService service services)&#123;</span><br><span class="line">futures.add(service.getPoints(identity));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>等待所有请求完成：然后，我们需要等待所有的请求都完成。这可以通过completableFuture.allof方法实现。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt;allFutures CompletableFuture.al10f(futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>))</span><br><span class="line">a11 Futures.join():<span class="comment">//等待所有请求完成</span></span><br></pre></td></tr></table></figure><ol><li>计算平均积分：当所有的请求都完成后，我们可以遍历futures:列表，获取每个服务的积分，并计算平均值。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Double&gt;points futures.stream()</span><br><span class="line">.map(CompletableFuture:join)/获取每个Futuref的结果</span><br><span class="line">collect(Collectors.toList());</span><br><span class="line"><span class="type">double</span> sum points.stream().mapToDouble(Double:doubleValue).sum();</span><br><span class="line"><span class="type">double</span> average sum points.size():</span><br></pre></td></tr></table></figure><ol><li>异常处理：在实际的应用中，我们还需要考虑异常处理。如果某个服务请求失败，我们应该能够捕获这个异常，并记录或处理它，而不是让整个程序崩溃。这可以通过在Comp1etab1 eFuture.上添加异常处理函数来实现。</li><li>优化和扩展：这个方案是一个基本的实现，但在实际应用中可能还需要进一步优化和扩展。例如，如果服务的数量非常多，或者每个服务的响应时间很长，那么可能需要考虑使用更高效的并发控制策略，如连接池或线程池。此外，还可以考虑使用更复杂的并发控制工具，如Reactive Programming或Project Reactor,来更好地做处理并发请求和响应。</li></ol><h1 id="防沉迷系统时间登录的模拟"><a href="#防沉迷系统时间登录的模拟" class="headerlink" title="防沉迷系统时间登录的模拟"></a>防沉迷系统时间登录的模拟</h1><ol><li>时间处理与比较：</li></ol><ul><li>使用Java的日期和时间APl(如LocalDateTime、ZonedDateTimes等)来处理时间相关的逻辑。</li><li>可以通过比较当前时间与设定的允许登录时间段来判断用户是否可以登录。</li></ul><ol><li>数据库管理：</li></ol><ul><li>使用数据库（如MySQL、Oracles等）来存储用户的基本信息、登录记录以及防沉迷设置。</li><li>通过查询数据库来判断用户的年龄和登录状态，以及记录用户的登录时间和行为。</li></ul><ol><li>认证与授权：</li></ol><ul><li>使用JWT(JSON Web Tokens)或OAuth等认证机制来验证用户的身份和权限。</li><li>对于未成年用户，可以根据其身份信息启用或调整防沉迷限制。</li></ul><ol><li>定时任务与调度：</li></ol><ul><li>利用Java的定时任务框架（如Quartz、Spring Task等）来定期检查用户的登录状态和时间。</li><li>可以设置定时任务来强制未成年用户在特定时间下线或限制其登绿。</li></ul><ol><li>日志记录与监控：</li></ol><ul><li>使用日志框架（如Log4j、SLF4J等）记录用户的登绿行为、时间以及任何与防沉迷系统相关的操</li></ul><p>作。</p><ul><li>通过监控工具实时监控系统的运行状态和用户行为，以便及时发现和处理异常情况。</li></ul><ol><li>异常处理与错误反馈：</li></ol><ul><li>使用java的异常处理机制来处理在登录过程中可能出现的各种异常情况。</li><li>对于不满足登录条件的用户，提供友好的错误提示和反馈。</li></ul><ol><li>缓存技术：</li></ol><ul><li>利用缓存技术（如Redis、Memcached等）来提高系统的响应速度和性能。</li><li>可以将用户的登录状态、时间等常用信息缓存起来，减少数据库访问次数。</li></ul><h1 id="现在有一个交易性的数据，日增长量可能达到千万级别的数据，交易完成后数据就不会发生变化了，但是会频繁地查询数据，请针对这个场景对数据库的设计和表的设计给出一些建议"><a href="#现在有一个交易性的数据，日增长量可能达到千万级别的数据，交易完成后数据就不会发生变化了，但是会频繁地查询数据，请针对这个场景对数据库的设计和表的设计给出一些建议" class="headerlink" title="现在有一个交易性的数据，日增长量可能达到千万级别的数据，交易完成后数据就不会发生变化了，但是会频繁地查询数据，请针对这个场景对数据库的设计和表的设计给出一些建议"></a>现在有一个交易性的数据，日增长量可能达到千万级别的数据，交易完成后数据就不会发生变化了，但是会频繁地查询数据，请针对这个场景对数据库的设计和表的设计给出一些建议</h1><ol><li>表结构的设计</li></ol><p>字段精简：只保留必要的字段，避免冗余和不必要的复杂结构。</p><p>选择合适的数据类型：使用最小的合适数据类型来存储数据，例如使用INT代替VARCHAR来存储整</p><p>数，使用DATETIME或TIMESTAMP来存储时间戳。</p><p>固定长度字段：尽量使用固定长度的字段，因为M小ySQL处理固定长度的字段更快。</p><ol><li>索引优化</li></ol><p>主键索引：确保表有一个唯一且简短的主键，这通常是交易引D或类似的唯一标识符。</p><p>查询优化索引：为经常用于查询的字段（如用户D、交易类型、时间等）创建索引。但要注意，</p><p>过多的索引会影响写入性能，因此需要权衡。</p><p>复合索引：如果经常按多个字段进行查询，考虑创建复合索引。</p><p>避免全表扫描：通过合适的索引来避免全表扫描，从而提高查询效率。</p><ol><li>分区</li></ol><p>水平分区：考虑按时间范围或某种业务逻辑对数据进行水平分区，这样可以将查询分散到不同的分</p><p>区上，提高查询效率。</p><ol><li>读写分离</li></ol><p>读写分离：实施读写分离策略，将读操作和写操作分散到不同的数据库实例成服务器上。可以使用</p><p>MySQL的主从复制功能来实现。</p><ol><li>缓存</li></ol><p>查询缓存：虽然MySQL有查询缓存功能，但在高并发和繁更新的场景下，查询缓存可能会导致性能下降。因此，需要根据实际情况决定是否启用查询缓存。</p><p>应用层缓存：使用Redis等内存数据库在应用层缓存频繁查询的数据，减少对MySQL的访问压力。</p><h1 id="在使用数据库时，数据库的CPU使用率非常高，如何排查这个问题"><a href="#在使用数据库时，数据库的CPU使用率非常高，如何排查这个问题" class="headerlink" title="在使用数据库时，数据库的CPU使用率非常高，如何排查这个问题"></a>在使用数据库时，数据库的CPU使用率非常高，如何排查这个问题</h1><p>一般而言，cpu使用率飙升可归纳为以下两点：</p><ul><li>大量的慢sql占用了cpu资源，拖垮了数据库，这类的慢sql常常表现为：查询的数据量过大，全表扫描、锁抢占甚至死锁、复杂查询等</li><li>QPS过高，本质上是数据库的承载的流量过大</li></ul><p><strong>慢<strong><strong>sql</strong></strong>优化思路</strong></p><ul><li>1.扫描数据库记录数较多。</li></ul><p>考虑表是否设置了合理的索引，表字段是否设置了合理的数据类型，sql是否有效的利用了索引等。</p><ul><li>2.sql中是否有做了大量的聚合、计算？</li></ul><p>考虑将sql简化，把逻辑操作上浮到业务中去做。</p><ul><li>3.sql返回的记录数过多。 考虑分页实现，通过limit将一次请求转为多次请求。</li><li>4.表中是否冗余字段过多？ 表若为宽表，包含大量冗余字段，可考虑分表。</li><li>5.库中是否有很多张表？ 此时可考虑将表拆分到多个库中，分库。</li><li>6.若库的读写较多，锁争抢激励，甚至死锁。 可考虑多库做读写分离。</li><li>7.机器的本身性能较低，不符合业务需求。 可考虑机器升级了。</li></ul><p><strong>qps****过高优化思路。</strong></p><ul><li>1.qps过高时，考虑是否可以使用缓存。</li><li>2.使用批量操作，将多个操作合并为一次请求，但此种方式需要考虑是否可以一次批量的数据有多大，避免造成慢sql。</li><li>3.考虑分库、读写分离，减少对一个机器的访问压力。</li><li>4.机器升级，没什么是钱解决不了的。</li></ul><h1 id="实现b站弹幕设计"><a href="#实现b站弹幕设计" class="headerlink" title="实现b站弹幕设计"></a>实现b站弹幕设计</h1><p>架构设计考虑以下几个场景：</p><ul><li>支持直播弹幕回放</li><li>用户进入直播间可以推送最新几秒的弹幕数据</li><li>长连模式和短连模式可以做降级切换</li></ul><p>为了不影响读写的性能，采用读写分离架构。</p><ul><li>写服务：若不考虑历史弹幕可回放，可以直接使用 Redis 作为唯一存储。若考虑支持弹幕的回放，数据还是需要持久化，可以考虑使用 MySQL 或者 TiDB，暂且认为写入不是较大的瓶颈。如果有更高性能的写需求，HBase、OpenTSDB 等都可以解决问题。</li><li>读服务：Redis 主要用于读缓存，缓存直播间最新的弹幕数据，采用直播间 ID 作为 Key。系统读服务最大 QPS &#x3D; Redis 集群QPS。</li></ul><p>Redis 存储结构选择：SortedSet。</p><ul><li>提交弹幕：ZADD，score 设置为时间戳。进一步优化可以只存储时间的 delta 值，减少<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/cdcs?from_column=20065&from=20065">数据存储</a>量。</li><li>弹幕查询：ZRANGEBYSCORE 定时轮询弹幕数据。</li></ul><p>有什么问题？</p><ul><li>系统性能与 Redis 集群容量强相关，性能提升需要扩容 Redis，成本高。</li><li>Redis 重复请求较多，相同直播间会存在很多重复的轮询请求。</li></ul><p><strong>缓存优化</strong></p><p>如果能让最新的实时弹幕数据都能命中本地缓存，那性能是最高的，同时大幅度降低了 Redis 的读取压力。所以弹幕读服务可以每秒轮询 Redis 数据，构建本地缓存。</p><p>热点问题：</p><ul><li>假设同时在线的直播间有 10000 个，读服务机器有 50 台，那么每秒轮询 Redis 的 QPS &#x3D; 10000 * 50 &#x3D; 50w，读取请求线性膨胀。</li><li>本地内存的使用量也随直播间的数量增长而膨胀，每个直播间的缓存的数据量降低，导致本地缓存的命中率降低，容易导致 GC 频繁。</li></ul><p><strong>热点优化</strong></p><p>如何降低本地缓存的使用量？</p><ul><li>因为火爆的直播间会占据整个平台大部分的流量，可以只针对火爆的直播间开启本地缓存。</li><li>通过路由控制同一个直播间的请求分发到固定的几台机器，例如一致性 Hash 算法。通过减少读服务机器上的直播间数量，达到降低本地缓存使用量的目的。</li></ul><p>上述方法可以有效地解决问题，但是不能解决流量不均衡的问题。不同直播间分配的机器资源不是拍脑袋定的，需要有理论依据，<code>可以根据直播间的一些数据指标进行动态分配机器资源。</code></p><ul><li>增加对直播间数据指标的统计，如单机 QPS、集群 QPS、单机直播间在线数等。</li><li>关于自适应的<a target="_blank" rel="noopener" href="https://cloud.tencent.com/product/clb?from_column=20065&from=20065">负载均衡</a>又是一个可以深挖的话题，在这里我们讨论几个常用的方案，有可能结合起来使用效果更好。<ul><li>分桶：不同 QPS 的范围段划分为不同的桶，根据桶范围的不同分配的机器数量也是不同的。</li><li>最大最小公平分配：根据直播间的 QPS 划分资源需求的权重比例，根据总机器的数量和权重比例来分配机器数量。</li><li>启发式算法：遗传算法、蚁群算法等。</li></ul></li></ul><p><strong>客户端<strong><strong>长连接</strong></strong>推送</strong></p><p>为了保障客户端消息的推送性能和实时性，长连接基本是必备的，最新的消息可以直接采用长连接实时推送。</p><ul><li>Push Server 从 Redis 中获取用户和直播间的订阅关系以及长连接信息。</li><li>连接代理只负责与客户端保持长连接。</li><li>海量的消息推送需要批量压缩。</li></ul><p><strong>弹幕回放</strong></p><p>增加一组专门用于回放的 Redis 集群，同时增加回放的本地缓存，其余设计与上述方案保持一致。</p><p>主要讨论了以下几个点：</p><ul><li>读写分离的架构设计</li><li>通过缓存优化读性能</li><li>长连接的方案设计以及客户端的消息推送</li></ul><h1 id="消息队列，两条消息不同topic-不同时间到达，将两条消息关联起来，如何实现"><a href="#消息队列，两条消息不同topic-不同时间到达，将两条消息关联起来，如何实现" class="headerlink" title="消息队列，两条消息不同topic,不同时间到达，将两条消息关联起来，如何实现"></a>消息队列，两条消息不同topic,不同时间到达，将两条消息关联起来，如何实现</h1><ol><li>消息ID与关联ID:</li></ol><ul><li>当发送第一条消息时，生成一个唯一的关联ID(Correlation ID)。</li><li>将这个关联ID作为消息的属性或头部与第一条消息一起发送。</li><li>当需要发送第二条消息时，使用相同的关联D。</li><li>在消息消费者端，当接收到消息时，检查关联性，并尝试将其与之前接收到的消息进行匹配。</li></ul><ol><li>外部存储：</li></ol><ul><li>使用数据库或缓存系统（如Redis)作为外部存储来跟踪消息。</li><li>当第一条消息到达时，将其关键信息（如消息D、时间戳等）存储在外部存储中，并使用一个唯一的键（例如基于消息的某个属性）进行索引。</li><li>当第二条消息到达时，检查其是否包含与第一条消息相关联的属性。如果包含，则从外部存储中检索第一条消息的信息，并进行关联。</li></ul><ol><li>延迟队列或定时任务：</li></ol><ul><li>如果第二条消息总是在第一条消息之后的一个可预测的时间窗口内到达，可以使用延迟队列或定时任务来处理。</li><li>当第一条消息到达时，将其存储在某个临时位置（如数据库、内存队列等）。</li><li>设置一个定时任务或延迟队列，等待一段时间后检查是否有与第一条消息相关的第二条消息。</li><li>如果找到第二条消息，则将它们关联起来。</li></ul><ol><li>消息队列的高级功能：</li></ol><ul><li>一些消息队列系统（如RabbitMQ、Apache Kafka等）提供了死信队列、消息重试等高级功能，可以帮助处理这种情况。</li><li>例如，在RabbitMQ中，可以使用消息的TTL(Time-To-Live)和死信队列来处理超时未处理的消息</li><li>在Apache Kafka中，可以使用流处理工具（如Kafka Streams或Flink)来处理跨多个topic的消息关联。</li></ul><ol><li>应用程序级别的关联：</li></ol><ul><li>在应用程序级别实现消息关联逻辑。这意味着当应用程序消费消息时，它会维护一个内部状态或数据结构来跟踪和关联不同topic的消息。</li><li>这需要应用程序能够处理可能的并发和状态管理问题。</li></ul><h1 id="一个表在不添加字段，不改动表结构的情况下，怎么增加新的属性"><a href="#一个表在不添加字段，不改动表结构的情况下，怎么增加新的属性" class="headerlink" title="一个表在不添加字段，不改动表结构的情况下，怎么增加新的属性"></a>一个表在不添加字段，不改动表结构的情况下，怎么增加新的属性</h1><p>在Java后端开发中，如果需要在不添加字段和不改动表结构的情况下为一个表增加新的属性，可以考虑以下几种策略：</p><p>\1. <strong>使用JSON字段</strong>：</p><p>如果数据库表中已经有一个JSON类型的字段，可以在该字段中添加新的属性。Java后端可以通过解析和修改JSON数据来实现。</p><p>\2. 使用视图（View）：</p><p>在数据库中创建一个视图，该视图基于原表，并添加了需要的新属性（可能是通过计算得到的）。Java后端查询视图而非原表。</p><p>\3. 使用缓存：</p><p>在应用程序中使用缓存（如Redis）来存储额外的属性。每次表中的数据被访问或修改时，应用程序逻辑负责更新缓存中的属性。</p><p>\4. 使用中间件或服务：</p><p>创建一个中间件或服务，它在数据访问层和业务逻辑层之间工作，负责在不改变数据库表结构的情况下添加额外的属性。</p><p>\5. 使用应用程序逻辑：</p><p>在Java应用程序中添加逻辑来处理新的属性。例如，可以根据现有的数据计算新的属性值，或者从其他数据源获取这些值。</p><p>\6. 使用数据库触发器（如果适用）：</p><p>如果数据库支持，可以创建触发器来自动填充额外的属性到另一个表或缓存中。但这通常需要对数据库结构有所改动。</p><p>\7. 使用数据库函数：</p><p>利用数据库的函数功能，在查询时动态计算新的属性值。</p><p>\8. 使用外部数据存储：</p><p>将新的属性存储在外部系统（如NoSQL数据库、搜索引擎等），通过应用程序逻辑来同步和查询这些数据。</p><p>\9. 使用数据库扩展（如果数据库支持）：</p><p>某些数据库支持通过插件或扩展来添加新的功能，这可能允许在不改变表结构的情况下添加属性。</p><p>\10. 使用ORM框架的特性：</p><p>​ 如果使用ORM框架（如Hibernate），可以利用框架提供的特性来映射额外的属性，例如通过关联对象或动态映射。</p><h1 id="设计一个累充奖励系统"><a href="#设计一个累充奖励系统" class="headerlink" title="设计一个累充奖励系统"></a>设计一个累充奖励系统</h1><p>一、系统架构设计</p><p>1.功能性需求</p><ul><li>用户充值记录：记录用户充值金额和时间。</li><li>奖励规则配置：设置不同充值金额对应的奖励。</li><li>奖励发放：根据用户的充值记录，自动发放奖励。</li></ul><p>二、数据库设计</p><p>1.数据表设计</p><p>用户表(user):存储用户信息，如用户D、用户名等。</p><p>充值记录表(recharge_record砂：存储用户的充值信息，如用户ID、充值金额、充值时间等。</p><p>奖励规则表(reward_ru1e:存储奖励规则，如充值金额阈值、对应奖励等。</p><p>奖励发放记录表(reward_record):存储奖励发放记录，如用户ID、奖励内容、</p><p>发放时间等</p><p>2.索引设计</p><p>在recharge_.record表的user_id和recharge._time字段上建立索引，提高查询效率</p><p>在reward_ru1e表的充值金额阈值字段上建立索引，方便根据充值金额查找对应的奖励。</p><p>3.关联关系</p><p>通过用户lD,recharge_.recordi和reward_recor表可以与user表进行关联。</p><p>通过奖励规侧则lD,reward_record表可以与reward_rule表进行关联。</p><ol><li><strong>数据库性能优化</strong>：<ol><li>定期优化查询语句，避免复杂的联表查询。</li><li>使用分页查询，避免一次性加载大量数据。</li></ol></li><li><strong>读写分离</strong>：<ol><li>将读操作和写操作分离到不同的数据库服务器。</li></ol></li><li><strong>分库分表</strong>：<ol><li>根据业务需求进行垂直或水平分库分表。</li></ol></li><li><strong>数据缓存</strong>：<ol><li>对频繁访问且不常变更的数据使用缓存策略。</li></ol></li><li><strong>异步处理</strong>：<ol><li>对于非实时性要求的操作，如奖励发放，可以采用异步处理。</li></ol></li><li><strong>数据备份与恢复</strong>：<ol><li>定期备份数据库，确保数据安全。</li></ol></li><li><strong>高可用性</strong>：<ol><li>通过主从复制、集群等方式提高数据库的可用性。</li></ol></li><li><strong>监控与告警</strong>：<ol><li>实施数据库性能监控，设置阈值告警。</li></ol></li><li><strong>数据一致性</strong>：<ol><li>使用事务管理确保数据操作的原子性、一致性、隔离性和持久性。</li></ol></li></ol><h1 id="百万级别以上的数据是怎么删除的"><a href="#百万级别以上的数据是怎么删除的" class="headerlink" title="百万级别以上的数据是怎么删除的"></a>百万级别以上的数据是怎么删除的</h1><p>当需要删除百万级的数据时，为了提高删除速度和减少对数据库性能的影响，可以采取以下一些优化技巧。</p><p><strong>使用批量删除</strong></p><p>为了减少数据库的IO开销，可以将删除操作分批进行。例如，将百万级数据分为一千个批次，每个批次删除一千行数据，可以使用循环语句结合LIMIT子句来实现。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> unique_checks<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">SET</span> foreign_key_checks<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">WHILE row_count <span class="operator">&gt;</span> <span class="number">0</span> DO</span><br><span class="line">    <span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">condition</span> LIMIT <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">SET</span> row_count <span class="operator">=</span> ROW_COUNT();</span><br><span class="line">    <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="keyword">END</span> WHILE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> autocommit<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> unique_checks<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">SET</span> foreign_key_checks<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在上面的示例中，我们关闭了自动提交（autocommit）、唯一键检查（unique_checks）和外键检查（foreign_key_checks）来优化删除过程。同时，采用循环的方式，每次删除一千行数据，并在每次删除后提交事务，直到所有的数据都被删除完。</p><p><strong>禁止触发器和索引</strong></p><p>删除大规模数据时，触发器和索引的维护可能会导致性能下降。为了提高删除速度，可以暂时禁止触发器和索引的维护，删除完成后再重新启用。可以使用以下语句来禁止和启用触发器和索引的维护。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 禁止触发器</span></span><br><span class="line"><span class="keyword">SET</span> session trigger_definer<span class="operator">=</span>&quot;DEFINER=your_definer_name@localhost&quot;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 禁止索引维护</span></span><br><span class="line"><span class="keyword">SET</span> session sql_log_bin<span class="operator">=</span><span class="number">0</span>; </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name DISABLE KEYS;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 启用索引维护</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name ENABLE KEYS;</span><br><span class="line"><span class="keyword">SET</span> session sql_log_bin<span class="operator">=</span><span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 启用触发器</span></span><br><span class="line"><span class="keyword">SET</span> session trigger_definer<span class="operator">=</span>&quot;&quot;;</span><br></pre></td></tr></table></figure><p><strong>使用分区表</strong></p><p>对于分区表来说，删除数据只需删除相应分区即可，这样就避免了扫描整个表的操作，提高了删除速度。可以使用以下语句删除分区表中的数据。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">PARTITION</span> partition_name;</span><br></pre></td></tr></table></figure><p>需要注意的是，使用分区表需要提前设计好分区策略，合理设置分区数量和范围，以便更好地支持删除操作。</p><p><strong>其他优化技巧</strong></p><ul><li>如果删除的数据涉及外键约束，可以先禁用外键约束再进行删除操作，以避免约束检查的开销。</li><li>使用合适的索引，能够加快删除操作的速度。</li><li>选择非繁忙时段进行删除操作，以避免对正常业务操作的影响。</li></ul><h1 id="多人调用请求，如果某一个人的请求发生了错误，如何具体定位到哪个人的调用出现了错误"><a href="#多人调用请求，如果某一个人的请求发生了错误，如何具体定位到哪个人的调用出现了错误" class="headerlink" title="多人调用请求，如果某一个人的请求发生了错误，如何具体定位到哪个人的调用出现了错误"></a>多人调用请求，如果某一个人的请求发生了错误，如何具体定位到哪个人的调用出现了错误</h1><ol><li><strong>请求跟踪ID</strong>：为每个请求生成一个唯一的跟踪ID（Trace ID），并将其存储在日志中。这样，即使在分布式系统中，也能追踪到请求的完整路径。</li><li><strong>用户会话标识</strong>：使用用户会话标识（如Session ID或JWT Token）来关联请求和用户。确保每个请求都包含这个标识，并在日志中记录。</li><li><strong>日志记录</strong>：使用日志框架（如Log4j、SLF4J等）记录详细的请求日志。日志应包括时间戳、请求ID、用户会话标识、请求的URL、方法、IP地址、错误信息等。</li><li><strong>异常捕获</strong>：在代码中使用try-catch块捕获异常，并记录异常信息。确保异常信息中包含足够的上下文，以便于问题定位。</li><li><strong>错误码和消息</strong>：为不同的错误类型定义错误码和错误消息，这样在日志中可以快速识别错误类型。</li><li>**中间件&#x2F;**<strong>拦截器</strong>：使用中间件或拦截器来处理请求和响应，记录每个请求的开始和结束时间，以及任何异常。</li><li><strong>分布式****跟踪</strong>：如果系统是分布式的，可以使用分布式跟踪系统（如Zipkin、Jaeger等）来跟踪请求在各个服务之间的流动。</li><li><strong>性能监控</strong>：使用性能监控工具（如New Relic、Datadog等）来监控服务的性能和健康状态。</li><li><strong>错误报告工具</strong>：集成错误报告工具（如Sentry、Rollbar等），它们可以捕获异常并提供详细的错误报告。</li><li><strong>审计日志</strong>：对于敏感操作，记录审计日志，包括操作人、操作时间、操作内容等信息。</li><li><strong>用户反馈</strong>：允许用户提供反馈，这可以作为定位问题的辅助手段。</li><li><strong>测试和验证</strong>：通过自动化测试（单元测试、集成测试等）来验证代码的正确性，减少错误发生的概率。</li><li><strong>代码审查</strong>：定期进行代码审查，以发现潜在的错误和性能问题。</li><li><strong>文档化</strong>：确保所有的错误处理和日志记录策略都有文档记录，以便团队成员理解和遵循</li></ol><h1 id="支付系统该如何设计"><a href="#支付系统该如何设计" class="headerlink" title="支付系统该如何设计"></a>支付系统该如何设计</h1><h2 id="支付系统总览"><a href="#支付系统总览" class="headerlink" title="支付系统总览"></a><strong>支付系统总览</strong></h2><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=Mjk4ZTk0YzM2YzRmMTFlYWU5OGQzZTgxMDA1ZWFmZjZfRzl1RGU2NUs4Rm5Ia1lXcXJVM3d6cGMxbUxsUjRmeU9fVG9rZW46Vlk4TGJTWmZPb2R0YkZ4N21IMWNUSVFHbmxmXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h2 id="核心系统解析"><a href="#核心系统解析" class="headerlink" title="核心系统解析"></a><strong>核心系统解析</strong></h2><h3 id="交易核心"><a href="#交易核心" class="headerlink" title="交易核心"></a><strong>交易核心</strong></h3><p>交易核心把公司的业务系统和底层支付关联起来，让业务系统专注于业务，不必关心底层支付。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MmEwNWY2ZGFiMzE2MjZmM2M0ZTFhNDQ1NGU4NmYzYzFfQlFiR1JkOEU5QWE2b1ZpZGRxQUI0dVQ2WlNRN2hjalNfVG9rZW46VlNncmJMTHFxb1ZzV3R4TlI4R2NwcDdNblNnXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p><strong>基础交易类型抽象</strong></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTgxZmRiYWJmZmUzMTVlYmE5MzhlNDJiZjA0NzkyNGRfZHBZenNyVlRmVWJSZ2xDN0JJQm43ZHRldkI0dzhUZUtfVG9rZW46S1BSd2JEdkh2b1VLNmx4YllpMGNib0lobmRlXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p><strong>多表聚合 &amp; 订单关联</strong></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YTIxZWU3MDc0NmYyZWNlOWYxMTQ1Y2M4NTllN2E3NzRfQWZwNDA1ZjhaSXdQUUp4bTRHS21EdndUU2NnTEtSaTJfVG9rZW46RENLSGJOWjNjb0FWT0d4bGl4NmNHRmV1blJoXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h3 id="支付核心"><a href="#支付核心" class="headerlink" title="支付核心"></a><strong>支付核心</strong></h3><p>支付核心主要负责将多种支付类型进行抽象，变成<code>充值</code>、<code>提现</code>、<code>退款</code>、<code>转账</code>四种支付形态。同时，还要负责集成多种支付工具，对支付指令进行编排等等。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2M2YzIxYTAxYjZjN2NiNDBlMzU5ZmJkZDBhNjEzYmFfbHVKVWN5RXFqUk1uSmQ0Z0t2YzFnUnk2Tld6TDNrcnBfVG9rZW46UWplVmJDOUZQbzliaHV4c2RncGNhNDBabkZiXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p><strong>支付行为编排</strong></p><p>其目的，是实现<code>插件式开发</code>、<code>支付规则可配置</code>的 灵活开发方式</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MDJjYTAxMzliYTExNzc1NDJiMGI5NjAxNmM0YWEzOWRfdEdwSkh1NWtzWm9naEtKdTFseVZCYktDNkRIbWNDclhfVG9rZW46RnFOYWJuZnpMbzNRMTl4Y2RheWNzM0xMbnZiXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p><strong>异常处理</strong></p><p>异常处理包括了 重复支付、部分支付、金额不一致、其他异常等异常场景。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWRhNTM4NmUzYWU0MTkyNjYyMDAzYjEyY2EzNWE4ZGFfUG5hNExqVnpoNVNGZWJzRW9KSFc0V0N2dFlFUlFKWUFfVG9rZW46Uzl3TGJ6TnF0b2VYY3B4UmZKUmM2TzFBbkdnXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h3 id="渠道网关"><a href="#渠道网关" class="headerlink" title="渠道网关"></a><strong>渠道网关</strong></h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YWY2NjM2NzNjMWFlNzVmOWU2ZmQ1NmNhMGRhMGQxYmRfU2lRN2x6em14c0NrVmRDOTY1Ym01QXZtb1ZLZDhNUkhfVG9rZW46Rk55d2JqQXM0b21MQ2Z4M1l6cGNNUW53bmtnXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h3 id="资金核算"><a href="#资金核算" class="headerlink" title="资金核算"></a><strong>资金核算</strong></h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MGVjODQxOWViNjdkYTc4ZjhkMmExNWY4ZDk0NWZlYTdfdUpPUnZaSGpZUE1sdEdSeWdDMTcyYjlkMkRvSVpjSXpfVG9rZW46TWhJeGJNYTVBbzBuak14QVJWMWN3QlZQbmRjXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h2 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a><strong>服务治理</strong></h2><h3 id="平台统一上下文"><a href="#平台统一上下文" class="headerlink" title="平台统一上下文"></a><strong>平台统一上下文</strong></h3><p>通过确定系统边界、业务建模拆分之后，整个支付平台被拆分几十个服务，而如何保障在服务间流转业务信息不被丢失，是我们需要考虑的问题。平台统一上下文的要素信息（唯一业务标识码），在整个支付平台链路中全程传递，被用来解决这个问题。</p><h3 id="数据一致性治理"><a href="#数据一致性治理" class="headerlink" title="数据一致性治理"></a><strong>数据一致性治理</strong></h3><p>大型的支付公司，内部都有非常严格和完备的数据一致性方案，比如采用业务侵入性非常大的分布式事务等，以牺牲开发效率来提升数据的稳定，是非常有必要的。而业务公司，如果不采用分布式事务又有哪些应对策略呢？</p><h4 id="CAS-校验"><a href="#CAS-校验" class="headerlink" title="CAS 校验"></a><strong>CAS 校验</strong></h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjYzZjk1NDU3NTlmZTQ0ZjVhMTQ3MWNmMzEzZWRlZGVfYmttaWxWcVZRbkpOcklONUlHQUVldDJyWmtOT05xUjRfVG9rZW46V1JOb2JCV1V3b2RHQXh4ZHR5RGM1ZFprbm1iXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h4 id="幂等-异常补偿"><a href="#幂等-异常补偿" class="headerlink" title="幂等 &amp; 异常补偿"></a><strong>幂等 &amp; 异常补偿</strong></h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MjA4NTk4MTY2YWUzZDMxNjcxZmY4Njc3NDRkZmQ4NWJfb2tOdEVvUFFTWlBRVzh1VlZ6MWI2QXVqM0VZTHZDWGdfVG9rZW46RjU2MGJSUFRCb3MxM3J4ZWdKM2MyTW5tblRiXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h4 id="对账"><a href="#对账" class="headerlink" title="对账"></a><strong>对账</strong></h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTNiZjg0NjhhYTEyNWFkNzFiMDc2ZWQ2MDQ3ZWJhMzlfaHlTOFJ2MllJdWw3S3pCOTg3U2JjYzdPdzl0YXpEZ0dfVG9rZW46Q2RnbGJHWndOb0ZuYVJ4b014c2NoSmlMbnhiXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h4 id="准实时对账"><a href="#准实时对账" class="headerlink" title="准实时对账"></a><strong>准实时对账</strong></h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjQ4ZGVlYWNkNTI4NzkxMDUxMzUzODE3NTlmNjNhNzlfbkNyWFJ1dFJlNWR2eEg1eXRxUVRKM0FWY2pDUnltTU1fVG9rZW46R2hIemJaaUNFbzlnVzJ4UjJnOGMyMDFKbjRkXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h3 id="DB-拆分"><a href="#DB-拆分" class="headerlink" title="DB 拆分"></a><strong>DB 拆分</strong></h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTBjYmI2ZmRiYWM3MGVjNGQ4YTNkNzhlOWQ0MTM0YTRfdnJMQUtkc0NlWE5YSHBaU29odm43c1NWMEhDU01PdjdfVG9rZW46SFlpSWJXNDZsb0kyUUx4ZkFkUGNIT1gzbkFnXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h3 id="异步化"><a href="#异步化" class="headerlink" title="异步化"></a><strong>异步化</strong></h3><p>支付是整个交易链路的核心环节，那么，怎么兼顾支付系统的稳定性和执行效率呢？是异步化。</p><h4 id="消息异步化"><a href="#消息异步化" class="headerlink" title="消息异步化"></a><strong>消息异步化</strong></h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MGEyMzZmNGU0ZjAzYzkzNDkzZDBiYmEzMTVmOTU3MDJfNkJUS3ZMQUJ4ak9OQWNKWEd4TnNDc2gzZjAxNW1RMHRfVG9rZW46QXNkeWJGOTVRb3UyaTB4bFdVeGNPUjhHbmdoXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h4 id="外部支付调用异步化"><a href="#外部支付调用异步化" class="headerlink" title="外部支付调用异步化"></a><strong>外部支付调用异步化</strong></h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OWEwODQxNjZkYzNhM2FlZDhjNjg3YWMxODA1MDc2M2RfQnduWDFPdGlWZUg3QTZySFlXVmgzNG5SV0xwUzM0UlNfVG9rZW46SEQxWWI5VzdSb1ZuNm54TVBDZGNxUng0bkxJXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p>这种同步调用的情况下，由于需要跨外部网络，响应的 RT 会非常长，可能会出现跨秒的情况。由于是同步调用，会阻塞整个支付链路。一旦 RT 很长且 QPS 比较大的情况下，服务会整体 hold 住，甚至会出现拒绝服务的情况。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=M2VhMjVkYmYzZmY4MTgyNWIwY2QxMDQ0YzdmOGVjYWFfa3dYRkNnWFFETmluaG1XMmkxejR4ZUltcmpDZFlaZ3BfVG9rZW46UmxGT2JTU2JLb1VsTnR4Y2FmN2NiVXhvblVoXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><p>因此，可以拆分获取凭证的操作，通过独立网关渠道前置服务，将获取的方式异步化，从前置网关获取内部凭证，然后由前置网关去异步调用第三方。</p><h4 id="异步并行化"><a href="#异步并行化" class="headerlink" title="异步并行化"></a><strong>异步并行化</strong></h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjYzNzU4ZGVlNTAwYjZhMjkwN2UyODA0YTA1NmY1YmJfSTRiTHRLM2JxSlNicUh1MTU2Umc1ZkxKYUdZQ0VuNzBfVG9rZW46UWN2ZmJ2ZTU2b0RKQmx4anA3aGNHUEpTbmxkXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h4 id="资金核算异步化"><a href="#资金核算异步化" class="headerlink" title="资金核算异步化"></a><strong>资金核算异步化</strong></h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NTkxZTkwZDlkMjg4YzgzMzIxYjE3ZmZlYzhmMjk5MDBfOGtNV2hZUjJBalVTcVR1enprZnhkRG9wR2FvNHRpTHBfVG9rZW46VklaUmJDWlRrb0hoQWF4YldxOWNSdmlxbktoXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h4 id="热点账户账务单独处理"><a href="#热点账户账务单独处理" class="headerlink" title="热点账户账务单独处理"></a><strong>热点账户账务单独处理</strong></h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NGUzYmVlNjJmNWNiNzVhYWY3ODk0YmZkYmNhMzM2MmRfWEswa3RkTnFNZTh2dktVZTNZY3BZQ05Memh4OUdsb09fVG9rZW46QlZ4U2I3R21Fb0JIY1V4Q21tZmNDS1lNbnViXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h4 id="记账事务切分"><a href="#记账事务切分" class="headerlink" title="记账事务切分"></a><strong>记账事务切分</strong></h4><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NjMwMDk1OGFlNTc3ZDg0ODhiZjliNzQ3ZGM0MjEyYjdfMVlMZFF0UXVZWmgyOWU4aGtwMW54T1dIQlhZSE1CMVBfVG9rZW46TGVzemIxYTBBbzh4Q0d4ZnZUZmM4cGwxblZjXzE3MTk4MTI1MzY6MTcxOTgxNjEzNl9WNA" alt="img"></p><h1 id="Redis中存储的value-50MB会出现什么问题-该如何解决"><a href="#Redis中存储的value-50MB会出现什么问题-该如何解决" class="headerlink" title="Redis中存储的value&gt;50MB会出现什么问题?该如何解决"></a>Redis中存储的value&gt;50MB会出现什么问题?该如何解决</h1><ol><li>内存消耗过多：Redis是一个内存数据库，大value会占用大量的内存空间，可能导致内存迅速耗尽，影响其他key-value对的存储和性能。</li><li>网络传输效率下降：当需要通过网络传输大value时，会占用更多的网络带宽和传输时间，可能号致网络延迟或拥堵。</li><li>性能下降：读取、写入或操作大value需要更多的CPU时间和内存资源，可能导致Redis的响应延迟和整体性能下降。</li><li>持久化问题：如果启用了Redis的持久化（如RDB或AOF),大value可能导致特久化操作变慢，甚至可能因磁盘空间不足而失败。</li><li>数据安全问题：在某些情况下，如果Redis实例崩渍，大value可能无法完整恢复，从而导致数据丢失或损坏。</li></ol><p>解决方案：</p><ol><li>数据拆分：将大value:拆分成多个小value进行存储。例如，可以将一个大对象拆分成多个字段或子对象，分别作为不同的key进行存储。</li><li>使用适当的数据结构：根据数据的特性选择合适的Redis数据结构，如Hash、List、Set或Sorted Set,以便更有效地存储和检索数据。</li><li>外部存储与Redisi配合：对于非常大的数据，可以考虑使用外部存储系统（如分布式文件系统、对象存储或数据库）来存储实际的数据内容，并在Redis中仅保存指向这些数据的引用或标识符。</li><li>监控与报警：设置内存使用阈值，并监控Redis实例的内存使用情况。当内存使用接近阈值时，发报警机制，以便及时采取措施避免内存耗尽。</li><li>优化持久化策略：根据实际情况调整RDB或AOF的持久化配置，如调整持久化频率、使用增量持久化等方式来减少持久化对大value的影响。</li><li>备份与恢复策略：定期备份Redis数据，并制定完善的恢复策略，以便在出现数据丢失或损坏时能够迅速恢复。</li></ol><h1 id="设计注册中心，心跳机制如何维护和考虑设计"><a href="#设计注册中心，心跳机制如何维护和考虑设计" class="headerlink" title="设计注册中心，心跳机制如何维护和考虑设计"></a>设计注册中心，心跳机制如何维护和考虑设计</h1><p>需要考虑的点：</p><p>服务注册 注册表结构设计 服务发现 服务订阅 服务推送 健康检查 集群同步：设计到数据同步，数据同步我们有哪些协议 raft 、distro、ZAB</p><p>选型</p><p>注册中心作为一个服务注册和发现的服务，必须是<strong>高可用</strong>的，所以应该是<strong>AP****模型</strong>；</p><p>1、注册中心提供节点信息的存储与扩展，使用mysql持久化，redis做缓存</p><p>2、提供权重设置，分组设置，可区分核心应用和非核心应用调用不同的分组，互不干扰</p><p>3、基于netty通过tcp协议，提供者和消费者与注册中心保持长连接</p><p>4、注册中心集群节点间可采用gossip协议维护集群节点的自动发现、转移和心跳</p><p>我们需要解决如下几个问题：</p><ul><li>服务如何注册</li><li>consumer如何知道provider</li><li>服务注册中心如何高可用</li><li>服务上下线，消费端如何动态感知</li></ul><p>服务注册</p><p>服务列表保存通常有三种方式：本地内存、数据库、第三方缓存系统注册上去后，consumer需要服务地址的时候，就可以用相应key去注册中心获取对应的服务列表。</p><p>同一个服务注册中心，我们可以注册多个服务，比如用户服务、商品服务、订单服务…</p><p>服务消费</p><p>consumer端通过key获取指定的服务地址列表。</p><p>简单来说，我们就是<strong>引用了</strong>一个第三方的服务来存放我们的服务提供者列表。并且以key-value的形式存储，key我们可以理解为服务名称，value就是服务实例列表。</p><p>注册中心高可用</p><p>高可用无非就是做<strong>集群</strong>，我们可以对注册中心部署多个节点。在消费端consumer只需要知道一个服务注册中心<strong>集群地址</strong><code>cluster-url</code>即可。</p><p>动态感知服务上下线</p><p>consumer拿到服务列表后，会把服务列表保存起来，保存到<strong>本地缓存里</strong>。</p><p>consumer通过一定的<strong>负载均衡算法</strong>，选择出一个地址，最后发起远程的调用。</p><p>如果我们的服务节点挂掉一个了，怎么办？</p><p>此时，服务注册中心的服务列表还是之前的列表，如果consumer调用到过掉的节点上，那岂不是会出问题呀。</p><p>所以，我们的服务注册中心需要知道哪个服务节点挂了，然后从对应服务列表里删除。</p><p>有种办法叫做心跳检测heartBeat，即就是服务注册中心，每隔一定时间去监测一下provider，如果监测到某个服务挂了，那就把对应服务地址从服务列表中删除。</p><p>可是不对呀，此时consumer端本地列表里还有过掉的服务地址，怎么办呢？</p><p>或者是，在增加一个新的服务节点</p><p>对于服务注册中心来说，就是服务列表里增加一个服务地址。</p><p>但是在消费端存在同样的问题，就是服务注册中心的服务列表和consumer端的服务列表不一样了。</p><p>如何让consumer端也动态感知呢？</p><p>其实很简单，此时，我们得思维换一下，因为consumer的服务列表是来自于服务注册中心，我们就可以把consumer理解为消费端，服务注册中心理解为服务端。此时，consumer端就可以去服务端（服务注册中心）拉取provider服务列表。</p><p>通常有两种方案：push和pull</p><p>push：服务注册中心主动推送服务列表给consumer。</p><p>pull：consumer主动从注册中心拉取服务列表。</p><p>不管是push还是pull，都会存在consumer和服务注册中心的<strong>通信管道</strong>。如果他们之间断开了，那就无法获取服务列表了。</p><p>还有就是服务注册中心<strong>知道consumer的地址</strong></p><p>我们的网络通信，必然会存在<strong>监听</strong>的动作。</p><p>如果服务注册中心要push到consumer，此时他们之间需要建立一个会话，所以，在服务注册中心会维护一个<strong>会话管理</strong>的模块。还有一种方式就是consumer提供一个**<code>API</code>**，这个<code>API</code>给服务注册中心进行回调。</p><p>push有个不好点，那就是服务注册中心需要维护大量的会话，而且还需要对每个会话维持一个心跳，以便知晓这些会话状态，得确保这些consumer能收到数据，</p><p>另外就是pull，pull其实就相对push就简单多了。pull和我们前面说的心跳机制是类似的，consumer端启动定时任务，每个多久拉取服务注册中心的服务列表。pull也不需要去维护大量的会话，我只需要每隔多久调用接口拉取服务列表即可。但是这里还是会存在一个问题，因为是定时去拉取，所以会存在一定的数据延迟，比如consumer刚刚拉取服务列表，但就在拉取结束的后，某个服务provider挂了，consumer就要等下次拉取才知道对应服务provider挂了。</p><p>还有一种方式long-pull，也叫<strong>长****轮询</strong>，是上面两种方案的优化方案，consumer发起拉取请求时，先把这个请求hold住，当服务注册中心有发生变化后，consumer端能立马感知。</p><p>通过上面的服务注册、服务消费、注册中心高可用以及动态感知服务的上下线，这就是我们去实现一个服务注册中心的通用模型。</p><h1 id="单核CPU，什么时候单线程任务比多线程任务更快"><a href="#单核CPU，什么时候单线程任务比多线程任务更快" class="headerlink" title="单核CPU，什么时候单线程任务比多线程任务更快"></a>单核CPU，什么时候单线程任务比多线程任务更快</h1><ol><li><strong>上下文切换开销</strong>：多线程任务需要在不同的线程之间进行上下文切换，这会产生一定的开销。如果任务是单线程的，就不需要进行上下文切换，可以减少这部分开销。</li><li><strong>线程管理开销</strong>：操作系统需要管理多个线程，包括调度、同步和通信等，这会产生额外的开销。单线程任务则不需要这些管理开销。</li><li><strong>任务性质</strong>：如果任务是计算密集型的，并且可以很好地利用CPU的计算资源，那么单线程可能比多线程更快，因为多线程需要额外的时间来处理线程间的同步和通信。</li><li><strong>I&#x2F;O****密集型任务</strong>：对于I&#x2F;O密集型任务，多线程可以提高性能，因为线程可以在等待I&#x2F;O操作完成时让其他线程运行。但如果I&#x2F;O操作非常快速或者任务主要是计算密集型的，那么单线程可能更高效。</li><li><strong>线程数量</strong>：如果线程数量超过了CPU的核心数，那么额外的线程将不会带来性能上的提升，反而可能因为线程竞争和上下文切换而导致性能下降。</li><li><strong>编程复杂性</strong>：编写和维护多线程程序通常比单线程程序要复杂得多。如果多线程程序没有正确地设计和优化，可能会导致性能问题，甚至比单线程版本更慢。</li><li><strong>锁和同步机制</strong>：多线程程序中使用的锁和同步机制可能会成为性能瓶颈。如果锁竞争严重，或者锁的使用不当，可能会导致线程阻塞，从而降低性能。</li><li><strong>任务的<strong><strong>并行</strong></strong>性</strong>：如果任务本身的并行性不高，即任务的各个部分不能很好地同时进行，那么多线程可能不会带来太大的性能提升。</li></ol><h1 id="第三方的接口没有访问到（支付），返回的过程没收到，怎么办"><a href="#第三方的接口没有访问到（支付），返回的过程没收到，怎么办" class="headerlink" title="第三方的接口没有访问到（支付），返回的过程没收到，怎么办"></a>第三方的接口没有访问到（支付），返回的过程没收到，怎么办</h1><p><strong>接口访问不到</strong></p><p>在执行第三方接口调用任务时，如果遇到程序响应迟滞直至超时，或者直接抛出诸如<code>Connection refused</code>、<code>Host is unreachable</code>、<code>SocketTimeoutException</code>之类的网络异常情况，这明确指示了无法成功建立起与目标服务器的通信连接。产生此问题的根源可能源自于多种因素，其中包括但不限于网络状况不佳、服务器尚未启动、域名解析错误或接口地址有误等。</p><p>为应对这类问题，首要步骤是自查本地网络环境是否正常。一旦确定自身网络并无故障，可行的操作之一是运用<code>ping</code>命令对目标域名进行探测，以验证域名能否被正确解析并得到响应。若域名无法解析，则可能表明对方服务器DNS配置存在问题；即使域名可以解析，但如果<code>ping</code>测试结果显示响应异常或超时，说明目标服务端存在潜在故障。在这种情况下，及时与对方的技术团队取得联系，共享诊断信息，共同协作进行问题排查是一种有效的解决策略。</p><p>此外，我们调用第三方接口还有可能遇到以下问题：</p><p><strong>接口突然没有返回数据&#x2F;数据异常</strong></p><p>原本正常的接口突然开始返回空数据，或者是返回的数据结构与预期不符，比如缺少必要的字段、数据格式错误、数据内容无效等，导致客户端无法正常解析和使用。</p><p>面对这类接口突然无响应或无法返回数据的问题，首先，我们需要从源头着手，全面核查请求参数和认证凭证的有效性。这包括仔细审查发送至接口的请求数据是否完整准确，以及确保使用的Token、Key等身份认证信息处于有效状态。同时，必须密切关注接口供应商是否有未提前公告的变更，如API版本升级、接口废弃等情况。</p><p>在代码实现层面上，为了能快速响应这类异常，我们应当对关键数据字段设置严格的监控与预警机制。例如，可以植入手动埋点并通过企业通讯工具（如钉钉消息、电子邮件提醒）实现即时告警。一旦监测到核心数据未能如期返回，系统应能立即发出警报，使开发人员能够在第一时间获知并处理此类问题，以防止其对整体业务流程造成干扰或经济损失。</p><p>以一个实际应用场景为例，当我们在上游系统中使用订单号向下游WMS系统查询出入库订单详情时，若发现特定订单号未能返回预期的订单信息，那么通过预先设定的监控和告警系统，我们将在第一时间接收到警告信息。在此基础上，应迅速与第三方系统的技术支持团队取得联系，查明原因并解决问题。同时，对于这类无法匹配的数据，应在业务流程中设立防护机制，及时拦截处理，以免对核心业务造成负面影响。</p><p><strong>接口超时&#x2F;异常，不稳定</strong></p><p>由于网络抖动，或者第三方系统不稳定，部署，服务器负载不均、并发访问量过大等等问题，可能会导致调用接口时花费的时间超出预期设定的超时时间，从而引发<code>TimeoutException</code>；或者接收到HTTP状态码表明出现异常，如<code>500 Internal Server Error</code>、<code>404 Not Found</code>等。这种坑是我们平常最容易遇见的也是最头疼的所在，因此需要我们给予足够的重视。</p><p>对于这类异常，首先我们在调用接口时设置合理的超时时间，我们以使用<code>Retrofit2</code>调用<code>http</code>接口为例，设置其请求超时时间以及读取超时时间：</p><p><strong>接口变更，版本迭代兼容性</strong></p><p>第三方系统对API进行版本升级或服务调整属于常见现象，这种情况下，原有的接口可能面临无法继续使用的问题，或者返回的数据结构、格式可能发生变动，部分接口随着版本升级可能存在不向下兼容的情况，调用旧版接口在新版环境下可能失效。针对此类状况，最佳实践是始终保持对服务提供商通告的关注，一旦得知有关更新信息，应迅速作出响应，及时调整并更新调用接口的方式。在代码层面，有必要预先设计并实现一套接口版本管理和兼容性处理机制，以确保无论接口如何演变，系统都能够平滑地适应和处理。</p><p>接口变更时，采用接口参数动态化是一种有效的应对策略，其核心理念是让客户端调用接口时具备更强的灵活性和适应性，特别是在接口新增、删除或修改参数的情况下，比如采取Map，JSON接受参数（当然不是很推荐。。。。）。</p><p>并且，对接口进行严密的异常监测同样至关重要，通过实时监控接口调用的异常状况，能够在问题发生的第一时间发现并上报。及时与第三方系统的技术支持团队沟通协调，并采取相应的补救措施，能够最大限度地减少接口变动对业务连续性的影响，确保系统稳定高效运行。</p><p><strong>API限制</strong></p><p>在一定时间段内频繁调用接口，然后突然所有请求都开始失败，返回的错误提示可能是调用频率过高、超出配额等。这是由于大多数第三方API为了防止滥用，会对调用次数、频次或流量进行限制。我们应密切关注接口文档中的调用限制说明，并在代码中采取限流措施，如设置合适的请求间隔、使用令牌桶算法或漏桶算法控制请求速度。当然也要做好接口监控告警策略。</p><p><strong>错误码定义混乱，字段结构不一致</strong></p><p>我们常常会遇到接口文档与实际错误码定义、字段结构不一致的问题，例如文档中标明错误码400代表参数错误，但实际上可能收到的是404错误响应；又或者返回的数据结构与文档描述不相吻合，这使得我们难以精准识别并恰当处理结果。针对此类问题，应当采取以下策略：</p><p>首先，构建自定义错误处理机制，创建专门的错误处理类，对所有可能出现的错误码进行统一且明确的处理。这样，无论接口返回何种错误码，都能确保有一套标准的逻辑进行响应和记录。</p><p>其次，针对那些与文档描述不符或者含义模糊不清的错误码和字段，应及时与第三方系统的技术团队展开沟通交流，明确其真实含义和用途。这样的互动有助于确保接口对接的精确性，避免因对错误码或字段理解不准确而引发的系统内部错误。</p><p>对于接口文档与实际不符的情况，一方面要通过定制化的错误处理机制增强系统的容错性与一致性，另一方面要强化与第三方系统的沟通协作，确保对接接口的清晰性和准确性，从而有效避免潜在问题对自身系统产生的不良影响。</p><p><strong>返回的<strong><strong>数据格式</strong></strong>不统一</strong></p><p>对于同一个系统，接口返回的数据格式在不同场景下可能有所差异，例如有的时候返回JSON对象，有的时候却是字符串或其他格式，例如xml等。</p><p>针对这类问题，我们需要编写包容性较强的解析逻辑，确保在任何情况下都能准确解构并处理返回数据。创建多个数据模型类对应不同格式的数据，根据接口返回的内容决定使用哪个模型类进行反序列化。针对不同的数据格式编写适配器，确保数据能统一转换为应用程序可处理的格式。</p><h1 id="如何在SpringBoot启动时执行特定代码"><a href="#如何在SpringBoot启动时执行特定代码" class="headerlink" title="如何在SpringBoot启动时执行特定代码"></a>如何在SpringBoot启动时执行特定代码</h1><ol><li><strong>监听ApplicationContext事件</strong>：通过实现<code>ApplicationListener&lt;ContextRefreshedEvent&gt;</code>接口，监听<code>ContextRefreshedEvent</code>事件，可在Spring容器初始化完成后执行初始化逻辑。这种方式适用于需要在所有Bean加载完毕后进行全局性初始化操作的场景。</li><li><strong>实现CommandLineRunner接口</strong>：Spring Boot启动后，会自动调用实现了<code>CommandLineRunner</code>接口的Bean的<code>run</code>方法，该方法可以处理命令行参数并执行启动时的特定操作。适用于需要根据命令行参数执行初始化逻辑或进行启动后一次性任务的情况。</li><li><strong>实现ApplicationRunner接口</strong>：与<code>CommandLineRunner</code>类似，<code>ApplicationRunner</code>也在Spring Boot启动后执行其<code>run</code>方法，但其参数为<code>ApplicationArguments</code>，提供了更强大的命令行参数解析功能。适合处理键值对形式的命令行参数并据此执行初始化任务。</li><li><strong>使用@PostConstruct注解</strong>：在Bean的方法上添加<code>@PostConstruct</code>注解，Spring会在该Bean的所有依赖注入完成后调用该方法进行初始化。这种方法用于单个Bean初始化完成后的特定逻辑，增强了代码的模块化和可维护性。</li><li><strong>@Bean注解中指定初始化方法</strong>：通过<code>@Bean</code>注解中的<code>initMethod</code>属性指定Bean的初始化方法，该方法在Bean实例化并完成注入后由Spring容器调用。这种方法适用于需要对特定Bean进行精细化初始化管理的场景。</li><li><strong>实现InitializingBean接口</strong>：Bean实现<code>InitializingBean</code>接口并重写<code>afterPropertiesSet</code>方法，也能实现在依赖注入完成后执行初始化逻辑。虽然传统但不如使用<code>@PostConstruct</code>注解优雅，且增加了类的耦合度。</li><li><strong>使用@EventListener注解</strong>：通过监听<code>ApplicationReadyEvent</code>等事件，可以在Spring Boot应用启动并准备就绪后执行初始化任务。这种方式延迟执行，适用于在所有Bean初始化完毕且应用已经完全启动后才需要进行的操作。</li></ol><h1 id="金额到底是用Long还是BigDecimal？"><a href="#金额到底是用Long还是BigDecimal？" class="headerlink" title="金额到底是用Long还是BigDecimal？"></a>金额到底是用Long还是BigDecimal？</h1><p><strong>排除<strong><strong>float</strong></strong>和double</strong></p><p>当然，对于金额，首先我们要排除的就是float和double。它们不适合用于精确的金融计算，因为<code>float</code>和<code>double</code>是基于IEEE 754标准的浮点数表示，它们无法精确地表示所有的十进制小数。这会导致在进行财务计算时出现舍入误差，这些误差可能会累积并导致不可预测的结果。</p><p><strong>选择Long</strong></p><p><code>Long</code>类型在Java中用于存储64位整数。它的主要优点是速度快，因为整数运算在CPU层面是非常高效的。另外，<code>Long</code>类型也占用较少的内存，并且整数类型(<code>BIGINT</code>)在数据库中占用较少的存储空间。</p><p>但是<code>Long</code>类型在处理金额时有几个明显的缺点：</p><ol><li><strong>精度问题</strong>：<code>Long</code>只能存储整数，无法直接表示小数。使用<code>Long</code>来表示以分为单位的金额（例如，100表示1元），此时就会失去小数的精度。即使使用某种方式来表示小数（例如，乘以100或10000），也会遇到舍入误差的问题。并且这种计算方式也会增加计算的复杂度。</li><li><strong>浮点数****问题</strong>：虽然这不是直接使用<code>Long</code>的问题，但如果你尝试将<code>Long</code>与浮点数（如<code>double</code>或<code>float</code>）进行转换以进行计算（比如汇率计算等），还是会遇到浮点数精度问题，这可能导致在财务计算中出现不可接受的误差。</li></ol><p>在阿里巴巴的开发手册中建议使用Long。</p><p>但是在一些金融系统当中，对小数位要求比较高的，比如精确到小数点后6位，那么我们使用Long进行存储，每次在计算时都要除以或者乘以1000000，那么计算的开销就很大了。</p><p>并且，如果在需求确认时，我们无法知道金额要求的小数位，那我们使用Long也是不行的，我们并不知道需要乘以或者除以多少个0。</p><p><strong>选择BigDecimal</strong></p><p><code>BigDecimal</code>是Java提供的一个类，用于任意精度的算术运算。它的主要优点是提供了高精度的计算，这对于金融和货币计算来说是非常重要的。<code>BigDecimal</code>可以表示任意大小的正数、负数或零，并可以精确控制舍入行为。并且在数据库中存储时也有对应的类型进行匹配，比如MySQL的<code>DECIMAL</code>类型提供了精确的数值存储，可以匹配<code>BigDecimal</code>的精度。</p><p>但是<code>BigDecimal</code>也有一些缺点：</p><ol><li><strong>性能</strong>：与<code>Long</code>相比，<code>BigDecimal</code>的性能较差。因为它的运算需要更多的内存和CPU时间。</li><li><strong>复杂性</strong>：使用<code>BigDecimal</code>进行运算比使用<code>Long</code>或基本数据类型更复杂。你需要考虑舍入模式、精度等因素。</li><li>在数据库中需要更多的存储空间来存储小数部分。</li></ol><p>而在Mysql的开发手册中，建议金额需要进行小数位计算时，存储要使用Decimal，否则我们要将金额乘以对应小数位的倍数变成BIGINT进行存储。</p><p>总结</p><p>基于上述对<code>Long</code>和<code>BigDecimal</code>的优缺点分析，我们可以得出以下结论：</p><p>在金额计算层面，即代码实现中，推荐使用<code>BigDecimal</code>进行所有与金额相关的计算。<code>BigDecimal</code>提供了高精度的数值运算，能够确保金额计算的精确性，避免了因浮点数精度问题导致的财务误差。使用<code>BigDecimal</code>可以简化代码逻辑，减少因处理精度问题而引入的复杂性。</p><p>而在数据库存储方面，我们需要根据具体需求进行权衡。如果业务需求已经明确金额只需精确到分（如某些国家&#x2F;地区的货币最小单位为分），并且我们确信不会涉及到需要更高精度的小数计算，那么可以使用<code>Long</code>类型进行存储，将金额转换为最小货币单位（如分）进行存储。这样可以节省存储空间并提高查询性能。</p><p>但是如果业务需求中金额的小数位数不确定，或者可能涉及多位小数的计算（如国际货币交易等），那么最好使用<code>DECIMAL</code>或<code>NUMERIC</code>类型进行存储。这些类型提供了精确的数值存储，可以确保数据库中的数据与应用程序中的<code>BigDecimal</code>对象保持一致，避免数据转换过程中可能引入的精度损失。</p><h1 id="记录日志功能的实现–AOP"><a href="#记录日志功能的实现–AOP" class="headerlink" title="记录日志功能的实现–AOP"></a>记录日志功能的实现–AOP</h1><p><strong>记录日志的意义：</strong></p><p>后台管理系统记录操作日志的意义非常重要，主要体现在以下几个方面：</p><p>1、安全性：操作日志可以记录管理员操作行为，以此来监控和防止管理员滥用权限或进行其他不当操作。如果后台管理系统没有记录操作日志，那么一旦出现不当操作，就无法对其进行追踪和定位，造成不可估量的安全风险。</p><p>2、追溯性：操作日志可以帮助管理员及时发现问题，并可以通过日志进行快速定位和处理。例如某个用户投诉自己的订单异常，管理员可以直接通过查询该订单的操作日志，找到问题所在并进行修改或解决。</p><p>因此，后台管理系统记录操作日志，对于维护系统的安全稳定性、保障客户数据的完整性和隐私性、提高系统及时响应和处理能力等方面具有重要意义，是保障企业正常运营和客户满意度的重要手段。</p><p><strong>日志数据表结构：</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sys_oper_log` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;日志主键&#x27;</span>,</span><br><span class="line">  `title` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;模块标题&#x27;</span>,</span><br><span class="line">  `business_type` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;业务类型（0其它 1新增 2修改 3删除）&#x27;</span>,</span><br><span class="line">  `<span class="keyword">method</span>` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;方法名称&#x27;</span>,</span><br><span class="line">  `request_method` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;请求方式&#x27;</span>,</span><br><span class="line">  `operator_type` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;操作类别（0其它 1后台用户 2手机端用户）&#x27;</span>,</span><br><span class="line">  `oper_name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;操作人员&#x27;</span>,</span><br><span class="line">  `dept_name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;部门名称&#x27;</span>,</span><br><span class="line">  `oper_url` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;请求URL&#x27;</span>,</span><br><span class="line">  `oper_ip` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;主机地址&#x27;</span>,</span><br><span class="line">  `oper_param` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;请求参数&#x27;</span>,</span><br><span class="line">  `json_result` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;返回参数&#x27;</span>,</span><br><span class="line">  `status` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;操作状态（0正常 1异常）&#x27;</span>,</span><br><span class="line">  `error_msg` <span class="type">varchar</span>(<span class="number">2000</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;错误消息&#x27;</span>,</span><br><span class="line">  `oper_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;操作时间&#x27;</span>,</span><br><span class="line">  `create_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `is_deleted` tinyint <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;删除标记（0:不可用 1:可用）&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">67</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 COMMENT<span class="operator">=</span><span class="string">&#x27;操作日志记录&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>AOP记录日志的主要优点包括：</strong></p><p>1、低侵入性：AOP记录日志不需要修改原有的业务逻辑代码，只需要新增一个切面即可。</p><p>2、统一管理：通过AOP记录日志可以将各个模块中需要记录日志的部分进行统一管理，降低了代码重复度，提高了代码可维护性和可扩展性。</p><p>3、提升效率：通过引入AOP记录日志，可以避免手动编写日志记录代码，减少了开发人员的工作量，提升了开发效率。</p><p>4、安全性：通过AOP记录日志，可以收集系统的操作日志，帮助管理员及时发现问题并进行调整，从而提高系统的安全性。</p><p><strong>AOP记录日志的整体思想</strong>：</p><p>1、基于自定义注解来确定切入点【优势：可以通过自定义注解携带一些变化的参数，比如模块名称】</p><p>2、基于环绕通知来完成日志记录</p><h2 id="切面类环境搭建"><a href="#切面类环境搭建" class="headerlink" title="切面类环境搭建"></a><strong>切面类环境搭建</strong></h2><p>新建记录日志模块，模块中引入依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">      &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="自定义Log注解"><a href="#自定义Log注解" class="headerlink" title="自定义Log注解"></a><strong>自定义Log注解</strong></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Log &#123;                <span class="comment">// 自定义操作日志记录注解</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">title</span><span class="params">()</span> ;                                                                <span class="comment">// 模块名称</span></span><br><span class="line">    <span class="keyword">public</span> OperatorType <span class="title function_">operatorType</span><span class="params">()</span> <span class="keyword">default</span> OperatorType.MANAGE;        <span class="comment">// 操作人类别</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">businessType</span><span class="params">()</span> ;     <span class="comment">// 业务类型（0其它 1新增 2修改 3删除）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSaveRequestData</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;   <span class="comment">// 是否保存请求的参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSaveResponseData</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;  <span class="comment">// 是否保存响应的参数</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>OperatorType</strong></p><p>操作人枚举类定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OperatorType</span> &#123;                <span class="comment">// 操作人类别</span></span><br><span class="line">    OTHER,                <span class="comment">// 其他</span></span><br><span class="line">    MANAGE,                <span class="comment">// 后台用户</span></span><br><span class="line">    MOBILE                <span class="comment">// 手机端用户</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LogAspect"><a href="#LogAspect" class="headerlink" title="LogAspect"></a><strong>LogAspect</strong></h2><p>定义一个切面类，并且在该切面类中提供一个环绕通知方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;            <span class="comment">// 环绕通知切面类定义</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AsyncOperLogService asyncOperLogService ;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(value = &quot;@annotation(sysLog)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doAroundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint , Log sysLog)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建前置参数</span></span><br><span class="line">        <span class="type">SysOperLog</span> <span class="variable">sysOperLog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SysOperLog</span>() ;</span><br><span class="line"></span><br><span class="line">        LogUtil.beforeHandleLog(sysLog , joinPoint , sysOperLog) ;</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            proceed = joinPoint.proceed();</span><br><span class="line">            <span class="comment">// 执行业务方法</span></span><br><span class="line">            LogUtil.afterHandlLog(sysLog , proceed , sysOperLog , <span class="number">0</span> , <span class="literal">null</span>) ;</span><br><span class="line">            <span class="comment">// 构建响应结果参数</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;                                 <span class="comment">// 代码执行进入到catch中，</span></span><br><span class="line">            <span class="comment">// 业务方法执行产生异常</span></span><br><span class="line">            e.printStackTrace();                                <span class="comment">// 打印异常信息</span></span><br><span class="line">            LogUtil.afterHandlLog(sysLog , proceed , sysOperLog , <span class="number">1</span> , e.getMessage()) ;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存日志数据</span></span><br><span class="line">        asyncOperLogService.saveSysOperLog(sysOperLog);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回执行结果</span></span><br><span class="line">        <span class="keyword">return</span> proceed ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EnableLogAspect"><a href="#EnableLogAspect" class="headerlink" title="EnableLogAspect"></a><strong>EnableLogAspect</strong></h2><p>想让LogAspect这个切面类在其他的业务服务中进行使用，那么就需要该切面类纳入到Spring容器中。Spring Boot默认会扫描和启动类所在包相同包中的bean以及子包中的bean。而LogAspect切面类不满足扫描条件，因此无法直接在业务服务中进行使用。那么此时可以通过自定义注解进行实现，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(value = LogAspect.class)</span>            <span class="comment">// 通过Import注解导入日志切面类到Spring容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableLogAspect &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SysOperLog"><a href="#SysOperLog" class="headerlink" title="SysOperLog"></a><strong>SysOperLog</strong></h2><p>定义一个与日志数据库表相对应的实体类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SysOperLog</span> <span class="keyword">extends</span> <span class="title class_">BaseEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String title;                                        <span class="comment">// 模块标题</span></span><br><span class="line">        <span class="keyword">private</span> String method;                                        <span class="comment">// 方法名称</span></span><br><span class="line">        <span class="keyword">private</span> String requestMethod;                        <span class="comment">// 请求方式</span></span><br><span class="line">        <span class="keyword">private</span> String operatorType;                        <span class="comment">// 操作类别（0其它 1后台用户 2手机端用户）</span></span><br><span class="line">    <span class="keyword">private</span> Integer businessType ;                        <span class="comment">// 业务类型（0其它 1新增 2修改 3删除）</span></span><br><span class="line">        <span class="keyword">private</span> String operName;                                <span class="comment">// 操作人员</span></span><br><span class="line">        <span class="keyword">private</span> String operUrl;                                        <span class="comment">// 请求URL</span></span><br><span class="line">        <span class="keyword">private</span> String operIp;                                        <span class="comment">// 主机地址</span></span><br><span class="line">        <span class="keyword">private</span> String operParam;                                <span class="comment">// 请求参数</span></span><br><span class="line">        <span class="keyword">private</span> String jsonResult;                                <span class="comment">// 返回参数</span></span><br><span class="line">        <span class="keyword">private</span> Integer status;                                        <span class="comment">// 操作状态（0正常 1异常）</span></span><br><span class="line">        <span class="keyword">private</span> String errorMsg;                                <span class="comment">// 错误消息</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LogAspect-1"><a href="#LogAspect-1" class="headerlink" title="LogAspect"></a><strong>LogAspect</strong></h2><p>添加工具类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作执行之后调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">afterHandlLog</span><span class="params">(Log sysLog, Object proceed,</span></span><br><span class="line"><span class="params">                                     SysOperLog sysOperLog, <span class="type">int</span> status ,</span></span><br><span class="line"><span class="params">                                     String errorMsg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sysLog.isSaveResponseData()) &#123;</span><br><span class="line">            sysOperLog.setJsonResult(JSON.toJSONString(proceed));</span><br><span class="line">        &#125;</span><br><span class="line">        sysOperLog.setStatus(status);</span><br><span class="line">        sysOperLog.setErrorMsg(errorMsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作执行之前调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">beforeHandleLog</span><span class="params">(Log sysLog,</span></span><br><span class="line"><span class="params">                                       ProceedingJoinPoint joinPoint,</span></span><br><span class="line"><span class="params">                                       SysOperLog sysOperLog)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置操作模块名称</span></span><br><span class="line">        sysOperLog.setTitle(sysLog.title());</span><br><span class="line">        sysOperLog.setOperatorType(sysLog.operatorType().name());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取目标方法信息</span></span><br><span class="line">        <span class="type">MethodSignature</span> <span class="variable">methodSignature</span> <span class="operator">=</span> (MethodSignature) joinPoint.getSignature() ;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> methodSignature.getMethod();</span><br><span class="line">        sysOperLog.setMethod(method.getDeclaringClass().getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求相关参数</span></span><br><span class="line">        <span class="type">ServletRequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> (ServletRequestAttributes)</span><br><span class="line">                RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> requestAttributes.getRequest();</span><br><span class="line">        sysOperLog.setRequestMethod(request.getMethod());</span><br><span class="line">        sysOperLog.setOperUrl(request.getRequestURI());</span><br><span class="line">        sysOperLog.setOperIp(request.getRemoteAddr());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置请求参数</span></span><br><span class="line">        <span class="keyword">if</span>(sysLog.isSaveRequestData()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">requestMethod</span> <span class="operator">=</span> sysOperLog.getRequestMethod();</span><br><span class="line">            <span class="keyword">if</span> (HttpMethod.PUT.name().equals(requestMethod) || HttpMethod.POST.name().equals(requestMethod)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">params</span> <span class="operator">=</span> Arrays.toString(joinPoint.getArgs());</span><br><span class="line">                sysOperLog.setOperParam(params);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sysOperLog.setOperName(AuthContextUtil.get().getUserName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在模块中定义保存日志数据的service接口，然后在具体的业务服务中给出实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AsyncOperLogService</span> &#123;                        <span class="comment">// 保存日志数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">saveSysOperLog</span><span class="params">(SysOperLog sysOperLog)</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncOperLogServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AsyncOperLogService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SysOperLogMapper sysOperLogMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span>      <span class="comment">// 异步执行保存日志操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveSysOperLog</span><span class="params">(SysOperLog sysOperLog)</span> &#123;</span><br><span class="line">        sysOperLogMapper.insert(sysOperLog);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：要想通过异步线程执行saveSysOperLog方法，那么此时就需要在启动类上添加**@EnableAsync**注解。</p><p>SysOperLogMapper持久层接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SysOperLogMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(SysOperLog sysOperLog)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SysOperLogMapper-xml"><a href="#SysOperLogMapper-xml" class="headerlink" title="SysOperLogMapper.xml"></a><strong>SysOperLogMapper.xml</strong></h2><ul><li>在SysOperLogMapper.xml映射文件中添加如下的SQL语句：</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.lcp.lcp.mapper.SysOperLogMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> &gt;</span></span><br><span class="line">        insert into sys_oper_log (</span><br><span class="line">            id,</span><br><span class="line">            title,</span><br><span class="line">            method,</span><br><span class="line">            request_method,</span><br><span class="line">            operator_type,</span><br><span class="line">            oper_name,</span><br><span class="line">            oper_url,</span><br><span class="line">            oper_ip,</span><br><span class="line">            oper_param,</span><br><span class="line">            json_result,</span><br><span class="line">            status,</span><br><span class="line">            error_msg</span><br><span class="line">        ) values (</span><br><span class="line">                     #&#123;id&#125;,</span><br><span class="line">                     #&#123;title&#125;,</span><br><span class="line">                     #&#123;method&#125;,</span><br><span class="line">                     #&#123;requestMethod&#125;,</span><br><span class="line">                     #&#123;operatorType&#125;,</span><br><span class="line">                     #&#123;operName&#125;,</span><br><span class="line">                     #&#123;operUrl&#125;,</span><br><span class="line">                     #&#123;operIp&#125;,</span><br><span class="line">                     #&#123;operParam&#125;,</span><br><span class="line">                     #&#123;jsonResult&#125;,</span><br><span class="line">                     #&#123;status&#125;,</span><br><span class="line">                     #&#123;errorMsg&#125;</span><br><span class="line">                 )</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="事务失效"><a href="#事务失效" class="headerlink" title="事务失效"></a>事务失效</h2><p>当我们自定义了切面类以后，如果不注意异常的处理，那么此时就会出现事务失效的情况。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Log(title = &quot;角色菜单模块&quot; , businessType = 2 )</span>                </span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAssign</span><span class="params">(AssginMenuDto assginMenuDto)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据角色的id删除其所对应的菜单数据</span></span><br><span class="line">    sysRoleMenuMapper.deleteByRoleId(assginMenuDto.getRoleId());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span> ;                <span class="comment">// 手动抛出异常</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取菜单的id</span></span><br><span class="line">    List&lt;Map&lt;String, Number&gt;&gt; menuInfo = assginMenuDto.getMenuIdList();</span><br><span class="line">    <span class="keyword">if</span>(menuInfo != <span class="literal">null</span> &amp;&amp; menuInfo.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sysRoleMenuMapper.doAssign(assginMenuDto) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：不加@Log注解事务可以进行回滚，但是加上该注解以后事务就会失效。</p><p><strong>问题分析</strong></p><p>Spring的事务控制是通过aop进行实现的，在框架底层会存在一个事务切面类，当业务方法产生异常以后，事务切面类感知到异常以后事务进行回滚。</p><p>当系统中存在多个切面类的时候，Spring框架会按照**@Order<strong>注解的值对切面进行排序，@Order的值越小优先级越高，@Order的值越大优先级越低。优先级越高的切面类越优先执行，当我们没有给切面类指定排序值的时候，我们自定义的切面类的优先级和aop切面类的优先级相同，那么此时</strong>事务切面类的优先级要高于自定义切面类**，那么切面类的执行顺序如下所示：</p><p>当在自定义切面类中对异常进行了捕获，没有将异常进行抛出，那么此时事务切面类是感知不到异常的存在，因此事务失效。</p><p><strong>问题解决</strong></p><p>解决方案一：使用@Order注解提高自定义切面类的优先级</p><p>解决方案二：在自定义切面类的catch中进行异常的抛出</p><h1 id="数据库数据批量导入es"><a href="#数据库数据批量导入es" class="headerlink" title="数据库数据批量导入es"></a>数据库数据批量导入es</h1><p>当时想的是如果项目上线的时候，肯定要把数据库中的中药材数据全部导入到es索引库中，为了以防万一，如果数据量很大，一次性导入肯定会发生OOM,所以当时我就想到可以使用线程池的方式导入，利用CountDownLatch来控制，就能避免一次性加载过多，防止内存溢出</p><p>具体流程我画成了流程图:</p><p>暂时无法在飞书文档外展示此内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApMedicineServiceImpl</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ApMedicineMapper apMedicineMapper;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestHighLevelclient client;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ARTICLE_ES_INDEX</span> <span class="operator">=</span><span class="string">&quot;app_info_article&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> PAGE_SIZE=<span class="number">2000</span>;</span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">importAll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//总条数</span></span><br><span class="line">       <span class="type">int</span> count apMedicineMapper.selectCount();</span><br><span class="line">        <span class="comment">//总页数</span></span><br><span class="line">       <span class="type">int</span> totalPagesize <span class="type">count</span> <span class="variable">PAGE_SIZE</span> <span class="operator">=</span><span class="number">0</span> count/PAGE_SIZE count/PAGE_SIZE +<span class="number">1</span>;</span><br><span class="line">       <span class="comment">//开始执行时间</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span>System.currentTimeMillis();</span><br><span class="line">       <span class="comment">//一共有多少页，就创建多少个CountDownLatch的计数</span></span><br><span class="line">       <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(totalPagesize);</span><br><span class="line">       <span class="type">int</span> fromIndex;</span><br><span class="line">       List&lt;SearchMedicineVo&gt; medicineList =<span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i&lt;totalPagesize;i++)&#123;</span><br><span class="line">           <span class="comment">//起始分页条数</span></span><br><span class="line">            fromIndex= i*PAGE_SIZE;</span><br><span class="line">           <span class="comment">//查询文章</span></span><br><span class="line">            medicineList= apMedicineMapper.LoadMedicineList(fromIndex,PAGE_SIZE);</span><br><span class="line">           <span class="comment">//创建线程，做批量插入es数据操作</span></span><br><span class="line">            <span class="type">TaskThread</span> <span class="variable">taskThread</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">TaskThread</span>(medicineList,countDownLatch);</span><br><span class="line">           <span class="comment">//执行线程</span></span><br><span class="line">            executorService.execute(taskThread);</span><br><span class="line">&#125;</span><br><span class="line">           <span class="comment">//调用await()方法，用来等待计数归零</span></span><br><span class="line">           countDownLatch.await();</span><br><span class="line">       </span><br><span class="line">           <span class="type">Long</span> <span class="variable">endTime</span> <span class="operator">=</span>System.currentTimeMillis();</span><br><span class="line">           log.info(<span class="string">&quot;es索引数据批量导入共：&#123;&#125;条，共消耗时间：&#123;&#125;秒&quot;</span>，count,(endTime-startTime)/<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TaskThread</span> implementst Runnable&#123;</span><br><span class="line">            List&lt;SearchMedicineVo&gt; medicineList;</span><br><span class="line">            CountDownLatch cdl;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">TaskThread</span><span class="params">(List&lt;SearchMedicineVo&gt; medicineList,CountDownLatch cdl)</span>&#123;</span><br><span class="line">               <span class="built_in">this</span>.medicineList =medicineList;</span><br><span class="line">               <span class="built_in">this</span>.cdl=cdl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">               <span class="comment">//批量导入</span></span><br><span class="line">               BulkRequest bulkRequest <span class="keyword">new</span> <span class="title class_">BulkRequest</span>(ARTICLE_ES_INDEX);</span><br><span class="line">               <span class="keyword">for</span> (SearchMedicineVo searchMedicineVo medicineList)&#123;</span><br><span class="line">                    bulkRequest.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>().id(searchMedicinevo.getId().tostring())</span><br><span class="line">                                   source(JSON.toJSONString(searchMedicineVo),XContentType.JSON));</span><br><span class="line">               &#125;</span><br><span class="line">                <span class="comment">//发送请求，批量添加数据到s索引库中</span></span><br><span class="line">                client.bulk(bulkRequest,Requestoptions.DEFAULT);</span><br><span class="line">               <span class="comment">//让计数减</span></span><br><span class="line">                cdl.countDown();</span><br><span class="line">            &#125;   </span><br><span class="line">         &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/%E5%BA%94%E7%94%A8/">应用</a></div><div class="post_share"><div class="social-share" data-image="/img/img02.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" title="计算机网络学习总结"><img class="cover" src="/img/img07.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络学习总结</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/01/%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%9B%9E%E9%A1%BE%E7%9F%A5%E8%AF%86/" title="在面试中回顾知识"><img class="cover" src="/img/img10.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">在面试中回顾知识</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/07/01/minio%E7%9A%84%E4%BD%BF%E7%94%A8/" title="minio的使用"><img class="cover" src="/img/img06.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-01</div><div class="title">minio的使用</div></div></a></div><div><a href="/2024/07/01/%E6%B5%85%E8%B0%88%E5%88%A9%E7%94%A8AOP%E5%AE%9E%E7%8E%B0%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD/" title="浅谈利用AOP实现记录日志功能"><img class="cover" src="/img/img12.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-01</div><div class="title">浅谈利用AOP实现记录日志功能</div></div></a></div><div><a href="/2024/07/01/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95-%E6%80%BB%E7%BB%93/" title="面试中的算法-总结"><img class="cover" src="/img/img10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-01</div><div class="title">面试中的算法-总结</div></div></a></div><div><a href="/2024/07/01/%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%9B%9E%E9%A1%BE%E7%9F%A5%E8%AF%86/" title="在面试中回顾知识"><img class="cover" src="/img/img10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-01</div><div class="title">在面试中回顾知识</div></div></a></div><div><a href="/2024/07/01/%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0Spring%E6%BA%90%E7%A0%81/" title="记录学习Spring源码"><img class="cover" src="/img/img02.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-01</div><div class="title">记录学习Spring源码</div></div></a></div><div><a href="/2024/07/01/VUE3%E5%AD%A6%E4%B9%A0/" title="VUE3学习总结"><img class="cover" src="/img/img12.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-01</div><div class="title">VUE3学习总结</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">李从浦</div><div class="author-info__description">志不强者智不达，言不信者行不果</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/licongpu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/licongpu" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="mailto:2816863923@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a><a class="social-icon" href="https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e" target="_blank" title="飞书"><i class="fa-sharp fa-solid fa-bookmark" style="color:#4a7dbe"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">一起学习,共同进步</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E7%99%BB%E5%BD%95%E5%B9%B6%E8%A7%A3%E5%86%B3%E7%99%BB%E9%99%86%E7%8A%B6%E6%80%81%E5%88%B7%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82"><span class="toc-number">1.</span> <span class="toc-text">基于Redis实现短信验证码的登录并解决登陆状态刷新的问题。</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E8%AE%BE%E8%AE%A1key%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 设计key的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E8%AE%BE%E8%AE%A1%E6%95%B4%E4%BD%93%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 设计整体访问流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E8%A7%A3%E5%86%B3%E7%8A%B6%E6%80%81%E7%99%BB%E5%BD%95%E5%88%B7%E6%96%B0%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 解决状态登录刷新问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mongodb%E5%AE%9E%E7%8E%B0%E8%AF%84%E8%AE%BA%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">2.</span> <span class="toc-text">Mongodb实现评论的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">表结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E6%8A%80%E6%9C%AFSpringDataMongoDB"><span class="toc-number">2.2.</span> <span class="toc-text">2.使用技术SpringDataMongoDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%90%AD%E5%BB%BA%E5%B7%A5%E7%A8%8B-pom-xml%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96%EF%BC%9A"><span class="toc-number">2.3.</span> <span class="toc-text">3.搭建工程,pom.xml引入依赖：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-application-yml%E4%B8%AD%E9%85%8D%E7%BD%AEmongodb"><span class="toc-number">2.4.</span> <span class="toc-text">4.application.yml中配置mongodb</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%96%87%E7%AB%A0%E8%AF%84%E8%AE%BA%E5%AE%9E%E4%BD%93%E7%B1%BB%E7%9A%84%E7%BC%96%E5%86%99-%E6%A0%B9%E6%8D%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%94%9F%E6%88%90"><span class="toc-number">2.5.</span> <span class="toc-text">5.文章评论实体类的编写(根据数据库表生成)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%B8%BA%E5%90%88%E9%80%82%E5%AD%97%E6%AE%B5%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">2.6.</span> <span class="toc-text">6.为合适字段建立索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%88%9B%E5%BB%BAcontroller%E3%80%81sevice%E3%80%81mapper%E5%B1%82"><span class="toc-number">2.7.</span> <span class="toc-text">7.创建controller、sevice、mapper层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%A0%B9%E6%8D%AE%E4%B8%8A%E7%BA%A7ID%E6%9F%A5%E8%AF%A2%E5%86%85%E6%8E%A8%E8%AF%84%E8%AE%BA%E7%9A%84%E5%88%86%E9%A1%B5%E5%88%97%E8%A1%A8"><span class="toc-number">2.8.</span> <span class="toc-text">8.根据上级ID查询内推评论的分页列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CommentRepository%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="toc-number">2.8.1.</span> <span class="toc-text">CommentRepository新增方法定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CommentService%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95"><span class="toc-number">2.8.2.</span> <span class="toc-text">CommentService新增方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-MongoTemplate%E5%AE%9E%E7%8E%B0%E8%AF%84%E8%AE%BA%E7%82%B9%E8%B5%9E"><span class="toc-number">2.9.</span> <span class="toc-text">9.MongoTemplate实现评论点赞</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%B0%E8%B1%A1%E6%9C%80%E6%B7%B1-%E8%A7%A3%E5%86%B3%E6%B7%B1%E5%88%86%E9%A1%B5%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">印象最深-解决深分页问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%87%E7%94%A8CompletableFuture%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%B1%87%E6%80%BB"><span class="toc-number">4.</span> <span class="toc-text">采用CompletableFuture异步编程实现数据汇总</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ESpring-Task%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%9C%9F%E6%B8%85%E7%90%86%E5%9B%9E%E8%AE%BF%E9%97%AE%E5%8D%B7%E6%95%B0%E6%8D%AE"><span class="toc-number">5.</span> <span class="toc-text">基于Spring Task定时任务调度实现定期清理回访问卷数据</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%A4%84%E7%90%86%E8%B6%85%E6%97%B6%E9%97%AE%E5%8D%B7"><span class="toc-number">5.1.</span> <span class="toc-text">5.1. 处理超时问卷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%AF%8F%E5%A4%A9%E5%87%8C%E6%99%A8%E8%A7%A6%E5%8F%91%E4%B8%80%E6%AC%A1%E6%B8%85%E7%90%86%E4%B8%80%E7%9B%B4%E5%A4%84%E4%BA%8E%E6%9C%AA%E5%8F%91%E5%B8%83%E7%8A%B6%E6%80%81%E7%9A%84%E9%97%AE%E5%8D%B7"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 每天凌晨触发一次清理一直处于未发布状态的问卷</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ESpringData-Elasticsearch%E6%93%8D%E7%BA%B5Elasticsearch%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%A3%80%E7%B4%A2%E4%B8%AD%E8%8D%AF%E6%9D%90sku%E4%BF%A1%E6%81%AF%E3%80%81%E7%83%AD%E9%94%80%E8%8D%AF%E6%9D%90"><span class="toc-number">6.</span> <span class="toc-text">基于SpringData Elasticsearch操纵Elasticsearch的实现检索中药材sku信息、热销药材</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedisson%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%94%9F%E6%88%90%E8%AE%A2%E5%8D%95%EF%BC%8C%E9%94%81%E5%AE%9A%E5%BA%93%E5%AD%98"><span class="toc-number">7.</span> <span class="toc-text">基于Redisson的分布式锁生成订单，锁定库存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERabbitMQ%E5%AE%9E%E7%8E%B0%E4%B8%AD%E8%8D%AF%E6%9D%90%E4%B8%8A%E4%B8%8B%E6%9E%B6%E3%80%81%E7%94%9F%E6%88%90%E8%AE%A2%E5%8D%95%E5%AE%8C%E6%88%90%EF%BC%8C%E5%88%A0%E9%99%A4%E9%87%87%E8%B4%AD%E8%BD%A6%E6%95%B0%E6%8D%AE%E3%80%81%E6%94%AF%E4%BB%98%E5%AE%8C%E6%88%90%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%9B%B4%E6%96%B0%E8%AE%A2%E5%8D%95%E7%8A%B6%E6%80%81%E5%92%8C%E6%89%A3%E5%87%8F%E5%BA%93%E5%AD%98%E7%AD%89%E3%80%82"><span class="toc-number">8.</span> <span class="toc-text">基于RabbitMQ实现中药材上下架、生成订单完成，删除采购车数据、支付完成之后，更新订单状态和扣减库存等。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%AB%E7%A0%81%E7%99%BB%E5%BD%95%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">扫码登录到底是怎么实现的？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E8%87%AA%E5%8A%A8%E5%8F%96%E6%B6%88%E5%8A%9F%E8%83%BD%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1"><span class="toc-number">10.</span> <span class="toc-text">订单超时自动取消功能如何设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89"><span class="toc-number">11.</span> <span class="toc-text">项目中如何保证的接口幂等</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E4%B8%AD%E7%9A%84%E5%B7%B2%E8%AF%BB%E6%B6%88%E6%81%AF%E5%92%8C%E6%9C%AA%E8%AF%BB%E6%B6%88%E6%81%AF%E8%AE%BE%E8%AE%A1"><span class="toc-number">12.</span> <span class="toc-text">消息推送中的已读消息和未读消息设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF%EF%BC%9F%E5%AE%83%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">13.</span> <span class="toc-text">布隆过滤器到底是什么东西？它有什么用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%9A%E5%91%98%E6%89%B9%E9%87%8F%E8%BF%87%E6%9C%9F%E7%9A%84%E6%96%B9%E6%A1%88%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">会员批量过期的方案怎么实现？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95"><span class="toc-number">15.</span> <span class="toc-text">日常开发中常见的限流算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7-Hash-%E7%AE%97%E6%B3%95%E5%87%BA%E7%8E%B0%E7%9A%84%E5%9C%BA%E6%99%AF%E5%92%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">16.</span> <span class="toc-text">一致性 Hash 算法出现的场景和如何解决</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F"><span class="toc-number">17.</span> <span class="toc-text">设计一个秒杀系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="toc-number">17.1.</span> <span class="toc-text">如何提高性能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-number">17.2.</span> <span class="toc-text">热点数据处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B0"><span class="toc-number">17.3.</span> <span class="toc-text">流量削峰</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-number">17.4.</span> <span class="toc-text">如何保持一致性？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E6%89%A3%E5%BA%93%E5%AD%98%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90"><span class="toc-number">17.4.1.</span> <span class="toc-text">减扣库存方案分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%87%8F%E6%89%A3%E5%BA%93%E5%AD%98%EF%BC%9F"><span class="toc-number">17.4.2.</span> <span class="toc-text">如何减扣库存？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%EF%BC%9F"><span class="toc-number">17.5.</span> <span class="toc-text">如何实现高可用性？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7"><span class="toc-number">17.5.1.</span> <span class="toc-text">服务降级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81"><span class="toc-number">17.5.2.</span> <span class="toc-text">服务限流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%92%E7%BB%9D%E8%AF%B7%E6%B1%82"><span class="toc-number">17.5.3.</span> <span class="toc-text">拒绝请求</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8-2G-%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%8C%E6%89%BE%E5%87%BA%E9%AB%98%E9%A2%91-top100-%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="toc-number">18.</span> <span class="toc-text">在 2G 大小的文件中，找出高频 top100 的单词</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%8F%91%E7%BA%A2%E5%8C%85%E7%9A%84API"><span class="toc-number">19.</span> <span class="toc-text">设计一个发红包的API</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%99%BB%E5%BD%95%E6%8B%89%E9%BB%91%E5%8A%9F%E8%83%BD%EF%BC%8C%E7%BB%99%E4%BD%A0%E4%B8%80%E6%89%B9%E8%A6%81%E6%8B%89%E9%BB%91%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E6%89%8B%E6%9C%BA%E5%8F%B7%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%8B%89%E9%BB%91%E5%92%8C%E6%8A%8A%E5%B7%B2%E7%BB%8F%E7%99%BB%E9%99%86%E7%9A%84%E8%A2%AB%E6%8B%89%E9%BB%91%E7%9A%84%E7%94%A8%E6%88%B7%E8%B8%A2%E4%B8%8B%E7%BA%BF%E3%80%82"><span class="toc-number">20.</span> <span class="toc-text">实现一个登录拉黑功能，给你一批要拉黑的用户名和手机号，实现拉黑和把已经登陆的被拉黑的用户踢下线。</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%BB%91%E5%90%8D%E5%8D%95%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1"><span class="toc-number">20.1.</span> <span class="toc-text">1. 黑名单数据模型设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%BB%91%E5%90%8D%E5%8D%95%E7%AE%A1%E7%90%86%E6%8E%A5%E5%8F%A3"><span class="toc-number">20.2.</span> <span class="toc-text">2. 黑名单管理接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E6%8B%A6%E6%88%AA"><span class="toc-number">20.3.</span> <span class="toc-text">3. 用户认证拦截</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%9C%A8%E7%BA%BF%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86"><span class="toc-number">20.4.</span> <span class="toc-text">4. 在线用户管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8WebSocket"><span class="toc-number">20.4.1.</span> <span class="toc-text">使用WebSocket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BD%AE%E8%AF%A2"><span class="toc-number">20.4.2.</span> <span class="toc-text">使用轮询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%94%A8%E6%88%B7%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86"><span class="toc-number">20.5.</span> <span class="toc-text">5. 用户会话管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8"><span class="toc-number">20.6.</span> <span class="toc-text">6. 事件驱动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%89%8D%E7%AB%AF%E4%BA%A4%E4%BA%92"><span class="toc-number">20.7.</span> <span class="toc-text">7. 前端交互</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%AE%89%E5%85%A8%E6%80%A7%E8%80%83%E8%99%91"><span class="toc-number">20.8.</span> <span class="toc-text">8. 安全性考虑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">20.9.</span> <span class="toc-text">9. 性能优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%B5%8B%E8%AF%95"><span class="toc-number">20.10.</span> <span class="toc-text">10. 测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%89%8B%E6%9C%BA%E5%8F%B7%E6%98%AF%E5%90%A6%E4%B8%BA%E6%96%B0%E7%94%A8%E6%88%B7"><span class="toc-number">21.</span> <span class="toc-text">怎么判断一个手机号是否为新用户</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2"><span class="toc-number">21.1.</span> <span class="toc-text">1. 数据库查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BC%93%E5%AD%98%E6%A3%80%E6%9F%A5"><span class="toc-number">21.2.</span> <span class="toc-text">2. 缓存检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%A3%E5%88%97%E9%9B%86%E5%90%88"><span class="toc-number">21.3.</span> <span class="toc-text">3. 散列集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%BC%82%E6%AD%A5%E6%A3%80%E6%9F%A5"><span class="toc-number">21.4.</span> <span class="toc-text">4. 异步检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%89%B9%E9%87%8F%E6%A3%80%E6%9F%A5"><span class="toc-number">21.5.</span> <span class="toc-text">5. 批量检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%88%A9%E7%94%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">21.6.</span> <span class="toc-text">6. 利用分布式系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%80%83%E8%99%91%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">21.7.</span> <span class="toc-text">7. 考虑数据一致性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B3%E5%8F%B0%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%A5%BD%E5%87%A0%E4%B8%AA%E4%B8%9A%E5%8A%A1%E7%BA%BF%EF%BC%8C%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E4%B8%9A%E5%8A%A1%E7%BA%BF%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%BF%87%E5%A4%9A%EF%BC%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%A7%AF%E5%8E%8B%E5%A4%A7%E9%87%8F%E6%B6%88%E6%81%AF%EF%BC%8C%E5%8E%BB%E5%8F%AA%E6%83%B3%E4%BB%BB%E5%8A%A1%E6%97%B6%E5%A4%A7%E9%87%8F%E6%93%8D%E4%BD%9C%E5%9C%A8A%E4%B8%9A%E5%8A%A1%E9%87%8C%E9%9D%A2%E8%8E%B7%E5%8F%96%EF%BC%8C%E8%AF%BB%E5%8F%96%E6%B6%88%E6%81%AF%E8%A6%81%E5%BE%88%E4%B9%85%EF%BC%8C%E5%AF%BC%E8%87%B4%E5%85%B6%E4%BB%96%E4%B8%9A%E5%8A%A1%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%A4%84%E7%90%86"><span class="toc-number">22.</span> <span class="toc-text">平台系统，好几个业务线，其中一个业务线消息生产过多，消息队列积压大量消息，去只想任务时大量操作在A业务里面获取，读取消息要很久，导致其他业务不能使用，如何快速处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E5%9E%8BExcel%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%A3%E6%9E%90%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="toc-number">23.</span> <span class="toc-text">大型Excel上传到服务器解析到数据库的系统设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#wx%E5%8A%A0%E5%A5%BD%E5%8F%8B%E6%80%8E%E4%B9%88%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5%E5%88%B0%E5%A5%BD%E5%8F%8B%E5%88%97%E8%A1%A8"><span class="toc-number">24.</span> <span class="toc-text">wx加好友怎么实时同步到好友列表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#wx%E5%A4%B4%E5%83%8F%E6%9B%B4%E6%8D%A2%E6%80%8E%E4%B9%88%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E7%BB%99%E6%89%80%E6%9C%89%E5%A5%BD%E5%8F%8B"><span class="toc-number">25.</span> <span class="toc-text">wx头像更换怎么实时同步更新给所有好友</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#wx%E4%B8%8D%E5%90%8C%E8%AE%BE%E5%A4%87%E7%99%BB%E5%BD%95%E6%80%8E%E4%B9%88%E4%BF%9D%E6%8C%81%E6%B6%88%E6%81%AF%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">26.</span> <span class="toc-text">wx不同设备登录怎么保持消息一致性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%BF%E4%B8%80%E4%B8%AA%E8%BA%AB%E4%BB%BD%E4%BF%A1%E6%81%AF%E5%8E%BB%E8%AF%B7%E6%B1%82%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%90%8C%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%A7%AF%E5%88%86%E6%8E%A5%E5%8F%A3%EF%BC%8C%E9%9C%80%E8%A6%81%E5%BF%AB%E9%80%9F%E6%B1%82%E5%87%BA%E5%B9%B3%E5%9D%87%E7%A7%AF%E5%88%86%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">拿一个身份信息去请求多个不同服务的积分接口，需要快速求出平均积分，如何实现？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%B2%E6%B2%89%E8%BF%B7%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E7%99%BB%E5%BD%95%E7%9A%84%E6%A8%A1%E6%8B%9F"><span class="toc-number">28.</span> <span class="toc-text">防沉迷系统时间登录的模拟</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%B0%E5%9C%A8%E6%9C%89%E4%B8%80%E4%B8%AA%E4%BA%A4%E6%98%93%E6%80%A7%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E6%97%A5%E5%A2%9E%E9%95%BF%E9%87%8F%E5%8F%AF%E8%83%BD%E8%BE%BE%E5%88%B0%E5%8D%83%E4%B8%87%E7%BA%A7%E5%88%AB%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BA%A4%E6%98%93%E5%AE%8C%E6%88%90%E5%90%8E%E6%95%B0%E6%8D%AE%E5%B0%B1%E4%B8%8D%E4%BC%9A%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E4%BA%86%EF%BC%8C%E4%BD%86%E6%98%AF%E4%BC%9A%E9%A2%91%E7%B9%81%E5%9C%B0%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%AF%B7%E9%92%88%E5%AF%B9%E8%BF%99%E4%B8%AA%E5%9C%BA%E6%99%AF%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%92%8C%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%BB%99%E5%87%BA%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE"><span class="toc-number">29.</span> <span class="toc-text">现在有一个交易性的数据，日增长量可能达到千万级别的数据，交易完成后数据就不会发生变化了，但是会频繁地查询数据，请针对这个场景对数据库的设计和表的设计给出一些建议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%B6%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84CPU%E4%BD%BF%E7%94%A8%E7%8E%87%E9%9D%9E%E5%B8%B8%E9%AB%98%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">30.</span> <span class="toc-text">在使用数据库时，数据库的CPU使用率非常高，如何排查这个问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0b%E7%AB%99%E5%BC%B9%E5%B9%95%E8%AE%BE%E8%AE%A1"><span class="toc-number">31.</span> <span class="toc-text">实现b站弹幕设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8C%E4%B8%A4%E6%9D%A1%E6%B6%88%E6%81%AF%E4%B8%8D%E5%90%8Ctopic-%E4%B8%8D%E5%90%8C%E6%97%B6%E9%97%B4%E5%88%B0%E8%BE%BE%EF%BC%8C%E5%B0%86%E4%B8%A4%E6%9D%A1%E6%B6%88%E6%81%AF%E5%85%B3%E8%81%94%E8%B5%B7%E6%9D%A5%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">32.</span> <span class="toc-text">消息队列，两条消息不同topic,不同时间到达，将两条消息关联起来，如何实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E8%A1%A8%E5%9C%A8%E4%B8%8D%E6%B7%BB%E5%8A%A0%E5%AD%97%E6%AE%B5%EF%BC%8C%E4%B8%8D%E6%94%B9%E5%8A%A8%E8%A1%A8%E7%BB%93%E6%9E%84%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E6%80%8E%E4%B9%88%E5%A2%9E%E5%8A%A0%E6%96%B0%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">33.</span> <span class="toc-text">一个表在不添加字段，不改动表结构的情况下，怎么增加新的属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%B4%AF%E5%85%85%E5%A5%96%E5%8A%B1%E7%B3%BB%E7%BB%9F"><span class="toc-number">34.</span> <span class="toc-text">设计一个累充奖励系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%99%BE%E4%B8%87%E7%BA%A7%E5%88%AB%E4%BB%A5%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%A0%E9%99%A4%E7%9A%84"><span class="toc-number">35.</span> <span class="toc-text">百万级别以上的数据是怎么删除的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E4%BA%BA%E8%B0%83%E7%94%A8%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9F%90%E4%B8%80%E4%B8%AA%E4%BA%BA%E7%9A%84%E8%AF%B7%E6%B1%82%E5%8F%91%E7%94%9F%E4%BA%86%E9%94%99%E8%AF%AF%EF%BC%8C%E5%A6%82%E4%BD%95%E5%85%B7%E4%BD%93%E5%AE%9A%E4%BD%8D%E5%88%B0%E5%93%AA%E4%B8%AA%E4%BA%BA%E7%9A%84%E8%B0%83%E7%94%A8%E5%87%BA%E7%8E%B0%E4%BA%86%E9%94%99%E8%AF%AF"><span class="toc-number">36.</span> <span class="toc-text">多人调用请求，如果某一个人的请求发生了错误，如何具体定位到哪个人的调用出现了错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E8%AF%A5%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1"><span class="toc-number">37.</span> <span class="toc-text">支付系统该如何设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E6%80%BB%E8%A7%88"><span class="toc-number">37.1.</span> <span class="toc-text">支付系统总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%B3%BB%E7%BB%9F%E8%A7%A3%E6%9E%90"><span class="toc-number">37.2.</span> <span class="toc-text">核心系统解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%98%93%E6%A0%B8%E5%BF%83"><span class="toc-number">37.2.1.</span> <span class="toc-text">交易核心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E4%BB%98%E6%A0%B8%E5%BF%83"><span class="toc-number">37.2.2.</span> <span class="toc-text">支付核心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%A0%E9%81%93%E7%BD%91%E5%85%B3"><span class="toc-number">37.2.3.</span> <span class="toc-text">渠道网关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E9%87%91%E6%A0%B8%E7%AE%97"><span class="toc-number">37.2.4.</span> <span class="toc-text">资金核算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86"><span class="toc-number">37.3.</span> <span class="toc-text">服务治理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E5%8F%B0%E7%BB%9F%E4%B8%80%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">37.3.1.</span> <span class="toc-text">平台统一上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E6%B2%BB%E7%90%86"><span class="toc-number">37.3.2.</span> <span class="toc-text">数据一致性治理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS-%E6%A0%A1%E9%AA%8C"><span class="toc-number">37.3.2.1.</span> <span class="toc-text">CAS 校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%82%E7%AD%89-%E5%BC%82%E5%B8%B8%E8%A1%A5%E5%81%BF"><span class="toc-number">37.3.2.2.</span> <span class="toc-text">幂等 &amp; 异常补偿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B4%A6"><span class="toc-number">37.3.2.3.</span> <span class="toc-text">对账</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%AE%9E%E6%97%B6%E5%AF%B9%E8%B4%A6"><span class="toc-number">37.3.2.4.</span> <span class="toc-text">准实时对账</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DB-%E6%8B%86%E5%88%86"><span class="toc-number">37.3.3.</span> <span class="toc-text">DB 拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%8C%96"><span class="toc-number">37.3.4.</span> <span class="toc-text">异步化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%BC%82%E6%AD%A5%E5%8C%96"><span class="toc-number">37.3.4.1.</span> <span class="toc-text">消息异步化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%94%AF%E4%BB%98%E8%B0%83%E7%94%A8%E5%BC%82%E6%AD%A5%E5%8C%96"><span class="toc-number">37.3.4.2.</span> <span class="toc-text">外部支付调用异步化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%B9%B6%E8%A1%8C%E5%8C%96"><span class="toc-number">37.3.4.3.</span> <span class="toc-text">异步并行化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E9%87%91%E6%A0%B8%E7%AE%97%E5%BC%82%E6%AD%A5%E5%8C%96"><span class="toc-number">37.3.4.4.</span> <span class="toc-text">资金核算异步化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%83%AD%E7%82%B9%E8%B4%A6%E6%88%B7%E8%B4%A6%E5%8A%A1%E5%8D%95%E7%8B%AC%E5%A4%84%E7%90%86"><span class="toc-number">37.3.4.5.</span> <span class="toc-text">热点账户账务单独处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E8%B4%A6%E4%BA%8B%E5%8A%A1%E5%88%87%E5%88%86"><span class="toc-number">37.3.4.6.</span> <span class="toc-text">记账事务切分</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84value-50MB%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98-%E8%AF%A5%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">38.</span> <span class="toc-text">Redis中存储的value&gt;50MB会出现什么问题?该如何解决</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%EF%BC%8C%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E5%A6%82%E4%BD%95%E7%BB%B4%E6%8A%A4%E5%92%8C%E8%80%83%E8%99%91%E8%AE%BE%E8%AE%A1"><span class="toc-number">39.</span> <span class="toc-text">设计注册中心，心跳机制如何维护和考虑设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E6%A0%B8CPU%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%BB%BB%E5%8A%A1%E6%AF%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%BB%E5%8A%A1%E6%9B%B4%E5%BF%AB"><span class="toc-number">40.</span> <span class="toc-text">单核CPU，什么时候单线程任务比多线程任务更快</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%B2%A1%E6%9C%89%E8%AE%BF%E9%97%AE%E5%88%B0%EF%BC%88%E6%94%AF%E4%BB%98%EF%BC%89%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%9A%84%E8%BF%87%E7%A8%8B%E6%B2%A1%E6%94%B6%E5%88%B0%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">41.</span> <span class="toc-text">第三方的接口没有访问到（支付），返回的过程没收到，怎么办</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8SpringBoot%E5%90%AF%E5%8A%A8%E6%97%B6%E6%89%A7%E8%A1%8C%E7%89%B9%E5%AE%9A%E4%BB%A3%E7%A0%81"><span class="toc-number">42.</span> <span class="toc-text">如何在SpringBoot启动时执行特定代码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%91%E9%A2%9D%E5%88%B0%E5%BA%95%E6%98%AF%E7%94%A8Long%E8%BF%98%E6%98%AFBigDecimal%EF%BC%9F"><span class="toc-number">43.</span> <span class="toc-text">金额到底是用Long还是BigDecimal？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%E2%80%93AOP"><span class="toc-number">44.</span> <span class="toc-text">记录日志功能的实现–AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E9%9D%A2%E7%B1%BB%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">44.1.</span> <span class="toc-text">切面类环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Log%E6%B3%A8%E8%A7%A3"><span class="toc-number">44.2.</span> <span class="toc-text">自定义Log注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LogAspect"><span class="toc-number">44.3.</span> <span class="toc-text">LogAspect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EnableLogAspect"><span class="toc-number">44.4.</span> <span class="toc-text">EnableLogAspect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SysOperLog"><span class="toc-number">44.5.</span> <span class="toc-text">SysOperLog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LogAspect-1"><span class="toc-number">44.6.</span> <span class="toc-text">LogAspect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SysOperLogMapper-xml"><span class="toc-number">44.7.</span> <span class="toc-text">SysOperLogMapper.xml</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88"><span class="toc-number">44.8.</span> <span class="toc-text">事务失效</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E6%89%B9%E9%87%8F%E5%AF%BC%E5%85%A5es"><span class="toc-number">45.</span> <span class="toc-text">数据库数据批量导入es</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/07/01/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1/" title="网络规划与设计"><img src="/img/img04.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="网络规划与设计"></a><div class="content"><a class="title" href="/2024/07/01/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1/" title="网络规划与设计">网络规划与设计</a><time datetime="2024-07-01T07:57:05.362Z" title="发表于 2024-07-01 15:57:05">2024-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/01/%E5%8C%BB%E5%AD%A6%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/" title="医学数据分析与挖掘"><img src="/img/img09.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="医学数据分析与挖掘"></a><div class="content"><a class="title" href="/2024/07/01/%E5%8C%BB%E5%AD%A6%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/" title="医学数据分析与挖掘">医学数据分析与挖掘</a><time datetime="2024-07-01T07:54:38.223Z" title="发表于 2024-07-01 15:54:38">2024-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/01/%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%9B%9E%E9%A1%BE%E7%9F%A5%E8%AF%86/" title="在面试中回顾知识"><img src="/img/img10.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="在面试中回顾知识"></a><div class="content"><a class="title" href="/2024/07/01/%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%9B%9E%E9%A1%BE%E7%9F%A5%E8%AF%86/" title="在面试中回顾知识">在面试中回顾知识</a><time datetime="2024-07-01T05:45:06.774Z" title="发表于 2024-07-01 13:45:06">2024-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/01/%E5%9C%A8%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%BA%94%E5%AF%B9%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/" title="在日常开发遇到的不同场景下的应对思路总结"><img src="/img/img02.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="在日常开发遇到的不同场景下的应对思路总结"></a><div class="content"><a class="title" href="/2024/07/01/%E5%9C%A8%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%BA%94%E5%AF%B9%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/" title="在日常开发遇到的不同场景下的应对思路总结">在日常开发遇到的不同场景下的应对思路总结</a><time datetime="2024-07-01T05:39:45.572Z" title="发表于 2024-07-01 13:39:45">2024-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" title="计算机网络学习总结"><img src="/img/img07.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="计算机网络学习总结"></a><div class="content"><a class="title" href="/2024/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" title="计算机网络学习总结">计算机网络学习总结</a><time datetime="2024-07-01T05:38:15.217Z" title="发表于 2024-07-01 13:38:15">2024-07-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 李从浦</div><div class="footer_custom_text">欢迎使用我的博客,期待一同进步</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="true" data-text="懒,羊,羊,大,王,的,博,客" data-fontsize="15px" data-random="false" async></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(btf.removeGlobalFnEvent("pjax"),btf.removeGlobalFnEvent("themeChange"),document.getElementById("rightside").classList.remove("rightside-show"),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>