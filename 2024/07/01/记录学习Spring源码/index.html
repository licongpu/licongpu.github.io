<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>记录学习Spring源码 | 青山入我怀</title><meta name="author" content="李从浦"><meta name="copyright" content="李从浦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="因为Spring源码这个东西实在是太难学了，学了忘，忘了学，反反复复，还有很多晦涩难懂的东西，甚至现在我感觉仍然是入门，只能说是把每节课学到的东西给记录一下，将来能多次回顾。笔记参考视频-黑马程序员 这几篇老文章都是我之前用飞书云文档写的，因转换格式问题，本文之前已写完的文档图片太多了，不想一一转化了，大家可以访问我的飞书云文档来查看这些图片–https:&#x2F;&#x2F;miu7shl031o.feishu."><meta property="og:type" content="article"><meta property="og:title" content="记录学习Spring源码"><meta property="og:url" content="http://licongpu.github.io/2024/07/01/%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0Spring%E6%BA%90%E7%A0%81/index.html"><meta property="og:site_name" content="青山入我怀"><meta property="og:description" content="因为Spring源码这个东西实在是太难学了，学了忘，忘了学，反反复复，还有很多晦涩难懂的东西，甚至现在我感觉仍然是入门，只能说是把每节课学到的东西给记录一下，将来能多次回顾。笔记参考视频-黑马程序员 这几篇老文章都是我之前用飞书云文档写的，因转换格式问题，本文之前已写完的文档图片太多了，不想一一转化了，大家可以访问我的飞书云文档来查看这些图片–https:&#x2F;&#x2F;miu7shl031o.feishu."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://licongpu.github.io/img/img11.jpg"><meta property="article:published_time" content="2024-07-01T05:13:06.904Z"><meta property="article:modified_time" content="2024-07-02T13:01:38.190Z"><meta property="article:author" content="李从浦"><meta property="article:tag" content="JAVA"><meta property="article:tag" content="Spring"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://licongpu.github.io/img/img11.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://licongpu.github.io/2024/07/01/%E8%AE%B0%E5%BD%95%E5%AD%A6%E4%B9%A0Spring%E6%BA%90%E7%A0%81/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:50},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体中文",cht_to_chs:"你已切换为简体中文",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#a29bfe",bgDark:"#7f8fa6",position:"bottom-left"},infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"记录学习Spring源码",isPost:!0,isHome:!1,isHighlightShrink:!0,isToc:!0,postUpdate:"2024-07-02 21:01:38"}</script><script>(e=>{e.saveToLocal={set:(e,t,o)=>{if(0===o)return;const a={value:t,expiry:Date.now()+864e5*o};localStorage.setItem(e,JSON.stringify(a))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!(Date.now()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=(e,t={})=>new Promise(((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},Object.keys(t).forEach((e=>{n.setAttribute(e,t[e])})),document.head.appendChild(n)})),e.getCSS=(e,t=!1)=>new Promise(((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},document.head.appendChild(n)})),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('/img/img11.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="青山入我怀"><span class="site-name">青山入我怀</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">记录学习Spring源码</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-07-01T05:13:06.904Z" title="发表于 2024-07-01 13:13:06">2024-07-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Spring/">Spring</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Spring/JAVA/">JAVA</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">70.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>322分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>因为Spring源码这个东西实在是太难学了，学了忘，忘了学，反反复复，还有很多晦涩难懂的东西，甚至现在我感觉仍然是入门，只能说是把每节课学到的东西给记录一下，将来能多次回顾。笔记参考视频-黑马程序员</p><p>这几篇老文章都是我之前用飞书云文档写的，因转换格式问题，本文之前已写完的文档图片太多了，不想一一转化了，大家可以访问我的飞书云文档来查看这些图片–<a target="_blank" rel="noopener" href="https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e,%E4%B8%8D%E8%BF%87%E5%90%8E%E7%BB%AD%E8%A1%A5%E5%85%85%E7%9A%84%E9%83%BD%E4%BC%9A%E6%9C%89%E5%9B%BE%E7%89%87">https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e,不过后续补充的都会有图片</a></p><h1 id="容器接口"><a href="#容器接口" class="headerlink" title="容器接口"></a>容器接口</h1><p>以 SpringBoot 的启动类为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A01Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(A01Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 run() 方法是有返回值的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(Application.class, args);</span><br></pre></td></tr></table></figure><p>ConfigurableApplicationContext</p><p>ConfigurableApplicationContext 接口继承了 ApplicationContext 接口，而 ApplicationContext 接口又间接地继承了 BeanFactory 接口，除此之外还继承了其他很多接口，相当于对 BeanFactory 进行了拓展。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTQ5ZDU4ZDNhNWY4Y2IxYWE4NmRiNzBjYzRhMDU3NWZfYXBEcEREbFM1cEhra0F5WnpwT0dFU2MwYTl1V2l2NGRfVG9rZW46VXpLMmI5Nk1Qb3gxRkx4QlpoWmNxaDNUbmdlXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><h2 id="1-1-BeanFactory介绍"><a href="#1-1-BeanFactory介绍" class="headerlink" title="1.1 BeanFactory介绍"></a>1.1 BeanFactory介绍</h2><ol><li>它是 ApplicationContext 的父接口</li><li>它才是 Spring 的核心容器，主要的 ApplicationContext 实现组合了它的功能，也就是说，BeanFactory 是 ApplicationContext 中的一个成员变量。</li><li>常用的 context.getBean(“xxx”) 方法，其实是调用了 BeanFactory 的 getBean() 方法。</li></ol><h2 id="1-2-BeanFactory-作用"><a href="#1-2-BeanFactory-作用" class="headerlink" title="1.2  BeanFactory 作用"></a>1.2 BeanFactory 作用</h2><p>IDEA中查看BeanFactory的相关方法</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ODMzMTJhZjdlODM3ZTkxMmM4ZWEzNzcyYjFiZDIwNTJfRnNGeHBTZmVyNzNNVDF5QmZoaDVUNDZlRm1OUHhyS0NfVG9rZW46SUpRMGJwZnVsb2RLNTN4U3RadmN1WTB1bndoXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>通过这些方法定义可知，BeanFactory 表面上只有 getBean() 方法，但实际上 Spring 中的控制反转、基本的依赖注入、乃至 Bean 的生命周期中的各个功能都是由它的实现类提供。</p><h2 id="1-3DefaultListableBeanFactory"><a href="#1-3DefaultListableBeanFactory" class="headerlink" title="1.3DefaultListableBeanFactory"></a>1.3DefaultListableBeanFactory</h2><h3 id="1-3-1DefaultListableBeanFactory简单介绍"><a href="#1-3-1DefaultListableBeanFactory简单介绍" class="headerlink" title="1.3.1DefaultListableBeanFactory简单介绍"></a>1.3.1DefaultListableBeanFactory简单介绍</h3><ol><li>DefaultListableBeanFactory 实现了 BeanFactory 接口，它能管理 Spring 中所有的 Bean，当然也包含 Spring 容器中的那些单例对象。</li><li>DefaultListableBeanFactory 还继承了DefaultSingletonBeanRegistry 类，这个类就是用来管理 Spring 容器中的单例对象。</li></ol><h3 id="1-3-2源码分析"><a href="#1-3-2源码分析" class="headerlink" title="1.3.2源码分析"></a>1.3.2源码分析</h3><p>进入DefaultSingletonBeanRegistry它有一个 Map 类型的成员变量 singletonObjects</p><p>Map 的 key 就是 Bean 的名字，而 value 是对应的 Bean，即单例对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure><p>演示</p><p>现有如下两个 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Component1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Component2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写程序查看 singletonObjects 中是否存在这两个 Bean 的信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A01Application</span> &#123;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A01Application.class, args);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">singletonObjects</span> <span class="operator">=</span> DefaultSingletonBeanRegistry.class.getDeclaredField(<span class="string">&quot;singletonObjects&quot;</span>);</span><br><span class="line">        singletonObjects.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getBeanFactory();</span><br><span class="line">        Map&lt;String, Object&gt; map = (Map&lt;String, Object&gt;) singletonObjects.get(beanFactory);</span><br><span class="line">        map.entrySet().stream().filter(e -&gt; e.getKey().startsWith(<span class="string">&quot;component&quot;</span>))</span><br><span class="line">            .forEach(e -&gt; System.out.println(e.getKey() + <span class="string">&quot;=&quot;</span> + e.getValue()));</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">component1=indi.lcp.bean.a01.Component1@25a5c7db</span><br><span class="line">component2=indi.lcp.bean.a01.Component2@4d27d9d</span><br></pre></td></tr></table></figure><h2 id="1-4ApplicationContext"><a href="#1-4ApplicationContext" class="headerlink" title="1.4ApplicationContext"></a>1.4ApplicationContext</h2><p>附一张ConfigurableApplicationContext的继承类图</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YmEzOThmN2Q5NDlhYTFmYzkyMWVmNzE0OTVmNTI1NWRfbndPUnlDcWN5RFM4MDRFeW9yeHE1QlB2WjQyMjJOUjNfVG9rZW46WE5IdWJwcFJ2b0tJWFN4MUpjeWNzanVEbm9lXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>可以看出ApplicationContext 除了继承 BeanFactory 外，还继承了：</p><ul><li>MessageSource：使其具备处理国际化资源的能力</li><li>ResourcePatternResolver：使其具备使用通配符进行资源匹配的能力</li><li>EnvironmentCapable：使其具备读取 Spring 环境信息、配置文件信息的能力</li><li>ApplicationEventPublisher：使其具备发布事件的能力</li></ul><p>依次深入看一下这四个类</p><h3 id="1-4-1MessageSource"><a href="#1-4-1MessageSource" class="headerlink" title="1.4.1MessageSource"></a>1.4.1MessageSource</h3><p>在 SpringBoot 项目的 resources 目录下创建 messages.properties、messages_en.properties、messages_zh_CN.properties、messages_zh_TW.properties 四个国际化文件，除 messages.properties 外，其余三个文件内容如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lcp=Li congpu</span><br><span class="line">lcp=李从浦</span><br><span class="line">lcp=李從浦</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A01Application.class, args);</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    System.out.println(context.getMessage(<span class="string">&quot;thanks&quot;</span>, <span class="literal">null</span>, Locale.ENGLISH));</span><br><span class="line">    System.out.println(context.getMessage(<span class="string">&quot;thanks&quot;</span>, <span class="literal">null</span>, Locale.SIMPLIFIED_CHINESE));</span><br><span class="line">    System.out.println(context.getMessage(<span class="string">&quot;thanks&quot;</span>, <span class="literal">null</span>, Locale.TRADITIONAL_CHINESE));</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Li congpu</span><br><span class="line">李从浦</span><br><span class="line">李從浦</span><br></pre></td></tr></table></figure><h3 id="1-4-2ResourcePatternResolver"><a href="#1-4-2ResourcePatternResolver" class="headerlink" title="1.4.2ResourcePatternResolver"></a>1.4.2ResourcePatternResolver</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A01Application.class, args);</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    Resource[] resources = context.getResources(<span class="string">&quot;classpath:application.properties&quot;</span>);</span><br><span class="line">    Assert.isTrue(resources.length &gt; <span class="number">0</span>, <span class="string">&quot;加载类路径下的 application.properties 文件失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 classpath* 可以加载 jar 里类路径下的 resource</span></span><br><span class="line">    resources = context.getResources(<span class="string">&quot;classpath*:META-INF/spring.factories&quot;</span>);</span><br><span class="line">    Assert.isTrue(resources.length &gt; <span class="number">0</span>, <span class="string">&quot;加载类路径下的 META-INF/spring.factories 文件失败&quot;</span>);</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-3EnvironmentCapable"><a href="#1-4-3EnvironmentCapable" class="headerlink" title="1.4.3EnvironmentCapable"></a>1.4.3EnvironmentCapable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A01Application.class, args);</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    System.out.println(context.getEnvironment().getProperty(<span class="string">&quot;java_home&quot;</span>));</span><br><span class="line">    System.out.println(context.getEnvironment().getProperty(<span class="string">&quot;properties.name&quot;</span>));</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java_home 是从环境变量中读取，properties.name 则是从 application.yml 配置文件中读取。</p><h3 id="1-4-4ApplicationEventPublisher"><a href="#1-4-4ApplicationEventPublisher" class="headerlink" title="1.4.4ApplicationEventPublisher"></a>1.4.4ApplicationEventPublisher</h3><p>定义事件类 UserRegisteredEvent：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegisteredEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6319117283222183184L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserRegisteredEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 Component1 作为发送事件的 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Component1</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;事件&quot;</span>);</span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> <span class="title class_">UserRegisteredEvent</span>(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 Component2 作为事件监听器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Component2</span> &#123;</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aaa</span><span class="params">(UserRegisteredEvent event)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, event);</span><br><span class="line">        log.debug(<span class="string">&quot;监听到事件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main() 方法中使用 Component1 发送事件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A01Application.class, args);</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    context.getBean(Component1.class).register();</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.bean.a01.Component1      - 事件 </span><br><span class="line">indi.lcp.bean.a01.Component2      - indi.lcp.bean.a01.UserRegisteredEvent[source=indi.lcp.bean.a01.Component1@25a5c7db] </span><br><span class="line">indi.lcp.bean.a01.Component2      - 监听到事件 </span><br></pre></td></tr></table></figure><h1 id="容器实现"><a href="#容器实现" class="headerlink" title="容器实现"></a>容器实现</h1><h2 id="2-1-BeanFactory-的实现"><a href="#2-1-BeanFactory-的实现" class="headerlink" title="2.1 BeanFactory 的实现"></a>2.1 BeanFactory 的实现</h2><p>有如下类，尝试将 Config 添加到 Bean 工厂中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;构造 Bean1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">getBean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bean2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean2</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;构造 Bean2()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要使用到 BeanFactory 的一个实现类： DefaultListableBeanFactory。有了 Bean 工厂，还需要定义 Bean，之后再把定义的 Bean 注册到工厂即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">    <span class="comment">// bean 的定义（class，scope，初始化，销毁）</span></span><br><span class="line">    <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(Config.class)</span><br><span class="line">            .setScope(<span class="string">&quot;singleton&quot;</span>)</span><br><span class="line">            .getBeanDefinition();</span><br><span class="line">    beanFactory.registerBeanDefinition(<span class="string">&quot;config&quot;</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有 config</span></span><br><span class="line">    Arrays.stream(beanFactory.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">config</span><br></pre></td></tr></table></figure><p>现在 Bean 工厂中 有且仅有一个 名为 config 的 Bean。</p><ul><li>解析配置类</li></ul><p>根据对 @Configuration 和 @Bean 两个注解的认识可知，Bean 工厂中应该还存在 bean1 和 bean2，那为什么现在没有呢？</p><p>很明显是现在的 BeanFactory 缺少了解析 @Configuration 和 @Bean 两个注解的能力。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="comment">// 给 BeanFactory 添加一些常用的后置处理器</span></span><br><span class="line">    AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory);</span><br><span class="line">    Arrays.stream(beanFactory.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据打印出的信息，可以看到有一个名为 org.springframework.context.annotation.internalConfigurationAnnotationProcessor 的 Bean，根据其所含的 ConfigurationAnnotationProcessor 字样，可以知道这个 Bean 就是用来处理 @Configuration 和 @Bean 注解的，将配置类中定义的 Bean 信息补充到 BeanFactory 中。</p><p>那为什么在 Bean 工厂中依旧没有 bean1 和 bean2 呢？</p><p>现在仅仅是将处理器添加到了 Bean 工厂，还没有使用处理器。</p><p>使用处理器很简单，先获取到处理器，然后再使用即可。像internalConfigurationAnnotationProcessor 这样的 Bean，都有一个共同的类型，名为 BeanFactoryPostProcessor，因此可以：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="comment">// 使用后置处理器</span></span><br><span class="line">    <span class="comment">// BeanFactoryPostProcessor 补充了一些 Bean 的定义</span></span><br><span class="line">    beanFactory.getBeansOfType(BeanFactoryPostProcessor.class).values().forEach(i -&gt; i.postProcessBeanFactory(beanFactory));</span><br><span class="line">    Arrays.stream(beanFactory.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">config</span><br><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">bean1</span><br><span class="line">bean2</span><br></pre></td></tr></table></figure><ul><li>依赖注入</li></ul><p>bean1 和 bean2 已经被添加到 Bean 工厂中，尝试获取 bean1 中的 bean2，查看 bean2 是否成功注入到 bean1 中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    System.out.println(beanFactory.getBean(Bean1.class).getBean2());</span><br><span class="line">&#125;</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure><p>bean2 没有成功被注入到 bean1 中。</p><p>在先前添加到 BeanFactory 中的后置处理器里，有名为 internalAutowiredAnnotationProcessor 和 internalCommonAnnotationProcessor 的两个后置处理器。前者用于解析 @Autowired 注解，后者用于解析 @Resource 注解，它们都有一个共同的类型 BeanPostProcessor，因此可以：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    System.out.println(<span class="string">&quot;---------------------------------------------&quot;</span>);</span><br><span class="line">    <span class="comment">// Bean 后置处理器，对 Bean 的生命周期的各个阶段提供拓展，例如 @AutoWired @Resource...</span></span><br><span class="line">    beanFactory.getBeansOfType(BeanPostProcessor.class).values().forEach(beanFactory::addBeanPostProcessor);</span><br><span class="line">    System.out.println(beanFactory.getBean(Bean1.class).getBean2());</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------</span><br><span class="line">[main] DEBUG indi.lcp.bean.a02.TestBeanFactory$Bean1 - 构造 Bean1()</span><br><span class="line">[main] DEBUG indi.lcp.bean.a02.TestBeanFactory$Bean2 - 构造 Bean2()</span><br><span class="line">indi.lcp.bean.a02.TestBeanFactory$Bean2@6ee12bac</span><br></pre></td></tr></table></figure><p>建立 BeanPostProcessor 和 BeanFactory 的关系后，bean2 被成功注入到 bean1 中了。</p><p>除此之外还可以发现：当需要使用 Bean 时，Bean 才会被创建，即按需加载。那有没有什么办法预先就初始化好单例对象呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预先初始化单例对象（完成依赖注入和初始化流程）  懒汉变饿汉</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">    System.out.println(<span class="string">&quot;---------------------------------------------&quot;</span>);</span><br><span class="line">    beanFactory.getBeansOfType(BeanPostProcessor.class).values().forEach(beanFactory::addBeanPostProcessor);</span><br><span class="line">    System.out.println(beanFactory.getBean(Bean1.class).getBean2());</span><br><span class="line">&#125;</span><br><span class="line">[main] DEBUG indi.lcp.bean.a02.TestBeanFactory$Bean1 - 构造 Bean1()</span><br><span class="line">[main] DEBUG indi.lcp.bean.a02.TestBeanFactory$Bean2 - 构造 Bean2()</span><br><span class="line">----------------------------------------</span><br><span class="line">indi.lcp.bean.a02.TestBeanFactory$Bean2@6ee12bac</span><br></pre></td></tr></table></figure><p><strong>学到了什么-&gt;BeanFactory 不会做的事 ：</strong></p><ul><li><p>主动调用 BeanFactory 后置处理器；</p></li><li><p>主动添加 Bean 后置处理器；</p></li><li><p>主动初始化单例对象；</p></li><li><p>解析 ${} 和 #{}</p></li><li><p><strong>扩展：后置处理器的排序</strong></p></li></ul><p>在最初给出的类信息中进行补充：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean3 <span class="title function_">bean3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean3</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean4 <span class="title function_">bean4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean4</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean3</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean3</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;构造 Bean3()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean4</span> <span class="keyword">implements</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean4</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;构造 Bean4()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Resource(name = &quot;bean4&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Inter bean3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Inter <span class="title function_">getInter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bean3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向 Bean 工厂中添加了 bean3 和 bean4，并且计划在 bean1 中注入 Inter 类型的 Bean。</p><p>现在 Bean 工厂中 Inter 类型的 Bean 有两个，分别是 bean3、bean4，那么会注入哪一个呢？</p><p>如果只使用 @Autowired，首先会按照类型注入，如果同种类型的 Bean 有多个，再按照变量名称注入，如果再注入失败，就报错；如果只使用 @Resource，也会采取与 @Autowired 一样的注入策略，只不过 @Resource 注解还可以指定需要注入 Bean 的 id（使用 name 属性进行指定），如果指定了需要注入 Bean 的 id，就直接按照指定的 id 进行注入，如果失败就报错。</p><p>那如果即使用 @Autowired 又使用 @Resource(name &#x3D; “bean4”) 呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    System.out.println(beanFactory.getBean(Bean1.class).getInter());</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a02.TestBeanFactory$Bean3@<span class="number">8e0379d</span></span><br></pre></td></tr></table></figure><p>根据打印的结果可知，@Autowired 先生效了，这是因为 internalAutowiredAnnotationProcessor 排在 internalCommonAnnotationProcessor 之前。可以查看它们的先后关系</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    beanFactory.getBeansOfType(BeanPostProcessor.class).values().forEach(i -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt; &quot;</span> + i);</span><br><span class="line">        beanFactory.addBeanPostProcessor(i);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor@6385cb26</span><br><span class="line">org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@<span class="number">38364841</span></span><br></pre></td></tr></table></figure></blockquote><p>也可以改变它们的顺序，然后再查看注入的是 bean3 还是 bean4：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    beanFactory.getBeansOfType(BeanPostProcessor.class).values().stream()</span><br><span class="line">        .sorted(Objects.requireNonNull(beanFactory.getDependencyComparator()))</span><br><span class="line">        .forEach(i -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt; &quot;</span> + i);</span><br><span class="line">            beanFactory.addBeanPostProcessor(i);</span><br><span class="line">        &#125;);</span><br><span class="line">    System.out.println(beanFactory.getBean(Bean1.class).getInter());</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt;&gt; org.springframework.context.annotation.CommonAnnotationBeanPostProcessor@6385cb26</span><br><span class="line">&gt;&gt;&gt;&gt; org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor@<span class="number">38364841</span></span><br><span class="line">indi.lcp.bean.a02.TestBeanFactory$Bean4@52e677af</span><br></pre></td></tr></table></figure><p>改变 BeanPostProcessor 的先后顺序后，@Resource(name &#x3D; “bean4”) 生效了，成功注入了 bean4。</p><p>为什么使用 beanFactory.getDependencyComparator() 后就改变了 BeanPostProcessor 的先后顺序呢？</p><p>在调用的 AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory); 方法源码中有：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerAnnotationConfigProcessors</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    registerAnnotationConfigProcessors(registry, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">registerAnnotationConfigProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">    BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">    <span class="keyword">if</span> (beanFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">            <span class="comment">// 设置比较器</span></span><br><span class="line">            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">            beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置的 AnnotationAwareOrderComparator 比较器会根据设置的 order 信息进行比较。</p><p>AutowiredAnnotationBeanPostProcessor 设置的 order 是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">order</span> <span class="operator">=</span> Ordered.LOWEST_PRECEDENCE - <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>CommonAnnotationBeanPostProcessor 设置的 order 是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">CommonAnnotationBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">    setOrder(Ordered.LOWEST_PRECEDENCE - <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值越小，优先级越大，就排在更前面，因此当设置了 AnnotationAwareOrderComparator 比较器后，CommonAnnotationBeanPostProcessor 排在更前面，@Resource 就先生效。</p><h2 id="2-2-ApplicationContext-的实现"><a href="#2-2-ApplicationContext-的实现" class="headerlink" title="2.2 ApplicationContext 的实现"></a>2.2 ApplicationContext 的实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lcp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/12/23 23:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A02Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">        <span class="meta">@Getter</span></span><br><span class="line">        <span class="meta">@Setter</span></span><br><span class="line">        <span class="keyword">private</span> Bean1 bean1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-1-ClassPathXmlApplicationContext"><a href="#2-2-1-ClassPathXmlApplicationContext" class="headerlink" title="2.2.1 ClassPathXmlApplicationContext"></a>2.2.1 ClassPathXmlApplicationContext</h3><p>较为经典的容器，基于 classpath 下的 xml 格式的配置文件来创建。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;indi.lcp.bean.a02.A02Application.Bean1&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;indi.lcp.bean.a02.A02Application.Bean2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bean1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line">private static void testClassPathXmlApplicationContext() &#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;b01.xml&quot;);</span><br><span class="line">    Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">    System.out.println(context.getBean(Bean2.class).getBean1());</span><br><span class="line">&#125;</span><br><span class="line">bean1</span><br><span class="line">bean2</span><br><span class="line">indi.lcp.bean.a02.A02Application$Bean1@2db7a79b</span><br></pre></td></tr></table></figure><h3 id="2-2-2-FileSystemXmlApplicationContext"><a href="#2-2-2-FileSystemXmlApplicationContext" class="headerlink" title="2.2.2 FileSystemXmlApplicationContext"></a>2.2.2 FileSystemXmlApplicationContext</h3><p>与 ClassPathXmlApplicationContext 相比，FileSystemXmlApplicationContext 是基于磁盘路径下 xml 格式的配置文件来创建。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testFileSystemXmlApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 使用相对路径时，以模块为起点（IDEA 中需要设置 Working directory），也支持绝对路径</span></span><br><span class="line">    <span class="type">FileSystemXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;bean\\src\\main\\resources\\b01.xml&quot;</span>);</span><br><span class="line">    Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">    System.out.println(context.getBean(Bean2.class).getBean1());</span><br><span class="line">&#125;</span><br><span class="line">bean1</span><br><span class="line">bean2</span><br><span class="line">indi.lcp.bean.a02.A02Application$Bean1@2db7a79b</span><br></pre></td></tr></table></figure><ul><li><strong>从XML 文件中读取 Bean 的定义</strong></li></ul><p>ClassPathXmlApplicationContext 和 FileSystemXmlApplicationContext 都依赖于从 XML 文件中读取 Bean 的信息，而这都利用了 XmlBeanDefinitionReader 进行读取。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testXmlBeanDefinitionReader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;读取之前...&quot;</span>);</span><br><span class="line">        Arrays.stream(beanFactory.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;读取之后...&quot;</span>);</span><br><span class="line">        <span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line"><span class="comment">//        reader.loadBeanDefinitions(new ClassPathResource(&quot;b01.xml&quot;));</span></span><br><span class="line">        reader.loadBeanDefinitions(<span class="keyword">new</span> <span class="title class_">FileSystemResource</span>(<span class="string">&quot;bean\\src\\main\\resources\\b01.xml&quot;</span>));</span><br><span class="line">        Arrays.stream(beanFactory.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">读取之前...</span><br><span class="line">读取之后...</span><br><span class="line">bean1</span><br><span class="line">bean2</span><br></pre></td></tr></table></figure><h3 id="2-2-3-AnnotationConfigApplicationContext"><a href="#2-2-3-AnnotationConfigApplicationContext" class="headerlink" title="2.2.3 AnnotationConfigApplicationContext"></a>2.2.3 AnnotationConfigApplicationContext</h3><p>基于 Java 配置类来创建。首先定义配置类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">(Bean1 bean1)</span> &#123;</span><br><span class="line">        <span class="type">Bean2</span> <span class="variable">bean2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">        bean2.setBean1(bean1);</span><br><span class="line">        <span class="keyword">return</span> bean2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Config.class);</span><br><span class="line">    Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">    System.out.println(context.getBean(Bean2.class).getBean1());</span><br><span class="line">&#125;</span><br><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">a02Application.Config</span><br><span class="line">bean1</span><br><span class="line">bean2</span><br><span class="line">indi.lcp.bean.a02.A02Application$Bean1@1f0f1111</span><br></pre></td></tr></table></figure><p>与前面两种基于 XML 创建 ApplicationContext 的方式相比，使用 AnnotationConfigApplicationContext 后，使得容器中多了一些后置处理器相关的 Bean。</p><p>如果要在先前的两种方式中也添加上这些 Bean，可以在 XML 进行配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;indi.lcp.bean.a02.A02Application.Bean1&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;indi.lcp.bean.a02.A02Application.Bean2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bean1&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bean1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  添加后置处理器  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-4-AnnotationConfigServletWebServerApplicationContext"><a href="#2-2-4-AnnotationConfigServletWebServerApplicationContext" class="headerlink" title="2.2.4 AnnotationConfigServletWebServerApplicationContext"></a>2.2.4 AnnotationConfigServletWebServerApplicationContext</h3><p>基于 Java 配置类来创建，用于 web 环境。首先定义配置类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 提供内嵌的 Web 容器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 添加前控制器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">registrationBean</span><span class="params">(DispatcherServlet dispatcherServlet)</span> &#123;</span><br><span class="line">        <span class="comment">// 将 DispatcherServlet 注册到 Tomcat 服务器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 bean 以 &#x27;/&#x27; 开头，将 &#x27;/&#x27; 后的 bean 的名称作为访问路径</span></span><br><span class="line">    <span class="meta">@Bean(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Controller <span class="title function_">controller1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 添加控制器，用于展示</span></span><br><span class="line">        <span class="keyword">return</span> (request, response) -&gt; &#123;</span><br><span class="line">            response.getWriter().println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAnnotationConfigServletWebServerApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigServletWebServerApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>(WebConfig.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，在浏览器中访问 <a target="_blank" rel="noopener" href="http://localhost:8080/hello">http://localhost:8080/hello</a> 路径则会显示出 hello 字样</p><h2 id="2-3-BeanFactory-接口体系"><a href="#2-3-BeanFactory-接口体系" class="headerlink" title="2.3 BeanFactory 接口体系"></a>2.3 BeanFactory 接口体系</h2><p>BeanFactory 其实就是 Spring IoC 容器，它本身是一个接口，提供了一系列获取 Bean 的方式。</p><p>基于它也有众多子接口：</p><ul><li>ListableBeanFactory：提供获取 Bean 集合的能力，比如一个接口可能有多个实现，通过该接口下的方法就能获取某种类型的所有 Bean；</li><li>HierarchicalBeanFactory：Hierarchical 意为“层次化”，通常表示一种具有层级结构的概念或组织方式，这种层次化结构可以通过父子关系来表示对象之间的关联，比如树、图、文件系统、组织架构等。根据该接口下的方法可知，能够获取到父容器，说明 BeanFactory 有父子容器概念；</li><li>AutowireCapableBeanFactory：提供了创建 Bean、自动装配 Bean、属性填充、Bean 初始化、依赖注入等能力，比如 @Autowired 注解的底层实现就依赖于该接口的 resolveDependency() 方法；</li><li>ConfigurableBeanFactory：该接口并未直接继承至 BeanFactory，而是继承了 HierarchicalBeanFactory。Configurable 意为“可配置的”，就是说该接口用于对 BeanFactory 进行一些配置，比如设置类型转换器。</li></ul><h2 id="2-4-读取-BeanDefinition"><a href="#2-4-读取-BeanDefinition" class="headerlink" title="2.4 读取 BeanDefinition"></a>2.4 读取 BeanDefinition</h2><p>BeanDefinition 也是一个接口，它封装了 Bean 的定义，Spring 根据 Bean 的定义，就能创建出符合要求的 Bean。</p><p>读取 BeanDefinition 可以通过下列两种类完成：</p><ul><li><p>BeanDefinitionReader</p></li><li><p>ClassPathBeanDefinitionScanner</p></li><li><p>BeanDefinitionReader</p></li></ul><p>该接口中对 loadBeanDefinitions() 方法进行了多种重载，支持传入一个或多个 Resource 对象、资源位置来加载 BeanDefinition。</p><p>它有一系列相关实现，比如：</p><ul><li>XmlBeanDefinitionReader：通过读取 XML 文件来加载；</li><li>PropertiesBeanDefinitionReader：通过读取 properties 文件来加载，此类已经被 @Deprecated 注解标记；</li></ul><p>除此之外，还有一个 AnnotatedBeanDefinitionReader，尽管它并不是 BeanDefinition 的子类，但它们俩长得很像，根据其类注释可知：它能够通过编程的方式对 Bean 进行注册，是 ClassPathBeanDefinitionScanner 的替代方案，能读取通过注解定义的 Bean。</p><ul><li>ClassPathBeanDefinitionScanner</li></ul><p>通过扫描指定包路径下的 @Component 及其派生注解来注册 Bean，是 @ComponentScan 注解的底层实现。</p><p>比如 MyBatis 通过继承 ClassPathBeanDefinitionScanner 实现通过 @MapperScan 注解来扫描指定包下的 Mapper 接口。</p><ul><li>BeanDefinitionRegistry</li></ul><p>AnnotatedBeanDefinitionReader 和 ClassPathBeanDefinitionScanner 中都有一个 BeanDefinitionRegistry 类型的成员变量，它是一个接口，提供了 BeanDefinition 的增加、删除和查找功能。</p><ul><li>注册与获取 Bean</li></ul><p>根据前面的补充，现在可以这样注册并获取 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultListableBeanFactoryTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 既实现了 BeanFactory，又实现了 BeanDefinitionRegistry</span></span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">        <span class="comment">// ClassPathBeanDefinitionScanner 的一种替代，编程式显式注册 bean</span></span><br><span class="line">        <span class="type">AnnotatedBeanDefinitionReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(beanFactory);</span><br><span class="line">        reader.registerBean(MyBean.class);</span><br><span class="line">        <span class="type">MyBean</span> <span class="variable">bean</span> <span class="operator">=</span> beanFactory.getBean(MyBean.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-ApplicationContext-接口体系"><a href="#2-5-ApplicationContext-接口体系" class="headerlink" title="2.5 ApplicationContext 接口体系"></a>2.5 ApplicationContext 接口体系</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">EnvironmentCapable</span>, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationContext 接口继承了许多接口，其中：</p><ul><li>EnvironmentCapable：提供获取 Environment 的能力</li><li>ListableBeanFactory：提供了获取某种类型的 Bean 集合的能力</li><li>HierarchicalBeanFactory：提供了获取父容器的能力</li><li>MessageSource：提供了对国际化信息进行处理的能力</li><li>ApplicationEventPublisher：提供了事件发布能力</li><li>ResourcePatternResolver：提供了通过通配符获取多个资源的能力</li></ul><p>虽然 ApplicationContext 继承了很多接口，但这些能力的实现是通过一种委派（Delegate）的方式实现的，这种方式也被叫做委派模式，但它并不属于 GoF 的 23 种设计模式中的一种，是一种面向对象的设计模式。什么是委派呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ResourcePatternResolver</span> <span class="variable">resourcePatternResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> resourcePatternResolver.getResources(locationPattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现获取资源的方式并不是由实现类自身完成，而是交给其内部的一个成员变量完成，这样的方式就是委派（这和对象适配器模式很相似）。</p><p>在日常编码遇到这样的实现逻辑时，类名可以以 Delegate 结尾。</p><ul><li>ConfigurableApplicationContext</li></ul><p>ApplicationContext 有一个子接口 ConfigurableApplicationContext，从类名就可以看出，它提供了对 ApplicationContext 进行配置的能力，浏览其内部方法可知，提供了诸如设置父容器、设置 Environment 等能力。</p><ul><li>AbstractApplicationContext</li></ul><p>ApplicationContext 有一个非常重要的抽象实现 AbstractApplicationContext，其他具体实现都会继承这个抽象实现，在其内部通过委派的方式实现了一些接口的能力，除此之外还有一个与 Spring Bean 的生命周期息息相关的方法：refresh()。</p><h1 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h1><p>自定义一个 SpringBoot 的主启动类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A03Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A03Application.class, args);</span><br><span class="line">        <span class="comment">// 调用 close 方法，显示生命周期的销毁阶段</span></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动类所在路径下再定义一个类，使其能够被自动装配：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LifeCycleBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LifeCycleBean</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">autowire</span><span class="params">(<span class="meta">@Value(&quot;$&#123;JAVA_HOME&#125;&quot;)</span> String home)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;依赖注入: &#123;&#125;&quot;</span>, home);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a03.LifeCycleBean        : 构造</span><br><span class="line">indi.lcp.bean.a03.LifeCycleBean        : 依赖注入: D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">indi.lcp.bean.a03.LifeCycleBean        : 初始化</span><br><span class="line">indi.lcp.bean.a03.LifeCycleBean        : 销毁</span><br></pre></td></tr></table></figure><p>除此之外，Spring 还提供了一些对 Bean 生命周期的各个阶段进行拓展的 BeanPostProcessor，比如 InstantiationAwareBeanPostProcessor 和 DestructionAwareBeanPostProcessor。</p><p>实现这两个接口，并使用 @Component 注解标记实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">InstantiationAwareBeanPostProcessor</span>, DestructionAwareBeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeforeDestruction</span><span class="params">(Object o, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;lifeCycleBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 销毁执行之前，如 @PreDestroy&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;lifeCycleBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 实例化之前执行，这里返回的对象会替换掉原本的 bean&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;lifeCycleBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 实例化之后执行，如果返回 false 会跳过依赖注入节点&quot;</span>);</span><br><span class="line">            <span class="comment">// return false;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;lifeCycleBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 依赖注入阶段执行，如 @Autowired、@Value、@Resource&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pvs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;lifeCycleBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 初始化执行之前，这里返回的对象会替换掉原本的 bean，如 @PostConstruct、@ConfigurationProperties&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;lifeCycleBean&quot;</span>.equals(beanName)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 初始化之后执行，这里返回的对象会替换掉原本的 bean，如代理增强&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再运行主启动类，查看控制台的日志信息（只列举主要信息）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.bean.a03.MyBeanPostProcessor  : &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 实例化之前执行，这里返回的对象会替换掉原本的 bean</span><br><span class="line">indi.lcp.bean.a03.LifeCycleBean        : 构造</span><br><span class="line">indi.lcp.bean.a03.MyBeanPostProcessor  : &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 实例化之后执行，如果返回 <span class="literal">false</span> 会跳过依赖注入节点</span><br><span class="line">indi.lcp.bean.a03.MyBeanPostProcessor  : &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 依赖注入阶段执行，如 <span class="meta">@Autowired</span>、<span class="meta">@Value</span>、<span class="meta">@Resource</span></span><br><span class="line">indi.lcp.bean.a03.LifeCycleBean        : 依赖注入: D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">indi.lcp.bean.a03.MyBeanPostProcessor  : &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 初始化执行之前，这里返回的对象会替换掉原本的 bean，如 <span class="meta">@PostConstruct</span>、<span class="meta">@ConfigurationProperties</span></span><br><span class="line">indi.lcp.bean.a03.LifeCycleBean        : 初始化</span><br><span class="line">indi.lcp.bean.a03.MyBeanPostProcessor  : &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 初始化之后执行，这里返回的对象会替换掉原本的 bean，如代理增强</span><br><span class="line">indi.lcp.bean.a03.MyBeanPostProcessor  : &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 销毁执行之前，如 <span class="meta">@PreDestroy</span></span><br><span class="line">indi.lcp.bean.a03.LifeCycleBean        : 销毁</span><br></pre></td></tr></table></figure><p>为什么实现了 BeanPostProcessor 接口后就能够在 Bean 生命周期的各个阶段进行拓展呢？</p><p>这使用了模板方法设计模式。</p><p>如下代码，模拟 BeanFactory 构造 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;构造 &quot;</span> + bean);</span><br><span class="line">        System.out.println(<span class="string">&quot;依赖注入 &quot;</span> + bean);</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化 &quot;</span> + bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设现在需要在依赖注入之后，初始化之前进行其他的操作，那首先能想到的就是在这个位置直接书写相关操作的代码，但这会使代码更加臃肿、增加耦合性，显然不是一种好方式。</p><p>可以定义一个接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inject</span><span class="params">(Object bean)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后对 MyBeanFactory 进行修改：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;构造 &quot;</span> + bean);</span><br><span class="line">        System.out.println(<span class="string">&quot;依赖注入 &quot;</span> + bean);</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor processor : processors) &#123;</span><br><span class="line">            processor.inject(bean);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化 &quot;</span> + bean);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;BeanPostProcessor&gt; processors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addProcessor</span><span class="params">(BeanPostProcessor processor)</span> &#123;</span><br><span class="line">        processors.add(processor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后如果需要拓展，调用 MyBeanFactory 实例的 addProcessor() 方法添加拓展逻辑即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBeanFactory</span>();</span><br><span class="line">    beanFactory.addProcessor(bean -&gt; System.out.println(<span class="string">&quot;解析 @Autowired&quot;</span>));</span><br><span class="line">    beanFactory.addProcessor(bean -&gt; System.out.println(<span class="string">&quot;解析 @Resource&quot;</span>));</span><br><span class="line">    beanFactory.getBean();</span><br><span class="line">&#125;</span><br><span class="line">构造 java.lang.Object@49097b5d</span><br><span class="line">依赖注入 java.lang.Object@49097b5d</span><br><span class="line">解析 <span class="meta">@Autowired</span></span><br><span class="line">解析 <span class="meta">@Resource</span></span><br><span class="line">初始化 java.lang.Object@49097b5d</span><br></pre></td></tr></table></figure><p>Bean的生命周期</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YzU3ZDMzYzkwMWMwZDE0ODJmN2NmZWNhN2UwNWI0ZWZfTmlPNEE1cWdkM1dyTTlzRDRiOXd4MXVrM3dlN1dMa1VfVG9rZW46WlZ4SWJhTGw5b3dQMWZ4ZXFGOGN6c21PbnNoXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><h1 id="Bean-后置处理器"><a href="#Bean-后置处理器" class="headerlink" title="Bean 后置处理器"></a><strong>Bean 后置处理器</strong></h1><h2 id="4-1-常见的-Bean-后置处理器"><a href="#4-1-常见的-Bean-后置处理器" class="headerlink" title="4.1 常见的 Bean 后置处理器"></a><strong>4.1 常见的 Bean 后置处理器</strong></h2><p>现有如下三个类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lcp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/12/25 22:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean2</span><span class="params">(Bean2 bean2)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;@Autowired 生效: &#123;&#125;&quot;</span>, bean2);</span><br><span class="line">        <span class="built_in">this</span>.bean2 = bean2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Bean3 bean3;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean3</span><span class="params">(Bean3 bean3)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;@Resource 生效: &#123;&#125;&quot;</span>, bean3);</span><br><span class="line">        <span class="built_in">this</span>.bean3 = bean3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String home;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHome</span><span class="params">(<span class="meta">@Value(&quot;$&#123;JAVA_HOME&#125;&quot;)</span> String home)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;@Value 生效: &#123;&#125;&quot;</span>, home);</span><br><span class="line">        <span class="built_in">this</span>.home = home;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;@PostConstruct 生效&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;@PreDestroy 生效&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean3</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bean2 和 Bean3 很简单，而在 Bean1 中使用了多个注解以实现 Bean 注入和值注入。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A04Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// GenericApplicationContext 是一个干净的容器</span></span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        <span class="comment">// 用原始方式注册三个 bean</span></span><br><span class="line">        context.registerBean(<span class="string">&quot;bean1&quot;</span>, Bean1.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;bean2&quot;</span>, Bean2.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;bean3&quot;</span>, Bean3.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化容器。执行 beanFactory 后置处理器，添加 bean 后置处理器，初始化所有单例</span></span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 销毁容器</span></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述方法后，控制台中只打印了与 Spring 相关的日志信息，也就是说 Bean1 中使用的注解并没有生效。</p><p>向 GenericApplicationContext 添加一些与 Bean 后置处理器相关的 Bean，使得 Bean1 中使用的注解能够生效。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    context.registerBean(<span class="string">&quot;bean3&quot;</span>, Bean3.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析值注入内容</span></span><br><span class="line">    context.getDefaultListableBeanFactory().setAutowireCandidateResolver(<span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>());</span><br><span class="line">    <span class="comment">// @Autowired @Value</span></span><br><span class="line">    context.registerBean(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a04.Bean1 - <span class="meta">@Autowired</span> 生效: indi.lcp.bean.a04.Bean2@29b5cd00</span><br><span class="line">indi.lcp.bean.a04.Bean1 - <span class="meta">@Value</span> 生效: D:\environment\JDK1<span class="number">.8</span></span><br></pre></td></tr></table></figure><p>@Autowired 和 @Value 注解成功生效，但 @Resource、@PostConstruct 和 @PreDestroy 依旧没有生效，因此还需要添加解析它们的 Bean 后置处理器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Resource @PostConstruct @PreDestroy</span></span><br><span class="line">    context.registerBean(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a04.Bean1 - <span class="meta">@Resource</span> 生效: indi.lcp.bean.a04.Bean3@12cdcf4</span><br><span class="line">indi.lcp.bean.a04.Bean1 - <span class="meta">@Autowired</span> 生效: indi.lcp.bean.a04.Bean2@6121c9d6</span><br><span class="line">indi.lcp.bean.a04.Bean1 - <span class="meta">@Value</span> 生效: D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">indi.lcp.bean.a04.Bean1 - <span class="meta">@PostConstruct</span> 生效</span><br><span class="line">INFO indi.lcp.bean.a04.Bean1 - <span class="meta">@PreDestroy</span> 生效</span><br></pre></td></tr></table></figure><p>解析 @ConfigurationProperties</p><p>使用 @ConfigurationProperties 可以指定配置信息的前缀，使得配置信息的读取更加简单。比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;java&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean4</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String home;</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码用于获取环境变量中 java.home 和 java.version 的信息。</p><p>对先前的 main() 方法进行补充：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    </span><br><span class="line">    context.registerBean(<span class="string">&quot;bean4&quot;</span>, Bean4.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    System.out.println(context.getBean(Bean4.class));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bean4 成功添加到容器中，但值注入失败了，显然也是因为缺少解析 @ConfigurationProperties 注解的后置处理器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    </span><br><span class="line">    context.registerBean(<span class="string">&quot;bean4&quot;</span>, Bean4.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="comment">// @ConfigurationProperties</span></span><br><span class="line">        ConfigurationPropertiesBindingPostProcessor.register(context.getDefaultListableBeanFactory());</span><br><span class="line"></span><br><span class="line">    System.out.println(context.getBean(Bean4.class));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">Bean4(home=D:\environment\JDK1<span class="number">.8</span>\jre, version=<span class="number">1.8</span><span class="number">.0_251</span>)</span><br></pre></td></tr></table></figure><h2 id="4-2-AutowiredAnnotationBeanPostProcessor"><a href="#4-2-AutowiredAnnotationBeanPostProcessor" class="headerlink" title="4.2 AutowiredAnnotationBeanPostProcessor"></a><strong>4.2 AutowiredAnnotationBeanPostProcessor</strong></h2><p>通过前文可知 AutowiredAnnotationBeanPostProcessor 用于解析 @Autowired 和 @Value 注解，那它究竟是怎么工作的呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">    <span class="comment">// 注册成品 Bean，不再进行 Bean 的创建、依赖注入、初始化等操作</span></span><br><span class="line">    beanFactory.registerSingleton(<span class="string">&quot;bean2&quot;</span>, <span class="keyword">new</span> <span class="title class_">Bean2</span>());</span><br><span class="line">    beanFactory.registerSingleton(<span class="string">&quot;bean3&quot;</span>, <span class="keyword">new</span> <span class="title class_">Bean3</span>());</span><br><span class="line">    <span class="comment">// @Value</span></span><br><span class="line">    beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看哪些属性、方法加了 @Autowired，这称之为 InjectionMetadata</span></span><br><span class="line">    <span class="type">AutowiredAnnotationBeanPostProcessor</span> <span class="variable">postProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutowiredAnnotationBeanPostProcessor</span>();</span><br><span class="line">    postProcessor.setBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="type">Bean1</span> <span class="variable">bean1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    System.out.println(bean1);</span><br><span class="line">    <span class="comment">// 执行依赖注入，@Autowired、@Value</span></span><br><span class="line">    postProcessor.postProcessProperties(<span class="literal">null</span>, bean1, <span class="string">&quot;bean1&quot;</span>);</span><br><span class="line">    System.out.println(bean1);</span><br><span class="line">&#125;</span><br><span class="line">Bean1(bean2=<span class="literal">null</span>, bean3=<span class="literal">null</span>, home=<span class="literal">null</span>)</span><br><span class="line"><span class="number">21</span>:<span class="number">31</span>:<span class="number">27.409</span> [main] INFO indi.lcp.bean.a04.Bean1 - <span class="meta">@Value</span> 生效: $&#123;JAVA_HOME&#125;</span><br><span class="line"><span class="number">21</span>:<span class="number">31</span>:<span class="number">27.419</span> [main] INFO indi.lcp.bean.a04.Bean1 - <span class="meta">@Autowired</span> 生效: indi.lcp.bean.a04.Bean2@5bcab519</span><br><span class="line"><span class="title function_">Bean1</span><span class="params">(bean2=indi.lcp.bean.a04.Bean2@5bcab519, bean3=<span class="literal">null</span>, home=$&#123;JAVA_HOME&#125;)</span></span><br></pre></td></tr></table></figure><p>在未调用 AutowiredAnnotationBeanPostProcessor#postProcessProperties() 方法时，Bean1 中的 bean2、bean3 和 home 都没有注入成功，而在调用之后，成功注入了 bean2 和 home，但 home 的值似乎有点奇怪，并没有打印出前文中相同的值，可能是因为没有成功解析 #{}？</p><p>至于 bean3 为什么没注入成功，是因为 <code>bean3</code> 的注入是利用 @Resource，而不是 @Autowired。如果对 Bean1 进行修改：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Bean3 bean3;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean3</span><span class="params">(Bean3 bean3)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;@Resource 生效: &#123;&#125;&quot;</span>, bean3);</span><br><span class="line">        <span class="built_in">this</span>.bean3 = bean3;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">Bean1(bean2=<span class="literal">null</span>, bean3=<span class="literal">null</span>, home=<span class="literal">null</span>)</span><br><span class="line"><span class="number">21</span>:<span class="number">36</span>:<span class="number">36.402</span> [main] INFO indi.lcp.bean.a04.Bean1 - <span class="meta">@Value</span> 生效: $&#123;JAVA_HOME&#125;</span><br><span class="line"><span class="number">21</span>:<span class="number">36</span>:<span class="number">36.406</span> [main] INFO indi.lcp.bean.a04.Bean1 - <span class="meta">@Autowired</span> 生效: indi.lcp.bean.a04.Bean2@490ab905</span><br><span class="line"><span class="title function_">Bean1</span><span class="params">(bean2=indi.lcp.bean.a04.Bean2@490ab905, bean3=indi.lcp.bean.a04.Bean3@56ac3a89, home=$&#123;JAVA_HOME&#125;)</span></span><br></pre></td></tr></table></figure><p>成功注入了 bean3。如果想要成功注入 home，则需要在 BeanFactory 中添加 #{} 的解析器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// $&#123;&#125; 的解析器</span></span><br><span class="line">    beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>()::resolvePlaceholders);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    postProcessor.postProcessProperties(<span class="literal">null</span>, bean1, <span class="string">&quot;bean1&quot;</span>);</span><br><span class="line">    System.out.println(bean1);</span><br><span class="line">&#125;</span><br><span class="line">Bean1(bean2=<span class="literal">null</span>, bean3=<span class="literal">null</span>, home=<span class="literal">null</span>)</span><br><span class="line">indi.lcp.bean.a04.Bean1 - <span class="meta">@Value</span> 生效: D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">indi.lcp.bean.a04.Bean1 - <span class="meta">@Autowired</span> 生效: indi.lcp.bean.a04.Bean2@4fe3c938</span><br><span class="line"><span class="title function_">Bean1</span><span class="params">(bean2=indi.lcp.bean.a04.Bean2@4fe3c938, bean3=indi.lcp.bean.a04.Bean3@5383967b, home=D:\environment\JDK1<span class="number">.8</span>)</span></span><br></pre></td></tr></table></figure><p>AutowiredAnnotationBeanPostProcessor#postProcessProperties()</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PropertyValues <span class="title function_">postProcessProperties</span><span class="params">(PropertyValues pvs, Object bean, String beanName)</span> &#123;</span><br><span class="line">    <span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        metadata.inject(bean, beanName, pvs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName, <span class="string">&quot;Injection of autowired dependencies failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 findAutowiringMetadata() 用于查找指定的 bean 对象中哪些地方使用了 @Autowired、@Value 等与注入相关的注解，并将这些信息封装在 InjectionMetadata 对象中，之后调用其 inject() 方法利用反射完成注入。</p><p>findAutowiringMetadata() 方法是一个私有方法，尝试利用反射进行调用并进行断点查看 InjectionMetadata 对象中的信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">AutowiredAnnotationBeanPostProcessor</span> <span class="variable">postProcessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutowiredAnnotationBeanPostProcessor</span>();</span><br><span class="line">    postProcessor.setBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="type">Bean1</span> <span class="variable">bean1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> AutowiredAnnotationBeanPostProcessor.class.getDeclaredMethod(<span class="string">&quot;findAutowiringMetadata&quot;</span>, String.class, Class.class, PropertyValues.class);</span><br><span class="line">    method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 获取 Bean1 上加了 @Value、@Autowired 注解的成员变量、方法参数信息</span></span><br><span class="line">    <span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> (InjectionMetadata) method.invoke(postProcessor, <span class="string">&quot;bean1&quot;</span>, Bean1.class, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 此处断点</span></span><br><span class="line">    System.out.println(metadata);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InjectionMetadata 中有一个名为 injectedElements 的集合类型成员变量，injectedElements 存储了被相关注解标记的成员变量、方法的信息，因为 Bean1 中的 bean3 成员变量、setBean2() ，setHome() 方法恰好被 @Autowired 注解标记。</p><p>然后按照源码一样，调用 InjectionMetadata#inject() 方法进行依赖注入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 Bean1 上加了 @Value、@Autowired 注解的成员变量、方法参数信息</span></span><br><span class="line">    <span class="type">InjectionMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> (InjectionMetadata) method.invoke(postProcessor, <span class="string">&quot;bean1&quot;</span>, Bean1.class, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 InjectionMetadata 来进行依赖注入，注入时按类型查找值</span></span><br><span class="line">    metadata.inject(bean1, <span class="string">&quot;bean1&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(bean1);</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a04.Bean1 - <span class="meta">@Value</span> 生效: D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">indi.lcp.bean.a04.Bean1 - <span class="meta">@Autowired</span> 生效: indi.lcp.bean.a04.Bean2@5383967b</span><br><span class="line"><span class="title function_">Bean1</span><span class="params">(bean2=indi.lcp.bean.a04.Bean2@5383967b, bean3=indi.lcp.bean.a04.Bean3@2ac273d3, home=D:\environment\JDK1<span class="number">.8</span>)</span></span><br></pre></td></tr></table></figure><p>调用 inject() 方法后会利用反射进行依赖注入，但在反射之前，肯定得先拿到被注入的对象或值，那这些对象或值是怎么取到的呢？</p><p>可以通过以下代码概括：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如何按类型查找值</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">bean3</span> <span class="operator">=</span> Bean1.class.getDeclaredField(<span class="string">&quot;bean3&quot;</span>);</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(bean3, <span class="literal">false</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> beanFactory.doResolveDependency(dd1, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(o1);</span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">setBean2</span> <span class="operator">=</span> Bean1.class.getDeclaredMethod(<span class="string">&quot;setBean2&quot;</span>, Bean2.class);</span><br><span class="line">    <span class="comment">// MethodParameter 构造方法的第二个参数表示需要解析的方法中参数的索引</span></span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(<span class="keyword">new</span> <span class="title class_">MethodParameter</span>(setBean2, <span class="number">0</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> beanFactory.doResolveDependency(dd2, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(o2);</span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">setHome</span> <span class="operator">=</span> Bean1.class.getDeclaredMethod(<span class="string">&quot;setHome&quot;</span>, String.class);</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(<span class="keyword">new</span> <span class="title class_">MethodParameter</span>(setHome, <span class="number">0</span>), <span class="literal">true</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o3</span> <span class="operator">=</span> beanFactory.doResolveDependency(dd3, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    System.out.println(o3);</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a04.Bean3@2ac273d3</span><br><span class="line">indi.lcp.bean.a04.Bean2@192b07fd</span><br><span class="line">D:\environment\JDK1<span class="number">.8</span></span><br></pre></td></tr></table></figure><h1 id="BeanFactory-后置处理器"><a href="#BeanFactory-后置处理器" class="headerlink" title="BeanFactory 后置处理器"></a><strong>BeanFactory 后置处理器</strong></h1><h2 id="5-1-常见的-BeanFactory-后置处理器"><a href="#5-1-常见的-BeanFactory-后置处理器" class="headerlink" title="5.1 常见的 BeanFactory 后置处理器"></a><strong>5.1 常见的 BeanFactory 后置处理器</strong></h2><p>先引入要用到的依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要用到的类信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.lcp.bean.a05;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;indi.lcp.bean.a05.component&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/advanced_spring&quot;</span>);</span><br><span class="line">        dataSource.setName(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> indi.lcp.bean.a05;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我被 Spring 管理啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> indi.lcp.bean.a05.component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean2</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我被 Spring 管理啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续使用 GenericApplicationContext 作为容器，向容器中注册 config：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">config</span><br></pre></td></tr></table></figure><p>并没有打印出除 config 以外的 Bean 信息，也就是说 Config 类中的 @ComponentScan 和 @Bean 注解都没有生效。</p><p>根据经验，显然是因为缺少某个后置处理器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">    <span class="comment">// @ComponentScan @Bean @Import @ImportResource</span></span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a05.component.Bean2 - 我被 Spring 管理啦</span><br><span class="line">indi.lcp.bean.a05.Bean1 - 我被 Spring 管理啦</span><br><span class="line">com.alibaba.druid.pool.DruidDataSource - &#123;dataSource-<span class="number">1</span>,root&#125; inited</span><br><span class="line">config</span><br><span class="line">org.springframework.context.annotation.ConfigurationClassPostProcessor</span><br><span class="line">bean2</span><br><span class="line">bean1</span><br><span class="line">sqlSessionFactoryBean</span><br><span class="line">dataSource</span><br></pre></td></tr></table></figure><p>在使用 MyBatis 时，经常会使用到 @Mapper 注解，而这个注解的解析也需要使用到特定的 BeanFactory 后置处理器。</p><p>以下两个接口被 @Mapper 注解标记：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.lcp.bean.a05.mapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mapper1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mapper2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后添加解析 @Mapper 注解的后置处理器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">    <span class="comment">// @ComponentScan @Bean @Import @ImportResource</span></span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">    context.registerBean(MapperScannerConfigurer.class,</span><br><span class="line">                i -&gt; i.getPropertyValues().add(<span class="string">&quot;basePackage&quot;</span>, <span class="string">&quot;indi.lcp.bean.a05.mapper&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 basePackage 是 MapperScannerConfigurer 中的一个成员变量，表示需要扫描的包路径，设置的值恰好是被 @Mapper 注解标记的接口所在的包路径。</p><p>控制台打印的信息中增加了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mapper1</span><br><span class="line">mapper2</span><br></pre></td></tr></table></figure><h2 id="5-2-模拟实现"><a href="#5-2-模拟实现" class="headerlink" title="5.2 模拟实现"></a><strong>5.2 模拟实现</strong></h2><p>移除向容器中添加的 ConfigurationClassPostProcessor 和 MapperScannerConfigurer 两个后置处理器，自行编码模拟它们功能的实现。</p><ul><li>组件扫描之 @ComponentScan</li></ul><p>在 Bean2 所在包路径下再增加两个类，用于后续测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.lcp.bean.a05.component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean3</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我被 Spring 管理啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean4</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;我被 Spring 管理啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 ComponentScanPostProcessor 用于实现 @ComponentScan 注解的解析：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lcp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/1/7 22:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentScanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用 context.refresh() 方法时回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="type">ComponentScan</span> <span class="variable">componentScan</span> <span class="operator">=</span> AnnotationUtils.findAnnotation(Config.class, ComponentScan.class);</span><br><span class="line">        <span class="keyword">if</span> (componentScan != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String packageName : componentScan.basePackages()) &#123;</span><br><span class="line">                System.out.println(packageName);</span><br><span class="line">                <span class="comment">// indi.lcp.bean.a05.component -&gt; classpath*:indi/lcp/bean/a05/component/**/**.class</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;classpath*:&quot;</span> + packageName.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>) + <span class="string">&quot;/**/**.class&quot;</span>;</span><br><span class="line">                <span class="comment">//  Resource[] resources = context.getResources(path);</span></span><br><span class="line">                Resource[] resources = <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>().getResources(path);</span><br><span class="line">                <span class="type">CachingMetadataReaderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">                <span class="type">AnnotationBeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationBeanNameGenerator</span>();</span><br><span class="line">                <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                    <span class="type">MetadataReader</span> <span class="variable">reader</span> <span class="operator">=</span> factory.getMetadataReader(resource);</span><br><span class="line">                    <span class="type">AnnotationMetadata</span> <span class="variable">annotationMetadata</span> <span class="operator">=</span> reader.getAnnotationMetadata();</span><br><span class="line"><span class="comment">//                    System.out.println(&quot;类名: &quot; + reader.getClassMetadata().getClassName());</span></span><br><span class="line"><span class="comment">//                    System.out.println(&quot;是否加了 @Component: &quot; + annotationMetadata.hasAnnotation(Component.class.getName()));</span></span><br><span class="line"><span class="comment">//                    System.out.println(&quot;是否加了 @Component 派生: &quot; + annotationMetadata.hasMetaAnnotation(Component.class.getName()));</span></span><br><span class="line">                    <span class="keyword">if</span> (annotationMetadata.hasAnnotation(Component.class.getName())</span><br><span class="line">                            || annotationMetadata.hasMetaAnnotation(Component.class.getName())) &#123;</span><br><span class="line">                        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(reader.getClassMetadata().getClassName())</span><br><span class="line">                                .getBeanDefinition();</span><br><span class="line">                        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> generator.generateBeanName(beanDefinition, registry);</span><br><span class="line">                        registry.registerBeanDefinition(name, beanDefinition);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">    context.registerBean(ComponentScanPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a05.component</span><br><span class="line">indi.lcp.bean.a05.component.Bean2      : 我被 Spring 管理啦</span><br><span class="line">indi.lcp.bean.a05.component.Bean3      : 我被 Spring 管理啦</span><br><span class="line">config</span><br><span class="line">indi.lcp.bean.a05.ComponentScanPostProcessor</span><br><span class="line">bean2</span><br><span class="line">bean3</span><br></pre></td></tr></table></figure><p>没使用 ConfigurationClassPostProcessor 也实现了 @ComponentScan 注解的解析！</p><ul><li>@Bean 的解析</li></ul><p>Config 类中再增加一个方法作为干扰项：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;indi.lcp.bean.a05.component&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与解析 @ComponentScan 一样，自行编写一个 BeanFactoryPostProcessor 的实现类用于解析 @Bean 注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lcp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/1/7 22:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="type">CachingMetadataReaderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">        <span class="type">MetadataReader</span> <span class="variable">reader</span> <span class="operator">=</span> factory.getMetadataReader(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;indi/lcp/bean/a05/Config.class&quot;</span>));</span><br><span class="line">        Set&lt;MethodMetadata&gt; methods = reader.getAnnotationMetadata().getAnnotatedMethods(Bean.class.getName());</span><br><span class="line">        <span class="keyword">for</span> (MethodMetadata method : methods) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">            <span class="type">String</span> <span class="variable">initMethod</span> <span class="operator">=</span> method.getAnnotationAttributes(Bean.class.getName()).get(<span class="string">&quot;initMethod&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> method.getMethodName();</span><br><span class="line">            <span class="type">BeanDefinitionBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition()</span><br><span class="line">                    .setFactoryMethodOnBean(methodName, <span class="string">&quot;config&quot;</span>)</span><br><span class="line">                    <span class="comment">// 工厂方法、构造方法的注入模式使用构造器模式</span></span><br><span class="line">                    .setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(initMethod)) &#123;</span><br><span class="line">                builder.setInitMethodName(initMethod);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> builder.getBeanDefinition();</span><br><span class="line">            registry.registerBeanDefinition(methodName, beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造 BeanDefinition 时调用了 setAutowireMode() 方法设置注入模式，这是因为在 <code>Config</code> 类中有一特殊的被 @Bean 标记的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">    <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">    sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收一个 DataSource 类型的参数，需要将容器中这个类型的 Bean 进行注入，设置的 AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR 注入模式则能完成这个功能。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(AtBeanPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a05.Config.bean1()</span><br><span class="line">indi.lcp.bean.a05.Config.sqlSessionFactoryBean(javax.sql.DataSource)</span><br><span class="line">indi.lcp.bean.a05.Config.dataSource()</span><br><span class="line">indi.lcp.bean.a05.Bean1                : 我被 Spring 管理啦</span><br><span class="line">com.alibaba.druid.pool.DruidDataSource   : &#123;dataSource-<span class="number">1</span>,root&#125; inited</span><br><span class="line">config</span><br><span class="line">indi.lcp.bean.a05.AtBeanPostProcessor</span><br><span class="line">bean1</span><br><span class="line">sqlSessionFactoryBean</span><br><span class="line">dataSource</span><br></pre></td></tr></table></figure><ul><li>@Mapper 的解析</li></ul><p>@Mapper 注解是在接口上使用的，但根据前文内容可知，@Mapper 被解析后在 Spring 容器中也存在与被标记的接口相关的 Bean。</p><p>难道 Spring 能管理接口？</p><p>那肯定是不行的，Spring 只能管理对象这是毋庸置疑的。那这些接口是怎么变成对象被 Spring 管理的呢？</p><p>这依赖于 MapperFactoryBean 将接口转换为对象。</p><p>在 Config 添加注册 Mapper1 和 Mapper2 的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MapperFactoryBean&lt;Mapper1&gt; <span class="title function_">mapper1</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">    MapperFactoryBean&lt;Mapper1&gt; factoryBean = <span class="keyword">new</span> <span class="title class_">MapperFactoryBean</span>&lt;&gt;(Mapper1.class);</span><br><span class="line">    factoryBean.setSqlSessionFactory(sqlSessionFactory);</span><br><span class="line">    <span class="keyword">return</span> factoryBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MapperFactoryBean&lt;Mapper2&gt; <span class="title function_">mapper2</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">    MapperFactoryBean&lt;Mapper2&gt; factoryBean = <span class="keyword">new</span> <span class="title class_">MapperFactoryBean</span>&lt;&gt;(Mapper2.class);</span><br><span class="line">    factoryBean.setSqlSessionFactory(sqlSessionFactory);</span><br><span class="line">    <span class="keyword">return</span> factoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再运行 main() 方法可以看到容器中存在名为 mapper1 和 mapper2 的 Bean。</p><p>这种方式虽然可以完成 Mapper 接口的注册，但每次只能单个注册，不能批量注册。</p><p>移除 Config 类中的 mapper1() 和 mapper2() 方法，自行编写 BeanDefinitionRegistryPostProcessor 接口的实现类完成 @Mapper 注解的解析：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lcp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/1/7 23:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="type">PathMatchingResourcePatternResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line">        Resource[] resources = resolver.getResources(<span class="string">&quot;classpath:indi/lcp/bean/a05/mapper/**/*.class&quot;</span>);</span><br><span class="line">        <span class="type">AnnotationBeanNameGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationBeanNameGenerator</span>();</span><br><span class="line">        <span class="type">CachingMetadataReaderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CachingMetadataReaderFactory</span>();</span><br><span class="line">        <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">            <span class="type">MetadataReader</span> <span class="variable">reader</span> <span class="operator">=</span> factory.getMetadataReader(resource);</span><br><span class="line">            <span class="type">ClassMetadata</span> <span class="variable">classMetadata</span> <span class="operator">=</span> reader.getClassMetadata();</span><br><span class="line">            <span class="keyword">if</span> (classMetadata.isInterface()) &#123;</span><br><span class="line">                <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(MapperFactoryBean.class)</span><br><span class="line">                        .addConstructorArgValue(classMetadata.getClassName())</span><br><span class="line">                        .setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE)</span><br><span class="line">                        .getBeanDefinition();</span><br><span class="line">                <span class="type">AbstractBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(classMetadata.getClassName())</span><br><span class="line">                        .getBeanDefinition();</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> generator.generateBeanName(bd, registry);</span><br><span class="line">                registry.registerBeanDefinition(name, beanDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line"></span><br><span class="line">    context.registerBean(AtBeanPostProcessor.class);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * AtBeanPostProcessor 的注册不能少，因为需要容器中存在 SqlSessionFactoryBean</span></span><br><span class="line"><span class="comment">     * 而 SqlSessionFactoryBean 是在配置类中利用 @Bean 进行注册的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    context.registerBean(MapperPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a05.Config.bean1()</span><br><span class="line">indi.lcp.bean.a05.Config.sqlSessionFactoryBean(javax.sql.DataSource)</span><br><span class="line">indi.lcp.bean.a05.Config.dataSource()</span><br><span class="line">indi.lcp.bean.a05.Bean1                : 我被 Spring 管理啦</span><br><span class="line">com.alibaba.druid.pool.DruidDataSource   : &#123;dataSource-<span class="number">1</span>,root&#125; inited</span><br><span class="line">config</span><br><span class="line">indi.lcp.bean.a05.AtBeanPostProcessor</span><br><span class="line">indi.lcp.bean.a05.MapperPostProcessor</span><br><span class="line">bean1</span><br><span class="line">sqlSessionFactoryBean</span><br><span class="line">dataSource</span><br><span class="line">mapper1</span><br><span class="line">mapper2</span><br></pre></td></tr></table></figure><p>容器中存在 mapper1 和 mapper2 两个 Bean。</p><h2 id="5-3-注册创建完成的-Bean"><a href="#5-3-注册创建完成的-Bean" class="headerlink" title="5.3. 注册创建完成的 Bean"></a>5.3. <strong>注册创建完成的 Bean</strong></h2><p>如果要将 Bean 添加到 Spring 容器中，需要先根据配置文件或注解信息为每一个 Bean 生成一个 BeanDefinition，然后将这些 BeanDefinition 添加到 BeanDefinitionRegistry 中，当创建 Bean 对象时，直接从 BeanDefinitionRegistry 中获取 BeanDefinition 来生成 Bean。</p><p>如果生成的 Bean 是单例的，Spring 会将它们保存到 SingletonBeanRegistry 中，后续需要时从这里面寻找，避免重复创建。</p><p>那么向 Spring 容器中添加单例 Bean 时，可以跳过注册 BeanDefinition，直接SingletonBeanRegistry 中添加创建完成的 Bean。既然添加的是创建完成的 Bean，所以 <strong>这个 Bean 不会经过 Spring 的生命周期。</strong></p><p>SingletonBeanRegistry 是一个接口，它有一个子接口名为 ConfigurableListableBeanFactory，而这恰好是 BeanFactoryPostProcessor 接口中抽象方法的参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试使用 BeanFactoryPostProcessor 注册创建完成的 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestBeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;bean2&quot;</span>, Bean2.class);</span><br><span class="line">        context.registerBean(MyBeanFactoryPostProcessor.class);</span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">        System.out.println(context.getBean(Bean1.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">            <span class="type">Bean1</span> <span class="variable">bean1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">            bean1.setName(<span class="string">&quot;lcp&quot;</span>);</span><br><span class="line">            beanFactory.registerSingleton(<span class="string">&quot;bean1&quot;</span>, bean1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@ToString</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">        <span class="meta">@Setter</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setBean2</span><span class="params">(Bean2 bean2)</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;依赖注入 bean2&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.bean2 = bean2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;初始化...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">bean2</span><br><span class="line">testBeanFactoryPostProcessor.MyBeanFactoryPostProcessor</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">TestBeanFactoryPostProcessor.Bean1(name=lcp, bean2=<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>BeanDefinition 的名称数组中不包含 bean1，也没有输出任何与经过 Spring 生命周期相关的日志信息，容器中 bean1 里注入的 bean2 也是 null。这表明通过这种方式注册的 Bean 不会注册 BeanDefinition，也不会经过 Spring 生命周期。</p><h1 id="Aware-接口"><a href="#Aware-接口" class="headerlink" title="Aware 接口"></a>Aware 接口</h1><h2 id="6-1-Aware-接口"><a href="#6-1-Aware-接口" class="headerlink" title="6.1. Aware 接口"></a>6.1. Aware 接口</h2><p>Aware 接口用于注入一些与容器相关的信息，比如：</p><ul><li>BeanNameAware 注入 Bean 的名字</li><li>BeanFactoryAware 注入 BeanFactory 容器</li><li>ApplicationContextAware 注入 ApplicationContext 容器</li><li>EmbeddedValueResolverAware 解析 ${}</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lcp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/1/8 16:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>, ApplicationContextAware &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前 Bean: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot;名字叫: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前 Bean: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot;容器是: &quot;</span> + applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;myBean&quot;</span>, MyBean.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">当前 Bean: indi.lcp.bean.a06.MyBean@16f7c8c1名字叫: myBean</span><br><span class="line">当前 Bean: indi.lcp.bean.a06.MyBean@16f7c8c1容器是: org.springframework.context.support.GenericApplicationContext@2669b199</span><br></pre></td></tr></table></figure><h2 id="6-2-InitializingBean"><a href="#6-2-InitializingBean" class="headerlink" title="6.2. InitializingBean"></a>6.2. InitializingBean</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>, ApplicationContextAware, InitializingBean &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前 Bean: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; 初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行 main() 方法有：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当前 Bean: indi.lcp.bean.a06.MyBean@16f7c8c1名字叫: myBean</span><br><span class="line">当前 Bean: indi.lcp.bean.a06.MyBean@16f7c8c1容器是: org.springframework.context.support.GenericApplicationContext@2669b199</span><br><span class="line">当前 Bean: indi.lcp.bean.a06.MyBean<span class="meta">@df27fae</span> 初始化</span><br></pre></td></tr></table></figure><p>当同时实现 Aware 接口和 InitializingBean 接口时，会先执行 Aware 接口。</p><p>BeanFactoryAware 、ApplicationContextAware 和 EmbeddedValueResolverAware 三个接口的功能可以使用 @Autowired 注解实现，InitializingBean 接口的功能也可以使用 @PostConstruct 注解实现，为什么还要使用接口呢？</p><p>@Autowired 和 @PostConstruct 注解的解析需要使用 Bean 后置处理器，属于拓展功能，而这些接口属于内置功能，不加任何拓展 Spring 就能识别。在某些情况下，拓展功能会失效，而内容功能不会失效。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">BeanNameAware</span>, ApplicationContextAware, InitializingBean &#123;</span><br><span class="line">           <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContextWithAutowired</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前 Bean: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; 使用 @Autowired 注解，容器是: &quot;</span> + applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前 Bean: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot; 使用 @PostConstruct 注解初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再运行 main() 方法会发现使用的注解没有被成功解析，原因很简单，GenericApplicationContext 是一个干净的容器，其内部没有用于解析这些注解的后置处理器。如果想要这些注解生效，则需要像前文一样添加必要的后置处理器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context.registerBean(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">context.registerBean(CommonAnnotationBeanPostProcessor.class);</span><br></pre></td></tr></table></figure><h2 id="6-3-失效的-Autowired-注解"><a href="#6-3-失效的-Autowired-注解" class="headerlink" title="6.3. 失效的 @Autowired 注解"></a>6.3. 失效的 @Autowired 注解</h2><p>在某些情况下，尽管容器中存在必要的后置处理器，但 @Autowired 和 @PostConstruct 注解也会失效。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig1</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;注入 ApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;myConfig1&quot;</span>, MyConfig1.class);</span><br><span class="line">    context.registerBean(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">    context.registerBean(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">    <span class="comment">// 解析配置类中的注解</span></span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a06.MyConfig1            : 注入 ApplicationContext</span><br><span class="line">indi.lcp.bean.a06.MyConfig1            : 初始化</span><br></pre></td></tr></table></figure><p>@Autowired 和 @PostConstruct 注解成功被解析。</p><p>如果再对 Config1 进行一点小小的修改呢?</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig1</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BeanFactoryPostProcessor <span class="title function_">processor1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> processor -&gt; log.info(<span class="string">&quot;执行 processor1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Config1 中添加了一个被 @Bean 注解标记的 processor1() 方法，用于向容器中添加 BeanFactoryPostProcessor。</p><p>如果再运行 main() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.bean.a06.MyConfig1            : 执行 processor1</span><br></pre></td></tr></table></figure><p>processor1() 方法成功生效，但 @Autowired 和 @PostConstruct 注解的解析失败了。</p><p>对于 context.refresh(); 方法来说，它主要按照以下顺序干了三件事：</p><ul><li>执行 BeanFactory 后置处理器；</li><li>添加 Bean 后置处理器；</li><li>创建和初始化单例对象。</li></ul><p>比如当 Java 配置类不包括 BeanFactoryPostProcessor 时：</p><p>BeanFactoryPostProcessor 会在 Java 配置类初始化之前执行。</p><p>当 Java 配置类中定义了BeanFactoryPostProcessor 时，如果要创建配置类中的 BeanFactoryPostProcessor 就必须 提前 创建和初始化 Java 配置类。</p><p>在创建和初始化 Java 配置类时，由于 BeanPostProcessor 还未准备好，无法解析配置类中的 @Autowired 等注解，导致 @Autowired 等注解失效：</p><p>要解决这个问题也很简单，使用相关接口的功能实现注入和初始化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig2</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span>, ApplicationContextAware &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;注入 ApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BeanFactoryPostProcessor <span class="title function_">processor2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> processor -&gt; log.info(<span class="string">&quot;执行 processor2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改下 main() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;myConfig2&quot;</span>, MyConfig2.class);</span><br><span class="line">    context.registerBean(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">    context.registerBean(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析配置类中的注解</span></span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a06.MyConfig2            : 注入 ApplicationContext</span><br><span class="line">indi.lcp.bean.a06.MyConfig2            : 初始化</span><br><span class="line">indi.lcp.bean.a06.MyConfig2            : 执行 processor2</span><br></pre></td></tr></table></figure><ol><li><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li><li><p>Aware 接口提供了一种 内置 的注入手段，可以注入 BeanFactory、ApplicationContext；</p></li><li><p>InitializingBean 接口提供了一种 内置 的初始化手段；</p></li><li><p>内置的注入和初始化不受拓展功能的影响，总会被执行，因此 Spring 框架内部的类总是使用这些接口。</p></li></ol><h1 id="初始化与销毁"><a href="#初始化与销毁" class="headerlink" title="初始化与销毁"></a>初始化与销毁</h1><p>初始化和销毁 Bean 的实现有三种：</p><ol><li>依赖于后置处理器提供的拓展功能</li><li>相关接口的功能</li><li>使用 @Bean 注解中的属性进行指定</li></ol><p>当同时存在以上三种方式时，它们的执行顺序也将按照上述顺序进行执行。</p><p>包含三种初始化方式的 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;初始化1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;初始化2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init3</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;初始化3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含三种销毁方式的 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> <span class="keyword">implements</span> <span class="title class_">DisposableBean</span> &#123;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy1</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;销毁1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;销毁2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy3</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;销毁3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A07Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A07Application.class, args);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;init3&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(destroyMethod = &quot;destroy3&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a07.Bean1                : 初始化<span class="number">1</span></span><br><span class="line">indi.lcp.bean.a07.Bean1                : 初始化<span class="number">2</span></span><br><span class="line">indi.lcp.bean.a07.Bean1                : 初始化<span class="number">3</span></span><br><span class="line">indi.lcp.bean.a07.Bean2                : 销毁<span class="number">1</span></span><br><span class="line">indi.lcp.bean.a07.Bean2                : 销毁<span class="number">2</span></span><br><span class="line">indi.lcp.bean.a07.Bean2                : 销毁<span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h1><h2 id="8-1-Scope-的类型与销毁"><a href="#8-1-Scope-的类型与销毁" class="headerlink" title="8.1 Scope 的类型与销毁"></a>8.1 Scope 的类型与销毁</h2><p>Scope 用于指定 Bean 的作用范围，有如下五个取值：</p><ul><li>singleton：单例（默认值）。容器启动时创建（未设置延迟），容器关闭时销毁</li><li>prototype：多例。每次使用时创建，不会自动销毁，需要调用 DefaultListableBeanFactory#destroyBean() 进行销毁</li><li>request：作用于 Web 应用的请求范围。每次请求用到此 Bean 时创建，请求结束时销毁</li><li>session：作用于 Web 应用的会话范围。每个会话用到此 Bean 时创建，会话结束时销毁</li><li>application：作用于 Web 应用的 ServletContext。Web 容器用到此 Bean 时创建，容器关闭时销毁</li></ul><p>前两个取值不再赘述，重点看下后三个取值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(WebApplicationContext.SCOPE_REQUEST)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanForRequest</span> &#123;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(WebApplicationContext.SCOPE_SESSION)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanForSession</span> &#123;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(WebApplicationContext.SCOPE_APPLICATION)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanForApplication</span> &#123;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写一个 Controller 进行测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanForRequest beanForRequest;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanForSession beanForSession;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeanForApplication beanForApplication;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/test&quot;, produces = &quot;text/html&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(HttpServletRequest request, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置 session 过期时间为 10 秒</span></span><br><span class="line">        session.setMaxInactiveInterval(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// ServletContext sc = request.getServletContext();</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;ul&gt;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;li&gt;request scope: &quot;</span> +  beanForRequest + <span class="string">&quot;&lt;/li&gt;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;li&gt;session scope: &quot;</span> +  beanForSession + <span class="string">&quot;&lt;/li&gt;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;li&gt;application scope: &quot;</span> +  beanForApplication + <span class="string">&quot;&lt;/li&gt;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;&lt;/ul&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主启动类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A08Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(A08Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用的 JDK 版本大于 8，需要要启动参数中添加如下信息避免报错：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--add-opens java.base/java.lang=ALL-UNNAMED</span><br></pre></td></tr></table></figure><p>但更建议在 pom.xml 中添加以下配置，一劳永逸：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;argLine&gt;</span><br><span class="line">                    --add-opens java.base/java.lang=ALL-UNNAMED</span><br><span class="line">                &lt;/argLine&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>运行主启动类，在浏览器中访问 <a target="_blank" rel="noopener" href="http://localhost:8080/test%EF%BC%8C%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%98%BE%E7%A4%BA%EF%BC%9A">http://localhost:8080/test，页面上显示：</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request scope: indi.lcp.bean.a08.BeanForRequest@34d37122</span><br><span class="line">session scope: indi.lcp.bean.a08.BeanForSession@75ee7b19</span><br><span class="line">application scope: indi.lcp.bean.a08.BeanForApplication@68b50897</span><br></pre></td></tr></table></figure><p>刷新页面，页面上的信息变化为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request scope: indi.lcp.bean.a08.BeanForRequest@2db4ac39</span><br><span class="line">session scope: indi.lcp.bean.a08.BeanForSession@75ee7b19</span><br><span class="line">application scope: indi.lcp.bean.a08.BeanForApplication@68b50897</span><br></pre></td></tr></table></figure><p>可以看到 request scope 发生了变化，session scope 和 application scope 没有变化。</p><p>这是因为刷新页面后就产生了一个新的请求，而 request 的作用范围只在一个请求内，因此每一个新请求就对应一个新的对象。</p><p>那要怎么改变 session scope 呢？</p><p>换一个浏览器访问 <a target="_blank" rel="noopener" href="http://localhost:8080/test%EF%BC%8C%E4%B8%A4%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E4%BC%9A%E8%AF%9D%E8%82%AF%E5%AE%9A%E4%B8%8D%E6%98%AF%E5%90%8C%E4%B8%80%E4%B8%AA%EF%BC%8C%E6%AD%A4%E6%97%B6">http://localhost:8080/test，两个浏览器中的会话肯定不是同一个，此时</a> session scope 应该会发生变化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request scope: indi.lcp.bean.a08.BeanForRequest@2286f290</span><br><span class="line">session scope: indi.lcp.bean.a08.BeanForSession@4f025f73</span><br><span class="line">application scope: indi.lcp.bean.a08.BeanForApplication@68b50897</span><br></pre></td></tr></table></figure><p>application 的作用范围是 ServletContext，要想 application scope 发生变化可以重启程序。</p><ul><li>销毁</li></ul><p>当刷新页面后，除了 request scope 的值发生变化外，在 IDEA 的控制台能看到以下信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.bean.a08.BeanForRequest       : destroy</span><br></pre></td></tr></table></figure><p>这表示 request 作用范围的 Bean 进行了销毁，执行了销毁方法。</p><p>如果想看到 session 作用范围的 Bean 执行销毁方法，可以等 session 过期时在控制台上看到对应的信息。默认情况下，session 的过期时间是 30 分钟，为了更好地测试，可以在配置文件中添加：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 修改 session 过期时间为 10s</span><br><span class="line">server.servlet.session.timeout=10s</span><br></pre></td></tr></table></figure><p>这个配置是全局的，如果只想针对某个请求进行配置，则可以：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/test&quot;, produces = &quot;text/html&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(HttpServletRequest request, HttpSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置 session 过期时间为 10 秒</span></span><br><span class="line">    session.setMaxInactiveInterval(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置 session 过期时间为 10 秒后，并不表示不进行任何操作 10 秒后就能在控制台上看到执行销毁方法的信息，经过测试，大概会等 1 分钟，静静等待 1 分钟左右，控制台上显示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.bean.a08.BeanForSession       : destroy</span><br></pre></td></tr></table></figure><p>很遗憾没有办法看到 application 作用范围的 Bean 执行销毁方法，因为 Spring 似乎并没有对 application 作用范围的 Bean 进行正确的销毁处理，因此在 Servlet 容器销毁时看不到 application 作用范围的 Bean 执行销毁方法。</p><h2 id="8-2-Scope-失效分析"><a href="#8-2-Scope-失效分析" class="headerlink" title="8.2. Scope 失效分析"></a>8.2. Scope 失效分析</h2><p>现有两个类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">F1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> F1 f1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后进行测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;indi.lcp.bean.a09&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A09Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A09Application.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> context.getBean(E.class);</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF1());</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF1());</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF1());</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在问题来了：F1 被 @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) 标记，之后向 e 中注入了 f1，那么 log.info(“{}”, e.getF1()); 打印出的 f1 应该都不是同一个对象吗？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F1@5fdcaa40</span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F1@5fdcaa40</span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F1@5fdcaa40</span><br></pre></td></tr></table></figure><p>获取到的 f1 居然都是同一个，也就是说向单例对象中注入多例对象失败了。</p><p>对于单例对象来说，依赖注入仅发生了一次，后续不会再注入其他的 f1，因此 e 始终使用的是第一次注入的 f1：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NDUzMTFiYTBlZjFlZGJhZDU4NzdkOTU3ZDVjMTZhZWJfVnRoUEJZYXZaeVpTUXdsclRkSTd2VFo5UzhKUEVLdzdfVG9rZW46UWxySGJwTm1Hb2xjZEx4UEozTmNmTUhEbmtoXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>为了解决这个问题，可以使用 @Lazy 生成代理对象，虽然代理对象依旧是同一个，但每次使用代理对象中的方法时，会由代理对象创建新的目标对象：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTI3ZmUxMzE3MjU3MWM2NGRlODM5OGU5NWI1MDUwNDJfeldLT0t1QU83VVBtV3JSbmtNWmhiMHJ1clB6OHlvUDdfVG9rZW46UWU0MWJRRVdrb29JT3J4OWQxNGNNN0lZblVmXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>解决方式一</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> F1 f1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再修改下 main() 方法，打印下 f1 的 Class 信息，查看是否是代理对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A09Application.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> context.getBean(E.class);</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF1().getClass());</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF1());</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF1());</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF1());</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a09.A09Application       : <span class="keyword">class</span> <span class="title class_">indi</span>.lcp.bean.a09.F1$$EnhancerBySpringCGLIB$$ea96cbb5</span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F1@<span class="number">37271612</span></span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F1@4c309d4d</span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F1@37883b97</span><br></pre></td></tr></table></figure><p>使用 @Lazy 注解后，注入的是代理对象，每次获取到的 f1 不再是同一个。</p><p>解决方式二</p><p>除了使用 @Lazy 注解外，可以使用 @Scope 注解的 proxyMode 属性指定代理模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(</span></span><br><span class="line"><span class="meta">        value = ConfigurableBeanFactory.SCOPE_PROTOTYPE,</span></span><br><span class="line"><span class="meta">        proxyMode = ScopedProxyMode.TARGET_CLASS</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">F2</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> F2 f2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后再测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;indi.lcp.bean.a09&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A09Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A09Application.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> context.getBean(E.class);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF2().getClass());</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF2());</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF2());</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF2());</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a09.A09Application       : <span class="keyword">class</span> <span class="title class_">indi</span>.lcp.bean.a09.F2$$EnhancerBySpringCGLIB$$f28665e2</span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F2@2525ff7e</span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F2@524d6d96</span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F2@152aa092</span><br></pre></td></tr></table></figure><p>解决方式三</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">F3</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectFactory&lt;F3&gt; f3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> F3 <span class="title function_">getF3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> f3.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;indi.lcp.bean.a09&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A09Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A09Application.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> context.getBean(E.class);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF3());</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF3());</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F3@76f2bbc1</span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F3@306cf3ea</span><br></pre></td></tr></table></figure><p>解决方式四</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">F4</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> F4 <span class="title function_">getF4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext.getBean(F4.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;indi.lcp.bean.a09&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A09Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A09Application.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> context.getBean(E.class);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF4());</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, e.getF4());</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F4@2beee7ff</span><br><span class="line">indi.lcp.bean.a09.A09Application       : indi.lcp.bean.a09.F4@5136d012</span><br></pre></td></tr></table></figure><p>如果对性能要求较高，则推荐使用后两种方式，前两种使用代理会有一定的性能损耗；如果不在乎那点性能损耗，则可以使用第一种方式，这种方式最简单。</p><p>四种解决方式虽然不同，但在理念上殊途同归，都是推迟了其他 Scope Bean 的获取，或者说按需加载。</p><h1 id="AspectJ-编译器增强"><a href="#AspectJ-编译器增强" class="headerlink" title="AspectJ 编译器增强"></a>AspectJ 编译器增强</h1><p>创建一个 SpringBoot 项目，除了常见的依赖外，记得导入 AOP 相关的依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>Service 类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(MyService.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切面类，注意这个切面类没有被 Spring 管理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意此切面并未被 Spring 管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(MyAspect.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* indi.lcp.service.MyService.foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;before()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于测试的主启动类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A10Application</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(A10Application.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A10Application.class, args);</span><br><span class="line">        <span class="type">MyService</span> <span class="variable">service</span> <span class="operator">=</span> context.getBean(MyService.class);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">&quot;service class: &#123;&#125;&quot;</span>, service.getClass());</span><br><span class="line">        service.foo();</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行主启动类后，控制台会显示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.A10Application                : service class: <span class="keyword">class</span> <span class="title class_">indi</span>.lcp.service.MyService</span><br><span class="line">indi.lcp.aop.MyAspect                  : before()</span><br><span class="line">indi.lcp.service.MyService             : foo()</span><br></pre></td></tr></table></figure><p>如果完全按照上述步骤进行，会发现 输出结果和给出的结果不一样。</p><p>在揭晓答案前，查看 service.getClass() 打印出的信息，它打印出的是原始类的 Class 信息，而非代理类的 Class 信息。</p><p>如果要问到 Spring AOP 的实现原理是什么，一下就能想到的是使用了代理，但这里并没有使用代理，依旧实现了增强。</p><p>这是因为在 pom.xml 中还引入了一个插件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;aspectj-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.11</span>&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;complianceLevel&gt;<span class="number">1.8</span>&lt;/complianceLevel&gt;</span><br><span class="line">                &lt;source&gt;<span class="number">8</span>&lt;/source&gt;</span><br><span class="line">                &lt;target&gt;<span class="number">8</span>&lt;/target&gt;</span><br><span class="line">                &lt;showWeaveInfo&gt;<span class="literal">true</span>&lt;/showWeaveInfo&gt;</span><br><span class="line">                &lt;verbose&gt;<span class="literal">true</span>&lt;/verbose&gt;</span><br><span class="line">                &lt;Xlint&gt;ignore&lt;/Xlint&gt;</span><br><span class="line">                &lt;encoding&gt;UTF-<span class="number">8</span>&lt;/encoding&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;execution&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;!-- use <span class="built_in">this</span> goal to weave all your main classes --&gt;</span><br><span class="line">                        &lt;goal&gt;compile&lt;/goal&gt;</span><br><span class="line">                        &lt;!-- use <span class="built_in">this</span> goal to weave all your test classes --&gt;</span><br><span class="line">                        &lt;goal&gt;test-compile&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                &lt;/execution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>之后不再使用 IDEA 自带的编译器进行编译，而是使用 Maven 编译</p><p>编译之后查看生成的 target 文件夹下的 MyService.class 文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(MyService.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyService</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        MyAspect.aspectOf().before();</span><br><span class="line">        log.info(<span class="string">&quot;foo()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 foo() 方法中增加了一行代码：MyAspect.aspectOf().before();，也就是这行代码对 foo() 方法实现了增强。</p><p>这种方式属于编译时增强，和 Lombok 类似。</p><p>既然如此，那岂不是说使用这种方式时，没有 Spring 容器也能实现方法的增强？</p><p>确实如此。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A10Application</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(A10Application.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyService</span>();</span><br><span class="line">        log.info(<span class="string">&quot;service class: &#123;&#125;&quot;</span>, service.getClass());</span><br><span class="line">        service.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.A10Application - service class: <span class="keyword">class</span> <span class="title class_">indi</span>.lcp.service.MyService</span><br><span class="line">indi.lcp.aop.MyAspect - before()</span><br><span class="line">indi.lcp.service.MyService - foo()</span><br></pre></td></tr></table></figure><p>除此之外，使用这种方式，就算 foo() 方法是静态方法，也能够成功增强。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(MyService.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A10Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyService.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.aop.MyAspect - before()</span><br><span class="line">indi.lcp.service.MyService - foo()</span><br></pre></td></tr></table></figure><h1 id="Agent-类加载"><a href="#Agent-类加载" class="headerlink" title="Agent 类加载"></a>Agent 类加载</h1><p>重新创建一个 SpringBoot 项目，同样需要导入 AOP 相关的依赖。</p><p>一个 Service 类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo()&quot;</span>);</span><br><span class="line">        bar();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;bar()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个切面类，注意这个切面类没有被 Spring 管理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* indi.lcp.service.MyService.*())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;before()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个用于测试的主启动类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A11Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A11Application.class, args);</span><br><span class="line">        <span class="type">MyService</span> <span class="variable">service</span> <span class="operator">=</span> context.getBean(MyService.class);</span><br><span class="line">        log.info(<span class="string">&quot;service class: &#123;&#125;&quot;</span>, service.getClass());</span><br><span class="line">        service.foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行主启动类后，控制台会显示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.A11Application                : service class: <span class="keyword">class</span> <span class="title class_">indi</span>.lcp.service.MyService</span><br><span class="line">indi.lcp.aop.MyAspect                  : before()</span><br><span class="line">indi.lcp.service.MyService             : foo()</span><br><span class="line">indi.lcp.aop.MyAspect                  : before()</span><br><span class="line">indi.lcp.service.MyService             : bar()</span><br></pre></td></tr></table></figure><p>如果完全按照上述步骤进行，会发现输出结果和给出的结果不一样。</p><p>那是怎么达到增强的效果呢？</p><p>首先得在 resources 目录下新建 META-INF 文件夹，并在 META-INF 目录下新建 aop.xml 文件，其内容如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;aspectj&gt;</span><br><span class="line">    &lt;aspects&gt;</span><br><span class="line">        &lt;!--    切面类全限定类名    --&gt;</span><br><span class="line">        &lt;aspect name=<span class="string">&quot;indi.lcp.aop.MyAspect&quot;</span>/&gt;</span><br><span class="line">        &lt;weaver options=<span class="string">&quot;-verbose -showWeaveInfo&quot;</span>&gt;</span><br><span class="line">            &lt;!--      被增强方法所在类的全限定类名      --&gt;</span><br><span class="line">            &lt;include within=<span class="string">&quot;indi.lcp.service.MyService&quot;</span>/&gt;</span><br><span class="line">            &lt;!--    切面类全限定类名    --&gt;</span><br><span class="line">            &lt;include within=<span class="string">&quot;indi.lcp.aop.MyAspect&quot;</span>/&gt;</span><br><span class="line">        &lt;/weaver&gt;</span><br><span class="line">    &lt;/aspects&gt;</span><br><span class="line">&lt;/aspectj&gt;</span><br></pre></td></tr></table></figure><p>在运行 main() 方法前添加 VM options：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-javaagent:D:\environment\Maven\<span class="number">3.6</span><span class="number">.3</span>-repository\.m2\repository\org\aspectj\aspectjweaver\<span class="number">1.9</span><span class="number">.7</span>\aspectjweaver-<span class="number">1.9</span><span class="number">.7</span>.jar</span><br></pre></td></tr></table></figure><p>其中的 D:\environment\Maven\3.6.3-repository.m2 指本地 Maven 仓库地址，还需要确保本地仓库中存在 1.9.7 版本的 aspectjweaver，否则修改至对应版本。</p><p>这时控制台输出的信息就和前文的内容一样了。</p><p>从输出的内容可以看到 service.getClass() 打印出的信息也是原始类的 Class 信息，而非代理类的 Class 信息。因此不依赖 Spring 容器，直接 new 一个 MyService 实例并调用其 foo() 方法也能达到增强的目的。</p><p>如果查看 MyService 对应的 class 文件，会发现其内容并没有被修改，可以断定不是编译时增强，这里是在类加载时增强</p><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><ol><li><h2 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h2></li></ol><p>JDK 动态代理 只能 针对接口进行代理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标对象</span></span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来加载在运行期间动态生成的字节码</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> JdkProxyDemo.class.getClassLoader();</span><br><span class="line">        <span class="type">Foo</span> <span class="variable">proxy</span> <span class="operator">=</span> (Foo) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Foo.class&#125;, (p, method, params) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">            <span class="comment">// 目标.方法(参数) --&gt; 方法.invoke(目标, 参数)</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, params);</span><br><span class="line">            System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">            <span class="comment">// 也返回目标方法执行的结果</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        proxy.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before...</span><br><span class="line">target foo</span><br><span class="line">after...</span><br></pre></td></tr></table></figure><p>代理对象和目标对象是兄弟关系，都实现了相同的接口，因此不能将代理对象强转成目标对象类型；</p><p>代理类与目标类之间没有继承关系，因此目标类可以被 final 修饰。</p><h2 id="11-2-CGLib-动态代理"><a href="#11-2-CGLib-动态代理" class="headerlink" title="11.2. CGLib 动态代理"></a>11.2. CGLib 动态代理</h2><p>CGLib 动态代理与 JDK 动态代理不一样，无需目标类实现某个特定的接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Target</span> <span class="variable">proxy</span> <span class="operator">=</span> (Target) Enhancer.create(Target.class, (MethodInterceptor) (obj, method, params, methodProxy) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">            <span class="comment">// 用方法反射调用目标</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, params);</span><br><span class="line">            System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        proxy.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before...</span><br><span class="line">target foo</span><br><span class="line">after...</span><br></pre></td></tr></table></figure><p>调用目标方法的方式有三种，上文使用的是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, params);</span><br></pre></td></tr></table></figure><p>使用这种方式，将利用反射对目标方法进行调用。</p><p>还可以使用 methodProxy 不利用反射对目标方法进行调用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部没使用反射，需要目标（spring 的选择）</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> methodProxy.invoke(target, args); </span><br><span class="line"><span class="comment">// 内部没使用反射，需要代理</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> methodProxy.invokeSuper(obj, args); </span><br></pre></td></tr></table></figure><ul><li>与 JDK 动态代理相比，CGLib 动态代理无需实现接口</li><li>代理对象和目标对象是父子关系，也就是说代理类继承了目标类</li><li>由于代理类继承了目标类，因此目标类不能被 final 修饰，否则将出现以下异常信息：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: Cannot subclass <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a12.CglibProxyDemo$Target</span><br></pre></td></tr></table></figure><ul><li>代理类继承目标类后，还会重写目标类中要求被增强的方法，因此被增强的方法不能被 final 修饰，否则将无法被增强，但不会抛出异常</li></ul><h1 id="JDK-动态代理原理"><a href="#JDK-动态代理原理" class="headerlink" title="JDK 动态代理原理"></a>JDK 动态代理原理</h1><h2 id="12-1-JDK-动态代理的模拟"><a href="#12-1-JDK-动态代理的模拟" class="headerlink" title="12.1 JDK 动态代理的模拟"></a>12.1 JDK 动态代理的模拟</h2><p>模拟 JDK 动态代理的实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">implements</span> <span class="title class_">A13</span>.Foo&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 功能增强</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 调用目标</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">A13</span>.Target().foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">$Proxy0</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">$Proxy0</span>();</span><br><span class="line">    proxy.foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before...</span><br><span class="line">target foo</span><br></pre></td></tr></table></figure><p>代码的实现很简单，但仔细想一下，如果是 JDK 中的实现：</p><p>“功能增强”的代码实现会直接硬编码吗？直接打印？</p><p>“调用目标”的代码就这样直接写上去？存不存在满足某些条件才调用目标的场景呢？</p><p>也就是说，“功能增强”和“调用目标”这两部分的代码都是不确定的。</p><p>针对这种“不确定”的实现，可以提供一个抽象类，等到用户具体使用时才实现抽象类，重写抽象方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">implements</span> <span class="title class_">A13</span>.Foo&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> A13.InvocationHandler h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(A13.InvocationHandler h) &#123;</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        h.invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">$Proxy0</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">$Proxy0</span>(<span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 功能增强</span></span><br><span class="line">            System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">            <span class="comment">// 2. 调用目标</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">A13</span>.Target().foo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    proxy.foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法，控制台依旧成功打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before...</span><br><span class="line">target foo</span><br></pre></td></tr></table></figure><p>多个抽象方法的接口</p><p>这样的实现依旧有问题，如果接口中提供了两个抽象方法呢？比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时无论是目标类，还是代理类都要重写这个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">implements</span> <span class="title class_">A13</span>.Foo&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> A13.InvocationHandler h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(A13.InvocationHandler h) &#123;</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        h.invoke();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        h.invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">$Proxy0</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">$Proxy0</span>(<span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 功能增强</span></span><br><span class="line">            System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">            <span class="comment">// 2. 调用目标</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">A13</span>.Target().foo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    proxy.foo();</span><br><span class="line">    <span class="comment">// 调用另一个方法</span></span><br><span class="line">    proxy.bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时再执行 main() 方法，控制台上打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before...</span><br><span class="line">target foo</span><br><span class="line">before...</span><br><span class="line">target foo</span><br></pre></td></tr></table></figure><p>打印结果有点问题。当调用代理对象的 bar() 方法时，输出了 target foo，而不是 bar() 方法应该打印的 target bar。</p><p>原因就出在实现 InvocationHandler 的 invoke() 方法时，依旧只调用了目标类的 foo() 方法，而不是 bar() 方法。</p><p>也就是说，在调用代理对象中的某个方法时，增强的应该是目标对象中对应的方法，希望在调用目标方法时能够动态编码。</p><p>那么可以在 invoke() 方法中添加两个入参，分别表示需要调用的目标方法和目标方法的参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加参数之后需要修改代理类，并将实现的抽象方法的 Method 对象与参数传递给 invoke() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">implements</span> <span class="title class_">A13</span>.Foo&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> A13.InvocationHandler h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(A13.InvocationHandler h) &#123;</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> A13.Foo.class.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        h.invoke(method, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> A13.Foo.class.getMethod(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        h.invoke(method, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要修改下 main() 方法中 InvocationHandler 的实现，利用传递的 Method 对象和参数信息反射调用目标方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">$Proxy0</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">$Proxy0</span>(<span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            <span class="comment">// 1. 功能增强</span></span><br><span class="line">            System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">            <span class="comment">// 2. 调用目标</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(<span class="keyword">new</span> <span class="title class_">Target</span>(), params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    proxy.foo();</span><br><span class="line">    <span class="comment">// 调用另一个方法</span></span><br><span class="line">    proxy.bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再执行 main() 方法，控制台上打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before...</span><br><span class="line">target foo</span><br><span class="line">before...</span><br><span class="line">target bar</span><br></pre></td></tr></table></figure><p>有返回值的抽象方法</p><p>优化还在继续，如果抽象方法有返回值呢？比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现了这个接口的目标类和代理类重写的方法都需要有具体的返回值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target bar&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标类很简单，直接返回，那代理类返回什么？</p><p>InvocationHandler 的 invoke() 方法是对“功能增强”和“调用目标”的抽象，因此可以使 invoke() 方法也返回一个值，返回的值即为目标方法的返回值，这样就可以使得代理类中的方法有值可返。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    Object <span class="title function_">invoke</span><span class="params">(Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">implements</span> <span class="title class_">A13</span>.Foo &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> A13.InvocationHandler h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(A13.InvocationHandler h) &#123;</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">foo</span> <span class="operator">=</span> A13.Foo.class.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">            h.invoke(foo, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">bar</span> <span class="operator">=</span> A13.Foo.class.getMethod(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) h.invoke(bar, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 main() 方法，打印 bar() 方法的返回值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">$Proxy0</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">$Proxy0</span>(<span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            <span class="comment">// 1. 功能增强</span></span><br><span class="line">            System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">            <span class="comment">// 2. 调用目标</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">new</span> <span class="title class_">Target</span>(), params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    proxy.foo();</span><br><span class="line">    <span class="comment">// 调用另一个方法</span></span><br><span class="line">    System.out.println(proxy.bar());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before...</span><br><span class="line">target foo</span><br><span class="line">before...</span><br><span class="line">target bar</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure><p>在静态代码块里创建 Method 实例</p><p>每调用一次代理对象中的方法都会创建一个 Method 实例，这些实例是可以复用的，因此可以将这些实例的创建移动到静态代码块中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">implements</span> <span class="title class_">A13</span>.Foo &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> A13.InvocationHandler h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(A13.InvocationHandler h) &#123;</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            h.invoke(foo, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) h.invoke(bar, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Method foo;</span><br><span class="line">    <span class="keyword">static</span> Method bar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            foo = A13.Foo.class.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">            bar = A13.Foo.class.getMethod(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>invoke() 方法增加代理对象作为参数</p><p>在 JDK 提供的 InvocationHandler 接口的 invoke() 方法还将代理对象作为方法的参数，以便用户根据实际情况使用。继续修改自定义的 InvocationHandler 接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改代理类中对 invoke() 方法的调用，第一个参数为当前类的实例，即 this：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">implements</span> <span class="title class_">A13</span>.Foo &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            h.invoke(<span class="built_in">this</span>, foo, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) h.invoke(<span class="built_in">this</span>, bar, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main() 方法重写的 invoke() 方法也要增加 proxy 参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">$Proxy0</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">$Proxy0</span>(<span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            <span class="comment">// 1. 功能增强</span></span><br><span class="line">            System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">            <span class="comment">// 2. 调用目标</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">new</span> <span class="title class_">Target</span>(), params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    proxy.foo();</span><br><span class="line">    <span class="comment">// 调用另一个方法</span></span><br><span class="line">    System.out.println(proxy.bar());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法，结果不发生变化。</p><p>向 JDK 靠齐</p><p>到此为止，自定义的 InvocationHandler 接口与 JDK 提供的 InvocationHandler 接口无异，注释自定义的 InvocationHandler，更换为 JDK 提供的 InvocationHandler 接口。</p><p>在 JDK 提供的 InvocationHandler 接口的注释中有一句：@see Proxy，在 Proxy 类的代码中有：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Proxy</span><span class="params">(InvocationHandler h)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy 类中有一个 InvocationHandler 对象的成员变量。</p><p>因此还可以使代理类 $Proxy0 继承 Proxy 来进一步减少代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">A13</span>.Foo &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6909541593982979501L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler h) &#123;</span><br><span class="line">        <span class="built_in">super</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-2-代理类的源码"><a href="#12-2-代理类的源码" class="headerlink" title="12.2 代理类的源码"></a>12.2 代理类的源码</h2><p>JDK 动态代理生成的代理类是以字节码的形式存在的，并不存在所谓的 .java 文件，但也不是说就没办法看到生成的代理类信息了。</p><p>以【11.1 JDK 动态代理】中的程序为例，查看 JDK 生成的代理类信息。</p><p>利用 Arthas 反编译代理类字节码文件</p><p>如果要使用 Arthas 的反编译功能需要满足两个条件：</p><p>知道被反编译文件的全限定类名</p><p>程序不能中断，需要存在 Java 进程</p><p>为了满足这个条件，可以在控制台打印出生成的代理类的全限定类名，然后利用阻塞 IO 使程序不中断：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 原始对象</span></span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来加载在运行期间动态生成的字节码</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> JdkProxyDemo.class.getClassLoader();</span><br><span class="line">    <span class="type">Foo</span> <span class="variable">proxy</span> <span class="operator">=</span> (Foo) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Foo.class&#125;, (p, method, params) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">        <span class="comment">// 目标.方法(参数) --&gt; 方法.invoke(目标, 参数)</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, params);</span><br><span class="line">        System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">        <span class="comment">// 也返回目标方法执行的结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印代理类的全限定类名</span></span><br><span class="line">    System.out.println(proxy.getClass());</span><br><span class="line">    </span><br><span class="line">    proxy.foo();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只要不在控制台上输入并回车，程序就不会终端</span></span><br><span class="line">    System.in.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a12.$Proxy0</span><br><span class="line">before...</span><br><span class="line">target foo</span><br><span class="line">after...</span><br></pre></td></tr></table></figure><p>其中的 indi.lcp.a12.$Proxy0 就是生成的代理类的全限定类名，可以把它复制下来，之后按照【10. Agent 类加载】中使用 Arthas 的方式 indi.lcp.a12.$Proxy0 进行反编译即可。</p><p>将生成的代理类字节码文件保存在磁盘上</p><p>除了借助外部工具外，还可以直接将 JDK 生成的代理类字节码文件保存在磁盘上，其做法与【Lambda 与序列化】一文中将函数式接口动态生成的 Class 保存到磁盘上类似。</p><p>可以在 main() 方法开头加一句：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.getProperties().put(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">System.getProperties().put(<span class="string">&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br></pre></td></tr></table></figure><p>不同版本的 JDK 添加的配置信息不同，至于具体是哪一个可以查看 JDK 中 ProxyGenerator 类中的 saveGeneratedFiles 成员变量，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">saveGeneratedFiles</span> <span class="operator">=</span> (Boolean)AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">GetBooleanAction</span>(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>));</span><br></pre></td></tr></table></figure><p>显然，此处应该使用第一种方式来设置系统属性。最终的 main() 方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 将动态代理生成的 class 保存到磁盘</span></span><br><span class="line">     System.getProperties().put(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原始对象</span></span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来加载在运行期间动态生成的字节码</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> JdkProxyDemo.class.getClassLoader();</span><br><span class="line">    <span class="type">Foo</span> <span class="variable">proxy</span> <span class="operator">=</span> (Foo) Proxy.newProxyInstance(classLoader, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Foo.class&#125;, (p, method, params) -&gt; &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    proxy.foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，还可以通过在运行前添加 VM options：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Dsun.misc.ProxyGenerator.saveGeneratedFiles=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>如果既在代码里设置了系统属性，又配置了 VM options，最终以代码中的配置为主。</p><p>运行 main() 方法，在当前项目目录下生成 indi.lcp.a12.$Proxy0.class 文件，查看其内容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="built_in">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m2, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m3, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m0, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;indi.lcp.a12.JdkProxyDemo$Foo&quot;</span>).getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其内容与自定义的 $Proxy0 几乎无异，只不过 JDK 生成的代理类信息还生成 equals()、toString() 和 hashCode() 三个方法对应的 Method 对象，并对它们也进行了相同的增强。</p><h2 id="12-3-JDK-代理类字节码生成"><a href="#12-3-JDK-代理类字节码生成" class="headerlink" title="12.3 JDK 代理类字节码生成"></a>12.3 JDK 代理类字节码生成</h2><p>JDK 在生成代理类时，没有经历源码阶段、编译阶段，而是直接到字节码阶段，使用了 ASM 来完成。</p><p>ASM 的学习成本较高，在此不做过多介绍，本节将采用一直“曲线求国”的方式，使用 IDEA 的 ASM Bytecode outline 插件将 Java 源码转换成使用 ASM 编写的代码。</p><p>ASM Bytecode outline 插件在高版本 Java 中可能无法很好地工作，建议在 Java8 环境下使用。</p><p>自行编写一个接口和代理类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6059465134835974286L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Method foo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            foo = Foo.class.getMethod(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler h) &#123;</span><br><span class="line">        <span class="built_in">super</span>(h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, foo, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上述代码进行编译，编译成功后在 $Proxy0 文件中右击，选择 Show Bytecode outline 浏览当前类对应的字节码信息</p><p>查看 ASMified，并拷贝其内容，复制到 $Proxy0Dump 中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> jdk.internal.org.objectweb.asm.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lcp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/1/16 22:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">$Proxy0Dump</span> <span class="keyword">implements</span> <span class="title class_">Opcodes</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] dump() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">        FieldVisitor fv;</span><br><span class="line">        MethodVisitor mv;</span><br><span class="line">        AnnotationVisitor av0;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成类信息</span></span><br><span class="line">        cw.visit(<span class="number">52</span>, ACC_PUBLIC + ACC_SUPER, <span class="string">&quot;indi/lcp/$Proxy0&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;java/lang/reflect/Proxy&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;indi/lcp/Foo&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line">        cw.visitSource(<span class="string">&quot;$Proxy0.java&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            fv = cw.visitField(ACC_PRIVATE + ACC_FINAL + ACC_STATIC, <span class="string">&quot;serialVersionUID&quot;</span>, <span class="string">&quot;J&quot;</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Long</span>(<span class="number">6059465134835974286L</span>));</span><br><span class="line">            fv.visitEnd();</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            fv = cw.visitField(ACC_STATIC, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;Ljava/lang/reflect/Method;&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            fv.visitEnd();</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            mv = cw.visitMethod(ACC_PROTECTED, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            mv.visitParameter(<span class="string">&quot;h&quot;</span>, <span class="number">0</span>);</span><br><span class="line">            mv.visitCode();</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            mv.visitLabel(l0);</span><br><span class="line">            mv.visitLineNumber(<span class="number">26</span>, l0);</span><br><span class="line">            mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">            mv.visitVarInsn(ALOAD, <span class="number">1</span>);</span><br><span class="line">            mv.visitMethodInsn(INVOKESPECIAL, <span class="string">&quot;java/lang/reflect/Proxy&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/reflect/InvocationHandler;)V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            mv.visitLabel(l1);</span><br><span class="line">            mv.visitLineNumber(<span class="number">27</span>, l1);</span><br><span class="line">            mv.visitInsn(RETURN);</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            mv.visitLabel(l2);</span><br><span class="line">            mv.visitLocalVariable(<span class="string">&quot;this&quot;</span>, <span class="string">&quot;Lindi/lcp/$Proxy0;&quot;</span>, <span class="literal">null</span>, l0, l2, <span class="number">0</span>);</span><br><span class="line">            mv.visitLocalVariable(<span class="string">&quot;h&quot;</span>, <span class="string">&quot;Ljava/lang/reflect/InvocationHandler;&quot;</span>, <span class="literal">null</span>, l0, l2, <span class="number">1</span>);</span><br><span class="line">            mv.visitMaxs(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">            mv.visitEnd();</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            mv = cw.visitMethod(ACC_PUBLIC, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            mv.visitCode();</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            mv.visitTryCatchBlock(l0, l1, l2, <span class="string">&quot;java/lang/Throwable&quot;</span>);</span><br><span class="line">            mv.visitLabel(l0);</span><br><span class="line">            mv.visitLineNumber(<span class="number">32</span>, l0);</span><br><span class="line">            mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">            mv.visitFieldInsn(GETFIELD, <span class="string">&quot;indi/lcp/$Proxy0&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;Ljava/lang/reflect/InvocationHandler;&quot;</span>);</span><br><span class="line">            mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">            mv.visitFieldInsn(GETSTATIC, <span class="string">&quot;indi/lcp/$Proxy0&quot;</span>, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;Ljava/lang/reflect/Method;&quot;</span>);</span><br><span class="line">            mv.visitInsn(ACONST_NULL);</span><br><span class="line">            mv.visitMethodInsn(INVOKEINTERFACE, <span class="string">&quot;java/lang/reflect/InvocationHandler&quot;</span>, <span class="string">&quot;invoke&quot;</span>, <span class="string">&quot;(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">            mv.visitInsn(POP);</span><br><span class="line">            mv.visitLabel(l1);</span><br><span class="line">            mv.visitLineNumber(<span class="number">35</span>, l1);</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            mv.visitJumpInsn(GOTO, l3);</span><br><span class="line">            mv.visitLabel(l2);</span><br><span class="line">            mv.visitLineNumber(<span class="number">33</span>, l2);</span><br><span class="line">            mv.visitFrame(Opcodes.F_SAME1, <span class="number">0</span>, <span class="literal">null</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;java/lang/Throwable&quot;</span>&#125;);</span><br><span class="line">            mv.visitVarInsn(ASTORE, <span class="number">1</span>);</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            mv.visitLabel(l4);</span><br><span class="line">            mv.visitLineNumber(<span class="number">34</span>, l4);</span><br><span class="line">            mv.visitTypeInsn(NEW, <span class="string">&quot;java/lang/reflect/UndeclaredThrowableException&quot;</span>);</span><br><span class="line">            mv.visitInsn(DUP);</span><br><span class="line">            mv.visitVarInsn(ALOAD, <span class="number">1</span>);</span><br><span class="line">            mv.visitMethodInsn(INVOKESPECIAL, <span class="string">&quot;java/lang/reflect/UndeclaredThrowableException&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/Throwable;)V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            mv.visitInsn(ATHROW);</span><br><span class="line">            mv.visitLabel(l3);</span><br><span class="line">            mv.visitLineNumber(<span class="number">36</span>, l3);</span><br><span class="line">            mv.visitFrame(Opcodes.F_SAME, <span class="number">0</span>, <span class="literal">null</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">            mv.visitInsn(RETURN);</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            mv.visitLabel(l5);</span><br><span class="line">            mv.visitLocalVariable(<span class="string">&quot;throwable&quot;</span>, <span class="string">&quot;Ljava/lang/Throwable;&quot;</span>, <span class="literal">null</span>, l4, l3, <span class="number">1</span>);</span><br><span class="line">            mv.visitLocalVariable(<span class="string">&quot;this&quot;</span>, <span class="string">&quot;Lindi/lcp/$Proxy0;&quot;</span>, <span class="literal">null</span>, l0, l5, <span class="number">0</span>);</span><br><span class="line">            mv.visitMaxs(<span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">            mv.visitEnd();</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            mv = cw.visitMethod(ACC_STATIC, <span class="string">&quot;&lt;clinit&gt;&quot;</span>, <span class="string">&quot;()V&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">            mv.visitCode();</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            mv.visitTryCatchBlock(l0, l1, l2, <span class="string">&quot;java/lang/NoSuchMethodException&quot;</span>);</span><br><span class="line">            mv.visitLabel(l0);</span><br><span class="line">            mv.visitLineNumber(<span class="number">19</span>, l0);</span><br><span class="line">            mv.visitLdcInsn(Type.getType(<span class="string">&quot;Lindi/lcp/Foo;&quot;</span>));</span><br><span class="line">            mv.visitLdcInsn(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">            mv.visitInsn(ICONST_0);</span><br><span class="line">            mv.visitTypeInsn(ANEWARRAY, <span class="string">&quot;java/lang/Class&quot;</span>);</span><br><span class="line">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/lang/Class&quot;</span>, <span class="string">&quot;getMethod&quot;</span>, <span class="string">&quot;(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            mv.visitFieldInsn(PUTSTATIC, <span class="string">&quot;indi/lcp/$Proxy0&quot;</span>, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;Ljava/lang/reflect/Method;&quot;</span>);</span><br><span class="line">            mv.visitLabel(l1);</span><br><span class="line">            mv.visitLineNumber(<span class="number">22</span>, l1);</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            mv.visitJumpInsn(GOTO, l3);</span><br><span class="line">            mv.visitLabel(l2);</span><br><span class="line">            mv.visitLineNumber(<span class="number">20</span>, l2);</span><br><span class="line">            mv.visitFrame(Opcodes.F_SAME1, <span class="number">0</span>, <span class="literal">null</span>, <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;java/lang/NoSuchMethodException&quot;</span>&#125;);</span><br><span class="line">            mv.visitVarInsn(ASTORE, <span class="number">0</span>);</span><br><span class="line">            <span class="type">Label</span> <span class="variable">l4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>();</span><br><span class="line">            mv.visitLabel(l4);</span><br><span class="line">            mv.visitLineNumber(<span class="number">21</span>, l4);</span><br><span class="line">            mv.visitTypeInsn(NEW, <span class="string">&quot;java/lang/NoSuchMethodError&quot;</span>);</span><br><span class="line">            mv.visitInsn(DUP);</span><br><span class="line">            mv.visitVarInsn(ALOAD, <span class="number">0</span>);</span><br><span class="line">            mv.visitMethodInsn(INVOKEVIRTUAL, <span class="string">&quot;java/lang/NoSuchMethodException&quot;</span>, <span class="string">&quot;getMessage&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            mv.visitMethodInsn(INVOKESPECIAL, <span class="string">&quot;java/lang/NoSuchMethodError&quot;</span>, <span class="string">&quot;&lt;init&gt;&quot;</span>, <span class="string">&quot;(Ljava/lang/String;)V&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            mv.visitInsn(ATHROW);</span><br><span class="line">            mv.visitLabel(l3);</span><br><span class="line">            mv.visitLineNumber(<span class="number">23</span>, l3);</span><br><span class="line">            mv.visitFrame(Opcodes.F_SAME, <span class="number">0</span>, <span class="literal">null</span>, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">            mv.visitInsn(RETURN);</span><br><span class="line">            mv.visitLocalVariable(<span class="string">&quot;e&quot;</span>, <span class="string">&quot;Ljava/lang/NoSuchMethodException;&quot;</span>, <span class="literal">null</span>, l4, l3, <span class="number">0</span>);</span><br><span class="line">            mv.visitMaxs(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">            mv.visitEnd();</span><br><span class="line">        &#125;</span><br><span class="line">        cw.visitEnd();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cw.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试方法使用 $Proxy0Dump 生成 $Proxy0 的 class 文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProxy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">byte</span>[] dump = $Proxy0Dump.dump();</span><br><span class="line"></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;$Proxy0.class&quot;</span>);</span><br><span class="line">        os.write(dump, <span class="number">0</span>, dump.length);</span><br><span class="line">        os.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，在工作目录下生成 $Proxy0.class。</p><p>工作目录查看方式：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGUxMTExNDRkYzgyYWI2YzVmMjBkYjU3OTkwODljZjRfMHFXVHRPWDFGbkQyMVB6UGZvREJ6eTczUnZIY1JLOW9fVG9rZW46VmlDd2JoSm1Jb1ZxSWx4R3E2Q2NoR2RWbjdnXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>也就是说会在 D:\Code\IdeaCode\advanced-spring 目录下生成 $Proxy0.class 文件，IDEA 反编译后的内容与手动编写的 $Proxy0.java 文件的内容无异。</p><p>实际使用时并不需要使用 $Proxy0Dump 生成 $Proxy.class 文件，而是利用 ClassLoader 直接加载类信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">byte</span>[] dump = $Proxy0Dump.dump();</span><br><span class="line"></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoader</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.defineClass(name, dump, <span class="number">0</span>, dump.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; proxyClass = classLoader.loadClass(<span class="string">&quot;indi.lcp.$Proxy0&quot;</span>);</span><br><span class="line">    Constructor&lt;?&gt; constructor = proxyClass.getConstructor(InvocationHandler.class);</span><br><span class="line">    <span class="type">Foo</span> <span class="variable">fooProxy</span> <span class="operator">=</span> (Foo) constructor.newInstance((InvocationHandler) (proxy, method, args1) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;模拟调用目标&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    fooProxy.foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before...</span><br><span class="line">模拟调用目标</span><br></pre></td></tr></table></figure><h2 id="12-4-JDK-反射优化"><a href="#12-4-JDK-反射优化" class="headerlink" title="12.4 JDK 反射优化"></a>12.4 JDK 反射优化</h2><p>使用 JDK 的动态代理时，会使用反射调用方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, params);</span><br></pre></td></tr></table></figure><p>相比于正常调用方法，利用反射的性能要稍微低一些，JDK 有怎么反射进行优化吗？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMethodProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">foo</span> <span class="operator">=</span> TestMethodProxy.class.getMethod(<span class="string">&quot;foo&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">17</span>; i++) &#123;</span><br><span class="line">            show(i, foo);</span><br><span class="line">            foo.invoke(<span class="literal">null</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法反射调用时，底层使用了 MethodAccessor 的实现类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> i, Method foo)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">getMethodAccessor</span> <span class="operator">=</span> Method.class.getDeclaredMethod(<span class="string">&quot;getMethodAccessor&quot;</span>);</span><br><span class="line">        getMethodAccessor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> getMethodAccessor.invoke(foo);</span><br><span class="line">        <span class="keyword">if</span> (invoke == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot;:&quot;</span> + <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// DelegatingMethodAccessorImpl 的全限定类名（不同版本的 JDK 存在差异）</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">delegate</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.DelegatingMethodAccessorImpl&quot;</span>).getDeclaredField(<span class="string">&quot;delegate&quot;</span>);</span><br><span class="line">        delegate.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(i + <span class="string">&quot;: &quot;</span> + delegate.get(invoke));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        System.out.println(i + <span class="string">&quot;: foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: <span class="literal">null</span></span><br><span class="line"><span class="number">1</span>: foo</span><br><span class="line"><span class="number">2</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">2</span>: foo</span><br><span class="line"><span class="number">3</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">3</span>: foo</span><br><span class="line"><span class="number">4</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">4</span>: foo</span><br><span class="line"><span class="number">5</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">5</span>: foo</span><br><span class="line"><span class="number">6</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">6</span>: foo</span><br><span class="line"><span class="number">7</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">7</span>: foo</span><br><span class="line"><span class="number">8</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">8</span>: foo</span><br><span class="line"><span class="number">9</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">9</span>: foo</span><br><span class="line"><span class="number">10</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">10</span>: foo</span><br><span class="line"><span class="number">11</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">11</span>: foo</span><br><span class="line"><span class="number">12</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">12</span>: foo</span><br><span class="line"><span class="number">13</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">13</span>: foo</span><br><span class="line"><span class="number">14</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">14</span>: foo</span><br><span class="line"><span class="number">15</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">15</span>: foo</span><br><span class="line"><span class="number">16</span>: sun.reflect.NativeMethodAccessorImpl@1be6f5c3</span><br><span class="line"><span class="number">16</span>: foo</span><br><span class="line"><span class="number">17</span>: sun.reflect.GeneratedMethodAccessor2@5b2133b1</span><br><span class="line"><span class="number">17</span>: foo</span><br></pre></td></tr></table></figure><p>从上述信息可知，第一次调用时没有使用 MethodAccessor 对象，从第二次到第十六次，使用了 NativeMethodAccessorImpl 对象，而在第十七次使用了 GeneratedMethodAccessor2 对象。</p><p>NativeMethodAccessorImpl 基于 Java 本地 API 实现，性能较低，第十七次调用换成 GeneratedMethodAccessor2 后，性能得到一定的提升。</p><p>使用 Arthas 反编译查看 GeneratedMethodAccessor2 类中的信息，内容如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneratedMethodAccessor2</span> <span class="keyword">extends</span> <span class="title class_">MethodAccessorImpl</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Loose catch block</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object object, Object[] objectArray)</span> <span class="keyword">throws</span> InvocationTargetException &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 正常调用方法</span></span><br><span class="line">            TestMethodProxy.foo((<span class="type">int</span>)c);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvocationTargetException</span>(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassCastException | NullPointerException runtimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="built_in">super</span>.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在反编译得到的代码中，不再是通过反射调用方法，而是直接正常调用方法，即：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TestMethodProxy.foo((<span class="type">int</span>)c);</span><br></pre></td></tr></table></figure><p>因此性能得到了提升，但这样的提升也是有一定代价的：为优化 一个 方法的反射调用，生成了一个 GeneratedMethodAccessor2 代理类。</p><h1 id="CGLib-动态代理原理"><a href="#CGLib-动态代理原理" class="headerlink" title="CGLib 动态代理原理"></a><strong>CGLib</strong> <strong>动态代理原理</strong></h1><h2 id="13-1-CGLib-动态代理的模拟"><a href="#13-1-CGLib-动态代理的模拟" class="headerlink" title="13.1 CGLib 动态代理的模拟"></a><strong>13.1</strong> <strong>CGLib</strong> <strong>动态代理的模拟</strong></h2><p>同样先模拟下 CGLib 动态代理的模拟：</p><p>被代理的类，即目标类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save(int)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">long</span> i)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save(long)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CGLib 动态代理生成的代理类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">extends</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor methodInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMethodInterceptor</span><span class="params">(MethodInterceptor methodInterceptor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.methodInterceptor = methodInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Method save0;</span><br><span class="line">    <span class="keyword">static</span> Method save1;</span><br><span class="line">    <span class="keyword">static</span> Method save2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            save0 = Target.class.getMethod(<span class="string">&quot;save&quot;</span>);</span><br><span class="line">            save1 = Target.class.getMethod(<span class="string">&quot;save&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">            save2 = Target.class.getMethod(<span class="string">&quot;save&quot;</span>, <span class="type">long</span>.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            methodInterceptor.intercept(<span class="built_in">this</span>, save0, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>], <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            methodInterceptor.intercept(<span class="built_in">this</span>, save1, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;i&#125;, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">long</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            methodInterceptor.intercept(<span class="built_in">this</span>, save2, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;i&#125;, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">Proxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>();</span><br><span class="line">    proxy.setMethodInterceptor(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">            <span class="comment">// 反射调用</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    proxy.save();</span><br><span class="line">    proxy.save(<span class="number">1</span>);</span><br><span class="line">    proxy.save(<span class="number">2L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before</span><br><span class="line"><span class="title function_">save</span><span class="params">()</span></span><br><span class="line">before</span><br><span class="line"><span class="title function_">save</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line">before</span><br><span class="line"><span class="title function_">save</span><span class="params">(<span class="type">long</span>)</span></span><br></pre></td></tr></table></figure><h2 id="13-2-MethodProxy"><a href="#13-2-MethodProxy" class="headerlink" title="13.2 MethodProxy"></a><strong>13.2 MethodProxy</strong></h2><p>在上述 Proxy 类中，重写了父类中的方法，并在重写的方法中调用了 <code>intercept()</code> 方法，重写的这些方法相当于是带增强功能的方法。</p><p>在 JDK 的动态代理中，使用反射对方法进行调用，而在 CGLib 动态代理中，可以使用 <code>intercept()</code> 方法中 <code>MethodProxy</code> 类型的参数实现不经过反射来调用方法。</p><p>接收的 <code>MethodProxy</code> 类型的参数可以像 <code>Method</code> 类型的参数一样，在静态代码块中被实例化。</p><p>可以通过静态方法 <code>MethodProxy.create()</code> 来创建 <code>MethodProxy</code> 对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> MethodProxy <span class="title function_">create</span><span class="params">(Class c1, Class c2, String desc, String name1, String name2)</span> &#123;</span><br><span class="line">   <span class="type">MethodProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodProxy</span>();</span><br><span class="line">   proxy.sig1 = <span class="keyword">new</span> <span class="title class_">Signature</span>(name1, desc);</span><br><span class="line">   proxy.sig2 = <span class="keyword">new</span> <span class="title class_">Signature</span>(name2, desc);</span><br><span class="line">   proxy.createInfo = <span class="keyword">new</span> <span class="title class_">CreateInfo</span>(c1, c2);</span><br><span class="line">   <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参数 <code>c1</code> 指目标类（或者说原始类）的 <code>Class</code> 对象；</li><li>参数 <code>c2</code> 指代理类的 <code>Class</code> 对象；</li><li>参数 <code>desc</code> 指方法描述符（【Lambda 与序列化】一文中介绍了关于 Java 描述符的更多内容）；</li><li>参数 <code>name1</code> 指带 <strong>增强</strong> 功能的方法名称；</li><li>参数 <code>name2</code> 指带 <strong>原始</strong> 功能的方法名称。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">extends</span> <span class="title class_">Target</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor methodInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMethodInterceptor</span><span class="params">(MethodInterceptor methodInterceptor)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.methodInterceptor = methodInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Method save0;</span><br><span class="line">    <span class="keyword">static</span> Method save1;</span><br><span class="line">    <span class="keyword">static</span> Method save2;</span><br><span class="line">    <span class="keyword">static</span> MethodProxy save0Proxy;</span><br><span class="line">    <span class="keyword">static</span> MethodProxy save1Proxy;</span><br><span class="line">    <span class="keyword">static</span> MethodProxy save2Proxy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            save0 = Target.class.getMethod(<span class="string">&quot;save&quot;</span>);</span><br><span class="line">            save1 = Target.class.getMethod(<span class="string">&quot;save&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">            save2 = Target.class.getMethod(<span class="string">&quot;save&quot;</span>, <span class="type">long</span>.class);</span><br><span class="line"></span><br><span class="line">            save0Proxy = MethodProxy.create(Target.class, Proxy.class, <span class="string">&quot;()V&quot;</span>, <span class="string">&quot;save&quot;</span>, <span class="string">&quot;saveSuper&quot;</span>);</span><br><span class="line">            save1Proxy = MethodProxy.create(Target.class, Proxy.class, <span class="string">&quot;(I)V&quot;</span>, <span class="string">&quot;save&quot;</span>, <span class="string">&quot;saveSuper&quot;</span>);</span><br><span class="line">            save2Proxy = MethodProxy.create(Target.class, Proxy.class, <span class="string">&quot;(J)V&quot;</span>, <span class="string">&quot;save&quot;</span>, <span class="string">&quot;saveSuper&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 带原始功能的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveSuper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.save();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveSuper</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.save(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveSuper</span><span class="params">(<span class="type">long</span> i)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.save(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 带增强功能的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            methodInterceptor.intercept(<span class="built_in">this</span>, save0, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>], save0Proxy);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            methodInterceptor.intercept(<span class="built_in">this</span>, save1, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;i&#125;, save1Proxy);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(<span class="type">long</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            methodInterceptor.intercept(<span class="built_in">this</span>, save2, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;i&#125;, save2Proxy);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>main()</code> 方法中不再使用 <code>Method</code> 类型的参数对方法进行调用，而是使用 <code>MethodProxy</code> 类型的参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部没有反射调用，但需要结合目标对象使用</span></span><br><span class="line"><span class="keyword">return</span> methodProxy.invoke(target, args);</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部没有反射调用，但需要结合代理对象使用</span></span><br><span class="line"><span class="keyword">return</span> methodProxy.invokeSuper(o, args);</span><br></pre></td></tr></table></figure><h1 id="MethodProxy-原理"><a href="#MethodProxy-原理" class="headerlink" title="MethodProxy 原理"></a>MethodProxy 原理</h1><p>调用 methodProxy.invoke() 方法时，会额外使用一个代理类，该代理类配合目标对象使用。调用 methodProxy.invokeSuper() 方法时，也会额外使用一个代理类，该代理类配合代理对象使用。</p><p>当调用 MethodProxy 对象的 invoke() 方法或 invokeSuper() 方法时，就会生成这两个代理类，它们都继承至 FastClass。</p><p>FastClass 是一个抽象类，其内部有多个抽象方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FastClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(String var1, Class[] var2)</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(Class[] var1)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title function_">invoke</span><span class="params">(<span class="type">int</span> var1, Object var2, Object[] var3)</span> <span class="keyword">throws</span> InvocationTargetException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title function_">newInstance</span><span class="params">(<span class="type">int</span> var1, Object[] var2)</span> <span class="keyword">throws</span> InvocationTargetException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(Signature signature)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">getMaxIndex</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点讲解 invoke() 方法与 getIndex(Signature signature) 方法。</p><p>模拟生成的与目标类相关的代理类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetFastClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Signature</span> <span class="variable">s0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Signature</span>(<span class="string">&quot;save&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Signature</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Signature</span>(<span class="string">&quot;save&quot;</span>, <span class="string">&quot;(I)V&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Signature</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Signature</span>(<span class="string">&quot;save&quot;</span>, <span class="string">&quot;(J)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;获取目标方法的编号&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Target 目标类中的方法：</span></span><br><span class="line"><span class="comment">     * save()             0</span></span><br><span class="line"><span class="comment">     * save(int)          1</span></span><br><span class="line"><span class="comment">     * save(long)         2</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> signature 包含方法名称、参数返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 方法编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(Signature signature)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s0.equals(signature)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s1.equals(signature)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s2.equals(signature)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 getIndex() 方法返回的方法编号正常调用目标对象方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index       方法编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target       目标对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 调用目标对象方法需要的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 方法返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(<span class="type">int</span> index, Object target, Object[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            ((Target) target).save();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">            ((Target) target).save((<span class="type">int</span>) args[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">2</span>) &#123;</span><br><span class="line">            ((Target) target).save((<span class="type">long</span>) args[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;无此方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TargetFastClass</span> <span class="variable">fastClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetFastClass</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> fastClass.getIndex(<span class="keyword">new</span> <span class="title class_">Signature</span>(<span class="string">&quot;save&quot;</span>, <span class="string">&quot;()V&quot;</span>));</span><br><span class="line">        fastClass.invoke(index, <span class="keyword">new</span> <span class="title class_">Target</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        index = fastClass.getIndex(<span class="keyword">new</span> <span class="title class_">Signature</span>(<span class="string">&quot;save&quot;</span>, <span class="string">&quot;(J)V&quot;</span>));</span><br><span class="line">        fastClass.invoke(index, <span class="keyword">new</span> <span class="title class_">Target</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">2L</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">save()</span><br><span class="line">save(<span class="type">long</span>)</span><br></pre></td></tr></table></figure><p>模拟生成的与代理类相关的代理类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFastClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Signature</span> <span class="variable">s0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Signature</span>(<span class="string">&quot;saveSuper&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Signature</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Signature</span>(<span class="string">&quot;saveSuper&quot;</span>, <span class="string">&quot;(I)V&quot;</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Signature</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Signature</span>(<span class="string">&quot;saveSuper&quot;</span>, <span class="string">&quot;(J)V&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;获取代理方法的编号&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Proxy 代理类中的方法：</span></span><br><span class="line"><span class="comment">     * saveSuper()             0</span></span><br><span class="line"><span class="comment">     * saveSuper(int)          1</span></span><br><span class="line"><span class="comment">     * saveSuper(long)         2</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> signature 包含方法名称、参数返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 方法编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(Signature signature)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s0.equals(signature)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s1.equals(signature)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s2.equals(signature)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 getIndex() 方法返回的方法编号正常调用代理对象中带原始功能的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 方法编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args  调用方法需要的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 方法返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(<span class="type">int</span> index, Object proxy, Object[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            ((Proxy) proxy).saveSuper();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">            ((Proxy) proxy).saveSuper((<span class="type">int</span>) args[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">2</span>) &#123;</span><br><span class="line">            ((Proxy) proxy).saveSuper((<span class="type">long</span>) args[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;无此方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProxyFastClass</span> <span class="variable">fastClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFastClass</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> fastClass.getIndex(<span class="keyword">new</span> <span class="title class_">Signature</span>(<span class="string">&quot;saveSuper&quot;</span>, <span class="string">&quot;()V&quot;</span>));</span><br><span class="line">        fastClass.invoke(index, <span class="keyword">new</span> <span class="title class_">Proxy</span>(), <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">save()</span><br></pre></td></tr></table></figure><p>总结</p><p>调用 MethodProxy.create() 方法创建 MethodProxy 对象时，要求传递带增强功能的方法名称、带原始功能的方法名称以及方法描述符。</p><p>根据两个方法名称和方法描述符可以在调用生成的两个代理类中的 getIndex() 方法时获取被增强方法的编号，之后：</p><p>调用 methodProxy.invoke() 方法时，就相当于调用 TargetFastClass 中的 invoke() 方法，并在这个 invoke() 方法中正常调用目标对象方法（Spring 底层的选择）。</p><p>调用 methodProxy.invokeSuper() 方法时，就相当于调用 ProxyFastClass 中的 invoke() 方法，并在这个 invoke() 方法中正常调用代理对象中带原始功能的方法。</p><p>与 JDK 中优化反射调用方法的对比</p><p>在 JDK 中需要反射调用 16 次方法后才会生成优化反射调用的代理类，而在 CGLib 中，当调用 MethodProxy.create() 方法时就会生成由于优化反射调用的代理类；</p><p>在 JDK 中一个方法的反射调用优化就要生成一个代理类，而在 CGLib 中，一个代理类生成两个 FastClass 代理类。</p><h1 id="JDK-和-CGLib-的统一"><a href="#JDK-和-CGLib-的统一" class="headerlink" title="JDK 和 CGLib 的统一"></a>JDK 和 CGLib 的统一</h1><h2 id="15-1-advisor"><a href="#15-1-advisor" class="headerlink" title="15.1. advisor"></a>15.1. advisor</h2><p>切面有 aspect 和 advisor 两个概念，aspect 是多组通知（advice）和切点（pointcut）的组合，也是实际编码时使用的，advisor 则是更细粒度的切面，仅包含一个通知和切点，aspect 在生效之前会被拆解成多个 advisor。</p><p>Spring 中对切点、通知、切面的抽象如下：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NzIwNmVmNTNhMmQzMWJiZjcyZWU4MzhhNDYzNzU1NWFfeEt3SjhNNkV1Y0d4RjJsMTRIU1VDTGM2eVYxUmdRVUNfVG9rZW46Q2R3a2J2VE1kb0NSYXl4SjIwMWNoZ3pJbnFmXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>切点：即 Pointcut，其典型实现是 AspectJExpressionPointcut</p><p>通知：即 Advice，其典型子类接口为 MethodInterceptor，表示环绕通知</p><p>切面：即 Advisor，仅包含一个切点和通知</p><p>本节将重点介绍 advisor 切面。</p><h2 id="15-2-切面与代理对象的创建"><a href="#15-2-切面与代理对象的创建" class="headerlink" title="15.2 切面与代理对象的创建"></a>15.2 切面与代理对象的创建</h2><p>通过以下四步创建切面和代理：</p><ul><li>备好切点</li><li>备好通知</li><li>备好切面</li><li>创建代理</li></ul><p>在 Spring 中，切点通过接口 org.springframework.aop.Pointcut 来表示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pointcut</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据类型过滤</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ClassFilter <span class="title function_">getClassFilter</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据方法匹配</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        MethodMatcher <span class="title function_">getMethodMatcher</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Canonical Pointcut instance that always matches.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Pointcut</span> <span class="variable">TRUE</span> <span class="operator">=</span> TruePointcut.INSTANCE;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pointcut 接口有很多实现类，比如：</p><p>AnnotationMatchingPointcut：通过注解进行匹配</p><p>AspectJExpressionPointcut：通过 AspectJ 表达式进行匹配（本节的选择）</p><p>在 Spring 中，通知的表示也有很多接口，在此介绍最基本、最重要的接口 org.aopalliance.intercept.MethodInterceptor，这个接口实现的通知属于环绕通知。</p><p>在 Spring 中，切面的实现也有很多，在此选择 DefaultPointcutAdvisor，创建这种切面时，传递一个节点和通知。</p><p>最后创建代理对象时，无需显式实现 JDK 动态代理或 CGLib 动态代理，Spring 提供了名为 ProxyFactory 的工厂，其内部通过不同的情况选择不同的代理实现，更方便地创建代理对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">I1</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target1</span> <span class="keyword">implements</span> <span class="title class_">I1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target1 foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target1 bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target2 foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target2 bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 两个切面概念：</span></span><br><span class="line"><span class="comment">     *  aspect =</span></span><br><span class="line"><span class="comment">     *          通知 1 （advice） + 切点 1（pointcut）</span></span><br><span class="line"><span class="comment">     *          通知 2 （advice） + 切点 2（pointcut）</span></span><br><span class="line"><span class="comment">     *          通知 3 （advice） + 切点 3（pointcut）</span></span><br><span class="line"><span class="comment">     *          ...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * advisor = 更细粒度的切面，包含一个通知和切点</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 备好切点（根据 AspectJ 表达式进行匹配）</span></span><br><span class="line">    <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">    pointcut.setExpression(<span class="string">&quot;execution(* foo())&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 备好通知</span></span><br><span class="line">    <span class="type">MethodInterceptor</span> <span class="variable">advice</span> <span class="operator">=</span> invocation -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 3. 备好切面</span></span><br><span class="line">    <span class="type">DefaultPointcutAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice);</span><br><span class="line">    <span class="comment">// 4. 创建代理</span></span><br><span class="line">    <span class="type">Target1</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target1</span>();</span><br><span class="line">    <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">    factory.setTarget(target);</span><br><span class="line">    factory.addAdvisor(advisor);</span><br><span class="line">    </span><br><span class="line">    <span class="type">I1</span> <span class="variable">proxy</span> <span class="operator">=</span> (I1) factory.getProxy();</span><br><span class="line">    System.out.println(proxy.getClass());</span><br><span class="line">    proxy.foo();</span><br><span class="line">    proxy.bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a15.A15$Target1$$EnhancerBySpringCGLIB$$381723d1</span><br><span class="line">before...</span><br><span class="line">target1 foo</span><br><span class="line">after...</span><br><span class="line">target1 bar</span><br></pre></td></tr></table></figure><p>foo() 方法被增强，但 bar() 并没有，并且选择了 CGLib 动态代理作为代理的实现。</p><p>Spring 是根据什么信息来选择不同的动态代理实现呢？</p><p>ProxyFactory 的父类 ProxyConfig 中有个名为 proxyTargetClass 的布尔类型成员变量：</p><ul><li>当 proxyTargetClass &#x3D;&#x3D; false，并且目标对象所在类实现了接口时，将选择 JDK 动态代理；</li><li>当 proxyTargetClass &#x3D;&#x3D; false，但目标对象所在类未实现接口时，将选择 CGLib 动态代理；</li><li>当 proxyTargetClass &#x3D;&#x3D; true，总是选择 CGLib 动态代理。</li></ul><p>上文中的 target 对象的所在类 Targer1 实现了 I1 接口，最终为什么依旧选择了 CGLib 动态代理作为代理类的创建方式呢？</p><p>这是因为并没有显示这是 target 对象的实现类，Spring 认为其并未实现接口。</p><p>设置 factory 对象的 interfaces 信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">factory.setInterfaces(target.getClass().getInterfaces());</span><br></pre></td></tr></table></figure><p>之后再运行 main()，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a15.$Proxy0</span><br><span class="line">before...</span><br><span class="line">target1 foo</span><br><span class="line">after...</span><br><span class="line">target1 bar</span><br></pre></td></tr></table></figure><p>此时选择的动态代理实现方式是 JDK 动态代理。</p><p>再设置 factory 对象的 proxyTargetClass 为 true：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">factory.setProxyTargetClass(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出以下内容，选择 CGLib 动态代理作为动态代理的实现方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a15.A15$Target1$$EnhancerBySpringCGLIB$$34c2d9b8</span><br><span class="line">before...</span><br><span class="line">target1 foo</span><br><span class="line">after...</span><br><span class="line">target1 bar</span><br></pre></td></tr></table></figure><p>再将 proxyTargetClass 的值修改回 false，并修改目标对象的所在类为 Target2，Target2 并未实现任何接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 创建代理</span></span><br><span class="line">    <span class="type">Target2</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target2</span>();</span><br><span class="line">    <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">    factory.setTarget(target);</span><br><span class="line">    factory.addAdvisor(advisor);</span><br><span class="line">    factory.setInterfaces(target.getClass().getInterfaces());</span><br><span class="line">    factory.setProxyTargetClass(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Target2</span> <span class="variable">proxy</span> <span class="operator">=</span> (Target2) factory.getProxy();</span><br><span class="line">    System.out.println(proxy.getClass());</span><br><span class="line">    proxy.foo();</span><br><span class="line">    proxy.bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出以下内容，依旧选择 CGLib 动态代理作为动态代理的实现方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a15.A15$Target2$$EnhancerBySpringCGLIB$$4bb2ac74</span><br><span class="line">before...</span><br><span class="line">target2 foo</span><br><span class="line">after...</span><br><span class="line">target2 bar</span><br></pre></td></tr></table></figure><p>ProxyFactory 是用来创建代理的核心实现，使用 AopProxyFactory 选择具体的代理实现：</p><ul><li>JdkDynamicAopProxy</li><li>ObjenesisCglibAopProxy</li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTY3MmM0YTk0MDZkOTRkYTE4MTQ0YzNiNmIxNmVkZDZfN1BkMlJoZ25jcU5TWFV6RmsyZjFVcUQzcjBsWndiaW1fVG9rZW46TzRIY2JaVWVlb0RXdm14UjBKUWN3Vngzbm1oXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>AopProxyFactory 根据 proxyTargetClass 等设置选择 AopProxy 实现，AopProxy 通过 getProxy() 方法创建代理对象。</p><p>上述类图中的类与接口都实现了 Advised 接口，能够获得关联的切面集合与目标（实际上是从 ProxyFactory 中获取的）。</p><p>调用代理方法时，会借助 ProxyFactory 统一将通知转换为环绕通知 MethodInterceptor。</p><h1 id="切点匹配"><a href="#切点匹配" class="headerlink" title="切点匹配"></a>切点匹配</h1><p>上一节中，选择 AspectJExpressionPointcut 作为切点的实现，判断编写的 AspectJ 表达式是否与某一方法匹配可以使用其 matches() 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">    <span class="type">AspectJExpressionPointcut</span> <span class="variable">pt1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">    pt1.setExpression(<span class="string">&quot;execution(* bar())&quot;</span>);</span><br><span class="line">    System.out.println(pt1.matches(T1.class.getMethod(<span class="string">&quot;foo&quot;</span>), T1.class));</span><br><span class="line">    System.out.println(pt1.matches(T1.class.getMethod(<span class="string">&quot;bar&quot;</span>), T1.class));</span><br><span class="line"></span><br><span class="line">    <span class="type">AspectJExpressionPointcut</span> <span class="variable">pt2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">    pt2.setExpression(<span class="string">&quot;@annotation(org.springframework.transaction.annotation.Transactional)&quot;</span>);</span><br><span class="line">    System.out.println(pt2.matches(T1.class.getMethod(<span class="string">&quot;foo&quot;</span>), T1.class));</span><br><span class="line">    System.out.println(pt2.matches(T1.class.getMethod(<span class="string">&quot;bar&quot;</span>), T1.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T1</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><p>@Transactional 是 Spring 中使用频率非常高的注解，那它底层是通过 AspectJExpressionPointcut 与 @annotation() 切点表达式相结合对目标方法进行匹配的吗？</p><p>答案是否定的。@Transactional 注解除了可以作用在方法上，还可以作用在类（或接口）上。</p><p>在底层 @Transactional 注解的匹配使用到了 StaticMethodMatcherPointcut，在此模拟一下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">StaticMethodMatcherPointcut</span> <span class="variable">pt3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticMethodMatcherPointcut</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> &#123;</span><br><span class="line">            <span class="comment">// 检查方法上是否添加了 @Transactional 注解</span></span><br><span class="line">            <span class="type">MergedAnnotations</span> <span class="variable">annotations</span> <span class="operator">=</span> MergedAnnotations.from(method);</span><br><span class="line">            <span class="keyword">if</span> (annotations.isPresent(Transactional.class)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查类上或所实现的接口是否添加了 @Transactional 注解</span></span><br><span class="line">            annotations = MergedAnnotations.from(targetClass, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY);</span><br><span class="line">            <span class="keyword">return</span> annotations.isPresent(Transactional.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    System.out.println(pt3.matches(T1.class.getMethod(<span class="string">&quot;foo&quot;</span>), T1.class));</span><br><span class="line">    System.out.println(pt3.matches(T1.class.getMethod(<span class="string">&quot;bar&quot;</span>), T1.class));</span><br><span class="line">    System.out.println(pt3.matches(T2.class.getMethod(<span class="string">&quot;foo&quot;</span>), T2.class));</span><br><span class="line">    System.out.println(pt3.matches(T3.class.getMethod(<span class="string">&quot;foo&quot;</span>), T3.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T1</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I3</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T3</span> <span class="keyword">implements</span> <span class="title class_">I3</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>无论是 AspectJExpressionPointcut 还是 StaticMethodMatcherPointcut，它们都实现了MethodMatcher 接口，用来执行方法的匹配。</p><h1 id="从-Aspect-到-Advisor"><a href="#从-Aspect-到-Advisor" class="headerlink" title="从 @Aspect 到 Advisor"></a>从 @Aspect 到 Advisor</h1><ol><li><h2 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h2></li></ol><p>准备一下类：</p><ul><li>两个目标类:</li></ul><p>一个使用 @Aspect 的高级切面</p><p>一个利用配置类实现的低级切面 Advisor</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target1 foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target2 bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 高级切面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Aspect1</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aspect1 before...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aspect1 after...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 低级切面，由一个切点和一个通知组成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Advisor <span class="title function_">advisor3</span><span class="params">(MethodInterceptor advice3)</span> &#123;</span><br><span class="line">        <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">        pointcut.setExpression(<span class="string">&quot;execution(* foo())&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MethodInterceptor <span class="title function_">advices</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> invocation -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;advice3 before...&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">            System.out.println(<span class="string">&quot;advice3 after...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 main() 方法创建 Spring 容器，并添加必要的 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;aspect1&quot;</span>, Aspect1.class);</span><br><span class="line">    context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">aspect1</span><br><span class="line">config</span><br><span class="line">org.springframework.context.annotation.ConfigurationClassPostProcessor</span><br><span class="line">advisor3</span><br><span class="line">advices</span><br></pre></td></tr></table></figure><p>Spring 中存在一个名为 AnnotationAwareAspectJAutoProxyCreator 的 Bean 后置处理器，尽管它的名称中没有 BeanPostProcessor 的字样，但它确实是实现了 BeanPostProcessor 接口的。</p><p>AnnotationAwareAspectJAutoProxyCreator 有两个主要作用：</p><ul><li>找到容器中所有的切面，针对高级切面，将其转换为低级切面；</li><li>根据切面信息，利用 ProxyFactory 创建代理对象。</li></ul><p>AnnotationAwareAspectJAutoProxyCreator 实现了 BeanPostProcessor，可以在 Bean 生命周期中的一些阶段对 Bean 进行拓展。AnnotationAwareAspectJAutoProxyCreator 可以在 Bean 进行 依赖注入之前、Bean 初始化之后 对 Bean 进行拓展。</p><p>重点介绍 AnnotationAwareAspectJAutoProxyCreator 中的两个方法：</p><ul><li>findEligibleAdvisors()：位于父类 AbstractAdvisorAutoProxyCreator 中，用于找到符合条件的切面类。低级切面直接添加，高级切面转换为低级切面再添加。</li><li>wrapIfNecessary()：位于父类 AbstractAutoProxyCreator 中，用于将有资格被代理的 Bean 进行包装，即创建代理对象。</li></ul><p>findEligibleAdvisors() 方法</p><p>findEligibleAdvisors() 方法接收两个参数：</p><ul><li>beanClass：配合切面使用的目标类 Class 信息</li><li>beanName：当前被代理的 Bean 的名称</li></ul><p>修改 main() 方法，向容器中添加 AnnotationAwareAspectJAutoProxyCreator 后置处理器，测试 findEligibleAdvisors() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(<span class="string">&quot;aspect1&quot;</span>, Aspect1.class);</span><br><span class="line">        context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">        context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line"></span><br><span class="line">        context.registerBean(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line"></span><br><span class="line">        context.refresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试 findEligibleAdvisors 方法</span></span><br><span class="line">        <span class="type">AnnotationAwareAspectJAutoProxyCreator</span> <span class="variable">creator</span> <span class="operator">=</span> context.getBean(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line">        <span class="comment">// 获取能够配合 Target1 使用的切面</span></span><br><span class="line">        List&lt;Advisor&gt; advisors = creator.findEligibleAdvisors(Target1.class, <span class="string">&quot;target1&quot;</span>);</span><br><span class="line">        advisors.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.aop.interceptor.ExposeInvocationInterceptor.ADVISOR</span><br><span class="line">org.springframework.aop.support.DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [org.springframework.aop.framework.autoproxy.A17$Config$$Lambda$<span class="number">56</span>/<span class="number">802243390</span>@7bd4937b]</span><br><span class="line">InstantiationModelAwarePointcutAdvisor: expression [execution(* foo())]; advice method [<span class="keyword">public</span> <span class="keyword">void</span> org.springframework.aop.framework.autoproxy.A17$Aspect1.before()]; perClauseKind=SINGLETON</span><br><span class="line">InstantiationModelAwarePointcutAdvisor: expression [execution(* foo())]; advice method [<span class="keyword">public</span> <span class="keyword">void</span> org.springframework.aop.framework.autoproxy.A17$Aspect1.after()]; perClauseKind=SINGLETON</span><br></pre></td></tr></table></figure><p>打印出 4 个能配合 Target1 使用的切面信息，其中：</p><ul><li>第一个切面 ExposeInvocationInterceptor.ADVISOR 是 Spring 为每个代理对象都会添加的切面；</li><li>第二个切面 DefaultPointcutAdvisor 是自行编写的低级切面；</li><li>第三个和第四个切面 InstantiationModelAwarePointcutAdvisor 是由高级切面转换得到的两个低级切面。</li></ul><p>若按照 creator.findEligibleAdvisors(Target2.class, “target2”) 的方式进行调用，控制台不会打印出任何信息，因为没有任何切面能够配合 Target2 使用。</p><p>wrapIfNecessary() 方法</p><p>wrapIfNecessary() 方法内部调用了 findEligibleAdvisors() 方法，若 findEligibleAdvisors() 方法返回的集合不为空，则表示需要创建代理对象。</p><p>如果需要创建对象，wrapIfNecessary() 方法返回的是代理对象，否则仍然是原对象。</p><p>wrapIfNecessary() 方法接收三个参数：</p><ul><li>bean：原始 Bean 实例</li><li>beanName：Bean 的名称</li><li>cacheKey：用于元数据访问的缓存 key</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> creator.wrapIfNecessary(<span class="keyword">new</span> <span class="title class_">Target1</span>(), <span class="string">&quot;target1&quot;</span>, <span class="string">&quot;target1&quot;</span>);</span><br><span class="line">    System.out.println(o1.getClass());</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> creator.wrapIfNecessary(<span class="keyword">new</span> <span class="title class_">Target2</span>(), <span class="string">&quot;target2&quot;</span>, <span class="string">&quot;target2&quot;</span>);</span><br><span class="line">    System.out.println(o2.getClass());</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.aop.framework.autoproxy.A17$Target1$$EnhancerBySpringCGLIB$$634976f6</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.aop.framework.autoproxy.A17$Target2</span><br></pre></td></tr></table></figure><p>Target1 对象是被代理的，而 Target2 依旧是原对象。</p><p>如果将 o1 转换为 Target1，并调用 foo() 方法，foo() 方法将被增强：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    ((Target1) o1).foo();</span><br><span class="line">    </span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">advice3 before...</span><br><span class="line">aspect1 before...</span><br><span class="line">target1 foo</span><br><span class="line">aspect1 after...</span><br><span class="line">advice3 after...</span><br></pre></td></tr></table></figure><p>切面的顺序控制</p><p>根据上述打印的信息可知，低级切面相比于高级切面先一步被执行，这个执行顺序是可以被控制的。</p><p>针对高级切面来说，可以在类上使用 @Order 注解，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Aspect1</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aspect1 before...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aspect1 after...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在高级切面中，@Order 只有放在类上才生效，放在方法上不会生效。比如高级切面中有多个前置通知，这些前置通知对应的方法上使用 @Order 注解是无法生效的。</p><p>针对低级切面，需要设置 advisor 的 order 值，而不是向高级切面那样使用 @Order 注解，使用 @Order 注解设置在 advisor3() 方法上是无用的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 低级切面，由一个切点和一个通知组成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Advisor <span class="title function_">advisor3</span><span class="params">(MethodInterceptor advice3)</span> &#123;</span><br><span class="line">        <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">        pointcut.setExpression(<span class="string">&quot;execution(* foo())&quot;</span>);</span><br><span class="line">        <span class="type">DefaultPointcutAdvisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice3);</span><br><span class="line">        <span class="comment">// 设置切面执行顺序</span></span><br><span class="line">        advisor.setOrder(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> advisor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置完成后，高级切面的执行优先级高于低级切面。执行 main() 方法验证执行顺序是否改变：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">aspect1 before...</span><br><span class="line">advice3 before...</span><br><span class="line">target1 foo</span><br><span class="line">advice3 after...</span><br><span class="line">aspect1 after...</span><br></pre></td></tr></table></figure><h2 id="17-2-代理对象创建时机"><a href="#17-2-代理对象创建时机" class="headerlink" title="17.2. 代理对象创建时机"></a>17.2. 代理对象创建时机</h2><p>使用 AnnotationAwareAspectJAutoProxyCreator Bean 后置处理器创建代理对象的时机有以下两个选择：</p><p>Bean 的依赖注入之前</p><p>Bean 初始化完成之后</p><p>这两个时机二选一，不会重复创建代理对象。</p><p>以下述代码为例，查看代理对象的创建时机：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.aop.framework.autoproxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A17_1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">        context.registerBean(Config.class);</span><br><span class="line">        context.refresh();</span><br><span class="line">        context.close();</span><br><span class="line">        <span class="comment">// 创建 -&gt; (*) 依赖注入 -&gt; 初始化 (*)</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解析 <span class="doctag">@AspectJ</span> 注解，产生代理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> AnnotationAwareAspectJAutoProxyCreator <span class="title function_">annotationAwareAspectJAutoProxyCreator</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationAwareAspectJAutoProxyCreator</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解析 <span class="doctag">@Autowired</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> AutowiredAnnotationBeanPostProcessor <span class="title function_">autowiredAnnotationBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutowiredAnnotationBeanPostProcessor</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 解析 <span class="doctag">@PostConstruct</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> CommonAnnotationBeanPostProcessor <span class="title function_">commonAnnotationBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonAnnotationBeanPostProcessor</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Advisor <span class="title function_">advisor</span><span class="params">(MethodInterceptor advice)</span> &#123;</span><br><span class="line">            <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">            pointcut.setExpression(<span class="string">&quot;execution(* foo())&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> MethodInterceptor <span class="title function_">advice</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> invocation -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Bean1</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Bean1()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Bean1 init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Bean2</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Bean2()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean1</span><span class="params">(Bean1 bean1)</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Bean2 setBean1(bean1) class is: &quot;</span> + bean1.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@PostConstruct</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Bean2 init()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 bean2 中注入了 bean1。运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Bean1()</span><br><span class="line">Bean1 <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">Creating implicit proxy <span class="keyword">for</span> bean <span class="string">&#x27;bean1&#x27;</span> with <span class="number">0</span> common interceptors and <span class="number">2</span> specific interceptors </span><br><span class="line"><span class="title function_">Bean2</span><span class="params">()</span></span><br><span class="line">Bean2 <span class="title function_">setBean1</span><span class="params">(bean1)</span> <span class="keyword">class</span> <span class="title class_">is</span>: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.aop.framework.autoproxy.A17_1$Bean1$$EnhancerBySpringCGLIB$$b7d6405</span><br><span class="line">Bean2 <span class="title function_">init</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>在 bean1 初始化完成后，额外打印了一句日志信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Creating implicit proxy <span class="keyword">for</span> bean <span class="string">&#x27;bean1&#x27;</span> with <span class="number">0</span> common interceptors and <span class="number">2</span> specific interceptors</span><br></pre></td></tr></table></figure><p>表示为 bean1 创建了隐式代理。</p><p>此时代理对象在 Bean 初始化完成之后创建。</p><p>之后为 bean2 进行依赖注入时，注入的 bean1 是代理对象。</p><p>在 Bean1 类中添加 setBean2() 方法，表示向 bean1 中注入 bean2，此时 bean1 依赖 bean2，而 bean2 原本就依赖了 bean1，出现循环依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean2</span><span class="params">(Bean2 bean2)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean1 setBean2(bean2) class is: &quot;</span> + bean2.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bean1 init()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行 main() 方法，查看 bean1 的代理对象的生成时机：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Bean1()</span><br><span class="line">Bean2()</span><br><span class="line">Creating implicit proxy <span class="keyword">for</span> bean <span class="string">&#x27;bean1&#x27;</span> with <span class="number">0</span> common interceptors and <span class="number">2</span> specific interceptors </span><br><span class="line">Bean2 <span class="title function_">setBean1</span><span class="params">(bean1)</span> <span class="keyword">class</span> <span class="title class_">is</span>: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.aop.framework.autoproxy.A17_1$Bean1$$EnhancerBySpringCGLIB$$5cff48bf</span><br><span class="line">Bean2 <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">Bean1 <span class="title function_">setBean2</span><span class="params">(bean2)</span> <span class="keyword">class</span> <span class="title class_">is</span>: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.aop.framework.autoproxy.A17_1$Bean2</span><br><span class="line">Bean1 <span class="title function_">init</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>首先进行 bean1 的实例化，然后进行 bean1 的依赖注入，但此时容器中并没有 bean2，因此需要进行 bean2 的实例化。</p><p>接下来进行 bean2 的依赖注入，向 bean2 中注入 bean1，注入的 bean1 应该是被增强的，即它的代理对象，因此创建 bean1 的代理对象后再完成 bean2 的依赖注入。</p><p>接着继续 bean2 的生命周期，完成 bean2 的初始化阶段，最后回到 bean1 的依赖注入阶段，向 bean1 中注入 bean2，最后完成 bean1 的初始化阶段。</p><p>总结</p><p>代理对象的创建时机：</p><ul><li>无循环依赖时，在 Bean 初始化阶段之后创建；</li><li>有循环依赖时，在 Bean 实例化后、依赖注入之前创建，并将代理对象暂存于二级缓存。Bean 的依赖注入阶段和初始化阶段不应该被增强，仍应被施加于原始对象。</li></ul><h2 id="17-3-高级切面转低级切面"><a href="#17-3-高级切面转低级切面" class="headerlink" title="17.3 高级切面转低级切面"></a>17.3 高级切面转低级切面</h2><p>调用 AnnotationAwareAspectJAutoProxyCreator 对象的 findEligibleAdvisors() 方法时，获取能配合目标 Class 使用的切面，最终返回 Advisor 列表。在搜索过程中，如果遇到高级切面，则会将其转换成低级切面。</p><p>现有切面类与目标类信息如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Aspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;around...before&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;around...after&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高级切面中与通知类型相关的常用注解有 5 个：</p><ul><li>@Before：前置通知</li><li>@AfterReturning：后置通知</li><li>@AfterThrowing：异常通知</li><li>@After：最终通知</li><li>@Around：环绕通知</li></ul><p>以解析 @Before 注解为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// 切面对象实例工厂，用于后续反射调用切面中的方法</span></span><br><span class="line">    <span class="type">AspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonAspectInstanceFactory</span>(<span class="keyword">new</span> <span class="title class_">Aspect</span>());</span><br><span class="line">    <span class="comment">// 高级切面转低级切面类</span></span><br><span class="line">    List&lt;Advisor&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Method method : Aspect.class.getDeclaredMethods()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(Before.class)) &#123;</span><br><span class="line">            <span class="comment">// 解析切点</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> method.getAnnotation(Before.class).value();</span><br><span class="line">            <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">            pointcut.setExpression(expression);</span><br><span class="line">            <span class="comment">// 通知类。前置通知对应的通知类是 AspectJMethodBeforeAdvice</span></span><br><span class="line">            <span class="type">AspectJMethodBeforeAdvice</span> <span class="variable">advice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJMethodBeforeAdvice</span>(method, pointcut, factory);</span><br><span class="line">            <span class="comment">// 切面</span></span><br><span class="line">            <span class="type">Advisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice);</span><br><span class="line">            list.add(advisor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Advisor advisor : list) &#123;</span><br><span class="line">        System.out.println(advisor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.aop.support.DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [org.springframework.aop.aspectj.AspectJMethodBeforeAdvice: advice method [<span class="keyword">public</span> <span class="keyword">void</span> org.springframework.aop.framework.autoproxy.A17_2$Aspect.before2()]; aspect name <span class="string">&#x27;&#x27;</span>]</span><br><span class="line"></span><br><span class="line">org.springframework.aop.support.DefaultPointcutAdvisor: pointcut [AspectJExpressionPointcut: () execution(* foo())]; advice [org.springframework.aop.aspectj.AspectJMethodBeforeAdvice: advice method [<span class="keyword">public</span> <span class="keyword">void</span> org.springframework.aop.framework.autoproxy.A17_2$Aspect.before1()]; aspect name <span class="string">&#x27;&#x27;</span>]</span><br></pre></td></tr></table></figure><p>@Before 标记的前置通知会被转换成原始的 AspectJMethodBeforeAdvice 形式，该对象包含了以下信息：</p><ul><li>通知对应的方法信息</li><li>切点信息</li><li>通知对象如何创建，本例公用一个 Aspect 对象</li></ul><p>通知相关注解与原始通知类对应关系如下：</p><p>注解 对应的原始通知类</p><p>@Before AspectJMethodBeforeAdvice</p><p>@AfterReturning AspectJAfterReturningAdvice</p><p>@AfterThrowing AspectJAfterThrowingAdvice</p><p>@After AspectJAfterAdvice</p><p>@Around AspectJAroundAdvice</p><h1 id="静态通知调用"><a href="#静态通知调用" class="headerlink" title="静态通知调用"></a>静态通知调用</h1><h2 id="18-1-统一转换成环绕通知"><a href="#18-1-统一转换成环绕通知" class="headerlink" title="18.1 统一转换成环绕通知"></a>18.1 统一转换成环绕通知</h2><p>通知相关注解都对应一个原始通知类，在 Spring 底层会将这些通知转换成环绕通知 MethodInterceptor。如果原始通知类本就实现了 MethodInterceptor 接口，则无需转换。</p><p>原始通知类 是否需要转换成 MethodInterceptor</p><p>AspectJMethodBeforeAdvice ✅</p><p>AspectJAfterReturningAdvice ✅</p><p>AspectJAfterThrowingAdvice ❌</p><p>AspectJAfterAdvice ❌</p><p>AspectJAroundAdvice ❌</p><p>使用 ProxyFactory 无论基于哪种方式创建代理对象，最终调用 advice（通知，或者说通知对应的方法）的都是 MethodInvocation 对象。</p><p>项目中存在的 advisor（原本的低级切面和由高级切面转换得到的低级切面）往往不止一个，它们一个套一个地被调用，因此需要一个调用链对象，即 MethodInvocation。</p><p>MethodInvocation 需要知道 advice 有哪些，还需要知道目标对象是哪个。调用次序如下：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGRjYmVkNjRiMDY2NzVjYjZlOWNkNTNmNTU2YjUxNGRfQW5XQm8zR0o1cTVxZkNnTmlzWXNTWkFJUVp0eGlscUNfVG9rZW46UWY4bWJLbVRzbzdLVHh4TWllcGNoT2pzblplXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>由上图可知，环绕 通知最适合作为 advice，而 Before、AfterReturning 都应该转换成环绕通知。</p><p>统一转换成环绕通知的形式，体现了设计模式中的适配器模式：</p><p>对外更方便使用和区分各种通知类型</p><p>对内统一都是环绕通知，统一使用 MethodInterceptor 表示</p><p>通过 ProxyFactory 对象的 getInterceptorsAndDynamicInterceptionAdvice() 方法将其他通知统一转换为 MethodInterceptor 环绕通知：</p><table><thead><tr><th>注解</th><th>原始通知类</th><th>适配器</th><th>拦截器</th></tr></thead><tbody><tr><td>@Before</td><td>AspectJMethodBeforeAdvice</td><td>MethodBeforeAdviceAdapter</td><td>MethodBeforeAdviceInterceptor</td></tr><tr><td>@AfterReturning</td><td>AspectJAfterReturningAdvice</td><td>AspectJAfterReturningAdvice</td><td>AfterReturningAdviceInterceptor</td></tr></tbody></table><p>转换得到的通知都是静态通知，体现在 getInterceptorsAndDynamicInterceptionAdvice() 方法中的 Interceptors 部分，这些通知在被调用时无需再次检查切点，直接调用即可。</p><p>切面类与目标类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Aspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;execution(* foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;execution(* foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* foo())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;around...before&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> pjp.proceed();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;around...after&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;target foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将高级切面转换成低级切面，并将通知统一转换成环绕通知：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">AspectInstanceFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonAspectInstanceFactory</span>(<span class="keyword">new</span> <span class="title class_">Aspect</span>());</span><br><span class="line">    <span class="comment">// 1. 高级切面转低级切面类</span></span><br><span class="line">    List&lt;Advisor&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Method method : Aspect.class.getDeclaredMethods()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(Before.class)) &#123;</span><br><span class="line">            <span class="comment">// 解析切点</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> method.getAnnotation(Before.class).value();</span><br><span class="line">            <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">            pointcut.setExpression(expression);</span><br><span class="line">            <span class="comment">// 通知类</span></span><br><span class="line">            <span class="type">AspectJMethodBeforeAdvice</span> <span class="variable">advice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJMethodBeforeAdvice</span>(method, pointcut, factory);</span><br><span class="line">            <span class="comment">// 切面</span></span><br><span class="line">            <span class="type">Advisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice);</span><br><span class="line">            list.add(advisor);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.isAnnotationPresent(AfterReturning.class)) &#123;</span><br><span class="line">            <span class="comment">// 解析切点</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> method.getAnnotation(AfterReturning.class).value();</span><br><span class="line">            <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">            pointcut.setExpression(expression);</span><br><span class="line">            <span class="comment">// 通知类</span></span><br><span class="line">            <span class="type">AspectJAfterReturningAdvice</span> <span class="variable">advice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJAfterReturningAdvice</span>(method, pointcut, factory);</span><br><span class="line">            <span class="comment">// 切面</span></span><br><span class="line">            <span class="type">Advisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice);</span><br><span class="line">            list.add(advisor);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.isAnnotationPresent(Around.class)) &#123;</span><br><span class="line">            <span class="comment">// 解析切点</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> method.getAnnotation(Around.class).value();</span><br><span class="line">            <span class="type">AspectJExpressionPointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJExpressionPointcut</span>();</span><br><span class="line">            pointcut.setExpression(expression);</span><br><span class="line">            <span class="comment">// 通知类</span></span><br><span class="line">            <span class="type">AspectJAroundAdvice</span> <span class="variable">advice</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AspectJAroundAdvice</span>(method, pointcut, factory);</span><br><span class="line">            <span class="comment">// 切面</span></span><br><span class="line">            <span class="type">Advisor</span> <span class="variable">advisor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(pointcut, advice);</span><br><span class="line">            list.add(advisor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Advisor advisor : list) &#123;</span><br><span class="line">        System.out.println(advisor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通知统一转换为环绕通知 MethodInterceptor</span></span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">    <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">    proxyFactory.setTarget(target);</span><br><span class="line">    proxyFactory.addAdvisors(list);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    List&lt;Object&gt; methodInterceptorList = proxyFactory.getInterceptorsAndDynamicInterceptionAdvice(Target.class.getMethod(<span class="string">&quot;foo&quot;</span>), Target.class);</span><br><span class="line">    <span class="keyword">for</span> (Object o : methodInterceptorList) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据打印信息可知：</p><p>前置通知 AspectJMethodBeforeAdvice 被转换成 MethodBeforeAdviceInterceptor</p><p>环绕通知 AspectJAroundAdvice 保持不变</p><p>后置通知 AspectJAfterReturningAdvice 被转换成 AfterReturningAdviceInterceptor</p><h2 id="18-2-调用链执行"><a href="#18-2-调用链执行" class="headerlink" title="18.2 调用链执行"></a>18.2 调用链执行</h2><p>高级切面成功转换成低级切面，切面中的通知也全部转换成环绕通知 MethodInterceptor，最后还要调用这些通知和目标方法。</p><p>这个调用交由调用链对象 MethodInvocation 来完成，在调用链对象中存放了所有经过转换得到的环绕通知和目标方法。</p><p>MethodInvocation 是一个接口，其最根本的实现是 ReflectiveMethodInvocation。</p><p>构建 ReflectiveMethodInvocation 对象需要 6 个参数：</p><ol><li>proxy：代理对象</li><li>target：目标对象</li><li>method：目标对象中的方法对象</li><li>arguments：调用目标对象中的方法需要的参数</li><li>targetClass：目标对象的 Class 对象</li><li>interceptorsAndDynamicMethodMatchers：转换得到的环绕通知列表</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">// 3. 创建并执行调用链 (环绕通知s + 目标)</span></span><br><span class="line">    <span class="type">MethodInvocation</span> <span class="variable">methodInvocation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReflectiveMethodInvocation</span>(</span><br><span class="line">        <span class="literal">null</span>, target, Target.class.getMethod(<span class="string">&quot;foo&quot;</span>), <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>], Target.class, methodInterceptorList</span><br><span class="line">    );</span><br><span class="line">    methodInvocation.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后会抛出异常：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalStateException: No MethodInvocation found:</span><br></pre></td></tr></table></figure><p>提示没有找到 MethodInvocation。但调用链对象不是已经创建好了吗？</p><p>这是因为调用链在执行过程会调用到很多通知，而某些通知内部可能需要使用调用链对象。因此需要将调用链对象存放在某一位置，使所有通知都能获取到调用链对象。</p><p>这个“位置”就是 当前线程。</p><p>那怎么将调用链对象放入当前线程呢？</p><p>可以在所有通知的最外层再添加一个环绕通知，其作用是将调用链对象放入当前线程。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=Zjg2MzQ2YTE5OTBjYTM1OWEzNmZkODNmYjYyZGNmM2RfS2hDWXI1NVVZd1NVOXNlM0t1c1hqV2hsNnNNbld1UHNfVG9rZW46THRjVmJROVVyb0xZOUd4cEVXUGNETmxFbkFoXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>可以使用 Spring 提供的 ExposeInvocationInterceptor 作为最外层的环绕通知。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通知统一转换为环绕通知 MethodInterceptor</span></span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">    <span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">    proxyFactory.setTarget(target);</span><br><span class="line">    <span class="comment">// 在最外层添加环绕通知，把 MethodInvocation 放入当前线程</span></span><br><span class="line">    proxyFactory.addAdvice(ExposeInvocationInterceptor.INSTANCE);</span><br><span class="line">    proxyFactory.addAdvisors(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">// 3. 创建并执行调用链 (环绕通知s + 目标)</span></span><br><span class="line">    <span class="type">MethodInvocation</span> <span class="variable">methodInvocation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReflectiveMethodInvocation</span>(</span><br><span class="line">        <span class="literal">null</span>, target, Target.class.getMethod(<span class="string">&quot;foo&quot;</span>), <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>], Target.class, methodInterceptorList</span><br><span class="line">    );</span><br><span class="line">    methodInvocation.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行 main() 方法不再报错，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">before1</span><br><span class="line">around...before</span><br><span class="line">before2</span><br><span class="line">target foo</span><br><span class="line">around...after</span><br><span class="line">afterReturning</span><br></pre></td></tr></table></figure><h2 id="18-3-模拟实现调用链"><a href="#18-3-模拟实现调用链" class="headerlink" title="18.3 模拟实现调用链"></a>18.3 模拟实现调用链</h2><p>调用链执行过程是一个递归过程。执行 proceed() 方法将调用调用链中下一个通知或目标方法。当调用链中没有通知时，就调用目标方法，反之调用下一个通知。</p><p>这体现了设计模式中的责任链模式。</p><p>目标类 Target：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Target foo()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 MethodInterceptor 接口，编写两个环绕通知：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Advice1</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Advice1.before()&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;Advice1.after()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Advice2</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Advice2.before()&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;Advice2.after()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 MethodInvocation 接口，实现自己的调用链：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyInvocation</span> <span class="keyword">implements</span> <span class="title class_">MethodInvocation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] args;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;MethodInterceptor&gt; methodInterceptorList;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocation</span><span class="params">(Object target, Method method, Object[] args, List&lt;MethodInterceptor&gt; methodInterceptorList)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">        <span class="built_in">this</span>.method = method;</span><br><span class="line">        <span class="built_in">this</span>.args = args;</span><br><span class="line">        <span class="built_in">this</span>.methodInterceptorList = methodInterceptorList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Method <span class="title function_">getMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object[] getArguments() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; methodInterceptorList.size()) &#123;</span><br><span class="line">            <span class="comment">// 调用目标，结束递归并返回</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逐一调用通知</span></span><br><span class="line">        <span class="type">MethodInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> methodInterceptorList.get(count++ - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归操作交给通知类</span></span><br><span class="line">        <span class="keyword">return</span> interceptor.invoke(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getThis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AccessibleObject <span class="title function_">getStaticPart</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 main() 方法，执行调用链，查看控制台输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">    List&lt;MethodInterceptor&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Advice1</span>(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Advice2</span>()</span><br><span class="line">    ));</span><br><span class="line">    <span class="type">MyInvocation</span> <span class="variable">invocation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocation</span>(target, Target.class.getMethod(<span class="string">&quot;foo&quot;</span>), <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>], list);</span><br><span class="line">    invocation.proceed();</span><br><span class="line">&#125;</span><br><span class="line">Advice1.before()</span><br><span class="line">Advice2.before()</span><br><span class="line">Target <span class="title function_">foo</span><span class="params">()</span></span><br><span class="line">Advice2.after()</span><br><span class="line">Advice1.after()</span><br></pre></td></tr></table></figure><h2 id="18-4-代理对象调用流程"><a href="#18-4-代理对象调用流程" class="headerlink" title="18.4 代理对象调用流程"></a>18.4 代理对象调用流程</h2><p>以 JDK 动态代理实现为例：</p><ul><li>从 ProxyFactory 获得 Target 和环绕通知链，根据它们创建 MethodInvocation 对象，简称 mi</li><li>首次执行 mi.proceed() 后发现有下一个环绕通知，调用它的 invoke(mi)</li><li>进入环绕通知 1，执行前增强，再次调用 mi.proceed() 后又发现有下一个环绕通知，调用它的 invoke(mi)</li><li>进入环绕通知 2，执行前增强，调用 mi.proceed() 发现没有环绕通知，调用 mi.invokeJoinPoint() 执行目标方法</li><li>目标方法执行结束，将结果返回给环绕通知 2，执行环绕通知 2 的后增强</li><li>环绕通知 2 继续将结果返回给环绕通知 1，执行环绕通知 1 的后增强</li><li>环绕通知 1 返回最终的结果</li></ul><h1 id="动态通知调用"><a href="#动态通知调用" class="headerlink" title="动态通知调用"></a>动态通知调用</h1><p>前文的示例都是静态通知调用，无需参数绑定，执行时无需切点信息，性能较高。</p><p>相应地就有动态通知调用，它需要参数绑定，执行时还需要切点信息，性能较低。比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态通知调用，无需参数绑定，性能较高</span></span><br><span class="line"><span class="comment">     * 执行时无需切点信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* foo(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态通知调用，需要参数绑定，性能较低</span></span><br><span class="line"><span class="comment">     * 执行时还需要切点信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* foo(..)) &amp;&amp; args(x)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;before(%d)\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标类 Target：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;target foo(%d)\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类 MyConfig：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AnnotationAwareAspectJAutoProxyCreator <span class="title function_">proxyCreator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnnotationAwareAspectJAutoProxyCreator</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyAspect <span class="title function_">myAspect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyAspect</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 main() 方法，新建 Spring 容器，查找符合条件的切面，将所有通知转换成环绕通知：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">    context.registerBean(MyConfig.class);</span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="type">AnnotationAwareAspectJAutoProxyCreator</span> <span class="variable">creator</span> <span class="operator">=</span> context.getBean(AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line">    List&lt;Advisor&gt; list = creator.findEligibleAdvisors(Target.class, <span class="string">&quot;target&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>();</span><br><span class="line">    <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">    factory.setTarget(target);</span><br><span class="line">    factory.addAdvisors(list);</span><br><span class="line"></span><br><span class="line">    List&lt;Object&gt; interceptorList = factory.getInterceptorsAndDynamicInterceptionAdvice(Target.class.getMethod(<span class="string">&quot;foo&quot;</span>, <span class="type">int</span>.class), Target.class);</span><br><span class="line">    <span class="keyword">for</span> (Object o : interceptorList) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 main() 方法，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.aop.interceptor.ExposeInvocationInterceptor@73e22a3d</span><br><span class="line">org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor@47faa49c</span><br><span class="line">org.springframework.aop.framework.InterceptorAndDynamicMethodMatcher@28f2a10f</span><br></pre></td></tr></table></figure><p>第一个 ExposeInvocationInterceptor 对象是 Spring 添加的环绕通知，第二个 MethodBeforeAdviceInterceptor 对象是前置通知转换得到的环绕通知，那 InterceptorAndDynamicMethodMatcher 对象是什么呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InterceptorAndDynamicMethodMatcher</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> MethodInterceptor interceptor;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> MethodMatcher methodMatcher;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">InterceptorAndDynamicMethodMatcher</span><span class="params">(MethodInterceptor interceptor, MethodMatcher methodMatcher)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.interceptor = interceptor;</span><br><span class="line">      <span class="built_in">this</span>.methodMatcher = methodMatcher;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InterceptorAndDynamicMethodMatcher 并没有实现 MethodInterceptor 接口，它 不是一个环绕通知，对应了动态通知调用。</p><p>因此 ProxyFactory 对象的 getInterceptorsAndDynamicInterceptionAdvice() 方法返回的不仅是转换得到的环绕通知，还有对应动态通知调用的 InterceptorAndDynamicMethodMatcher 对象。</p><p>InterceptorAndDynamicMethodMatcher 对象中包含了环绕通知 interceptor 对象和切点信息 methodMatcher（前文使用过的 AspectJExpressionPointcut 也实现了 MethodMatcher 接口）。</p><p>尝试查看 InterceptorAndDynamicMethodMatcher 对象中包含的信息，但该类并未声明成 public，其成员变量也未被 public 修饰，也没提供获取的方式，但可以使用反射：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object o : interceptorList) &#123;</span><br><span class="line">        showDetail(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showDetail</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;org.springframework.aop.framework.InterceptorAndDynamicMethodMatcher&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (clazz.isInstance(o)) &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">methodMatcher</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;methodMatcher&quot;</span>);</span><br><span class="line">            methodMatcher.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            <span class="type">Field</span> <span class="variable">methodInterceptor</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;interceptor&quot;</span>);</span><br><span class="line">            methodInterceptor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;环绕通知和切点：&quot;</span> + o);</span><br><span class="line">            System.out.println(<span class="string">&quot;\t切点为：&quot;</span> + methodMatcher.get(o));</span><br><span class="line">            System.out.println(<span class="string">&quot;\t通知为：&quot;</span> + methodInterceptor.get(o));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;普通环绕通知：&quot;</span> + o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">普通环绕通知：org.springframework.aop.interceptor.ExposeInvocationInterceptor@73e22a3d</span><br><span class="line">普通环绕通知：org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor@47faa49c</span><br><span class="line">环绕通知和切点：org.springframework.aop.framework.InterceptorAndDynamicMethodMatcher<span class="meta">@f736069</span></span><br><span class="line">        切点为：AspectJExpressionPointcut: (<span class="type">int</span> x) execution(* foo(..)) &amp;&amp; args(x)</span><br><span class="line">        通知为：org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor@6da21078</span><br></pre></td></tr></table></figure><p>根据打印的切点信息可知，InterceptorAndDynamicMethodMatcher 对象的确对应了动态通知调用。</p><p>最后创建调用链对象，执行通知和原始方法：。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> factory.getProxy();</span><br><span class="line">    <span class="type">MethodInvocation</span> <span class="variable">methodInvocation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReflectiveMethodInvocation</span>(</span><br><span class="line">        proxy, target, Target.class.getMethod(<span class="string">&quot;foo&quot;</span>, <span class="type">int</span>.class), <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="number">100</span>&#125;, Target.class, interceptorList</span><br><span class="line">    ) &#123;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    methodInvocation.proceed();</span><br><span class="line">&#125;</span><br><span class="line">before1</span><br><span class="line"><span class="title function_">before</span><span class="params">(<span class="number">100</span>)</span></span><br><span class="line">target <span class="title function_">foo</span><span class="params">(<span class="number">100</span>)</span></span><br></pre></td></tr></table></figure><p>动态通知调用需要切点信息，需要对参数进行匹配和绑定，复杂程度高，性能比静态通知调用低。</p><h1 id="RequestMappingHandlerMapping-与-RequestMappingHandlerAdapter"><a href="#RequestMappingHandlerMapping-与-RequestMappingHandlerAdapter" class="headerlink" title="RequestMappingHandlerMapping 与 RequestMappingHandlerAdapter"></a>RequestMappingHandlerMapping 与 RequestMappingHandlerAdapter</h1><h2 id="20-1-DispatcherServlet-的初始化"><a href="#20-1-DispatcherServlet-的初始化" class="headerlink" title="20.1 DispatcherServlet 的初始化"></a>20.1 DispatcherServlet 的初始化</h2><p>选择支持内嵌Tomcat 服务器的 Spring 容器作为 ApplicationContext 的实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigServletWebServerApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>(WebConfig.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebConfig 作为配置类，向 Spring 容器中添加内嵌 Web 容器工厂、DispatcherServlet 和 DispatcherServlet 注册对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内嵌 Web 容器工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">tomcatServletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 DispatcherServlet</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册 DispatcherServlet，Spring MVC 的入口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">dispatcherServletRegistrationBean</span><span class="params">(DispatcherServlet dispatcherServlet)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Tomcat initialized with <span class="title function_">port</span><span class="params">(s)</span>: <span class="number">8080</span> (http)</span><br><span class="line">Root WebApplicationContext: initialization completed in <span class="number">2132</span> ms</span><br></pre></td></tr></table></figure><p>Tomcat 容器初始化成功，Spring 容器初始化成功，但 DispatcherServlet 还未被初始化。</p><p>当Tomcat 服务器 首次 使用到 DispatcherServlet 时，才会由Tomcat 服务器初始化 DispatcherServlet。</p><p>清空控制台信息，使用浏览器访问 localhost:8080，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">信息: Initializing Spring DispatcherServlet <span class="string">&#x27;dispatcherServlet&#x27;</span></span><br><span class="line">[INFO ] Initializing Servlet <span class="string">&#x27;dispatcherServlet&#x27;</span> </span><br><span class="line">[TRACE] No MultipartResolver <span class="string">&#x27;multipartResolver&#x27;</span> declared </span><br><span class="line">[TRACE] No LocaleResolver <span class="string">&#x27;localeResolver&#x27;</span>: using <span class="keyword">default</span> [AcceptHeaderLocaleResolver] </span><br><span class="line">[TRACE] No ThemeResolver <span class="string">&#x27;themeResolver&#x27;</span>: using <span class="keyword">default</span> [FixedThemeResolver] </span><br><span class="line">[TRACE] No HandlerMappings declared <span class="keyword">for</span> servlet <span class="string">&#x27;dispatcherServlet&#x27;</span>: using <span class="keyword">default</span> strategies from DispatcherServlet.properties </span><br><span class="line">[TRACE] No HandlerAdapters declared <span class="keyword">for</span> servlet <span class="string">&#x27;dispatcherServlet&#x27;</span>: using <span class="keyword">default</span> strategies from DispatcherServlet.properties </span><br><span class="line">[TRACE] No HandlerExceptionResolvers declared in servlet <span class="string">&#x27;dispatcherServlet&#x27;</span>: using <span class="keyword">default</span> strategies from DispatcherServlet.properties </span><br><span class="line">[TRACE] No RequestToViewNameTranslator <span class="string">&#x27;viewNameTranslator&#x27;</span>: using <span class="keyword">default</span> [DefaultRequestToViewNameTranslator] </span><br><span class="line">[TRACE] No ViewResolvers declared <span class="keyword">for</span> servlet <span class="string">&#x27;dispatcherServlet&#x27;</span>: using <span class="keyword">default</span> strategies from DispatcherServlet.properties </span><br><span class="line">[TRACE] No FlashMapManager <span class="string">&#x27;flashMapManager&#x27;</span>: using <span class="keyword">default</span> [SessionFlashMapManager] </span><br><span class="line">[INFO] Completed initialization in <span class="number">482</span> ms </span><br></pre></td></tr></table></figure><p>完成 DispatcherServlet 的初始化。</p><p>使用 DEBUG 查看 DispatcherServlet 的初始化时机</p><p>断点 DispatcherServlet 的 onRefresh() 方法中 this.initStrategies(context); 的所在行：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.initStrategies(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 DEBUG 方式重启程序，此时程序尚未执行到断点处。</p><p>再次在浏览器中访问 localhost:8080，程序执行到断点处。</p><p>查看调用栈可知，是从 GenericServlet 的 init() 方法执行到 onRefresh() 方法的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="built_in">this</span>.config = config;</span><br><span class="line">    <span class="built_in">this</span>.init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此 DispatcherServlet 的初始化流程走的是 Servlet 的初始化流程。</p><p>使 DispatcherServlet 在Tomcat 服务器启动时被初始化</p><p>修改添加到 Spring 容器的 DispatcherServlet 注册 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">dispatcherServletRegistrationBean</span><span class="params">(DispatcherServlet dispatcherServlet)</span> &#123;</span><br><span class="line">    <span class="type">DispatcherServletRegistrationBean</span> <span class="variable">registrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> registrationBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置其 loadOnStartup 为一个正数。</p><p>当存在多个 DispatcherServlet 需要被注册时，设置的 loadOnStartup 越大，优先级越小，初始化顺序越靠后。</p><p>再次重启程序，根据控制台输出的内容可知，不仅完成 Tomcat 和 Spring 容器的初始化，DispatcherServlet 也初始化成功。</p><p>抽取配置信息到配置文件中</p><p>使用 @PropertySource 注解设置配置类需要读取的配置文件，以便后续读取配置文件中的内容。</p><p>要读取配置文件中的内容，可以使用 @Value 注解，但该注解一次仅仅能够读取一个值，现实是往往需要从配置文件中读取多个值。</p><p>可以使用 @EnableConfigurationProperties 注解完成配置文件信息与对象的绑定，后续使用时作为 @Bean 注解标记的方法的参数直接在方法中使用即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server.port=<span class="number">9090</span></span><br><span class="line">spring.mvc.servlet.load-on-startup=<span class="number">1</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;WebMvcProperties.class, ServerProperties.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内嵌 Web 容器工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">tomcatServletWebServerFactory</span><span class="params">(ServerProperties serverProperties)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>(serverProperties.getPort());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 DispatcherServlet</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册 DispatcherServlet，Spring MVC 的入口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">dispatcherServletRegistrationBean</span><span class="params">(DispatcherServlet dispatcherServlet,</span></span><br><span class="line"><span class="params">                                                                               WebMvcProperties webMvcProperties)</span> &#123;</span><br><span class="line">        <span class="type">DispatcherServletRegistrationBean</span> <span class="variable">registrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        registrationBean.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup());</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次重启程序，根据控制台输出的内容可知，Tomcat 此时监听的端口是 9090，DispatcherServlet 也在 Tomcat 启动时被初始化。</p><p>DispatcherServlet 初始化时执行的操作</p><p>回到 DispatcherServlet 的 onRefresh() 方法，它又调用了 initStrategies() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initStrategies</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.initMultipartResolver(context);</span><br><span class="line">    <span class="built_in">this</span>.initLocaleResolver(context);</span><br><span class="line">    <span class="built_in">this</span>.initThemeResolver(context);</span><br><span class="line">    <span class="built_in">this</span>.initHandlerMappings(context);</span><br><span class="line">    <span class="built_in">this</span>.initHandlerAdapters(context);</span><br><span class="line">    <span class="built_in">this</span>.initHandlerExceptionResolvers(context);</span><br><span class="line">    <span class="built_in">this</span>.initRequestToViewNameTranslator(context);</span><br><span class="line">    <span class="built_in">this</span>.initViewResolvers(context);</span><br><span class="line">    <span class="built_in">this</span>.initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中初始化了一系列组件，见名识意即可，重点介绍：</p><p>initHandlerMappings()：初始化处理器映射器</p><p>initHandlerAdapters()：初始化处理器适配器</p><p>initHandlerExceptionResolvers()：初始化异常处理器</p><p>在所有的初始化方法中都有一个相似的逻辑，首先使用一个布尔值判断是否检测 所有 目标组件。</p><p>Spring 支持父子容器嵌套，如果判断的布尔值为 true，那么 Spring 不仅会在当前容器中获取目标组件，还会在其所有父级容器中寻找。</p><p>以 initHandlerMappings() 为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.handlerMappings = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.detectAllHandlerMappings) &#123; <span class="comment">// 是否需要检测所有处理器映射器</span></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 无需检测所有处理器映射器时，获取当前容器中的处理器映射器</span></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前容器中没有处理器映射器时，设置默认的处理器映射器</span></span><br><span class="line">        <span class="built_in">this</span>.handlerMappings = <span class="built_in">this</span>.getDefaultStrategies(context, HandlerMapping.class);</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-2-RequestMappingHandlerMapping"><a href="#20-2-RequestMappingHandlerMapping" class="headerlink" title="20.2 RequestMappingHandlerMapping"></a>20.2 RequestMappingHandlerMapping</h2><p>HandlerMapping，即处理器映射器，用于建立请求路径与控制器方法的映射关系。</p><p>RequestMappingHandlerMapping 是 HandlerMapping 的一种实现，根据类名可知，它是通过 @RequestMapping 注解来实现路径映射。</p><p>当 Spring 容器中没有 HandlerMapping 的实现时，尽管 DispatcherServlet 在初始化时会添加一些默认的实现，但这些实现不会交由 Spring 管理，而是作为 DispatcherServlet 的成员变量。</p><p>在配置类中将 RequestMappingHandlerMapping 添加到 Spring 容器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RequestMappingHandlerMapping <span class="title function_">requestMappingHandlerMapping</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerMapping</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个控制器类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Controller1</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;test1()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/test2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">test2</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;test2(&#123;&#125;)&quot;</span>, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/test3&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">test3</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;test3(&#123;&#125;)&quot;</span>, token);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test4&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;test4&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写 main() 方法，从 Spring 容器中获取 RequestMappingHandlerMapping，再获取请求路径与映射器方法的映射关系，并根据给定请求获取控制器方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">AnnotationConfigServletWebServerApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>(WebConfig.class);</span><br><span class="line">    <span class="comment">// 解析 @RequestMapping 以及派生注解，在初始化时生成路径与控制器方法的映射关系</span></span><br><span class="line">    <span class="type">RequestMappingHandlerMapping</span> <span class="variable">handlerMapping</span> <span class="operator">=</span> context.getBean(RequestMappingHandlerMapping.class);</span><br><span class="line">    <span class="comment">// 获取映射结果</span></span><br><span class="line">    Map&lt;RequestMappingInfo, HandlerMethod&gt; handlerMethods = handlerMapping.getHandlerMethods();</span><br><span class="line">    handlerMethods.forEach((k, v) -&gt; System.out.println(k + <span class="string">&quot; = &quot;</span> + v));</span><br><span class="line">    <span class="comment">// 根据给定请求获取控制器方法，返回处理器执行链</span></span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">chain</span> <span class="operator">=</span> handlerMapping.getHandler(<span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/test1&quot;</span>));</span><br><span class="line">    System.out.println(chain);</span><br><span class="line">&#125;</span><br><span class="line">&#123;GET [/test1]&#125; = indi.lcp.a20.Controller1#test1()</span><br><span class="line">&#123;POST [/test2]&#125; = indi.lcp.a20.Controller1#test2(String)</span><br><span class="line">&#123;PUT [/test3]&#125; = indi.lcp.a20.Controller1#test3(String)</span><br><span class="line">&#123; [/test4]&#125; = indi.lcp.a20.Controller1#test4()</span><br><span class="line">HandlerExecutionChain with [indi.lcp.a20.Controller1#test1()] and <span class="number">0</span> interceptors</span><br></pre></td></tr></table></figure><p>getHandler() 方法返回的对象时处理器执行链，不仅包含映射器方法，还包含需要执行的拦截器信息</p><p>需要导入以下依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="20-3-RequestMappingHandlerAdapter"><a href="#20-3-RequestMappingHandlerAdapter" class="headerlink" title="20.3 RequestMappingHandlerAdapter"></a>20.3 RequestMappingHandlerAdapter</h2><p>RequestMappingHandlerAdapter 实现了 HandlerAdapter 接口，HandlerAdapter 用于执行控制器方法，而 RequestMapping 表明 RequestMappingHandlerAdapter 用于执行被 @RequestMapping 注解标记的控制器方法。</p><p>同样需要在配置类中将 RequestMappingHandlerAdapter 添加到 Spring 容器，但该类中需要测试的方法被 protected 修饰，无法直接使用，因此创建一个子类，将子类添加到 Spring 容器中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRequestMappingHandlerAdapter</span> <span class="keyword">extends</span> <span class="title class_">RequestMappingHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">invokeHandlerMethod</span><span class="params">(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MyRequestMappingHandlerAdapter <span class="title function_">myRequestMappingHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyRequestMappingHandlerAdapter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main() 方法中测试 RequestMappingHandlerAdapter 的 invokeHandlerMethod() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;/test2&quot;</span>);</span><br><span class="line">    request.setParameter(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lcp&quot;</span>);</span><br><span class="line">    <span class="type">MockHttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletResponse</span>();</span><br><span class="line">    <span class="type">MyRequestMappingHandlerAdapter</span> <span class="variable">handlerAdapter</span> <span class="operator">=</span> context.getBean(MyRequestMappingHandlerAdapter.class);</span><br><span class="line">    handlerAdapter.invokeHandlerMethod(request, response, ((HandlerMethod) handlerMapping.getHandler(request).getHandler()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现控制器方法的调用很简单，但如何将请求参数与方法参数相绑定的呢？</p><p>显然是需要解析 @RequestParam 注解。</p><p>Spring 支持许多种类的控制器方法参数，不同种类的参数使用不同的解析器，使用 MyRequestMappingHandlerAdapter 的 getArgumentResolvers() 方法获取所有参数解析器。</p><p>Spring 也支持许多种类的控制器方法返回值类型，使用 MyRequestMappingHandlerAdapter 的 getReturnValueHandlers() 方法获取所有返回值处理器。</p><p>自定义参数解析器</p><p>假如经常需要使用到请求头中的 Token 信息，自定义 @Token 注解，使用该注解标记控制器方法的哪个参数来获取 Token 信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.PARAMETER)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Token &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使 test3() 控制器方法参数被 @Token 标记：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PutMapping(&quot;/test3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">test3</span><span class="params">(<span class="meta">@Token</span> String token)</span> &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;test3(&#123;&#125;)&quot;</span>, token);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义参数解析器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenArgumentResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodArgumentResolver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parameter.getParameterAnnotation(Token.class) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">resolveArgument</span><span class="params">(MethodParameter parameter,</span></span><br><span class="line"><span class="params">                                  ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">                                  NativeWebRequest webRequest,</span></span><br><span class="line"><span class="params">                                  WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> webRequest.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将参数解析器添加到 HandlerAdapter 中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MyRequestMappingHandlerAdapter <span class="title function_">myRequestMappingHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TokenArgumentResolver</span> <span class="variable">tokenArgumentResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TokenArgumentResolver</span>();</span><br><span class="line">    <span class="type">MyRequestMappingHandlerAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRequestMappingHandlerAdapter</span>();</span><br><span class="line">    adapter.setCustomArgumentResolvers(Collections.singletonList(tokenArgumentResolver));</span><br><span class="line">    <span class="keyword">return</span> adapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试执行 test3() 控制器方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">tokenRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>(<span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;/test3&quot;</span>);</span><br><span class="line">    tokenRequest.addHeader(<span class="string">&quot;token&quot;</span>, <span class="string">&quot;token info&quot;</span>);</span><br><span class="line">    handlerAdapter.invokeHandlerMethod(tokenRequest, response, ((HandlerMethod) handlerMapping.getHandler(tokenRequest).getHandler()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义返回值处理器</p><p>当 @ResponseBody 标记了控制器方法时，方法的返回值会转换成 JSON 写入响应体中。</p><p>自定义 @Yml 注解，被 @Yml 注解标记的控制器方法的返回值会转换成 YAML 写入响应体中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Yml &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使 test4() 控制器方法被 @Yml 注解标记：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test4&quot;)</span></span><br><span class="line"><span class="meta">@Yml</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;test4&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义返回值处理器将返回值转换成 YAML：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YmlReturnValueHandler</span> <span class="keyword">implements</span> <span class="title class_">HandlerMethodReturnValueHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> returnType.getMethodAnnotation(Yml.class) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(Object returnValue,</span></span><br><span class="line"><span class="params">                                  MethodParameter returnType,</span></span><br><span class="line"><span class="params">                                  ModelAndViewContainer mavContainer,</span></span><br><span class="line"><span class="params">                                  NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 转换返回结果为 YAML</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>().dump(returnValue);</span><br><span class="line">        <span class="comment">// 将 YAML 字符串写入响应体</span></span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> webRequest.getNativeResponse(HttpServletResponse.class);</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/plain;charset=utf-8&quot;</span>);</span><br><span class="line">        response.getWriter().print(str);</span><br><span class="line">        <span class="comment">// 设置请求已经处理完毕</span></span><br><span class="line">        mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将返回值处理器添加到 HandlerAdapter 中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MyRequestMappingHandlerAdapter <span class="title function_">myRequestMappingHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MyRequestMappingHandlerAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRequestMappingHandlerAdapter</span>();</span><br><span class="line">    <span class="type">YmlReturnValueHandler</span> <span class="variable">ymlReturnValueHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">YmlReturnValueHandler</span>();</span><br><span class="line">    adapter.setCustomReturnValueHandlers(Collections.singletonList(ymlReturnValueHandler));</span><br><span class="line">    <span class="keyword">return</span> adapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试执行 test4() 控制器方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">test4Req</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/test4&quot;</span>);</span><br><span class="line">    handlerAdapter.invokeHandlerMethod(test4Req, response, ((HandlerMethod) handlerMapping.getHandler(test4Req).getHandler()));</span><br><span class="line">    <span class="type">byte</span>[] content = response.getContentAsByteArray();</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(content, StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参数解析器"><a href="#参数解析器" class="headerlink" title="参数解析器"></a>参数解析器</h1><p>Spring 提供了许多种类的控制器方法参数解析器，定义一个包含多个不同种类参数的控制器方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(&quot;name1&quot;)</span> String name1, // name1=张三</span></span><br><span class="line"><span class="params">            String name2, // name2=李四</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(&quot;age&quot;)</span> <span class="type">int</span> age, // age=<span class="number">18</span></span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(name = &quot;home&quot;, defaultValue = &quot;$&#123;JAVA_HOME&#125;&quot;)</span> String home1, // spring 获取数据</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file, // 上传文件</span></span><br><span class="line"><span class="params">            <span class="meta">@PathVariable(&quot;id&quot;)</span> <span class="type">int</span> id, //  /test/<span class="number">124</span>   /test/&#123;id&#125;</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestHeader(&quot;Content-Type&quot;)</span> String header,</span></span><br><span class="line"><span class="params">            <span class="meta">@CookieValue(&quot;token&quot;)</span> String token,</span></span><br><span class="line"><span class="params">            <span class="meta">@Value(&quot;$&#123;JAVA_HOME&#125;&quot;)</span> String home2, // spring 获取数据  $&#123;&#125; #&#123;&#125;</span></span><br><span class="line"><span class="params">            HttpServletRequest request, // request, response, session ...</span></span><br><span class="line"><span class="params">            <span class="meta">@ModelAttribute(&quot;abc&quot;)</span> User user1, // name=zhang&amp;age=<span class="number">18</span></span></span><br><span class="line"><span class="params">            User user2, // name=zhang&amp;age=<span class="number">18</span></span></span><br><span class="line"><span class="params">            <span class="meta">@RequestBody</span> User user3 // json</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将控制器方法封装成 HandlerMethod 并打印方法中每个参数的信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 控制器方法封装成 HandlerMethod</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> Controller.class.getMethod(<span class="string">&quot;test&quot;</span>, String.class, String.class,</span><br><span class="line">            <span class="type">int</span>.class, String.class, MultipartFile.class,</span><br><span class="line">            <span class="type">int</span>.class, String.class, String.class,</span><br><span class="line">            String.class, HttpServletRequest.class, User.class,</span><br><span class="line">            User.class, User.class);</span><br><span class="line">    <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">Controller</span>(), method);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析每个参数值</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">annotations</span> <span class="operator">=</span> Arrays.stream(parameter.getParameterAnnotations())</span><br><span class="line">                .map(i -&gt; i.annotationType().getSimpleName()).collect(Collectors.joining());</span><br><span class="line">        <span class="type">String</span> <span class="variable">appendAt</span> <span class="operator">=</span> annotations.length() &gt; <span class="number">0</span> ? <span class="string">&quot;@&quot;</span> + annotations + <span class="string">&quot; &quot;</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 设置参数名解析器</span></span><br><span class="line">        parameter.initParameterNameDiscovery(<span class="keyword">new</span> <span class="title class_">DefaultParameterNameDiscoverer</span>());</span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span> + parameter.getParameterIndex() + <span class="string">&quot;] &quot;</span> + appendAt +</span><br><span class="line">                parameter.getParameterType().getSimpleName() + <span class="string">&quot; &quot;</span> + parameter.getParameterName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">0</span>] <span class="meta">@RequestParam</span> String name1</span><br><span class="line">[<span class="number">1</span>] String name2</span><br><span class="line">[<span class="number">2</span>] <span class="meta">@RequestParam</span> <span class="type">int</span> age</span><br><span class="line">[<span class="number">3</span>] <span class="meta">@RequestParam</span> String home1</span><br><span class="line">[<span class="number">4</span>] <span class="meta">@RequestParam</span> MultipartFile file</span><br><span class="line">[<span class="number">5</span>] <span class="meta">@PathVariable</span> <span class="type">int</span> id</span><br><span class="line">[<span class="number">6</span>] <span class="meta">@RequestHeader</span> String header</span><br><span class="line">[<span class="number">7</span>] <span class="meta">@CookieValue</span> String token</span><br><span class="line">[<span class="number">8</span>] <span class="meta">@Value</span> String home2</span><br><span class="line">[<span class="number">9</span>] HttpServletRequest request</span><br><span class="line">[<span class="number">10</span>] <span class="meta">@ModelAttribute</span> User user1</span><br><span class="line">[<span class="number">11</span>] User user2</span><br><span class="line">[<span class="number">12</span>] <span class="meta">@RequestBody</span> User user3</span><br></pre></td></tr></table></figure><h2 id="21-1-RequestParam"><a href="#21-1-RequestParam" class="headerlink" title="21.1. @RequestParam"></a>21.1. @RequestParam</h2><p>@RequestParam 注解的解析需要使用到 RequestParamMethodArgumentResolver 参数解析器。构造时需要两个参数：</p><ul><li>beanFactory：Bean 工厂对象。需要解析 ${} 时，就需要指定 Bean 工厂对象</li><li>useDefaultResolution：布尔类型参数。为 false 表示只解析添加了 @RequestParam 注解的参数，为 true 针对未添加 @RequestParam 注解的参数也使用该参数解析器进行解析。</li></ul><p>RequestParamMethodArgumentResolver 利用 resolveArgument() 方法完成参数的解析，该方法需要传递四个参数：</p><ul><li>parameter：参数对象</li><li>mavContainer：ModelAndView 容器，用来存储中间的 Model 结果</li><li>webRequest：由 ServletWebRequest 封装后的请求对象</li><li>binderFactory：数据绑定工厂，用于完成对象绑定和类型转换，比如将字符串类型的 18 转换成整</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(WebConfig.class);</span><br><span class="line">    <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getBeanFactory();</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> mockRequest();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制器方法封装成 HandlerMethod</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> Controller.class.getMethod(<span class="string">&quot;test&quot;</span>, String.class, String.class,</span><br><span class="line">            <span class="type">int</span>.class, String.class, MultipartFile.class,</span><br><span class="line">            <span class="type">int</span>.class, String.class, String.class,</span><br><span class="line">            String.class, HttpServletRequest.class, User.class,</span><br><span class="line">            User.class, User.class);</span><br><span class="line">    <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">Controller</span>(), method);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备对象绑定与类型转换</span></span><br><span class="line">    <span class="type">ServletRequestDataBinderFactory</span> <span class="variable">binderFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRequestDataBinderFactory</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备 ModelAndViewContainer 用来存储中间的 Model 结果</span></span><br><span class="line">    <span class="type">ModelAndViewContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndViewContainer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析每个参数值</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">        <span class="comment">// useDefaultResolution 为 false 表示必须添加 @RequestParam 注解</span></span><br><span class="line">        <span class="type">RequestParamMethodArgumentResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">annotations</span> <span class="operator">=</span> Arrays.stream(parameter.getParameterAnnotations())</span><br><span class="line">                .map(i -&gt; i.annotationType().getSimpleName()).collect(Collectors.joining());</span><br><span class="line">        <span class="type">String</span> <span class="variable">appendAt</span> <span class="operator">=</span> annotations.length() &gt; <span class="number">0</span> ? <span class="string">&quot;@&quot;</span> + annotations + <span class="string">&quot; &quot;</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 设置参数名解析器</span></span><br><span class="line">        parameter.initParameterNameDiscovery(<span class="keyword">new</span> <span class="title class_">DefaultParameterNameDiscoverer</span>());</span><br><span class="line">        <span class="type">String</span> <span class="variable">paramInfo</span> <span class="operator">=</span> <span class="string">&quot;[&quot;</span> + parameter.getParameterIndex() + <span class="string">&quot;] &quot;</span> + appendAt +</span><br><span class="line">                parameter.getParameterType().getSimpleName() + <span class="string">&quot; &quot;</span> + parameter.getParameterName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resolver.supportsParameter(parameter)) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> resolver.resolveArgument(parameter, container, <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request), binderFactory);</span><br><span class="line">            System.out.println(Objects.requireNonNull(v).getClass());</span><br><span class="line">            System.out.println(paramInfo + <span class="string">&quot; -&gt; &quot;</span> + v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(paramInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">[<span class="number">0</span>] <span class="meta">@RequestParam</span> String name1 -&gt; zhangsan</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">[<span class="number">1</span>] String name2 -&gt; lisi</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.Integer</span><br><span class="line">[<span class="number">2</span>] <span class="meta">@RequestParam</span> <span class="type">int</span> age -&gt; <span class="number">18</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">[<span class="number">3</span>] <span class="meta">@RequestParam</span> String home1 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile</span><br><span class="line">[<span class="number">4</span>] <span class="meta">@RequestParam</span> MultipartFile file -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile<span class="meta">@f2ff811</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalStateException: Optional <span class="type">int</span> parameter <span class="string">&#x27;id&#x27;</span> is present but cannot be translated into a <span class="literal">null</span> value due to being declared as a primitive type. Consider declaring it as object wrapper <span class="keyword">for</span> the corresponding primitive type.</span><br></pre></td></tr></table></figure><p>控制器方法 test() 的前 5 个参数解析成功，但在解析第 6 个参数时产生了异常。</p><p>这是因为在构造 RequestParamMethodArgumentResolver 对象时，将 useDefaultResolution 设置为 true，针对未添加 @RequestParam 注解的参数都使用该参数解析器进行解析。第 6 个参数需要的 id 信息使用该解析器解析得到的结果是 null，无法将 null 值赋值给基本类型 int，显然第 6 个及其以后的参数应该使用其他参数解析器进行解析。</p><p>多个参数解析器的组合 - 组合模式</p><p>不同种类的参数需要不同的参数解析器，当前使用的参数解析器不支持当前参数的解析时，就应该换一个参数解析器进行解析。</p><p>可以将所有参数解析器添加到一个集合中，然后遍历这个集合，实现上述需求。</p><p>Spring 提供了名为 HandlerMethodArgumentResolverComposite 的类，对上述逻辑进行封装。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析每个参数值</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">        <span class="comment">// 多个参数解析器的组合</span></span><br><span class="line">        <span class="type">HandlerMethodArgumentResolverComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>();</span><br><span class="line">        composite.addResolvers(</span><br><span class="line">                <span class="comment">// useDefaultResolution 为 false 表示必须添加 @RequestParam 注解</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">true</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (composite.supportsParameter(parameter)) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> composite.resolveArgument(parameter, container, <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request), binderFactory);</span><br><span class="line">            System.out.println(paramInfo + <span class="string">&quot; -&gt; &quot;</span> + v);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(paramInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21-2-PathVariable"><a href="#21-2-PathVariable" class="headerlink" title="21.2 @PathVariable"></a>21.2 @PathVariable</h2><p>@PathVariable 注解的解析需要使用到 PathVariableMethodArgumentResolver 参数解析器。构造时无需传入任何参数。</p><p>使用该解析器需要一个 Map 集合，该 Map 集合是 @RequestMapping 注解上指定的路径和实际 URL 路径进行匹配后，得到的路径上的参数与实际路径上的值的关系（获取这个 Map 并将其设置给 request 作用域由 HandlerMapping 完成）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析每个参数值</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">        <span class="comment">// 多个参数解析器的组合</span></span><br><span class="line">        <span class="type">HandlerMethodArgumentResolverComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>();</span><br><span class="line">        composite.addResolvers(</span><br><span class="line">            <span class="comment">// useDefaultResolution 为 false 表示必须添加 @RequestParam 注解</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">false</span>),</span><br><span class="line">            <span class="comment">// 解析 @PathVariable</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PathVariableMethodArgumentResolver</span>()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 RequestParamMethodArgumentResolver 参数解析器的构造，将 useDefaultResolution 设置为 false，让程序 暂时 不抛出异常。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>] <span class="meta">@RequestParam</span> String name1 -&gt; zhangsan</span><br><span class="line">[<span class="number">1</span>] String name2</span><br><span class="line">[<span class="number">2</span>] <span class="meta">@RequestParam</span> <span class="type">int</span> age -&gt; <span class="number">18</span></span><br><span class="line">[<span class="number">3</span>] <span class="meta">@RequestParam</span> String home1 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">4</span>] <span class="meta">@RequestParam</span> MultipartFile file -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@11c9af63</span><br><span class="line">[<span class="number">5</span>] <span class="meta">@PathVariable</span> <span class="type">int</span> id -&gt; <span class="number">123</span></span><br></pre></td></tr></table></figure><h2 id="21-3-RequestHeader"><a href="#21-3-RequestHeader" class="headerlink" title="21.3 @RequestHeader"></a>21.3 @RequestHeader</h2><p>@RequestHeader 注解的解析需要使用到 RequestHeaderMethodArgumentResolver 参数解析器。构造时需要传入一个Bean 工厂对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析每个参数值</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">        <span class="comment">// 多个参数解析器的组合</span></span><br><span class="line">        <span class="type">HandlerMethodArgumentResolverComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>();</span><br><span class="line">        composite.addResolvers(</span><br><span class="line">            <span class="comment">// useDefaultResolution 为 false 表示必须添加 @RequestParam 注解</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">false</span>),</span><br><span class="line">            <span class="comment">// 解析 @PathVariable</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PathVariableMethodArgumentResolver</span>(),</span><br><span class="line">            <span class="comment">// 解析 @RequestHeader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestHeaderMethodArgumentResolver</span>(beanFactory)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">0</span>] <span class="meta">@RequestParam</span> String name1 -&gt; zhangsan</span><br><span class="line">[<span class="number">1</span>] String name2</span><br><span class="line">[<span class="number">2</span>] <span class="meta">@RequestParam</span> <span class="type">int</span> age -&gt; <span class="number">18</span></span><br><span class="line">[<span class="number">3</span>] <span class="meta">@RequestParam</span> String home1 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">4</span>] <span class="meta">@RequestParam</span> MultipartFile file -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@3943a2be</span><br><span class="line">[<span class="number">5</span>] <span class="meta">@PathVariable</span> <span class="type">int</span> id -&gt; <span class="number">123</span></span><br><span class="line">[<span class="number">6</span>] <span class="meta">@RequestHeader</span> String header -&gt; application/json</span><br></pre></td></tr></table></figure><h2 id="21-4-CookieValue"><a href="#21-4-CookieValue" class="headerlink" title="21.4 @CookieValue"></a>21.4 @CookieValue</h2><p>@CookieValue 注解的解析需要使用到 ServletCookieValueMethodArgumentResolver 参数解析器。构造时需要传入一个Bean 工厂对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析每个参数值</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">        <span class="comment">// 多个参数解析器的组合</span></span><br><span class="line">        <span class="type">HandlerMethodArgumentResolverComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>();</span><br><span class="line">        composite.addResolvers(</span><br><span class="line">            <span class="comment">// useDefaultResolution 为 false 表示必须添加 @RequestParam 注解</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">false</span>),</span><br><span class="line">            <span class="comment">// 解析 @PathVariable</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PathVariableMethodArgumentResolver</span>(),</span><br><span class="line">            <span class="comment">// 解析 @RequestHeader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestHeaderMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 @CookieValue</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletCookieValueMethodArgumentResolver</span>(beanFactory)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">0</span>] <span class="meta">@RequestParam</span> String name1 -&gt; zhangsan</span><br><span class="line">[<span class="number">1</span>] String name2</span><br><span class="line">[<span class="number">2</span>] <span class="meta">@RequestParam</span> <span class="type">int</span> age -&gt; <span class="number">18</span></span><br><span class="line">[<span class="number">3</span>] <span class="meta">@RequestParam</span> String home1 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">4</span>] <span class="meta">@RequestParam</span> MultipartFile file -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@1329eff</span><br><span class="line">[<span class="number">5</span>] <span class="meta">@PathVariable</span> <span class="type">int</span> id -&gt; <span class="number">123</span></span><br><span class="line">[<span class="number">6</span>] <span class="meta">@RequestHeader</span> String header -&gt; application/json</span><br><span class="line">[<span class="number">7</span>] <span class="meta">@CookieValue</span> String token -&gt; <span class="number">123456</span></span><br></pre></td></tr></table></figure><h2 id="21-5-Value"><a href="#21-5-Value" class="headerlink" title="21.5 @Value"></a>21.5 @Value</h2><p>@Value 注解的解析需要使用到 ExpressionValueMethodArgumentResolver 参数解析器。构造时需要传入一个Bean 工厂对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析每个参数值</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">        <span class="comment">// 多个参数解析器的组合</span></span><br><span class="line">        <span class="type">HandlerMethodArgumentResolverComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>();</span><br><span class="line">        composite.addResolvers(</span><br><span class="line">            <span class="comment">// useDefaultResolution 为 false 表示必须添加 @RequestParam 注解</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">false</span>),</span><br><span class="line">            <span class="comment">// 解析 @PathVariable</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PathVariableMethodArgumentResolver</span>(),</span><br><span class="line">            <span class="comment">// 解析 @RequestHeader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestHeaderMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 @CookieValue</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletCookieValueMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 @Value</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ExpressionValueMethodArgumentResolver</span>(beanFactory)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">0</span>] <span class="meta">@RequestParam</span> String name1 -&gt; zhangsan</span><br><span class="line">[<span class="number">1</span>] String name2</span><br><span class="line">[<span class="number">2</span>] <span class="meta">@RequestParam</span> <span class="type">int</span> age -&gt; <span class="number">18</span></span><br><span class="line">[<span class="number">3</span>] <span class="meta">@RequestParam</span> String home1 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">4</span>] <span class="meta">@RequestParam</span> MultipartFile file -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@46fa7c39</span><br><span class="line">[<span class="number">5</span>] <span class="meta">@PathVariable</span> <span class="type">int</span> id -&gt; <span class="number">123</span></span><br><span class="line">[<span class="number">6</span>] <span class="meta">@RequestHeader</span> String header -&gt; application/json</span><br><span class="line">[<span class="number">7</span>] <span class="meta">@CookieValue</span> String token -&gt; <span class="number">123456</span></span><br><span class="line">[<span class="number">8</span>] <span class="meta">@Value</span> String home2 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br></pre></td></tr></table></figure><h2 id="21-6-HttpServletRequest"><a href="#21-6-HttpServletRequest" class="headerlink" title="21.6 HttpServletRequest"></a>21.6 HttpServletRequest</h2><p>HttpServletRequest 类型的参数的解析需要使用到 ServletRequestMethodArgumentResolver 参数解析器。构造时无需传入任何参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析每个参数值</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">        <span class="comment">// 多个参数解析器的组合</span></span><br><span class="line">        <span class="type">HandlerMethodArgumentResolverComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>();</span><br><span class="line">        composite.addResolvers(</span><br><span class="line">            <span class="comment">// useDefaultResolution 为 false 表示必须添加 @RequestParam 注解</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">false</span>),</span><br><span class="line">            <span class="comment">// 解析 @PathVariable</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PathVariableMethodArgumentResolver</span>(),</span><br><span class="line">            <span class="comment">// 解析 @RequestHeader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestHeaderMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 @CookieValue</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletCookieValueMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 @Value</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ExpressionValueMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 HttpServletRequest</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletRequestMethodArgumentResolver</span>()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">0</span>] <span class="meta">@RequestParam</span> String name1 -&gt; zhangsan</span><br><span class="line">[<span class="number">1</span>] String name2</span><br><span class="line">[<span class="number">2</span>] <span class="meta">@RequestParam</span> <span class="type">int</span> age -&gt; <span class="number">18</span></span><br><span class="line">[<span class="number">3</span>] <span class="meta">@RequestParam</span> String home1 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">4</span>] <span class="meta">@RequestParam</span> MultipartFile file -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@5f683daf</span><br><span class="line">[<span class="number">5</span>] <span class="meta">@PathVariable</span> <span class="type">int</span> id -&gt; <span class="number">123</span></span><br><span class="line">[<span class="number">6</span>] <span class="meta">@RequestHeader</span> String header -&gt; application/json</span><br><span class="line">[<span class="number">7</span>] <span class="meta">@CookieValue</span> String token -&gt; <span class="number">123456</span></span><br><span class="line">[<span class="number">8</span>] <span class="meta">@Value</span> String home2 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">9</span>] HttpServletRequest request -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest@152aa092</span><br></pre></td></tr></table></figure><p>ServletRequestMethodArgumentResolver 参数解析器不仅可以解析 HttpServletRequest 类型的参数，还支持许多其他类型的参数，其支持的参数类型可在 supportsParameter() 方法中看到：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supportsParameter</span><span class="params">(MethodParameter parameter)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; paramType = parameter.getParameterType();</span><br><span class="line">    <span class="keyword">return</span> (WebRequest.class.isAssignableFrom(paramType) ||</span><br><span class="line">            ServletRequest.class.isAssignableFrom(paramType) ||</span><br><span class="line">            MultipartRequest.class.isAssignableFrom(paramType) ||</span><br><span class="line">            HttpSession.class.isAssignableFrom(paramType) ||</span><br><span class="line">            (pushBuilder != <span class="literal">null</span> &amp;&amp; pushBuilder.isAssignableFrom(paramType)) ||</span><br><span class="line">            (Principal.class.isAssignableFrom(paramType) &amp;&amp; !parameter.hasParameterAnnotations()) ||</span><br><span class="line">            InputStream.class.isAssignableFrom(paramType) ||</span><br><span class="line">            Reader.class.isAssignableFrom(paramType) ||</span><br><span class="line">            HttpMethod.class == paramType ||</span><br><span class="line">            Locale.class == paramType ||</span><br><span class="line">            TimeZone.class == paramType ||</span><br><span class="line">            ZoneId.class == paramType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21-7-ModelAttribute"><a href="#21-7-ModelAttribute" class="headerlink" title="21.7 @ModelAttribute"></a>21.7 @ModelAttribute</h2><p>@ModelAttribute 注解的解析需要使用到 ServletModelAttributeMethodProcessor 参数解析器。构造时需要传入一个布尔类型的值。为 false 时，表示 @ModelAttribute 不是不必须的，即是必须的。</p><p>针对 @ModelAttribute(“abc”) User user1 和 User user2 两种参数来说，尽管后者没有使用 @ModelAttribute 注解，但它们使用的是同一种解析器。</p><p>添加两个 ServletModelAttributeMethodProcessor 参数解析器，先解析带 @ModelAttribute 注解的参数，再解析不带 @ModelAttribute 注解的参数。</p><p>通过 ServletModelAttributeMethodProcessor 解析得到的数据还会被存入 ModelAndViewContainer 中。存储的数据结构是一个 Map，其 key 为 @ModelAttribute 注解指定的 value 值，在未显式指定的情况下，默认为对象类型的首字母小写对应的字符串。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(</span></span><br><span class="line"><span class="params">                // 指定 value</span></span><br><span class="line"><span class="params">        <span class="meta">@ModelAttribute(&quot;abc&quot;)</span> User user1, // name=zhang&amp;age=<span class="number">18</span></span></span><br><span class="line"><span class="params">        User user2, // name=zhang&amp;age=<span class="number">18</span></span></span><br><span class="line"><span class="params">        <span class="meta">@RequestBody</span> User user3 // json</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析每个参数值</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">        <span class="comment">// 多个参数解析器的组合</span></span><br><span class="line">        <span class="type">HandlerMethodArgumentResolverComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>();</span><br><span class="line">        composite.addResolvers(</span><br><span class="line">            <span class="comment">// useDefaultResolution 为 false 表示必须添加 @RequestParam 注解</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">false</span>),</span><br><span class="line">            <span class="comment">// 解析 @PathVariable</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PathVariableMethodArgumentResolver</span>(),</span><br><span class="line">            <span class="comment">// 解析 @RequestHeader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestHeaderMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 @CookieValue</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletCookieValueMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 @Value</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ExpressionValueMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 HttpServletRequest</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletRequestMethodArgumentResolver</span>(),</span><br><span class="line">            <span class="comment">// 解析 @ModelAttribute，且不能省略</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">false</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">true</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (composite.supportsParameter(parameter)) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">v</span> <span class="operator">=</span> composite.resolveArgument(parameter, container, <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request), binderFactory);</span><br><span class="line">            System.out.println(paramInfo + <span class="string">&quot; -&gt; &quot;</span> + v);</span><br><span class="line">            <span class="comment">// 打印模型数据</span></span><br><span class="line">            <span class="type">ModelMap</span> <span class="variable">modelMap</span> <span class="operator">=</span> container.getModel();</span><br><span class="line">            <span class="keyword">if</span> (MapUtils.isNotEmpty(modelMap)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;模型数据: &quot;</span> + modelMap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(paramInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">0</span>] <span class="meta">@RequestParam</span> String name1 -&gt; zhangsan</span><br><span class="line">[<span class="number">1</span>] String name2</span><br><span class="line">[<span class="number">2</span>] <span class="meta">@RequestParam</span> <span class="type">int</span> age -&gt; <span class="number">18</span></span><br><span class="line">[<span class="number">3</span>] <span class="meta">@RequestParam</span> String home1 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">4</span>] <span class="meta">@RequestParam</span> MultipartFile file -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@2beee7ff</span><br><span class="line">[<span class="number">5</span>] <span class="meta">@PathVariable</span> <span class="type">int</span> id -&gt; <span class="number">123</span></span><br><span class="line">[<span class="number">6</span>] <span class="meta">@RequestHeader</span> String header -&gt; application/json</span><br><span class="line">[<span class="number">7</span>] <span class="meta">@CookieValue</span> String token -&gt; <span class="number">123456</span></span><br><span class="line">[<span class="number">8</span>] <span class="meta">@Value</span> String home2 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">9</span>] HttpServletRequest request -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest@5fa07e12</span><br><span class="line">[<span class="number">10</span>] <span class="meta">@ModelAttribute</span> User user1 -&gt; A21.User(name=张三, age=<span class="number">18</span>)</span><br><span class="line">模型数据: &#123;abc=A21.User(name=张三, age=<span class="number">18</span>), org.springframework.validation.BindingResult.abc=org.springframework.validation.BeanPropertyBindingResult: <span class="number">0</span> errors&#125;</span><br><span class="line">[<span class="number">11</span>] User user2 -&gt; A21.User(name=张三, age=<span class="number">18</span>)</span><br><span class="line">模型数据: &#123;abc=A21.User(name=张三, age=<span class="number">18</span>), org.springframework.validation.BindingResult.abc=org.springframework.validation.BeanPropertyBindingResult: <span class="number">0</span> errors, user=A21.User(name=张三, age=<span class="number">18</span>), org.springframework.validation.BindingResult.user=org.springframework.validation.BeanPropertyBindingResult: <span class="number">0</span> errors&#125;</span><br><span class="line">[<span class="number">12</span>] <span class="meta">@RequestBody</span> User user3 -&gt; A21.User(name=李四, age=<span class="number">20</span>)</span><br><span class="line">模型数据: &#123;abc=A21.User(name=张三, age=<span class="number">18</span>), org.springframework.validation.BindingResult.abc=org.springframework.validation.BeanPropertyBindingResult: <span class="number">0</span> errors, user=A21.User(name=张三, age=<span class="number">18</span>), org.springframework.validation.BindingResult.user=org.springframework.validation.BeanPropertyBindingResult: <span class="number">0</span> errors&#125;</span><br></pre></td></tr></table></figure><p>@RequestBody User user3 参数也被 ServletModelAttributeMethodProcessor 解析了，如果想使其数据通过 JSON 数据转换而来，则需要使用另一个参数解析器。</p><h2 id="21-8-RequestBody"><a href="#21-8-RequestBody" class="headerlink" title="21.8 @RequestBody"></a>21.8 @RequestBody</h2><p>@RequestBody 注解的解析需要使用到 RequestResponseBodyMethodProcessor 参数解析器。构造时需要传入一个消息转换器列表。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析每个参数值</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">        <span class="comment">// 多个参数解析器的组合</span></span><br><span class="line">        <span class="type">HandlerMethodArgumentResolverComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>();</span><br><span class="line">        composite.addResolvers(</span><br><span class="line">            <span class="comment">// useDefaultResolution 为 false 表示必须添加 @RequestParam 注解</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">false</span>),</span><br><span class="line">            <span class="comment">// 解析 @PathVariable</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PathVariableMethodArgumentResolver</span>(),</span><br><span class="line">            <span class="comment">// 解析 @RequestHeader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestHeaderMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 @CookieValue</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletCookieValueMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 @Value</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ExpressionValueMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 HttpServletRequest</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletRequestMethodArgumentResolver</span>(),</span><br><span class="line">            <span class="comment">// 解析 @ModelAttribute，且不能省略</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">false</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>())),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">true</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">0</span>] <span class="meta">@RequestParam</span> String name1 -&gt; zhangsan</span><br><span class="line">[<span class="number">1</span>] String name2</span><br><span class="line">[<span class="number">2</span>] <span class="meta">@RequestParam</span> <span class="type">int</span> age -&gt; <span class="number">18</span></span><br><span class="line">[<span class="number">3</span>] <span class="meta">@RequestParam</span> String home1 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">4</span>] <span class="meta">@RequestParam</span> MultipartFile file -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@5e17553a</span><br><span class="line">[<span class="number">5</span>] <span class="meta">@PathVariable</span> <span class="type">int</span> id -&gt; <span class="number">123</span></span><br><span class="line">[<span class="number">6</span>] <span class="meta">@RequestHeader</span> String header -&gt; application/json</span><br><span class="line">[<span class="number">7</span>] <span class="meta">@CookieValue</span> String token -&gt; <span class="number">123456</span></span><br><span class="line">[<span class="number">8</span>] <span class="meta">@Value</span> String home2 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">9</span>] HttpServletRequest request -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest@13bc8645</span><br><span class="line">[<span class="number">10</span>] <span class="meta">@ModelAttribute</span> User user1 -&gt; A21.User(name=张三, age=<span class="number">18</span>)</span><br><span class="line">[<span class="number">11</span>] User user2 -&gt; A21.User(name=张三, age=<span class="number">18</span>)</span><br><span class="line">[<span class="number">12</span>] <span class="meta">@RequestBody</span> User user3 -&gt; A21.User(name=李四, age=<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>@RequestBody User user3 参数数据通过 JSON 数据得到，与上一节的解析进行区分。</p><p>除此之外，添加的参数解析器顺序也影响着解析结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">false</span>),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>())),</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>先添加解析 @ModelAttribute 注解的解析器，再添加解析 @RequestBody 注解的解析器，最后添加解析省略了 @ModelAttribute 注解的解析器。如果更换最后两个解析器的顺序，那么 @RequestBody User user3 将会被 ServletModelAttributeMethodProcessor 解析，而不是 RequestResponseBodyMethodProcessor。</p><p>因此 String name2 参数也能通过添加同种参数但不同构造参数的解析器进行解析，注意添加的解析器的顺序，先处理对象，再处理单个参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析每个参数值</span></span><br><span class="line">    <span class="keyword">for</span> (MethodParameter parameter : handlerMethod.getMethodParameters()) &#123;</span><br><span class="line">        <span class="comment">// 多个参数解析器的组合</span></span><br><span class="line">        <span class="type">HandlerMethodArgumentResolverComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>();</span><br><span class="line">        composite.addResolvers(</span><br><span class="line">            <span class="comment">// useDefaultResolution 为 false 表示必须添加 @RequestParam 注解</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">false</span>),</span><br><span class="line">            <span class="comment">// 解析 @PathVariable</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PathVariableMethodArgumentResolver</span>(),</span><br><span class="line">            <span class="comment">// 解析 @RequestHeader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestHeaderMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 @CookieValue</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletCookieValueMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 @Value</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ExpressionValueMethodArgumentResolver</span>(beanFactory),</span><br><span class="line">            <span class="comment">// 解析 HttpServletRequest</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletRequestMethodArgumentResolver</span>(),</span><br><span class="line">            <span class="comment">// 解析 @ModelAttribute，且不能省略</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">false</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>())),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">true</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">RequestParamMethodArgumentResolver</span>(beanFactory, <span class="literal">true</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">0</span>] <span class="meta">@RequestParam</span> String name1 -&gt; zhangsan</span><br><span class="line">[<span class="number">1</span>] String name2 -&gt; lisi</span><br><span class="line">[<span class="number">2</span>] <span class="meta">@RequestParam</span> <span class="type">int</span> age -&gt; <span class="number">18</span></span><br><span class="line">[<span class="number">3</span>] <span class="meta">@RequestParam</span> String home1 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">4</span>] <span class="meta">@RequestParam</span> MultipartFile file -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest$StandardMultipartFile@5e17553a</span><br><span class="line">[<span class="number">5</span>] <span class="meta">@PathVariable</span> <span class="type">int</span> id -&gt; <span class="number">123</span></span><br><span class="line">[<span class="number">6</span>] <span class="meta">@RequestHeader</span> String header -&gt; application/json</span><br><span class="line">[<span class="number">7</span>] <span class="meta">@CookieValue</span> String token -&gt; <span class="number">123456</span></span><br><span class="line">[<span class="number">8</span>] <span class="meta">@Value</span> String home2 -&gt; D:\environment\JDK1<span class="number">.8</span></span><br><span class="line">[<span class="number">9</span>] HttpServletRequest request -&gt; org.springframework.web.multipart.support.StandardMultipartHttpServletRequest@13bc8645</span><br><span class="line">[<span class="number">10</span>] <span class="meta">@ModelAttribute</span> User user1 -&gt; A21.User(name=张三, age=<span class="number">18</span>)</span><br><span class="line">[<span class="number">11</span>] User user2 -&gt; A21.User(name=张三, age=<span class="number">18</span>)</span><br><span class="line">[<span class="number">12</span>] <span class="meta">@RequestBody</span> User user3 -&gt; A21.User(name=李四, age=<span class="number">20</span>)</span><br></pre></td></tr></table></figure><h1 id="获取参数名"><a href="#获取参数名" class="headerlink" title="获取参数名"></a>获取参数名</h1><p>在项目的 src 目录外创建一个 Bean2.java 文件，使其不会被 IDEA 自动编译：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.lcp.a22;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将命令行切换到 Bean2.java 文件所在目录的位置，执行 javac .\Bean2.java 命令手动编译 Bean2.java。查看 Bean2.class 文件的内容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.lcp.a22;<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String var1, <span class="type">int</span> var2)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译生成的 class 文件中的 foo() 方法的参数名称不再是 name 和 age，也就是说直接使用 javac 命令进行编译得到的字节码文件不会保存方法的参数名称。</p><p>执行 javac -parameters .\Bean2.java 再次编译 Bean2.java，并查看得到的 Bean2.class 文件内容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.lcp.a22;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bean2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foo() 方法的参数名称得以保留。</p><p>还可以使用 javap -c -v .\Bean2.class 命令反编译 Bean2.class，foo() 方法的反编译结果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(java.lang.String, <span class="type">int</span>)</span>;</span><br><span class="line">  descriptor: (Ljava/lang/String;I)V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">0</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span><br><span class="line">       <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">  MethodParameters:</span><br><span class="line">    Name                           Flags</span><br><span class="line">    name</span><br><span class="line">    age</span><br></pre></td></tr></table></figure><p>foo() 方法的参数信息被保存在 MethodParameters 中，可以使用 反射 获取：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 反射获取参数名</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">foo</span> <span class="operator">=</span> Bean2.class.getMethod(<span class="string">&quot;foo&quot;</span>, String.class, <span class="type">int</span>.class);</span><br><span class="line">    <span class="keyword">for</span> (Parameter parameter : foo.getParameters()) &#123;</span><br><span class="line">        System.out.println(parameter.getName());       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">name</span><br><span class="line">age</span><br></pre></td></tr></table></figure><p>使用 javac -g .\Bean2.java 命令进行编译也会保留方法的参数信息。再次使用 javap 反编译 Bean2.class，foo() 方法的反编译结果如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(java.lang.String, <span class="type">int</span>)</span>;</span><br><span class="line">  descriptor: (Ljava/lang/String;I)V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">0</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span><br><span class="line">       <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lindi/lcp/a22/Bean2;</span><br><span class="line">          <span class="number">0</span>       <span class="number">1</span>     <span class="number">1</span>  name   Ljava/lang/String;</span><br><span class="line">          <span class="number">0</span>       <span class="number">1</span>     <span class="number">2</span>   age   I</span><br></pre></td></tr></table></figure><p>foo() 方法的参数信息被保存在 LocalVariableTable 中，不能使用反射获取，但可以使用 ASM 获取，使用 Spring 封装的解析工具：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 反射获取参数名</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">foo</span> <span class="operator">=</span> Bean2.class.getMethod(<span class="string">&quot;foo&quot;</span>, String.class, <span class="type">int</span>.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于 LocalVariableTable 本地变量表获取</span></span><br><span class="line">    <span class="type">LocalVariableTableParameterNameDiscoverer</span> <span class="variable">discoverer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariableTableParameterNameDiscoverer</span>();</span><br><span class="line">    String[] parameterNames = discoverer.getParameterNames(foo);</span><br><span class="line">    System.out.println(Arrays.toString(parameterNames));</span><br><span class="line">&#125;</span><br><span class="line">[name, age]</span><br></pre></td></tr></table></figure><p>在【21. 参数解析器】中并没有使用 LocalVariableTableParameterNameDiscoverer，而是使用的是 DefaultParameterNameDiscoverer。DefaultParameterNameDiscoverer 将两种实现进行了统一：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultParameterNameDiscoverer</span> <span class="keyword">extends</span> <span class="title class_">PrioritizedParameterNameDiscoverer</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">DefaultParameterNameDiscoverer</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (KotlinDetector.isKotlinReflectPresent() &amp;&amp; !NativeDetector.inNativeImage()) &#123;</span><br><span class="line">         addDiscoverer(<span class="keyword">new</span> <span class="title class_">KotlinReflectionParameterNameDiscoverer</span>());</span><br><span class="line">      &#125;</span><br><span class="line">      addDiscoverer(<span class="keyword">new</span> <span class="title class_">StandardReflectionParameterNameDiscoverer</span>());</span><br><span class="line">      addDiscoverer(<span class="keyword">new</span> <span class="title class_">LocalVariableTableParameterNameDiscoverer</span>());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javac -g 的局限性</p><p>假设有这样一个接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.lcp.a22;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String name, <span class="type">int</span> age)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用 javac -g .\Bean1.java 命令进行编译后，再利用 javap 查看 foo() 方法的反编译结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(java.lang.String, <span class="type">int</span>)</span>;</span><br><span class="line">  descriptor: (Ljava/lang/String;I)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_ABSTRACT</span><br></pre></td></tr></table></figure><p>并没有记录抽象方法 foo() 的参数信息。</p><p>如果使用 javac -parameters .\Bean1.java 呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(java.lang.String, <span class="type">int</span>)</span>;</span><br><span class="line">  descriptor: (Ljava/lang/String;I)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_ABSTRACT</span><br><span class="line">  MethodParameters:</span><br><span class="line">    Name                           Flags</span><br><span class="line">    name</span><br><span class="line">    age</span><br></pre></td></tr></table></figure><p>参数信息得以保留。</p><h1 id="对象绑定与类型转换"><a href="#对象绑定与类型转换" class="headerlink" title="对象绑定与类型转换"></a>对象绑定与类型转换</h1><h2 id="23-1-三种转换接口"><a href="#23-1-三种转换接口" class="headerlink" title="23.1 三种转换接口"></a>23.1 三种转换接口</h2><p>底层第一套转换接口与实现</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjQxZTQwMjAzNWNkMGMyNzc5NTlmZWEwNGZlNGYyZWFfdjZVeWJXZ21TUTQ0UlpEY1VKR1FXRUUzUjBrclN3MnZfVG9rZW46T2g5MGJDOGxib1hlM0d4cThCUWNDdmlJbnhkXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>Printer 把其它类型转为 String</p><p>Parser 把 String 转为其它类型</p><p>Formatter 综合 Printer 与 Parser 的功能</p><p>Converter 把类型 S 转为类型 T</p><p>Printer、Parser、Converter 经过适配转换成 GenericConverter 放入 Converters 集合</p><p>FormattingConversionService 利用其它接口实现转换</p><p>底层第二套转换接口</p><p>由 JDK 提供，而不是 Spring。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YzdmNDk0ZDIxYTVkNjc5OWUzZTMwMmIzNzFjMWY4ZjRfZDZQYUw5d2kxZ0t6cVJrY0JwNHNEM1pLcWhra0t3bXZfVG9rZW46SHhOQWJrRVBub2s0Slh4RHZza2NtWTllbkliXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>PropertyEditor 将 String 与其它类型相互转换</p><p>PropertyEditorRegistry 可以注册多个 PropertyEditor 对象</p><p>可以通过 FormatterPropertyEditorAdapter 与第一套接口进行适配</p><p>高层转换接口与实现</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjE1NGQ4NjJjMzQzOTM2YTIwYTFjZWFiMmI5OThiYTZfNTBLS0xPdXJkblAyUDIwYjU3SXF1TDBQOGxWUHI3a2tfVG9rZW46WVhWYmIyZTJpb1k5V2Z4aVM5TmM3WXRzbkZnXzE3MTk4MTE0NTk6MTcxOTgxNTA1OV9WNA" alt="img"></p><p>它们都实现了 TypeConverter 高层转换接口，在转换时会用到 TypeConverterDelegate 委派ConversionService 与 PropertyEditorRegistry 真正执行转换（使用 Facade 门面模式）</p><p>首先查看是否存在实现了 PropertyEditorRegistry 的自定义转换器，@InitBinder 注解实现的就是自定义转换器（用了适配器模式把 Formatter 转为需要的 PropertyEditor）</p><p>再查看是否存在 ConversionService 实现</p><p>再利用默认的 PropertyEditor 实现</p><p>最后有一些特殊处理</p><p>SimpleTypeConverter 仅做类型转换</p><p>BeanWrapperImpl 利用 Property，即 Getter&#x2F;Setter，为 Bean 的属性赋值，，必要时进行类型转换</p><p>DirectFieldAccessor 利用 Field，即字段，为 Bean 的字段赋值，必要时进行类型转换</p><p>ServletRequestDataBinder 为 Bean 的属性执行绑定，必要时进行类型转换，根据布尔类型成员变量 directFieldAccess 选择利用 Property 还是 Field，还具备校验与获取校验结果功能</p><h2 id="23-2-使用示例"><a href="#23-2-使用示例" class="headerlink" title="23.2 使用示例"></a>23.2 使用示例</h2><p>SimpleTypeConverter</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SimpleTypeConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleTypeConverter</span>();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> converter.convertIfNecessary(<span class="string">&quot;13&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line">    System.out.println(number);</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> converter.convertIfNecessary(<span class="string">&quot;1999/03/04&quot;</span>, Date.class);</span><br><span class="line">    System.out.println(date);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">13</span></span><br><span class="line">Thu Mar <span class="number">04</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1999</span></span><br></pre></td></tr></table></figure><p>BeanWrapperImpl</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 利用反射为 bean 的属性赋值</span></span><br><span class="line">    <span class="type">MyBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    <span class="type">BeanWrapperImpl</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(bean);</span><br><span class="line">    wrapper.setPropertyValue(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">    wrapper.setPropertyValue(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    wrapper.setPropertyValue(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;1999/03/04&quot;</span>);</span><br><span class="line">    System.out.println(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> String b;</span><br><span class="line">    <span class="keyword">private</span> Date c;</span><br><span class="line">&#125;</span><br><span class="line">TestBeanWrapper.MyBean(a=<span class="number">10</span>, b=hello, c=Thu Mar <span class="number">04</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1999</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 利用反射为 bean 的字段赋值</span></span><br><span class="line">    <span class="type">MyBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    <span class="type">DirectFieldAccessor</span> <span class="variable">accessor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectFieldAccessor</span>(bean);</span><br><span class="line">    accessor.setPropertyValue(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">    accessor.setPropertyValue(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    accessor.setPropertyValue(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;1999/03/04&quot;</span>);</span><br><span class="line">    System.out.println(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> String b;</span><br><span class="line">    <span class="keyword">private</span> Date c;</span><br><span class="line">&#125;</span><br><span class="line">TestFieldAccessor.MyBean(a=<span class="number">10</span>, b=hello, c=Thu Mar <span class="number">04</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1999</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 执行数据绑定</span></span><br><span class="line">    <span class="type">MyBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    <span class="type">DataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataBinder</span>(bean);</span><br><span class="line">    <span class="type">MutablePropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>();</span><br><span class="line">    pvs.add(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">    pvs.add(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    pvs.add(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;1999/03/04&quot;</span>);</span><br><span class="line">    binder.bind(pvs);</span><br><span class="line">    System.out.println(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> String b;</span><br><span class="line">    <span class="keyword">private</span> Date c;</span><br><span class="line">&#125;</span><br><span class="line">TestDataBinder.MyBean(a=<span class="number">10</span>, b=hello, c=Thu Mar <span class="number">04</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1999</span>)</span><br></pre></td></tr></table></figure><p>如果 MyBean 没有提供 Getter&#x2F;Setter 方法，可以调用 DataBinder 的 initDirectFieldAccess() 方法使数据绑定逻辑走字段赋值，而不是属性赋值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 执行数据绑定</span></span><br><span class="line">    <span class="type">MyBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    <span class="type">DataBinder</span> <span class="variable">binder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataBinder</span>(bean);</span><br><span class="line">    binder.initDirectFieldAccess();</span><br><span class="line">    <span class="type">MutablePropertyValues</span> <span class="variable">pvs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MutablePropertyValues</span>();</span><br><span class="line">    pvs.add(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">    pvs.add(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    pvs.add(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;1999/03/04&quot;</span>);</span><br><span class="line">    binder.bind(pvs);</span><br><span class="line">    System.out.println(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> String b;</span><br><span class="line">    <span class="keyword">private</span> Date c;</span><br><span class="line">&#125;</span><br><span class="line">TestDataBinder.MyBean(a=<span class="number">10</span>, b=hello, c=Thu Mar <span class="number">04</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1999</span>)</span><br></pre></td></tr></table></figure><p>Web 环境下的数据绑定</p><p>Web 环境下的数据绑定需要使用 DataBinder 的子类 ServletRequestDataBinder。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// web 环境下的数据绑定</span></span><br><span class="line">    <span class="type">MyBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">    <span class="type">DataBinder</span> <span class="variable">dataBinder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRequestDataBinder</span>(bean);</span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>();</span><br><span class="line">    request.setParameter(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;10&quot;</span>);</span><br><span class="line">    request.setParameter(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    request.setParameter(<span class="string">&quot;c&quot;</span>, <span class="string">&quot;1999/03/04&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dataBinder.bind(<span class="keyword">new</span> <span class="title class_">ServletRequestParameterPropertyValues</span>(request));</span><br><span class="line"></span><br><span class="line">    System.out.println(bean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> String b;</span><br><span class="line">    <span class="keyword">private</span> Date c;</span><br><span class="line">&#125;</span><br><span class="line">TestServletDataBinder.MyBean(a=<span class="number">10</span>, b=hello, c=Thu Mar <span class="number">04</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1999</span>)</span><br></pre></td></tr></table></figure><h2 id="23-3-绑定器工厂"><a href="#23-3-绑定器工厂" class="headerlink" title="23.3 绑定器工厂"></a>23.3 绑定器工厂</h2><p>现有如下两个类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Web 环境下进行数据绑定：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>();</span><br><span class="line">    request.setParameter(<span class="string">&quot;birthday&quot;</span>, <span class="string">&quot;1999|01|02&quot;</span>);</span><br><span class="line">    request.setParameter(<span class="string">&quot;address.name&quot;</span>, <span class="string">&quot;成都&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="type">ServletRequestDataBinder</span> <span class="variable">dataBinder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRequestDataBinder</span>(user);</span><br><span class="line"></span><br><span class="line">    dataBinder.bind(<span class="keyword">new</span> <span class="title class_">ServletRequestParameterPropertyValues</span>(request));</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>birthday 和 address.name 都能绑定成功吗？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TestServletDataBinderFactory.User(birthday=<span class="literal">null</span>, address=TestServletDataBinderFactory.Address(name=成都))</span><br></pre></td></tr></table></figure><p>birthday 绑定失败，要想使其绑定成功，需要自定义转换器，有两种方式：</p><p>使用 Spring 提供的 ConversionService</p><p>使用 JDK 提供的 PropertyEditorRegistry</p><p>创建 DataBinder 的职责交由 DataBinderFactory 完成，以便添加各种选项，拓展不同的自定义转换器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>();</span><br><span class="line">    request.setParameter(<span class="string">&quot;birthday&quot;</span>, <span class="string">&quot;1999|01|02&quot;</span>);</span><br><span class="line">    request.setParameter(<span class="string">&quot;address.name&quot;</span>, <span class="string">&quot;成都&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    <span class="type">ServletRequestDataBinderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRequestDataBinderFactory</span>(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="type">WebDataBinder</span> <span class="variable">dataBinder</span> <span class="operator">=</span> factory.createBinder(<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request), user, <span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dataBinder.bind(<span class="keyword">new</span> <span class="title class_">ServletRequestParameterPropertyValues</span>(request));</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台输出的结果不变。</p><p>利用 @InitBinder 自定义转换器</p><p>声明一个 Controller 类，其中包含一个被 @InitBinder 注解标记的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">(WebDataBinder dataBinder)</span> &#123;</span><br><span class="line">        <span class="comment">// 拓展 dataBinder 的转换器</span></span><br><span class="line">        dataBinder.addCustomFormatter(<span class="keyword">new</span> <span class="title class_">MyDateFormatter</span>(<span class="string">&quot;用 @InitBinder 进行拓展&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 WebDataBinder 作为方法参数，在方法体内添加自定义转换器 MyDateFormatter：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDateFormatter</span> <span class="keyword">implements</span> <span class="title class_">Formatter</span>&lt;Date&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyDateFormatter</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="comment">// 仅做测试</span></span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">print</span><span class="params">(Date date, Locale locale)</span> &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy|MM|dd&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sdf.format(date);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">parse</span><span class="params">(String text, Locale locale)</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; 进入了: &#123;&#125;&quot;</span>, desc);</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy|MM|dd&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> sdf.parse(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造 DataBinderFactory 时传入 InvocableHandlerMethod 列表，列表中包含根据 Controller 对象、Controller 类中被 @InitBinder 注解标记的方法对象构造的 InvocableHandlerMethod 对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">InvocableHandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvocableHandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">MyController</span>(), MyController.class.getMethod(<span class="string">&quot;myMethod&quot;</span>, WebDataBinder.class));</span><br><span class="line"></span><br><span class="line">    <span class="type">ServletRequestDataBinderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRequestDataBinderFactory</span>(Collections.singletonList(handlerMethod), <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次执行 main()，birthday 被成功绑定：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[DEBUG] indi.lcp.a23.MyDateFormatter      - &gt;&gt;&gt;&gt;&gt;&gt; 进入了: 用 <span class="meta">@InitBinder</span> 进行拓展 </span><br><span class="line">TestServletDataBinderFactory.User(birthday=Sat Jan <span class="number">02</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1999</span>, address=TestServletDataBinderFactory.Address(name=成都))</span><br></pre></td></tr></table></figure><p>这种方式使用了 JDK 提供的 PropertyEditorRegistry，证据就在 WebDataBinder 的 addCustomFormatter() 方法中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCustomFormatter</span><span class="params">(Formatter&lt;?&gt; formatter)</span> &#123;</span><br><span class="line">   <span class="type">FormatterPropertyEditorAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormatterPropertyEditorAdapter</span>(formatter);</span><br><span class="line">   getPropertyEditorRegistry().registerCustomEditor(adapter.getFieldType(), adapter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConversionService 拓展</p><p>选择 FormattingConversionService 作为 ConversionService 的实现，向其中添加自定义转换器 MyDateFormatter。</p><p>构造 DataBinderFactory 时传入 WebBindingInitializer 的实现，因此将 FormattingConversionService 封装成 ConfigurableWebBindingInitializer 传入 DataBinderFactory 的构造方法中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip-- </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 ConversionService 转换</span></span><br><span class="line">    <span class="type">FormattingConversionService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormattingConversionService</span>();</span><br><span class="line">    service.addFormatter(<span class="keyword">new</span> <span class="title class_">MyDateFormatter</span>(<span class="string">&quot;用 ConversionService 方式拓展转换功能&quot;</span>));</span><br><span class="line">    <span class="type">ConfigurableWebBindingInitializer</span> <span class="variable">initializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurableWebBindingInitializer</span>();</span><br><span class="line">    initializer.setConversionService(service);</span><br><span class="line">    <span class="type">ServletRequestDataBinderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRequestDataBinderFactory</span>(<span class="literal">null</span>, initializer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">[DEBUG] indi.lcp.a23.MyDateFormatter      - &gt;&gt;&gt;&gt;&gt;&gt; 进入了: 用 ConversionService 方式拓展转换功能 </span><br><span class="line">TestServletDataBinderFactory.User(birthday=Sat Jan <span class="number">02</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1999</span>, address=TestServletDataBinderFactory.Address(name=成都))</span><br></pre></td></tr></table></figure><p>如果同时存在 @InitBinder 和 ConversionService，将以 @InitBinder 为主，@InitBinder 实现的转换器属于自定义转换器，自定义转换器的优先级更高：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip-- </span></span><br><span class="line"></span><br><span class="line">    <span class="type">FormattingConversionService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FormattingConversionService</span>();</span><br><span class="line">    service.addFormatter(<span class="keyword">new</span> <span class="title class_">MyDateFormatter</span>(<span class="string">&quot;用 ConversionService 方式拓展转换功能&quot;</span>));</span><br><span class="line">    <span class="type">ConfigurableWebBindingInitializer</span> <span class="variable">initializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurableWebBindingInitializer</span>();</span><br><span class="line">    initializer.setConversionService(service);</span><br><span class="line">    <span class="type">InvocableHandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvocableHandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">MyController</span>(), MyController.class.getMethod(<span class="string">&quot;myMethod&quot;</span>, WebDataBinder.class));</span><br><span class="line">    <span class="type">ServletRequestDataBinderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRequestDataBinderFactory</span>(Collections.singletonList(handlerMethod), initializer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">[DEBUG] indi.lcp.a23.MyDateFormatter      - &gt;&gt;&gt;&gt;&gt;&gt; 进入了: 用 <span class="meta">@InitBinder</span> 进行拓展 </span><br><span class="line">TestServletDataBinderFactory.User(birthday=Sat Jan <span class="number">02</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1999</span>, address=TestServletDataBinderFactory.Address(name=成都))</span><br></pre></td></tr></table></figure><p>默认的 ConversionService</p><p>ConversionService 有一个默认实现 DefaultFormattingConversionService，它还是 FormattingConversionService 的子类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip-- </span></span><br><span class="line"></span><br><span class="line">    <span class="type">DefaultFormattingConversionService</span> <span class="variable">conversionService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultFormattingConversionService</span>();</span><br><span class="line">    <span class="type">ConfigurableWebBindingInitializer</span> <span class="variable">initializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurableWebBindingInitializer</span>();</span><br><span class="line">    initializer.setConversionService(conversionService);</span><br><span class="line">    <span class="type">ServletRequestDataBinderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletRequestDataBinderFactory</span>(<span class="literal">null</span>, initializer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TestServletDataBinderFactory.User(birthday=<span class="literal">null</span>, address=TestServletDataBinderFactory.Address(name=成都))</span><br></pre></td></tr></table></figure><p>birthday 绑定失败，默认的 ConversionService 需要搭配注解 @DateTimeFormat 使用。在目标类的字段上使用该注解标记，并指定被转换的日期格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@DateTimeFormat(pattern = &quot;yyyy|MM|dd&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行 main() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TestServletDataBinderFactory.User(birthday=Sat Jan <span class="number">02</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1999</span>, address=TestServletDataBinderFactory.Address(name=成都))</span><br></pre></td></tr></table></figure><p>在 SpringBoot 中还提供了 ApplicationConversionService，它也是 FormattingConversionService 的子类，上述代码将 DefaultFormattingConversionService 换成 ApplicationConversionService 也能达到相同效果。</p><h2 id="23-4-Spring-的泛型操作技巧"><a href="#23-4-Spring-的泛型操作技巧" class="headerlink" title="23.4 Spring 的泛型操作技巧"></a>23.4 Spring 的泛型操作技巧</h2><p>有一基类 BaseDao，接收一个泛型参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseDao</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">findOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>围绕 BaseDao 有如下五个类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeDao</span> <span class="keyword">extends</span> <span class="title class_">BaseDao</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDao</span> <span class="keyword">extends</span> <span class="title class_">BaseDao</span>&lt;Student&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherDao</span> <span class="keyword">extends</span> <span class="title class_">BaseDao</span>&lt;Teacher&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试获取 BaseDao 子类泛型参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. java api</span></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    <span class="comment">// 带有泛型信息的父类信息</span></span><br><span class="line">    <span class="type">Type</span> <span class="variable">teacherDaoType</span> <span class="operator">=</span> TeacherDao.class.getGenericSuperclass();</span><br><span class="line">    System.out.println(<span class="string">&quot;TeacherDao type: &quot;</span> + teacherDaoType);</span><br><span class="line">    System.out.println(<span class="string">&quot;TeacherDao type class: &quot;</span> + teacherDaoType.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="type">Type</span> <span class="variable">employeeDaoType</span> <span class="operator">=</span> EmployeeDao.class.getGenericSuperclass();</span><br><span class="line">    System.out.println(<span class="string">&quot;EmployeeDao type: &quot;</span> + employeeDaoType);</span><br><span class="line">    System.out.println(<span class="string">&quot;EmployeeDao type class: &quot;</span> + employeeDaoType.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有泛型参数的 Type 对象才是 ParameterizedType 类型</span></span><br><span class="line">    <span class="keyword">if</span> (teacherDaoType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">        <span class="type">ParameterizedType</span> <span class="variable">parameterizedType</span> <span class="operator">=</span> (ParameterizedType) teacherDaoType;</span><br><span class="line">        System.out.println(parameterizedType.getActualTypeArguments()[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. spring api 1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    Class&lt;?&gt; t = GenericTypeResolver.resolveTypeArgument(TeacherDao.class, BaseDao.class);</span><br><span class="line">    System.out.println(t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. spring api 2</span></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    System.out.println(ResolvableType.forClass(StudentDao.class).getSuperType().getGeneric().resolve());</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">TeacherDao type: indi.lcp.a23.sub.BaseDao</span><br><span class="line">TeacherDao type class: <span class="keyword">class</span> <span class="title class_">sun</span>.reflect.generics.reflectiveObjects.ParameterizedTypeImpl</span><br><span class="line">EmployeeDao type: <span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a23.sub.BaseDao</span><br><span class="line">EmployeeDao type class: <span class="keyword">class</span> <span class="title class_">java</span>.lang.Class</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a23.sub.Teacher</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a23.sub.Teacher</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a23.sub.Student</span><br></pre></td></tr></table></figure><h1 id="ControllerAdvice-之-InitBinder"><a href="#ControllerAdvice-之-InitBinder" class="headerlink" title="ControllerAdvice 之 @InitBinder"></a>ControllerAdvice 之 @InitBinder</h1><p>功能与使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@ControllerAdvice</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyControllerAdvice</span> &#123;</span><br><span class="line">        <span class="meta">@InitBinder</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">binder3</span><span class="params">(WebDataBinder webDataBinder)</span> &#123;</span><br><span class="line">            webDataBinder.addCustomFormatter(<span class="keyword">new</span> <span class="title class_">MyDateFormatter</span>(<span class="string">&quot;binder3 转换器&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Controller</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller1</span> &#123;</span><br><span class="line">        <span class="meta">@InitBinder</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">binder1</span><span class="params">(WebDataBinder webDataBinder)</span> &#123;</span><br><span class="line">            webDataBinder.addCustomFormatter(<span class="keyword">new</span> <span class="title class_">MyDateFormatter</span>(<span class="string">&quot;binder1 转换器&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Controller</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller2</span> &#123;</span><br><span class="line">        <span class="meta">@InitBinder</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">binder21</span><span class="params">(WebDataBinder webDataBinder)</span> &#123;</span><br><span class="line">            webDataBinder.addCustomFormatter(<span class="keyword">new</span> <span class="title class_">MyDateFormatter</span>(<span class="string">&quot;binder21 转换器&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@InitBinder</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">binder22</span><span class="params">(WebDataBinder webDataBinder)</span> &#123;</span><br><span class="line">            webDataBinder.addCustomFormatter(<span class="keyword">new</span> <span class="title class_">MyDateFormatter</span>(<span class="string">&quot;binder22 转换器&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 @InitBinder 作用的方法存在于被 @ControllerAdvice 标记的类里面时，是对 所有 控制器都生效的自定义类型转换器。当 @InitBinder 作用的方法存在于被 @Controller 标记的类里面时，是 只对当前 控制器生效的自定义类型转换器。</p><p>@InitBinder 的来源有两个：</p><ol><li>@ControllerAdvice 标记的类中 @InitBinder 标记的方法，由 RequestMappingHandlerAdapter 在初始化时解析并记录</li><li>@Controller 标记的类中 @InitBinder 标记的方法，由 RequestMappingHandlerAdapter 在控制器方法首次执行时解析并记录</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(WebConfig.class);</span><br><span class="line">    <span class="type">RequestMappingHandlerAdapter</span> <span class="variable">handlerAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerAdapter</span>();</span><br><span class="line"></span><br><span class="line">    handlerAdapter.setApplicationContext(context);</span><br><span class="line">    handlerAdapter.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;1. 刚开始...&quot;</span>);</span><br><span class="line">    showBindMethods(handlerAdapter);</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showBindMethods</span><span class="params">(RequestMappingHandlerAdapter handlerAdapter)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">initBinderAdviceCache</span> <span class="operator">=</span> RequestMappingHandlerAdapter.class.getDeclaredField(<span class="string">&quot;initBinderAdviceCache&quot;</span>);</span><br><span class="line">    initBinderAdviceCache.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    Map&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt; globalMap = (Map&lt;ControllerAdviceBean, Set&lt;Method&gt;&gt;) initBinderAdviceCache.get(handlerAdapter);</span><br><span class="line">    log.debug(<span class="string">&quot;全局的 @InitBinder 方法 &#123;&#125;&quot;</span>,</span><br><span class="line">              globalMap.values().stream()</span><br><span class="line">              .flatMap(ms -&gt; ms.stream().map(m -&gt; m.getName()))</span><br><span class="line">              .collect(Collectors.toList())</span><br><span class="line">             );</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">initBinderCache</span> <span class="operator">=</span> RequestMappingHandlerAdapter.class.getDeclaredField(<span class="string">&quot;initBinderCache&quot;</span>);</span><br><span class="line">    initBinderCache.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; controllerMap = (Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;) initBinderCache.get(handlerAdapter);</span><br><span class="line">    log.debug(<span class="string">&quot;控制器的 @InitBinder 方法 &#123;&#125;&quot;</span>,</span><br><span class="line">              controllerMap.entrySet().stream()</span><br><span class="line">              .flatMap(e -&gt; e.getValue().stream().map(v -&gt; e.getKey().getSimpleName() + <span class="string">&quot;.&quot;</span> + v.getName()))</span><br><span class="line">              .collect(Collectors.toList())</span><br><span class="line">             );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.a24.A24                  - <span class="number">1.</span> 刚开始... </span><br><span class="line">indi.lcp.a24.A24                  - 全局的 <span class="meta">@InitBinder</span> 方法 [binder3] </span><br><span class="line">indi.lcp.a24.A24                  - 控制器的 <span class="meta">@InitBinder</span> 方法 [] </span><br></pre></td></tr></table></figure><p>全局的 @InitBinder 方法被解析并记录，但控制器中被 @InitBinder 标记的方法并没有被解析记录。</p><p>模拟调用控制器方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    </span><br><span class="line">    log.debug(<span class="string">&quot;1. 刚开始...&quot;</span>);</span><br><span class="line">    showBindMethods(handlerAdapter);</span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">getDataBinderFactory</span> <span class="operator">=</span> RequestMappingHandlerAdapter.class.getDeclaredMethod(<span class="string">&quot;getDataBinderFactory&quot;</span>, HandlerMethod.class);</span><br><span class="line">    getDataBinderFactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;2. 模拟调用 Controller1 的 foo 方法...&quot;</span>);</span><br><span class="line">    getDataBinderFactory.invoke(handlerAdapter, <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">WebConfig</span>.Controller1(), WebConfig.Controller1.class.getMethod(<span class="string">&quot;foo&quot;</span>)));</span><br><span class="line">    showBindMethods(handlerAdapter);</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;3. 模拟调用 Controller2 的 bar 方法时...&quot;</span>);</span><br><span class="line">    getDataBinderFactory.invoke(handlerAdapter, <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">WebConfig</span>.Controller2(), WebConfig.Controller2.class.getMethod(<span class="string">&quot;bar&quot;</span>)));</span><br><span class="line">    showBindMethods(handlerAdapter);</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1.</span> 刚开始... </span><br><span class="line">全局的 <span class="meta">@InitBinder</span> 方法 [binder3] </span><br><span class="line">控制器的 <span class="meta">@InitBinder</span> 方法 [] </span><br><span class="line"><span class="number">2.</span> 模拟调用 Controller1 的 foo 方法... </span><br><span class="line">全局的 <span class="meta">@InitBinder</span> 方法 [binder3] </span><br><span class="line">控制器的 <span class="meta">@InitBinder</span> 方法 [Controller1.binder1] </span><br><span class="line"><span class="number">3.</span> 模拟调用 Controller2 的 bar 方法时... </span><br><span class="line">全局的 <span class="meta">@InitBinder</span> 方法 [binder3] </span><br><span class="line">控制器的 <span class="meta">@InitBinder</span> 方法 [Controller1.binder1, Controller2.binder22, Controller2.binder21] </span><br></pre></td></tr></table></figure><p>首次调用控制器中的方法时，控制器中被 @InitBinder 标记方法被解析记录。</p><h1 id="控制器方法执行流程"><a href="#控制器方法执行流程" class="headerlink" title="控制器方法执行流程"></a>控制器方法执行流程</h1><p>ServletInvocableHandlerMethod 的组成</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmE3MDE2MTdiYWU2Mjk2NjdmMDkwZmY3MDRhYWE2NzFfU25qV00yRUxuOE91WEpQZXFJZHlkZFlTRFp2bWxPNEVfVG9rZW46UlQyR2IzM0wyb2NId3h4VUpFQWNwa1Mwbm10XzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><p>HandlerMethod 需要：</p><ul><li>bean，即哪个 Controller</li><li>method，即 Controller 中的哪个方法</li></ul><p>ServletInvocableHandlerMethod 需要：</p><ul><li>WebDataBinderFactory，用于对象绑定、类型转换</li><li>ParameterNameDiscoverer，用于参数名解析</li><li>HandlerMethodArgumentResolverComposite，用于解析参数</li><li>HandlerMethodReturnValueHandlerComposite，用于处理返回值</li></ul><p>控制器方法执行流程</p><p>以 RequestMappingHandlerAdapter 为起点，创建 WebDataBinderFactory，添加自定义类型转换器，再创建 ModelFactory，添加 Model 数据</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NjRjNTQxNzk2ODJjMzYzMGNmNzg2NmRkYzljY2E2MDZfbXQ1M1dSelZzWUhiZ2o2N3NGVHRMSkJxVUowOTlPaklfVG9rZW46UmtGRWJvVTJpb2ZjaDB4ZWJFc2NFQUN3bjBkXzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><p>接下来调用 ServletInvocableHandlerMethod，主要完成三件事：</p><ul><li>准备参数</li><li>反射调用控制器方法</li><li>处理返回值</li></ul><h1 id="ControllerAdvice-之-ModelAttribute"><a href="#ControllerAdvice-之-ModelAttribute" class="headerlink" title="ControllerAdvice 之 @ModelAttribute"></a>ControllerAdvice 之 @ModelAttribute</h1><p>准备 @ModelAttribute 在整个 HandlerAdapter 调用过程中所处的位置</p><p>功能与使用</p><p>@ModelAttribute 可以作用在参数上和方法上。</p><p>当其作用在参数上时，会将请求中的参数信息 按名称 注入到指定对象中，并将这个对象信息自动添加到 ModelMap 中。当未指定 @ModelAttribute 的 value 时，添加到 ModelMap 中的 key 是对象类型首字母小写对应的字符串。此时的 @ModelAttribute 注解由 ServletModelAttributeMethodProcessor 解析。</p><p>当其作用在方法上时：</p><p>如果该方法在被 @Controller 注解标记的类中，会在当前控制器中每个控制器方法执行前执行被 @ModelAttribute 标记的方法，如果该方法有返回值，自动将返回值添加到 ModelMap 中。当未指定 @ModelAttribute 的 value 时，添加到 ModelMap 中的 key 是返回值类型首字母小写对应的字符串。</p><p>如果该方法在被 @ControllerAdvice 注解标记的类中，会在所有控制器方法执行前执行该方法。</p><p>作用在方法上的 @ModelAttribute 注解由 RequestMappingHandlerAdapter 解析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller1</span> &#123;</span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.OK)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">foo</span><span class="params">(<span class="meta">@ModelAttribute(&quot;u&quot;)</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 @ResponseStatus 注解，咋不考虑返回值的处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyControllerAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@ModelAttribute(&quot;a&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">aa</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先不使用 RequestMappingHandlerAdapter 对作用在方法上的 @ModelAttribute 注解进行解析，沿用【25. 控制器方法执行流程】中的 main() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">foo</span><br><span class="line">&#123;u=WebConfig.User(name=lcp), org.springframework.validation.BindingResult.u=org.springframework.validation.BeanPropertyBindingResult: <span class="number">0</span> errors&#125;</span><br></pre></td></tr></table></figure><p>再解析方法上的 @ModelAttribute 注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(WebConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">RequestMappingHandlerAdapter</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerAdapter</span>();</span><br><span class="line">    adapter.setApplicationContext(context);</span><br><span class="line">    adapter.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>();</span><br><span class="line">    request.setParameter(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lcp&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取模型工厂</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">getModelFactory</span> <span class="operator">=</span> RequestMappingHandlerAdapter.class.getDeclaredMethod(<span class="string">&quot;getModelFactory&quot;</span>, HandlerMethod.class, WebDataBinderFactory.class);</span><br><span class="line">    getModelFactory.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">ModelFactory</span> <span class="variable">modelFactory</span> <span class="operator">=</span> (ModelFactory) getModelFactory.invoke(adapter, handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化模型数据</span></span><br><span class="line">    modelFactory.initModel(<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request), container, handlerMethod);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">foo</span><br><span class="line">&#123;a=aa, u=WebConfig.User(name=lcp), org.springframework.validation.BindingResult.u=org.springframework.validation.BeanPropertyBindingResult: <span class="number">0</span> errors&#125;</span><br></pre></td></tr></table></figure><p>{a&#x3D;aa} 也被放入到 ModelAndViewContainer 中。</p><h1 id="返回值处理器"><a href="#返回值处理器" class="headerlink" title="返回值处理器"></a>返回值处理器</h1><p>含有多种返回值的控制器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;test1()&quot;</span>);</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;view1&quot;</span>);</span><br><span class="line">        mav.addObject(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;test2()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;view2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;test3()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;test4()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HttpEntity&lt;User&gt; <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;test5()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpEntity</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;赵六&quot;</span>, <span class="number">40</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HttpHeaders <span class="title function_">test6</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;test6()&quot;</span>);</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">        headers.add(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> headers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">test7</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;test7()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;钱七&quot;</span>, <span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试渲染视图需要用到的配置</p><p>为测试对视图的渲染，采用 Freemarker 进行测试，先导入 Freemarker 依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>Freemarker 配置类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FreeMarkerConfigurer <span class="title function_">freeMarkerConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">FreeMarkerConfigurer</span> <span class="variable">configurer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FreeMarkerConfigurer</span>();</span><br><span class="line">        configurer.setDefaultEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        configurer.setTemplateLoaderPath(<span class="string">&quot;classpath:templates&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> configurer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * FreeMarkerView 在借助 Spring 初始化时，会要求在 web 环境才会走 setConfiguration, 这里想办法去掉了 web 环境的约束</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FreeMarkerViewResolver <span class="title function_">viewResolver</span><span class="params">(FreeMarkerConfigurer configurer)</span> &#123;</span><br><span class="line">        <span class="type">FreeMarkerViewResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FreeMarkerViewResolver</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> AbstractUrlBasedView <span class="title function_">instantiateView</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">FreeMarkerView</span> <span class="variable">view</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FreeMarkerView</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isContextRequired</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                view.setConfiguration(configurer.getConfiguration());</span><br><span class="line">                <span class="keyword">return</span> view;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        resolver.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        resolver.setPrefix(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        resolver.setSuffix(<span class="string">&quot;.ftl&quot;</span>);</span><br><span class="line">        resolver.setExposeSpringMacroHelpers(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> resolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染视图使用的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">renderView</span><span class="params">(ApplicationContext context, ModelAndViewContainer container,</span></span><br><span class="line"><span class="params">                               ServletWebRequest webRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt; 渲染视图&quot;</span>);</span><br><span class="line">    <span class="type">FreeMarkerViewResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> context.getBean(FreeMarkerViewResolver.class);</span><br><span class="line">    <span class="type">String</span> <span class="variable">viewName</span> <span class="operator">=</span> container.getViewName() != <span class="literal">null</span> ? container.getViewName() : <span class="keyword">new</span> <span class="title class_">DefaultRequestToViewNameTranslator</span>().getViewName(webRequest.getRequest());</span><br><span class="line">    log.debug(<span class="string">&quot;没有获取到视图名, 采用默认视图名: &#123;&#125;&quot;</span>, viewName);</span><br><span class="line">    <span class="comment">// 每次渲染时, 会产生新的视图对象, 它并非被 Spring 所管理, 但确实借助了 Spring 容器来执行初始化</span></span><br><span class="line">    <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> resolver.resolveViewName(viewName, Locale.getDefault());</span><br><span class="line">    view.render(container.getModel(), webRequest.getRequest(), webRequest.getResponse());</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(((MockHttpServletResponse) webRequest.getResponse()).getContentAsByteArray(), StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供构造 HandlerMethodReturnValueHandlerComposite 对象的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HandlerMethodReturnValueHandlerComposite <span class="title function_">getReturnValueHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">HandlerMethodReturnValueHandlerComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodReturnValueHandlerComposite</span>();</span><br><span class="line">    composite.addHandlers(Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ModelAndViewMethodReturnValueHandler</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ViewNameMethodReturnValueHandler</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">false</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HttpEntityMethodProcessor</span>(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>())),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HttpHeadersReturnValueHandler</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>())),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">true</span>)</span><br><span class="line">    ));</span><br><span class="line">    <span class="keyword">return</span> composite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试返回值处理器的方法 testReturnValueProcessor()</p><p>利用两个函数式接口 Comsumer，对 Mock 的请求进行补充，或者在请求处理完毕后，输出 Mock 的响应信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testReturnValueProcessor</span><span class="params">(ApplicationContext context, String methodName,</span></span><br><span class="line"><span class="params">                                             Consumer&lt;MockHttpServletRequest&gt; requestConsumer,</span></span><br><span class="line"><span class="params">                                             Consumer&lt;MockHttpServletResponse&gt; responseConsumer)</span> &#123;</span><br><span class="line">    <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> Controller.class.getMethod(methodName);</span><br><span class="line">    <span class="type">Controller</span> <span class="variable">controller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Controller</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(controller);</span><br><span class="line"></span><br><span class="line">    <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(context, method);</span><br><span class="line">    <span class="type">ModelAndViewContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndViewContainer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">HandlerMethodReturnValueHandlerComposite</span> <span class="variable">composite</span> <span class="operator">=</span> getReturnValueHandler();</span><br><span class="line">    <span class="type">MethodParameter</span> <span class="variable">returnType</span> <span class="operator">=</span> handlerMethod.getReturnType();</span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>();</span><br><span class="line">    Optional.ofNullable(requestConsumer).ifPresent(i -&gt; i.accept(request));</span><br><span class="line">    <span class="type">MockHttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletResponse</span>();</span><br><span class="line">    <span class="type">ServletWebRequest</span> <span class="variable">webRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response);</span><br><span class="line">    <span class="keyword">if</span> (composite.supportsReturnType(returnType)) &#123;</span><br><span class="line">        composite.handleReturnValue(returnValue, returnType, container, webRequest);</span><br><span class="line">        System.out.println(container.getModel());</span><br><span class="line">        System.out.println(container.getViewName());</span><br><span class="line">        <span class="keyword">if</span> (!container.isRequestHandled()) &#123;</span><br><span class="line">            <span class="comment">// 渲染视图</span></span><br><span class="line">            renderView(context, container, webRequest);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Optional.ofNullable(responseConsumer).ifPresent(i -&gt; i.accept(response));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="27-1-ModelAndView"><a href="#27-1-ModelAndView" class="headerlink" title="27.1 ModelAndView"></a>27.1 ModelAndView</h2><p>ModelAndView 类型的返回值由 ModelAndViewMethodReturnValueHandler 处理，构造时无需传入任何参数。</p><p>解析 ModelAndView 时，将其中的视图和模型数据分别提取出来，放入 ModelAndViewContainer 中，之后根据视图信息找到对应的模板页面，再将模型数据填充到模板页面中，完成视图的渲染。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(WebConfig.class);</span><br><span class="line">    test1(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    testReturnValueProcessor(context, <span class="string">&quot;test1&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的模板页面 view1.ftl：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;zh&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;view1&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello! $&#123;name&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">indi.lcp.a27.A27$Controller       - test1() </span><br><span class="line">&#123;name=张三&#125;</span><br><span class="line">view1</span><br><span class="line">indi.lcp.a27.A27                  - &gt;&gt;&gt;&gt;&gt;&gt; 渲染视图 </span><br><span class="line">indi.lcp.a27.A27                  - 没有获取到视图名, 采用默认视图名: view1 </span><br><span class="line">indi.lcp.a27.WebConfig$<span class="number">1</span>$<span class="number">1</span>        - View name <span class="string">&#x27;view1&#x27;</span>, model &#123;name=张三&#125; </span><br><span class="line">indi.lcp.a27.WebConfig$<span class="number">1</span>$<span class="number">1</span>        - Rendering [/view1.ftl] </span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;zh&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;view1&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello! 张三&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="27-2-字符串类型"><a href="#27-2-字符串类型" class="headerlink" title="27.2 字符串类型"></a>27.2 字符串类型</h2><p>控制器方法的返回值是字符串类型时，返回的字符串即为视图的名称。与 ModelAndView 类型的返回值相比，不包含模型数据。</p><p>此种类型的返回值由 ViewNameMethodReturnValueHandler 处理，构造时无需传入任何参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    testReturnValueProcessor(context, <span class="string">&quot;test2&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的模板页面 view2.ftl：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;zh&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;view2&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">indi.lcp.a27.A27$Controller       - test2() </span><br><span class="line">&#123;&#125;</span><br><span class="line">view2</span><br><span class="line">indi.lcp.a27.A27                  - &gt;&gt;&gt;&gt;&gt;&gt; 渲染视图 </span><br><span class="line">indi.lcp.a27.A27                  - 没有获取到视图名, 采用默认视图名: view2 </span><br><span class="line">indi.lcp.a27.WebConfig$<span class="number">1</span>$<span class="number">1</span>        - View name <span class="string">&#x27;view2&#x27;</span>, model &#123;&#125; </span><br><span class="line">indi.lcp.a27.WebConfig$<span class="number">1</span>$<span class="number">1</span>        - Rendering [/view2.ftl] </span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;zh&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;view2&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="27-3-ModelAttribute"><a href="#27-3-ModelAttribute" class="headerlink" title="27.3 @ModelAttribute"></a>27.3 @ModelAttribute</h2><p>@ModelAttribute 的用法在【26. ControllerAdvice 之 @ModelAttribute】中已经介绍过，简单来说，当 @ModelAttribute 注解作用在方法上时，会将方法的返回值作为模型数据添加到 ModelAndViewContainer 中。</p><p>@ModelAttribute 标记的方法的返回值由 ServletModelAttributeMethodProcessor 解析，构造时需要传入一个布尔类型数据 annotationNotRequired，表示 @ModelAttribute 注解是否不是必须的。</p><p>模型数据已经有了，但视图名称又是什么呢？</p><p>在实际开发场景中，控制器方法需要被 @RequestMapping 标记，并指定请求地址，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;test3()&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当未找到视图名称时，默认以请求路径作为视图名称。</p><p>但在本节测试中省略了路径映射这一步，因此需要通过编程的方式将请求路径解析后的结果放入 request 作用域中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Consumer&lt;MockHttpServletRequest&gt; <span class="title function_">mockHttpServletRequestConsumer</span><span class="params">(String methodName)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> req -&gt; &#123;</span><br><span class="line">        req.setRequestURI(<span class="string">&quot;/&quot;</span> + methodName);</span><br><span class="line">        UrlPathHelper.defaultInstance.resolveAndCacheLookupPath(req);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> <span class="string">&quot;test3&quot;</span>;</span><br><span class="line">    testReturnValueProcessor(context, methodName, </span><br><span class="line">                             mockHttpServletRequestConsumer(methodName), <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的模板页面 test3.ftl：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;zh&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;test3&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello! $&#123;user.name&#125; $&#123;user.age&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">indi.lcp.a27.A27$Controller       - test3() </span><br><span class="line">&#123;user=A27.User(name=李四, age=<span class="number">20</span>)&#125;</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">indi.lcp.a27.A27                  - &gt;&gt;&gt;&gt;&gt;&gt; 渲染视图 </span><br><span class="line">indi.lcp.a27.A27                  - 没有获取到视图名, 采用默认视图名: test3 </span><br><span class="line">indi.lcp.a27.WebConfig$<span class="number">1</span>$<span class="number">1</span>        - View name <span class="string">&#x27;test3&#x27;</span>, model &#123;user=A27.User(name=李四, age=<span class="number">20</span>)&#125; </span><br><span class="line">indi.lcp.a27.WebConfig$<span class="number">1</span>$<span class="number">1</span>        - Rendering [/test3.ftl] </span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;zh&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;test3&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello! 李四 <span class="number">20</span>&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>针对控制器方法 test4() 也可以按照相同方式测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> <span class="string">&quot;test4&quot;</span>;</span><br><span class="line">    testReturnValueProcessor(context, methodName, mockHttpServletRequestConsumer(methodName), <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的模板页面 test4.ftl：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;zh&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;test4&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello! $&#123;user.name&#125; $&#123;user.age&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">indi.lcp.a27.A27$Controller       - test4() </span><br><span class="line">&#123;user=A27.User(name=王五, age=<span class="number">30</span>)&#125;</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">indi.lcp.a27.A27                  - &gt;&gt;&gt;&gt;&gt;&gt; 渲染视图 </span><br><span class="line">indi.lcp.a27.A27                  - 没有获取到视图名, 采用默认视图名: test4 </span><br><span class="line">indi.lcp.a27.WebConfig$<span class="number">1</span>$<span class="number">1</span>        - View name <span class="string">&#x27;test4&#x27;</span>, model &#123;user=A27.User(name=王五, age=<span class="number">30</span>)&#125; </span><br><span class="line">indi.lcp.a27.WebConfig$<span class="number">1</span>$<span class="number">1</span>        - Rendering [/test4.ftl] </span><br><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;zh&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;test4&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello! 王五 <span class="number">30</span>&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>与解析参数类似，返回值处理器的执行顺序也有严格要求。</p><h2 id="27-4-HttpEntity"><a href="#27-4-HttpEntity" class="headerlink" title="27.4 HttpEntity"></a>27.4 HttpEntity</h2><p>HttpEntity 类型的返回值由 HttpEntityMethodProcessor 处理，构造时需要传入一个消息转换器列表。</p><p>这种类型的返回值表示响应完成，无需经过视图的解析、渲染流程再生成响应。可在处理器的 handleReturnValue() 方法中得以论证：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleReturnValue</span><span class="params">(<span class="meta">@Nullable</span> Object returnValue, MethodParameter returnType,</span></span><br><span class="line"><span class="params">                              ModelAndViewContainer mavContainer, </span></span><br><span class="line"><span class="params">                              NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 一进入方法就设置请求处理完毕</span></span><br><span class="line">    mavContainer.setRequestHandled(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HttpEntity 中包含了状态码、响应体信息和响应头信息。</p><p>尝试在请求处理完毕后，输出响应体信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Consumer&lt;MockHttpServletResponse&gt; RESPONSE_CONSUMER = resp -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (String name : resp.getHeaderNames()) &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; = &quot;</span> + resp.getHeader(name));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(resp.getContentAsByteArray(), StandardCharsets.UTF_8));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    testReturnValueProcessor(context, <span class="string">&quot;test5&quot;</span>, <span class="literal">null</span>, RESPONSE_CONSUMER);</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.a27.A27$Controller       - test5() </span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">Content-Type = application/json</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;赵六&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">40</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="27-5-HttpHeaders"><a href="#27-5-HttpHeaders" class="headerlink" title="27.5 HttpHeaders"></a>27.5 HttpHeaders</h2><p>与 HttpEntity 相比，HttpHeaders 只包含响应头信息，HttpHeaders 类型的返回值由 HttpHeadersReturnValueHandler 处理，构造时无需传入任何参数。</p><p>与 HttpEntity 一样，这种类型的返回值也表示响应完成，无需经过视图的解析、渲染流程再生成响应，也可在处理器的 handleReturnValue() 方法中得以论证（省略源码）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    testReturnValueProcessor(context, <span class="string">&quot;test6&quot;</span>, <span class="literal">null</span>, RESPONSE_CONSUMER);</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.a27.A27$Controller       - test6() </span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">Content-Type = text/html</span><br></pre></td></tr></table></figure><h2 id="27-6-ResponseBody"><a href="#27-6-ResponseBody" class="headerlink" title="27.6 @ResponseBody"></a>27.6 @ResponseBody</h2><p>@ResponseBody 标记的方法的返回值由 RequestResponseBodyMethodProcessor 处理，构造时需要传入一个消息转换器列表。</p><p>这样的返回值也表示响应完成，无需经过视图的解析、渲染流程再生成响应，也可在处理器的 handleReturnValue() 方法中得以论证（省略源码）。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    testReturnValueProcessor(context, <span class="string">&quot;test7&quot;</span>, <span class="literal">null</span>, RESPONSE_CONSUMER);</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.a27.A27$Controller       - test7() </span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="literal">null</span></span><br><span class="line">Content-Type = application/json</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;钱七&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">50</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h1><p>在构造参数解析器 RequestResponseBodyMethodProcessor、返回值解析器 HttpEntityMethodProcessor 和 HttpEntityMethodProcessor 时，都需要传入消息转换器列表。</p><p>消息转换器的基类是 HttpMessageConverter。</p><p>介绍两个常见的消息转换器的实现：</p><ul><li>MappingJackson2XmlHttpMessageConverter</li><li>MappingJackson2XmlHttpMessageConverter</li></ul><p>一个 User 类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonCreator</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="meta">@JsonProperty(&quot;name&quot;)</span> String name, <span class="meta">@JsonProperty(&quot;age&quot;)</span> <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 User 对象转换成 JSON 格式的数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MockHttpOutputMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpOutputMessage</span>();</span><br><span class="line">    <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 判断能否将对象转换成目标消息格式</span></span><br><span class="line">    <span class="keyword">if</span> (converter.canWrite(User.class, MediaType.APPLICATION_JSON)) &#123;</span><br><span class="line">        converter.write(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>), MediaType.APPLICATION_JSON, message);</span><br><span class="line">        System.out.println(message.getBodyAsString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><p>将 User 对象转换成 XML 格式的数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MockHttpOutputMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpOutputMessage</span>();</span><br><span class="line">    <span class="type">MappingJackson2XmlHttpMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2XmlHttpMessageConverter</span>();</span><br><span class="line">    <span class="keyword">if</span> (converter.canWrite(User.class, MediaType.APPLICATION_XML)) &#123;</span><br><span class="line">        converter.write(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>), MediaType.APPLICATION_XML, message);</span><br><span class="line">        System.out.println(message.getBodyAsString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 MappingJackson2XmlHttpMessageConverter 时，需要额外导入依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;User&gt;&lt;name&gt;李四&lt;/name&gt;&lt;age&gt;<span class="number">20</span>&lt;/age&gt;&lt;/User&gt;</span><br></pre></td></tr></table></figure><p>将 JSON 格式的数据转换成 User 对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//language=JSON</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  \&quot;name\&quot;: \&quot;李四\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  \&quot;age\&quot;: 20\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    <span class="type">MockHttpInputMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpInputMessage</span>(json.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    <span class="type">MappingJackson2HttpMessageConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>();</span><br><span class="line">    <span class="keyword">if</span> (converter.canRead(User.class, MediaType.APPLICATION_JSON)) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">read</span> <span class="operator">=</span> converter.read(User.class, message);</span><br><span class="line">        System.out.println(read);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">A28.User(name=李四, age=<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>如果存在多个消息转换器呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>();</span><br><span class="line">    <span class="type">MockHttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletResponse</span>();</span><br><span class="line">    <span class="type">ServletWebRequest</span> <span class="variable">webRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response);</span><br><span class="line"></span><br><span class="line">    request.addHeader(HttpHeaders.ACCEPT, MimeTypeUtils.APPLICATION_XML_VALUE);</span><br><span class="line">    response.setContentType(MimeTypeUtils.APPLICATION_JSON_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="type">RequestResponseBodyMethodProcessor</span> <span class="variable">processor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MappingJackson2XmlHttpMessageConverter</span>()</span><br><span class="line">    ));</span><br><span class="line">    processor.handleReturnValue(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MethodParameter</span>(A28.class.getMethod(<span class="string">&quot;user&quot;</span>), -<span class="number">1</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ModelAndViewContainer</span>(),</span><br><span class="line">        webRequest</span><br><span class="line">    );</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(response.getContentAsByteArray(), StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">user</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以添加的消息转换器顺序为主，比如此处会将 User 对象转换成 JSON 格式的数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><p>调换添加的消息转换器顺序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">RequestResponseBodyMethodProcessor</span> <span class="variable">processor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MappingJackson2XmlHttpMessageConverter</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>()</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这下会将 User 对象转换成 XML 格式的数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;User&gt;&lt;name&gt;张三&lt;/name&gt;&lt;age&gt;<span class="number">18</span>&lt;/age&gt;&lt;/User&gt;</span><br></pre></td></tr></table></figure><p>再将添加的消息转换器顺序还原，在请求头中添加 Accept 信息，指定数据格式为 XML：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    request.addHeader(HttpHeaders.ACCEPT, MimeTypeUtils.APPLICATION_XML_VALUE);</span><br><span class="line">    <span class="type">RequestResponseBodyMethodProcessor</span> <span class="variable">processor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MappingJackson2XmlHttpMessageConverter</span>()</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管转换成 JSON 的转换器在前，但会以请求头中指定的 Accept 信息为主：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;User&gt;&lt;name&gt;张三&lt;/name&gt;&lt;age&gt;<span class="number">18</span>&lt;/age&gt;&lt;/User&gt;</span><br></pre></td></tr></table></figure><p>在上文基础上，在指定响应的 Content-Type 为 application&#x2F;json：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    request.addHeader(HttpHeaders.ACCEPT, MimeTypeUtils.APPLICATION_XML_VALUE);</span><br><span class="line">    response.setContentType(MimeTypeUtils.APPLICATION_JSON_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="type">RequestResponseBodyMethodProcessor</span> <span class="variable">processor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MappingJackson2XmlHttpMessageConverter</span>()</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时又会以 Content-Type 的信息为主：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><p>总结</p><p>@ResponseBody 注解由 RequestResponseBodyMethodProcessor 解析，但涉及到的数据格式转换由消息转换器完成。</p><p>当存在多个消息转换器时，如果选择 MediaType：</p><ul><li>首先看 @RequestMapping 注解的 produces 为主，相当于设置了响应的 Content-Type，比如：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping(produces = MimeTypeUtils.APPLICATION_JSON_VALUE)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">user</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>再看请求头中的 Accept 是否指定了目标格式</li><li>最后按照消息转换器的添加顺序进行转换</li></ul><h1 id="ControllerAdvice-之-ResponseBodyAdvice"><a href="#ControllerAdvice-之-ResponseBodyAdvice" class="headerlink" title="ControllerAdvice 之 ResponseBodyAdvice"></a>ControllerAdvice 之 ResponseBodyAdvice</h1><p>ResponseBodyAdvice 是一个接口，对于实现了这个接口并被 @ControllerAdvice 标记的类来说，能够在调用每个控制器方法返回结果前，调用重写的 ResponseBodyAdvice 接口中的 beforeBodyWrite() 方法对返回值进行增强。</p><p>现有一个控制器类与内部使用到的 User 类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用控制器方法，并输出响应数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(WebConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">ServletInvocableHandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletInvocableHandlerMethod</span>(</span><br><span class="line">        context.getBean(WebConfig.MyController.class),</span><br><span class="line">        WebConfig.MyController.class.getMethod(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">    handlerMethod.setDataBinderFactory(<span class="keyword">new</span> <span class="title class_">ServletRequestDataBinderFactory</span>(Collections.emptyList(), <span class="literal">null</span>));</span><br><span class="line">    handlerMethod.setParameterNameDiscoverer(<span class="keyword">new</span> <span class="title class_">DefaultParameterNameDiscoverer</span>());</span><br><span class="line">    <span class="comment">// 设置参数解析器（省略源码）</span></span><br><span class="line">    handlerMethod.setHandlerMethodArgumentResolvers(getArgumentResolvers(context));</span><br><span class="line">    <span class="comment">// 设置返回值处理器（省略源码）</span></span><br><span class="line">    handlerMethod.setHandlerMethodReturnValueHandlers(getReturnValueHandlers(context));</span><br><span class="line"></span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>();</span><br><span class="line">    <span class="type">MockHttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletResponse</span>();</span><br><span class="line">    <span class="type">ModelAndViewContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndViewContainer</span>();</span><br><span class="line">    handlerMethod.invokeAndHandle(<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response), container);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(response.getContentAsByteArray(), StandardCharsets.UTF_8));</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台输出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><p>在实际开发场景中常常需要对返回的数据类型进行统一，比如都返回 Result 类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@JsonInclude(JsonInclude.Include.NON_NULL)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonCreator</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Result</span><span class="params">(<span class="meta">@JsonProperty(&quot;code&quot;)</span> <span class="type">int</span> code, <span class="meta">@JsonProperty(&quot;data&quot;)</span> Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Result</span><span class="params">(<span class="type">int</span> code, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">200</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">200</span>, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">error</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">500</span>, <span class="string">&quot;服务器内部错误:&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了直接让控制器方法返回 Result 外，还可以使用 ResponseBodyAdvice 进行增强：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyControllerAdvice</span> <span class="keyword">implements</span> <span class="title class_">ResponseBodyAdvice</span>&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter returnType,</span></span><br><span class="line"><span class="params">                            Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 满足条件才转换</span></span><br><span class="line"><span class="comment">         * 1. 控制器方法被 @ResponseBody 注解标记</span></span><br><span class="line"><span class="comment">         * 2. 控制器方法所在类被 @ResponseBody 注解或包含 @ResponseBody 注解的注解标记</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> returnType.getMethodAnnotation(ResponseBody.class) != <span class="literal">null</span></span><br><span class="line">            || AnnotationUtils.findAnnotation(returnType.getContainingClass(), ResponseBody.class) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">beforeBodyWrite</span><span class="params">(Object body,</span></span><br><span class="line"><span class="params">                                  MethodParameter returnType,</span></span><br><span class="line"><span class="params">                                  MediaType selectedContentType,</span></span><br><span class="line"><span class="params">                                  Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType,</span></span><br><span class="line"><span class="params">                                  ServerHttpRequest request,</span></span><br><span class="line"><span class="params">                                  ServerHttpResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (body <span class="keyword">instanceof</span> Result) &#123;</span><br><span class="line">            <span class="keyword">return</span> body;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok(body);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行上述增强后，再运行 main() 方法， 输出结果不变， 这是因为没有将实现的 ResponseBodyAdvice 添加到返回值处理器中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HandlerMethodReturnValueHandlerComposite <span class="title function_">getReturnValueHandlers</span><span class="params">(AnnotationConfigApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加 advice</span></span><br><span class="line">    List&lt;ControllerAdviceBean&gt; annotatedBeans = ControllerAdviceBean.findAnnotatedBeans(context);</span><br><span class="line">    List&lt;Object&gt; responseBodyAdviceList = annotatedBeans.stream()</span><br><span class="line">        .filter(b -&gt; b.getBeanType() != <span class="literal">null</span> </span><br><span class="line">                &amp;&amp; ResponseBodyAdvice.class.isAssignableFrom(b.getBeanType()))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    <span class="type">HandlerMethodReturnValueHandlerComposite</span> <span class="variable">composite</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethodReturnValueHandlerComposite</span>();</span><br><span class="line">    <span class="comment">// 省略其他返回值处理器的添加</span></span><br><span class="line">    composite.addHandler(<span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(</span><br><span class="line">        Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>()),</span><br><span class="line">        responseBodyAdviceList</span><br><span class="line">    ));</span><br><span class="line">    composite.addHandler(<span class="keyword">new</span> <span class="title class_">ServletModelAttributeMethodProcessor</span>(<span class="literal">true</span>));</span><br><span class="line">    <span class="keyword">return</span> composite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行 main() 方法，控制台输出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;code&quot;</span>:<span class="number">200</span>,<span class="string">&quot;data&quot;</span>:&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>如果将控制器方法修改成以下形式，也能输出相同的结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>DispatcherServlet 中对异常处理的核心方法是 processHandlerException()，在这个方法中会对所有异常解析器进行遍历，然后使用每个异常解析器对异常信息进行处理。</p><p>存放异常解析器的是 DispatcherServlet 中泛型为 HandlerExceptionResolver、名为 handlerExceptionResolvers 的列表成员变量。</p><p>HandlerExceptionResolver 是一个接口，本节讲解解析 @ExceptionHandler 注解的异常解析器 ExceptionHandlerExceptionResolver。</p><p>四个控制器类，测试异常处理方法被 @ResponseBody 注解标记、异常处理方法返回 ModelAndView、嵌套异常和对异常处理方法的参数处理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">handle</span><span class="params">(ArithmeticException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singletonMap(<span class="string">&quot;error&quot;</span>, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handler</span><span class="params">(ArithmeticException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;test2&quot;</span>, Collections.singletonMap(<span class="string">&quot;error&quot;</span>, e.getMessage()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">handle</span><span class="params">(IOException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singletonMap(<span class="string">&quot;error&quot;</span>, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">handle</span><span class="params">(Exception e, HttpServletRequest request)</span> &#123;</span><br><span class="line">        System.out.println(request);</span><br><span class="line">        <span class="keyword">return</span> Collections.singletonMap(<span class="string">&quot;error&quot;</span>, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExceptionHandlerExceptionResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExceptionHandlerExceptionResolver</span>();</span><br><span class="line">    resolver.setMessageConverters(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>()));</span><br><span class="line">    <span class="comment">// 调用该方法，添加默认的参数解析器和返回值处理器</span></span><br><span class="line">    resolver.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>();</span><br><span class="line">    <span class="type">MockHttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletResponse</span>();</span><br><span class="line">    <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">Controller1</span>(), Controller1.class.getMethod(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    <span class="type">Exception</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;除以零&quot;</span>);</span><br><span class="line">    resolver.resolveException(request, response, handlerMethod, e);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(response.getContentAsByteArray(), StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">    handlerMethod = <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">Controller2</span>(), Controller2.class.getMethod(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> resolver.resolveException(request, response, handlerMethod, e);</span><br><span class="line">    System.out.println(modelAndView.getModel());</span><br><span class="line">    System.out.println(modelAndView.getViewName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 嵌套异常</span></span><br><span class="line">    handlerMethod = <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">Controller3</span>(), Controller3.class.getMethod(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    e = <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;e1&quot;</span>, <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;e2&quot;</span>, <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;e3&quot;</span>)));</span><br><span class="line">    resolver.resolveException(request, response, handlerMethod, e);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(response.getContentAsByteArray(), StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常处理方法参数处理</span></span><br><span class="line">    handlerMethod = <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">Controller4</span>(), Controller4.class.getMethod(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    e = <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;e4&quot;</span>);</span><br><span class="line">    resolver.resolveException(request, response, handlerMethod, e);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(response.getContentAsByteArray(), StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;error&quot;</span>:<span class="string">&quot;除以零&quot;</span>&#125;</span><br><span class="line">&#123;error=除以零&#125;</span><br><span class="line">test2</span><br><span class="line">&#123;<span class="string">&quot;error&quot;</span>:<span class="string">&quot;除以零&quot;</span>&#125;&#123;<span class="string">&quot;error&quot;</span>:<span class="string">&quot;e3&quot;</span>&#125;</span><br><span class="line">org.springframework.mock.web.MockHttpServletRequest@7c1e2a9e</span><br><span class="line">&#123;<span class="string">&quot;error&quot;</span>:<span class="string">&quot;除以零&quot;</span>&#125;&#123;<span class="string">&quot;error&quot;</span>:<span class="string">&quot;e3&quot;</span>&#125;&#123;<span class="string">&quot;error&quot;</span>:<span class="string">&quot;e4&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="ControllerAdvice-之-ExceptionHandler"><a href="#ControllerAdvice-之-ExceptionHandler" class="headerlink" title="ControllerAdvice 之 @ExceptionHandler"></a>ControllerAdvice 之 @ExceptionHandler</h1><p>控制器中被 @ExceptionHandler 标记的异常处理方法只会在当前控制器中生效，如果想要某个异常处理方法全局生效，则需要将异常处理方法编写在被 @ControllerAdvice 注解标记的类中。</p><p>一个“朴素”的控制器类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当不存在任何异常处理方法时，调用控制器中的 foo() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>();</span><br><span class="line">    <span class="type">MockHttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletResponse</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">ExceptionHandlerExceptionResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExceptionHandlerExceptionResolver</span>();</span><br><span class="line">    resolver.setMessageConverters(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2XmlHttpMessageConverter</span>()));</span><br><span class="line">    resolver.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">    <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">Controller1</span>(), Controller1.class.getMethod(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    <span class="type">Exception</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;e1&quot;</span>);</span><br><span class="line">    resolver.resolveException(request, response, handlerMethod, exception);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(response.getContentAsByteArray(), StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main() 方法运行后，控制台不输出任何信息。</p><p>编写配置类，向 Spring 容器中添加 ExceptionHandlerExceptionResolver，并声明全局异常处理方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@ControllerAdvice</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyControllerAdvice</span> &#123;</span><br><span class="line">        <span class="meta">@ExceptionHandler</span></span><br><span class="line">        <span class="meta">@ResponseBody</span></span><br><span class="line">        <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">handle</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.singletonMap(<span class="string">&quot;error&quot;</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ExceptionHandlerExceptionResolver <span class="title function_">resolver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ExceptionHandlerExceptionResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExceptionHandlerExceptionResolver</span>();</span><br><span class="line">        resolver.setMessageConverters(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>()));</span><br><span class="line">        <span class="comment">// 无需调用 resolver.afterPropertiesSet(); 方法，这是 Spring 的提供的内置拓展，会在 Spring 生命周期中自动执行</span></span><br><span class="line">        <span class="keyword">return</span> resolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExceptionHandlerExceptionResolver 不再直接通过 new 关键词构造，而是从 Spring 容器中获取：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MockHttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletRequest</span>();</span><br><span class="line">    <span class="type">MockHttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MockHttpServletResponse</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(WebConfig.class);</span><br><span class="line">    <span class="type">ExceptionHandlerExceptionResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> context.getBean(ExceptionHandlerExceptionResolver.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">HandlerMethod</span> <span class="variable">handlerMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerMethod</span>(<span class="keyword">new</span> <span class="title class_">Controller1</span>(), Controller1.class.getMethod(<span class="string">&quot;foo&quot;</span>));</span><br><span class="line">    <span class="type">Exception</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;e1&quot;</span>);</span><br><span class="line">    resolver.resolveException(request, response, handlerMethod, exception);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(response.getContentAsByteArray(), StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Tomcat-异常处理"><a href="#Tomcat-异常处理" class="headerlink" title="Tomcat 异常处理"></a>Tomcat 异常处理</h1><p>可以利用 @ExceptionHandler 和 @ControllerAdvice 注解全局对控制器方法中抛出的异常进行处理，但针对诸如 filter 中不在控制器方法中的异常就变得无能为力了。</p><p>因此需要一个更上层的“异常处理者”，这个“异常处理者”就是 Tomcat 服务器。</p><h2 id="32-1-Tomcat-的错误页处理"><a href="#32-1-Tomcat-的错误页处理" class="headerlink" title="32.1 Tomcat 的错误页处理"></a>32.1 Tomcat 的错误页处理</h2><p>首先将“老三样”利用配置类添加到 Spring 容器中，还要将 RequestMappingHandlerMapping 和 RequestMappingHandlerAdapter 也添加到 Spring 容器中。</p><p>必要的控制器也不能少，控制器方法手动制造异常，但不提供使用 @ExceptionHandler 实现的异常处理方法，将产生的异常交由 Tomcat 处理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">servletRegistrationBean</span><span class="params">(DispatcherServlet dispatcherServlet)</span> &#123;</span><br><span class="line">        <span class="type">DispatcherServletRegistrationBean</span> <span class="variable">registrationBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        registrationBean.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RequestMappingHandlerMapping <span class="title function_">requestMappingHandlerMapping</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 解析 @RequestMapping</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerMapping</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RequestMappingHandlerAdapter <span class="title function_">requestMappingHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RequestMappingHandlerAdapter</span> <span class="variable">handlerAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerAdapter</span>();</span><br><span class="line">        <span class="comment">// 注意默认的 RequestMappingHandlerAdapter 不会带 jackson 转换器</span></span><br><span class="line">        handlerAdapter.setMessageConverters(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>()));</span><br><span class="line">        <span class="keyword">return</span> handlerAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Controller</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">        <span class="meta">@RequestMapping(&quot;test&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> ModelAndView <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 AnnotationConfigServletWebServerApplicationContext 创建 Spring Web 容器，并输出所有的路径映射信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigServletWebServerApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>(WebConfig.class);</span><br><span class="line">    <span class="type">RequestMappingHandlerMapping</span> <span class="variable">handlerMapping</span> <span class="operator">=</span> context.getBean(RequestMappingHandlerMapping.class);</span><br><span class="line">    handlerMapping.getHandlerMethods().forEach((k, v) -&gt; System.out.println(<span class="string">&quot;映射路径: &quot;</span> + k + <span class="string">&quot;\t方法信息: &quot;</span> + v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台只输出一条路径映射信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">映射路径: &#123; [/test]&#125;        方法信息: indi.lcp.a32.WebConfig$MyController#test()</span><br></pre></td></tr></table></figure><p>在浏览器中访问 <a target="_blank" rel="noopener" href="http://localhost:8080/test">http://localhost:8080/test</a> 地址：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=Mzc1YWY5MTc2YjFjMWM2OTVjZTNjMmUwZTY5YmQwMTdfNWhyaEpYaGg2Skp4dE1iMjFpbUJVcXNhY09hcW9QcHRfVG9rZW46Q3VsSWJlbDBBb3EyOGx4b1VpeGN3NGxUbmNoXzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><p>显示 Tomcat 的错误处理页，并在页面中输出了错误信息。</p><p>Tomcat 默认提供的错误处理方式返回的是 HTML 格式的数据，但需要返回 JSON 格式的数据又该怎么自定义呢？</p><p>修改 Tomcat 默认的错误处理路径，并添加后置处理器进行注册：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改了 Tomcat 服务器默认错误地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ErrorPageRegistrar <span class="title function_">errorPageRegistrar</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * ErrorPageRegistrar 由 SpringBoot 提供，TomcatServletWebServerFactory 也实现了该接口</span></span><br><span class="line"><span class="comment">     * 出现错误，会使用请求转发 forward 跳转到 error 地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> webServerFactory -&gt; webServerFactory.addErrorPages(<span class="keyword">new</span> <span class="title class_">ErrorPage</span>(<span class="string">&quot;/error&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ErrorPageRegistrarBeanPostProcessor <span class="title function_">errorPageRegistrarBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在 TomcatServletWebServerFactory 初始化完成前，获取容器中所有的 ErrorPageRegistrar</span></span><br><span class="line"><span class="comment">     * 并将这些 ErrorPageRegistrar 进行注册</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ErrorPageRegistrarBeanPostProcessor</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启程序，再次在浏览器中访问 <a target="_blank" rel="noopener" href="http://localhost:8080/test%EF%BC%8C%E6%AD%A4%E6%97%B6%E9%A1%B5%E9%9D%A2%E4%B8%8A%E4%B8%8D%E5%86%8D%E6%98%BE%E7%A4%BA">http://localhost:8080/test，此时页面上不再显示</a> Tomcat 的默认错误处理页，而是产生了 404 错误。</p><p>这是因为整个程序中并没有名称为 error 的页面，或者为 &#x2F;error 的请求路径。在控制器中添加请求路径为 &#x2F;error 的控制器方法，该方法被 @ResponseBody 标记，最终返回 JSON 格式的数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/error&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">error</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// tomcat 会将异常对象存储到 request 作用域中，可以直接获取</span></span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">e</span> <span class="operator">=</span> (Throwable) request.getAttribute(RequestDispatcher.ERROR_EXCEPTION);</span><br><span class="line">    <span class="keyword">return</span> Collections.singletonMap(<span class="string">&quot;error&quot;</span>, e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次重启程序，控制台输出的路径映射信息多了一条：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">映射路径: &#123; [/error]&#125;        方法信息: indi.lcp.a32.WebConfig$MyController#error(HttpServletRequest)</span><br><span class="line">映射路径: &#123; [/test]&#125;        方法信息: indi.lcp.a32.WebConfig$MyController#test()</span><br></pre></td></tr></table></figure><p>在浏览器中访问 <a target="_blank" rel="noopener" href="http://localhost:8080/test">http://localhost:8080/test</a> ：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWFhZWFhYTE4NjhhYjA3YTE5ZTYxOWZlN2EwNGZhNmVfdXExNUNiZmtwSm1lVEc4WmxHeUdQUXh0cW1ON3Zva1lfVG9rZW46Sm9nUWJMRmFjb1VtcFB4dTRWT2NDMmlHbndiXzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><h2 id="32-2-BasicErrorController"><a href="#32-2-BasicErrorController" class="headerlink" title="32.2 BasicErrorController"></a>32.2 BasicErrorController</h2><p>BasicErrorController 是由 SpringBoot 提供的类，它也是一个控制器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&#123;&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicErrorController</span> <span class="keyword">extends</span> <span class="title class_">AbstractErrorController</span> &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的映射路径会先从配置文件中读取，在未进行任何配置的情况下，默认路径是 &#x2F;error。</p><p>向容器中添加 BasicErrorController，构造 BasicErrorController 时需要传递两个参数：</p><ul><li>errorAttributes：错误属性，可以理解成封装的错误信息对象</li><li>errorProperties：也可以翻译成错误属性，用于对输出的错误信息进行配置</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> BasicErrorController <span class="title function_">basicErrorController</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BasicErrorController</span>(<span class="keyword">new</span> <span class="title class_">DefaultErrorAttributes</span>(), <span class="keyword">new</span> <span class="title class_">ErrorProperties</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移除前文添加的 error() 控制器方法。</p><p>再次重启程序，控制台输出的路径映射信息为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">映射路径: &#123; [/error]&#125;        方法信息: org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController#error(HttpServletRequest)</span><br><span class="line">映射路径: &#123; [/test]&#125;        方法信息: indi.lcp.a32.WebConfig$MyController#test()</span><br><span class="line">映射路径: &#123; [/error], produces [text/html]&#125;        方法信息: org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController#errorHtml(HttpServletRequest, HttpServletResponse)</span><br></pre></td></tr></table></figure><p>路径映射信息多了两条，它们的请求路径一样，但根据不同的请求来源返回不同格式的数据。</p><p>使用接口测试工具访问</p><p>如果采用 Postman 等接口测试工具访问 <a target="_blank" rel="noopener" href="http://localhost:8080/test">http://localhost:8080/test</a> 路径时，将返回 JSON 格式的数据，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;timestamp&quot;</span>: <span class="number">1674736682248</span>,</span><br><span class="line">  <span class="string">&quot;status&quot;</span>: <span class="number">500</span>,</span><br><span class="line">  <span class="string">&quot;error&quot;</span>: <span class="string">&quot;Internal Server Error&quot;</span>,</span><br><span class="line">  <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/test&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>timestamp、status 等响应内容就是错误属性 errorAttributes 的中包含的内容。</p><p>返回的数据中并没有显示异常信息，可以通过配置文件进行配置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server.error.include-exception=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>也可以在添加 BasicErrorController 到 Spring 容器中时，设置错误属性 errorProperties：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> BasicErrorController <span class="title function_">basicErrorController</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ErrorProperties</span> <span class="variable">errorProperties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ErrorProperties</span>();</span><br><span class="line">    errorProperties.setIncludeException(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BasicErrorController</span>(<span class="keyword">new</span> <span class="title class_">DefaultErrorAttributes</span>(), errorProperties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启程序，再次使用接口测试工具访问 <a target="_blank" rel="noopener" href="http://localhost:8080/test%EF%BC%9A">http://localhost:8080/test：</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;timestamp&quot;</span>: <span class="number">1674736991768</span>,</span><br><span class="line">  <span class="string">&quot;status&quot;</span>: <span class="number">500</span>,</span><br><span class="line">  <span class="string">&quot;error&quot;</span>: <span class="string">&quot;Internal Server Error&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exception&quot;</span>: <span class="string">&quot;java.lang.ArithmeticException&quot;</span>,</span><br><span class="line">  <span class="string">&quot;path&quot;</span>: <span class="string">&quot;/test&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用浏览器访问</p><p>如果使用浏览器访问 <a target="_blank" rel="noopener" href="http://localhost:8080/test%EF%BC%8C%E5%8F%88%E4%BC%9A%E5%9B%9E%E5%88%B0%E2%80%9C%E8%A7%A3%E6%94%BE%E5%89%8D%E2%80%9D%EF%BC%8C%E6%98%BE%E7%A4%BA%E4%B8%8E">http://localhost:8080/test，又会回到“解放前”，显示与</a> Tomcat 的默认错误处理页相同的内容。</p><p>这是因为使用浏览器访问时，将调用 BasicErrorController 中的 errorHtml() 控制器方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">    produces = &#123;&quot;text/html&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">errorHtml</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="type">HttpStatus</span> <span class="variable">status</span> <span class="operator">=</span> <span class="built_in">this</span>.getStatus(request);</span><br><span class="line">    Map&lt;String, Object&gt; model = Collections.unmodifiableMap(<span class="built_in">this</span>.getErrorAttributes(request, <span class="built_in">this</span>.getErrorAttributeOptions(request, MediaType.TEXT_HTML)));</span><br><span class="line">    response.setStatus(status.value());</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="built_in">this</span>.resolveErrorView(request, response, status, model);</span><br><span class="line">    <span class="keyword">return</span> modelAndView != <span class="literal">null</span> ? modelAndView : <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;error&quot;</span>, model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法返回 ModelAndView，并且在没有添加新的错误视图的情况下，尝试寻找视图名称为 error 的视图。</p><p>这里既没有添加新的错误视图，也没有名称为 error 的视图，因此最终又会交由 Tomcat 进行处理。</p><p>尝试向 Spring 容器中添加一个 View 视图，Bean 的名字 必须 是 error：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> View <span class="title function_">error</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (model, request, response) -&gt; &#123;</span><br><span class="line">        System.out.println(model);</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        response.getWriter().print(<span class="string">&quot;&lt;h3&gt;服务器内部错误&lt;/h3&gt;&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了能够在查找指定名称的视图时按照 View 类型的 Bean 的名称进行匹配，还需要添加一个解析器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ViewResolver <span class="title function_">viewResolver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// View 类型的 Bean 的名称即为视图名称</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanNameViewResolver</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启程序，使用浏览器访问 <a target="_blank" rel="noopener" href="http://localhost:8080/test%EF%BC%9A">http://localhost:8080/test：</a></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NjgzODA4NzBjY2VjMjU3MTZiNmU3ZmE4NjY3NTQ2MWRfMVBUVUZ5M1lUMGJRMlJkUTFBdERVNTJlZGtTWjRFVXRfVG9rZW46U29zdWJtZVozb3p3UzZ4V3VRaWNLejBKblRnXzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><p>控制台还打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;timestamp=Thu Jan <span class="number">26</span> <span class="number">21</span>:<span class="number">01</span>:<span class="number">50</span> CST <span class="number">2023</span>, status=<span class="number">500</span>, error=Internal Server Error, exception=java.lang.ArithmeticException, path=/test&#125;</span><br></pre></td></tr></table></figure><h1 id="BeanNameUrlHandlerMapping-与-SimpleControllerHandlerAdapter"><a href="#BeanNameUrlHandlerMapping-与-SimpleControllerHandlerAdapter" class="headerlink" title="BeanNameUrlHandlerMapping 与 SimpleControllerHandlerAdapter"></a>BeanNameUrlHandlerMapping 与 SimpleControllerHandlerAdapter</h1><h2 id="33-1-功能与使用"><a href="#33-1-功能与使用" class="headerlink" title="33.1 功能与使用"></a>33.1 功能与使用</h2><p>BeanNameUrlHandlerMapping 与 RequestMappingHandlerMapping 类似，也是用于解析请求路径，只不过 BeanNameUrlHandlerMapping 将根据请求路径在 Spring 容器中寻找同名的 Bean，对请求进行处理，这个 Bean 必须 以 &#x2F; 开头。比如：请求路径为 &#x2F;c1，寻找的 Bean 的名称也是 &#x2F;c1。</p><p>SimpleControllerHandlerAdapter 与 RequestMappingHandlerAdapter 也类似，也是用于调用控制器方法，但要求控制器类必须实现 org.springframework.web.servlet.mvc.Controller 接口。</p><p>现有三个控制器类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;/c1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller1</span> <span class="keyword">implements</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        response.getWriter().print(<span class="string">&quot;this is c1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;/c2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Controller2</span> <span class="keyword">implements</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        response.getWriter().print(<span class="string">&quot;this is c2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;/c3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Controller <span class="title function_">controller3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (request, response) -&gt; &#123;</span><br><span class="line">        response.getWriter().print(<span class="string">&quot;this is c3&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供配置类 WebConfig，添加 Web 换件下必要的 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">servletRegistrationBean</span><span class="params">(DispatcherServlet dispatcherServlet)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BeanNameUrlHandlerMapping <span class="title function_">beanNameUrlHandlerMapping</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanNameUrlHandlerMapping</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SimpleControllerHandlerAdapter <span class="title function_">simpleControllerHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleControllerHandlerAdapter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigServletWebServerApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>(WebConfig.class);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，在浏览器中访问 <a target="_blank" rel="noopener" href="http://localhost:8080/c1%EF%BC%8C%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%98%BE%E7%A4%BA">http://localhost:8080/c1，页面上显示</a> this is c1。更换请求路径为 c2、c3 后，也会出现类似的信息。</p><h2 id="33-2-自定义实现"><a href="#33-2-自定义实现" class="headerlink" title="33.2 自定义实现"></a>33.2 自定义实现</h2><p>在配置类 WebConfig 中移除 Spring 提供的 BeanNameUrlHandlerMapping 与 SimpleControllerHandlerAdapter，手动编码实现它们的功能。</p><p>为了与前文的测试形成对比，将 Controller2 的 Bean 名称设置为 c2，而不是 &#x2F;c2，使其不能被解析到。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyHandlerMapping</span> <span class="keyword">implements</span> <span class="title class_">HandlerMapping</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        <span class="type">Controller</span> <span class="variable">controller</span> <span class="operator">=</span> controllerMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (controller == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HandlerExecutionChain</span>(controller);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Controller&gt; controllerMap;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        controllerMap = context.getBeansOfType(Controller.class).entrySet().stream()</span><br><span class="line">            .filter(i -&gt; i.getKey().startsWith(<span class="string">&quot;/&quot;</span>))</span><br><span class="line">            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> handler <span class="keyword">instanceof</span> Controller;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                               HttpServletResponse response,</span></span><br><span class="line"><span class="params">                               Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> Controller) &#123;</span><br><span class="line">            ((Controller) handler).handleRequest(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，在浏览器中访问：</p><p><a target="_blank" rel="noopener" href="http://localhost:8080/c1%EF%BC%8C%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%98%BE%E7%A4%BA">http://localhost:8080/c1，页面上显示</a> this is c1；</p><p><a target="_blank" rel="noopener" href="http://localhost:8080/c2%EF%BC%8C%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%98%BE%E7%A4%BA">http://localhost:8080/c2，页面上显示</a> 404；</p><p><a target="_blank" rel="noopener" href="http://localhost:8080/c3%EF%BC%8C%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%98%BE%E7%A4%BA">http://localhost:8080/c3，页面上显示</a> this is c3。</p><h1 id="RouterFunctionMapping-与-HandlerFunctionAdapter"><a href="#RouterFunctionMapping-与-HandlerFunctionAdapter" class="headerlink" title="RouterFunctionMapping 与 HandlerFunctionAdapter"></a>RouterFunctionMapping 与 HandlerFunctionAdapter</h1><p>RouterFunctionMapping 在初始化时，在 Spring 容器中收集所有 RouterFunction，RouterFunction 包括两部分：</p><ol><li>RequestPredicate：设置映射条件</li><li>HandlerFunction：处理逻辑</li></ol><p>当请求到达时，根据映射条件找到 HandlerFunction，即 handler，然后使用 HandlerFunctionAdapter 调用 handler。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">servletRegistrationBean</span><span class="params">(DispatcherServlet dispatcherServlet)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouterFunctionMapping <span class="title function_">routerFunctionMapping</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RouterFunctionMapping</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HandlerFunctionAdapter <span class="title function_">handlerFunctionAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HandlerFunctionAdapter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title function_">r1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> route(GET(<span class="string">&quot;/r1&quot;</span>), req -&gt; ok().body(<span class="string">&quot;this is r1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title function_">r2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> route(GET(<span class="string">&quot;/r2&quot;</span>), req -&gt; ok().body(<span class="string">&quot;this is r2&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">AnnotationConfigServletWebServerApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>(WebConfig.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，在浏览器中访问 <a target="_blank" rel="noopener" href="http://localhost:8080/r1%EF%BC%8C%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%98%BE%E7%A4%BA">http://localhost:8080/r1，页面上显示</a> this is r1，访问 r2 时也类似。</p><h1 id="SimpleUrlHandlerMapping-与HttpRequestHandlerAdapter"><a href="#SimpleUrlHandlerMapping-与HttpRequestHandlerAdapter" class="headerlink" title="SimpleUrlHandlerMapping 与HttpRequestHandlerAdapter"></a>SimpleUrlHandlerMapping 与HttpRequestHandlerAdapter</h1><h2 id="35-1-功能与使用"><a href="#35-1-功能与使用" class="headerlink" title="35.1 功能与使用"></a>35.1 功能与使用</h2><p>概括一下，这两个主要用于静态资源处理，SimpleUrlHandlerMapping 用于静态资源映射，而静态资源处理器是 ResourceHttpRequestHandler，HttpRequestHandlerAdapter 用于处理器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">servletRegistrationBean</span><span class="params">(DispatcherServlet dispatcherServlet)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SimpleUrlHandlerMapping <span class="title function_">simpleUrlHandlerMapping</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">        <span class="type">SimpleUrlHandlerMapping</span> <span class="variable">mapping</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleUrlHandlerMapping</span>();</span><br><span class="line">        <span class="comment">// 设置静态资源处理器，得到所有映射关系</span></span><br><span class="line">        Map&lt;String, ResourceHttpRequestHandler&gt; map = context.getBeansOfType(ResourceHttpRequestHandler.class);</span><br><span class="line">        mapping.setUrlMap(map);</span><br><span class="line">        <span class="keyword">return</span> mapping;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> HttpRequestHandlerAdapter <span class="title function_">httpRequestHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpRequestHandlerAdapter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;/**&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResourceHttpRequestHandler <span class="title function_">handler1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ResourceHttpRequestHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceHttpRequestHandler</span>();</span><br><span class="line">        <span class="comment">// 以 / 结尾表示目录，否则认为是文件</span></span><br><span class="line">        handler.setLocations(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;static/&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;/img/**&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResourceHttpRequestHandler <span class="title function_">handler2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ResourceHttpRequestHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceHttpRequestHandler</span>();</span><br><span class="line">        handler.setLocations(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;images/&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加的两个 ResourceHttpRequestHandler 类型的 Bean，分别设置了它们处理 ClassPath 路径下哪个目录下的静态资源，那如何将请求路径与静态资源访问路径进行映射呢？</p><p>也就是说，当要访问 ClassPath 路径下的 static 目录下的静态资源时，应该通过哪个请求路径呢？</p><p>可以利用通配符设置添加的 ResourceHttpRequestHandler 类型的 Bean 的名称。</p><p>比如设置 Bean 的名称为 &#x2F;**，那么在访问 localhost:8080&#x2F;r1.html 时，就会尝试访问 ClassPath 路径下 static 目录中名为 r1.html 的静态资源；又比如设置 Bean 的名称为 &#x2F;img&#x2F;**，那么在访问 localhost:8080&#x2F;img&#x2F;1.jpg 时， 就会尝试访问 ClassPath 路径下 images 目录中名为 1.jpg 的静态资源。</p><h2 id="35-2-资源解析器"><a href="#35-2-资源解析器" class="headerlink" title="35.2 资源解析器"></a>35.2 资源解析器</h2><p>ResourceHttpRequestHandler 用于对静态资源进行处理，但静态资源解析的功能是由 ResourceResolver 完成的。</p><p>ResourceHttpRequestHandler 实现了 InitializingBean 接口，查看重写的 afterPropertiesSet()：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    resolveResourceLocations();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.resourceResolvers.isEmpty()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.resourceResolvers.add(<span class="keyword">new</span> <span class="title class_">PathResourceResolver</span>());</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用的资源解析器列表为空时，默认添加最基本的资源解析器 PathResourceResolver。</p><p>尝试添加额外的资源解析器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean(&quot;/**&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResourceHttpRequestHandler <span class="title function_">handler1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ResourceHttpRequestHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResourceHttpRequestHandler</span>();</span><br><span class="line">    <span class="comment">// 以 / 结尾表示目录，否则认为是文件</span></span><br><span class="line">    handler.setLocations(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;static/&quot;</span>)));</span><br><span class="line">    <span class="comment">// 不使用默认的资源解析器，而是使用自行添加的</span></span><br><span class="line">    handler.setResourceResolvers(Arrays.asList(</span><br><span class="line">            <span class="comment">// 读取资源时使用缓存</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CachingResourceResolver</span>(<span class="keyword">new</span> <span class="title class_">ConcurrentMapCache</span>(<span class="string">&quot;cache1&quot;</span>)),</span><br><span class="line">            <span class="comment">// 读取压缩资源</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">EncodedResourceResolver</span>(),</span><br><span class="line">            <span class="comment">// 最基本的：从磁盘上读取静态资源</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PathResourceResolver</span>()</span><br><span class="line">    ));</span><br><span class="line">    <span class="keyword">return</span> handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加了三个资源解析器：</p><ul><li>CachingResourceResolver：对静态资源进行缓存</li><li>EncodedResourceResolver：对静态资源进行压缩</li><li>PathResourceResolver：最基本的资源处理器</li></ul><p>还要注意添加的顺序，先尝试从缓存中获取，再尝试获取压缩文件，最后才是直接从磁盘上读取。</p><p>针对 EncodedResourceResolver 来说，Spring 不会自行对静态资源进行压缩，需要在配置类中提供压缩方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initGzip</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;static&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> resource.getFile();</span><br><span class="line">    <span class="keyword">for</span> (File file : dir.listFiles(pathname -&gt; pathname.getName().endsWith(<span class="string">&quot;.html&quot;</span>))) &#123;</span><br><span class="line">        System.out.println(file);</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">             <span class="type">GZIPOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GZIPOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file.getAbsoluteFile() + <span class="string">&quot;.gz&quot;</span>))) &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span> * <span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类对应的 Bean 初始化阶段时，将 ClassPath 路径下 static 目录中的静态资源进行压缩。</p><p>比如 static 目录下的 r1.html 会被压缩成 r1.html.gz，在访问 r1.html 时，会访问压缩文件 r1.html.gz，由浏览器识别并解压成 r1.html 进行访问，减少网络传输数据量。</p><h2 id="35-3-欢迎页处理"><a href="#35-3-欢迎页处理" class="headerlink" title="35.3 欢迎页处理"></a>35.3 欢迎页处理</h2><p>将访问 根路径 的请求，映射到某一欢迎页。这个功能由 WelcomePageHandlerMapping 完成。</p><p>设置静态资源欢迎页为 ClassPath 下 static 目录中的 index.html 文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> WelcomePageHandlerMapping <span class="title function_">welcomePageHandlerMapping</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> context.getResource(<span class="string">&quot;classpath:static/index.html&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WelcomePageHandlerMapping</span>(</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        context,</span><br><span class="line">        resource,</span><br><span class="line">        <span class="string">&quot;/**&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序会根据配置的欢迎页映射器生成一个实现了 Controller 接口的处理器，使用 SimpleControllerHandlerAdapter 执行生成的处理器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SimpleControllerHandlerAdapter <span class="title function_">simpleControllerHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleControllerHandlerAdapter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启程序，控制台会输出一条如下的日志，表示欢迎页配置成功：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">o.s.b.a.w.s.WelcomePageHandlerMapping - Adding welcome page: <span class="keyword">class</span> <span class="title class_">path</span> resource [<span class="keyword">static</span>/index.html] </span><br></pre></td></tr></table></figure><p>在浏览器上访问 localhost:8080 时，会直接访问静态资源 static&#x2F;index.html 的内容。</p><p>注意： 如果重启程序后访问 localhost:8080 并没有跳转到配置的欢迎页，可以重新编译项目后在运行。</p><p>总结</p><p>WelcomePageHandlerMapping 作为欢迎页映射器，只将根路径，即 &#x2F; 映射到配置的欢迎页。</p><p>它内置了一个处理器，名为 ParameterizableViewController，该处理器不执行逻辑，仅根据固定的视图名 forward:index.html 去寻找视图。</p><p>SimpleControllerHandlerAdapter 用于调用处理器，根据重定向到根路径的 index.html 页面，执行静态资源处理器，访问 static 目录下的 index.html 文件（在配置类中自行配置的）。</p><h2 id="35-4-映射器与适配器总结"><a href="#35-4-映射器与适配器总结" class="headerlink" title="35.4 映射器与适配器总结"></a>35.4 映射器与适配器总结</h2><p>HandlerMapping 用于建立请求路径与控制器之间的映射关系：</p><ul><li>RequestMappingHandlerMapping：解析 @RequestMapping 及其派生注解，建立请求路径与控制器方法之间的映射关系</li><li>WelcomePageHandlerMapping：映射 &#x2F; 根路径，寻找欢迎页</li><li>BeanNameUrlHandlerMapping：与 Bean 的名称进行匹配，要求名称必须以 &#x2F; 开头</li><li>RouterFunctionMapping：将 RequestPredicate 映射到 HandlerFunction</li><li>SimpleUrlHandlerMapping：静态资源映射</li></ul><p>映射器之间的顺序也是有要求的，SpringBoot 中的映射器按上述顺序排序。</p><p>HandlerAdapter 用于对各种处理器进行适配调用（适配器 模式）：</p><ul><li>RequestMappingHandlerAdapter：执行被 @RequestMapping 标记的控制器方法，内部还会使用参数解析器、返回值处理器对控制器方法的参数、返回值进行处理（组合 模式）</li><li>SimpleControllerHandlerAdapter：执行实现了 Controller 接口的处理器</li><li>HandlerFunctionAdapter：处理 HandlerFunction 函数式接口</li><li>HttpRequestHandlerAdapter：处理 HttpRequestHandler 接口，用于静态资源处理</li></ul><p>ResourceHttpRequestHandler 中的 setResourceResolvers() 方法是 责任链 模式体现。</p><h1 id="MVC-处理流程"><a href="#MVC-处理流程" class="headerlink" title="MVC 处理流程"></a>MVC 处理流程</h1><p>当浏览器发送一个请求 <a target="_blank" rel="noopener" href="http://localhost:8080/hello">http://localhost:8080/hello</a> 后，请求到达服务器，其处理流程是：</p><p>服务器提供了 DispatcherServlet，它使用的是标准 Servlet 技术</p><p>路径：默认映射路径为 &#x2F;，即会匹配到所有请求 URL，可作为请求的统一入口，DispatcherServlet 也被称之为 前控制器。但也有例外：</p><p>JSP 不会匹配到 DispatcherServlet</p><p>其它有路径的 Servlet 匹配优先级也高于 DispatcherServlet</p><p>创建：在 SpringBoot 中，由自动配置类 DispatcherServletAutoConfiguration 提供 DispatcherServlet 的 Bean</p><p>初始化：DispatcherServlet 初始化时会优先到容器里寻找各种组件，作为它的成员变量</p><p>HandlerMapping，初始化时记录映射关系</p><p>HandlerAdapter，初始化时准备参数解析器、返回值处理器、消息转换器</p><p>HandlerExceptionResolver，初始化时准备参数解析器、返回值处理器、消息转换器</p><p>ViewResolver</p><p>DispatcherServlet 利用 RequestMappingHandlerMapping 查找控制器方法</p><p>例如根据 &#x2F;hello 路径找到被 @RequestMapping(“&#x2F;hello”) 标记的控制器方法，控制器方法会被封装成 HandlerMethod 对象，并结合 匹配到的拦截器 一起返回给 DispatcherServlet。</p><p>HandlerMethod 和 拦截器 合称为 HandlerExecutionChain（调用链）对象。</p><p>DispatcherServlet 接下来会</p><p>调用拦截器的 preHandle() 方法，返回一个布尔类型的值。若返回 true，则放行，进行后续调用，反之拦截请求，不进行后续调用；</p><p>RequestMappingHandlerAdapter 调用处理器方法，准备数据绑定工厂、模型工厂、ModelAndViewContainer、将 HandlerMethod 完善为 ServletInvocableHandlerMethod</p><p>@ControllerAdvice 全局增强点 1️⃣：利用 @ModelAttribute 补充模型数据</p><p>@ControllerAdvice 全局增强点 2️⃣：利用 @InitBinder 补充自定义类型转换器</p><p>使用 HandlerMethodArgumentResolver 准备参数</p><p>@ControllerAdvice 全局增强点 3️⃣：利用 RequestBodyAdvice 接口对请求体增强</p><p>调用 ServletInvocableHandlerMethod</p><p>使用 HandlerMethodReturnValueHandler 处理返回值</p><p>@ControllerAdvice 全局增强点 4️⃣：利用 RequestBodyAdvice 对响应体增强</p><p>根据 ModelAndViewContainer 获取 ModelAndView</p><p>如果返回的 ModelAndView 为 null，不走第 4 步视图解析及渲染流程。例如返回值处理器调用了 HttpMessageConverter 将结果转换为 JSON，这时 ModelAndView 就为 null</p><p>如果返回的 ModelAndView 不为 null，会在第 4 步走视图解析及渲染流程</p><p>调用拦截器的 postHandle() 方法</p><p>处理异常或视图渲染</p><p>如果 1~3 步中出现异常，使用 ExceptionHandlerExceptionResolver 处理异常流程</p><p>@ControllerAdvice 全局增强点 5️⃣：利用 @ExceptionHandler 进行统一异常处理</p><p>未出现异常时，进行视图解析及渲染流程</p><p>调用拦截器的 afterCompletion() 方法</p><h1 id="Boot-骨架项目"><a href="#Boot-骨架项目" class="headerlink" title="Boot 骨架项目"></a>Boot 骨架项目</h1><p>使用 IDEA 创建 SpringBoot 项目时，会创建出 .mvn 目录、HELP.md、mvnw 和 mvnw.cmd 等不必要的文件。</p><p>如果是 Linux 环境下，执行以下命令获取 SpringBoot 的骨架，并添加 web、mysql、mybatis 依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl -G https:<span class="comment">//start.spring.io/pom.xml -d dependencies=web,mysql,mybatis -o pom.xml</span></span><br></pre></td></tr></table></figure><p>也可以使用 Postman 等接口测试工具来实现。</p><p>更多用法执行以下命令进行参考：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curl https:<span class="comment">//start.spring.io</span></span><br></pre></td></tr></table></figure><h1 id="Boot-War-项目"><a href="#Boot-War-项目" class="headerlink" title="Boot War 项目"></a>Boot War 项目</h1><h2 id="38-1-项目的构建"><a href="#38-1-项目的构建" class="headerlink" title="38.1 项目的构建"></a>38.1 项目的构建</h2><p>利用 IDEA 创建新模块 test_war，区别在于选择的打包方式是 War：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MjZkMjVhYTAwNmZjOTg2ZGUxNzg5ODdiYjkyYjUwNTNfMGZmeHk5QlBFY1pDT2JPMkwzWFFhZlI1cW1RaUtYS3pfVG9rZW46VzUxRmJTdnBObzBaa3N4UGczdmM2ZlpIbjQzXzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><p>选择依赖时，勾选 Spring Web。</p><p>一般来说，选择 War 作为打包方式都是为了使用 JSP，因为 JSP 不能配合 Jar 打包方式使用。</p><p>JSP 文件的存放路径是固定的，在 src&#x2F;main 目录下的 webapp 目录，如果没有 webapp 目录，需要自行创建。之后新建 hello.jsp：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h3&gt;Hello!&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>之后新建控制器类 HelloController，编写控制器方法 hello()，返回值类型是 String，要求返回的是视图名称：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后要在配置文件中配置视图的前缀、后缀，使控制器方法返回的视图名称对应视图名称的 JSP 页面：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.mvc.view.prefix=/</span><br><span class="line">spring.mvc.view.suffix=.jsp</span><br></pre></td></tr></table></figure><h2 id="38-2-项目的测试"><a href="#38-2-项目的测试" class="headerlink" title="38.2 项目的测试"></a>38.2 项目的测试</h2><p>使用外置 Tomcat 测试</p><p>首先得安装外置 Tomcat，省略安装步骤。</p><p>然后在 IDEA 的 Run&#x2F;Debug Configurations 中进行配置，选择安装的外置 Tomcat：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MjA3MjQxMjkwMzk4NDliYmRjZTIwMTQzNDFhNjQ5YTNfdm1zRlpSeldkc2h2RWk5ZEFXbHdSSzhuaGFXbzN3QU5fVG9rZW46WTdFMGJTM2Vqb1RkYlB4UXRCdmM4SjFPbkhkXzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><p>然后在 Deployment 中指定当前项目的部署方式和应用程序上下文路径：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NjMxMzBmNmEzMTYzNjM3YzJlNTMzZmJmOTU2MTEwOTdfcHVtN1dDVW1zTWFtQ3BQMm5QTzM3VWxrR2wwNlJsdENfVG9rZW46QmsxbWIzZnB1b0FxbG94SXRKd2NZWXpJbjRkXzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><p>尽管使用外置 Tomcat 进行测试，但主启动类不能少：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestWarApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(TestWarApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，还要编写 ServletInitializer，在外置 Tomcat 启动时，找到 SpringBoot 项目的主启动类，执行 SpringBoot 流程：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletInitializer</span> <span class="keyword">extends</span> <span class="title class_">SpringBootServletInitializer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> SpringApplicationBuilder <span class="title function_">configure</span><span class="params">(SpringApplicationBuilder application)</span>   &#123;</span><br><span class="line">        <span class="keyword">return</span> application.sources(TestWarApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有 ServletInitializer 类，则无法使 SpringBoot 项目使用外置 Tomcat。</p><p>运行程序后，访问 localhost:8080&#x2F;hello，页面进入编写的 hello.jsp 页面</p><p>使用内嵌 Tomcat 测试</p><p>打包方式为 Jar 时，直接运行主启动类，然后访问对应的请求路径即可跳转到指定的视图中，那打包访问变成 War 之后，使用这种方式还能够成功跳转吗？</p><p>程序运行成功后，访问 localhost:8080&#x2F;hello，页面并没有按照预期跳转到 hello.jsp 页面中，也是下载了该页面。</p><p>这是因为内嵌 Tomcat 中不具备 JSP 解析能力，如果要想使其具备解析 JSP 的能力，需要添加依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>之后再访问 localhost:8080&#x2F;hello，页面进入编写的 hello.jsp 页面。</p><p>使用内嵌 Tomcat 测试遇到的问题</p><p>添加 tomcat-embed-jasper 依赖后，访问 localhost:8080&#x2F;hello，仍在下载 hello.jsp。</p><p>答：清理浏览器缓存，在浏览器的 DevTools 中的 Network 内 勾选 Disable cache 以禁用缓存。</p><p>添加 tomcat-embed-jasper 依赖后，访问 localhost:8080&#x2F;hello，页面 404。</p><p>答：设置运行主启动类的 Run&#x2F;Debug Configurations 中的 Working directory 为当前模块所在目录。</p><p>参考链接：springboot 在idea多模块下 子模块的web项目用内置tomcat启动访问jsp报404</p><h1 id="Boot-启动过程"><a href="#Boot-启动过程" class="headerlink" title="Boot 启动过程"></a>Boot 启动过程</h1><h2 id="39-1-SpringApplication-的构造"><a href="#39-1-SpringApplication-的构造" class="headerlink" title="39.1 SpringApplication 的构造"></a>39.1 SpringApplication 的构造</h2><p>SpringBoot 的主启动类类似于：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BootApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(BootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 SpringApplication#run() 方法是核心方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> run(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(primarySources).run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终使用 new 关键字构造了 SpringApplication 对象，然后调用了非静态 run() 方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="literal">null</span>, primarySources);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.primarySources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">    <span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="built_in">this</span>.bootstrapRegistryInitializers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(</span><br><span class="line">        getSpringFactoriesInstances(BootstrapRegistryInitializer.class));</span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造 SpringApplication 对象时做了如下几件事：</p><p>获取 Bean Definition 源</p><p>推断应用类型</p><p>添加 ApplicationContext 初始化器</p><p>添加事件监听器</p><p>主类推断</p><p>获取 Bean Definition 源</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A39_1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SpringApplication</span> <span class="variable">spring</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(A39_1.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建并初始化 Spring 容器</span></span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> spring.run(args);</span><br><span class="line">        Arrays.stream(context.getBeanDefinitionNames()).forEach(i -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;name: &quot;</span> + i +</span><br><span class="line">                               <span class="string">&quot; 来源: &quot;</span> + context.getBeanFactory().getBeanDefinition(i).getResourceDescription());</span><br><span class="line">        &#125;);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出错误信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Web application could not be started as there was no org.springframework.boot.web.servlet.server.ServletWebServerFactory bean defined in the context.</span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Check your application<span class="string">&#x27;s dependencies for a supported servlet web server.</span></span><br><span class="line"><span class="string">Check the configured web application type.</span></span><br></pre></td></tr></table></figure><p>这是因为添加了 spring-boot-starter-web 依赖，但 Spring 容器中并没有 ServletWebServerFactory 类型的 Bean。向容器中添加即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> TomcatServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后在运行 main() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name: org.springframework.context.annotation.internalConfigurationAnnotationProcessor 来源: <span class="literal">null</span></span><br><span class="line">name: org.springframework.context.annotation.internalAutowiredAnnotationProcessor 来源: <span class="literal">null</span></span><br><span class="line">name: org.springframework.context.annotation.internalCommonAnnotationProcessor 来源: <span class="literal">null</span></span><br><span class="line">name: org.springframework.context.event.internalEventListenerProcessor 来源: <span class="literal">null</span></span><br><span class="line">name: org.springframework.context.event.internalEventListenerFactory 来源: <span class="literal">null</span></span><br><span class="line">name: a39_1 来源: <span class="literal">null</span></span><br><span class="line">name: org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory 来源: <span class="literal">null</span></span><br><span class="line">name: bean2 来源: indi.lcp.a39.A39_1</span><br><span class="line">name: servletWebServerFactory 来源: indi.lcp.a39.A39_1</span><br></pre></td></tr></table></figure><p>来源为 null 的 Bean 是由 Spring 提供的“内置” Bean。</p><p>使用 XML 配置文件添加 Bean，并利用 setSources() 方法设置创建 ApplicationContext 的其他源：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SpringApplication</span> <span class="variable">spring</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(A39_1.class);</span><br><span class="line">    spring.setSources(Collections.singleton(<span class="string">&quot;classpath:b01.xml&quot;</span>));</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行 main() 方法，控制台打印的内容多了一条：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name: bean1 来源: <span class="keyword">class</span> <span class="title class_">path</span> resource [b01.xml]</span><br></pre></td></tr></table></figure><p>推断应用类型</p><p>应用类型的推断在构造方法中可以看到：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip-- </span></span><br><span class="line">        <span class="comment">// 推断应用类型</span></span><br><span class="line">    <span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推断逻辑由 WebApplicationType 枚举中的 deduceFromClasspath() 方法完成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> WebApplicationType <span class="title function_">deduceFromClasspath</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ClassUtils.isPresent() 判断类路径下是否存在某个类</span></span><br><span class="line">    <span class="keyword">if</span> (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, <span class="literal">null</span>) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, <span class="literal">null</span>)</span><br><span class="line">        &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="comment">// 响应式 Web 应用</span></span><br><span class="line">        <span class="keyword">return</span> WebApplicationType.REACTIVE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String className : SERVLET_INDICATOR_CLASSES) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ClassUtils.isPresent(className, <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 非 Web 应用</span></span><br><span class="line">            <span class="keyword">return</span> WebApplicationType.NONE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Web 应用</span></span><br><span class="line">    <span class="keyword">return</span> WebApplicationType.SERVLET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用反射调用 deduceFromClasspath() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">deduceFromClasspath</span> <span class="operator">=</span> WebApplicationType.class.getDeclaredMethod(<span class="string">&quot;deduceFromClasspath&quot;</span>);</span><br><span class="line">    deduceFromClasspath.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;\t应用类型为: &quot;</span> + deduceFromClasspath.invoke(<span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">应用类型为: SERVLET</span><br></pre></td></tr></table></figure><p>添加 ApplicationContext 初始化器</p><p>调用 SpringApplication 对象的 run() 方法时会创建 ApplicationContext，最后调用 ApplicationContext 的 refresh() 方法完成初始化。</p><p>在创建与初始化完成之间的一些拓展功能就由 ApplicationContext 初始化器完成。</p><p>在 SpringApplication 的构造方法中，添加的初始化器信息从配置文件中读取：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="comment">// 从配置文件中读取初始化器</span></span><br><span class="line">    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以调用 SpringApplication 对象的 addInitializers() 方法添加自定义初始化器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    spring.addInitializers(applicationContext -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (applicationContext <span class="keyword">instanceof</span> GenericApplicationContext) &#123;</span><br><span class="line">            <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> (GenericApplicationContext) applicationContext;</span><br><span class="line">            context.registerBean(<span class="string">&quot;bean3&quot;</span>, Bean3.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并初始化 Spring 容器</span></span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> spring.run(args);</span><br><span class="line">    Arrays.stream(context.getBeanDefinitionNames()).forEach(i -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name: &quot;</span> + i +</span><br><span class="line">                           <span class="string">&quot; 来源: &quot;</span> + context.getBeanFactory().getBeanDefinition(i).getResourceDescription());</span><br><span class="line">    &#125;);</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean3</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印的 Bean 又多了一条：</p><p>name: bean3 来源: null</p><p>添加事件监听器</p><p>与添加 ApplicationContext 初始化器一样，在 SpringApplication 的构造方法中，添加的事件监听器信息从配置文件中读取：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="comment">// 从配置文件中读取事件监听器</span></span><br><span class="line">    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以调用 SpringApplication 对象的 addListeners() 方法添加自定义事件监听器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="comment">// 输出所有事件信息</span></span><br><span class="line">    spring.addListeners(event -&gt; System.out.println(<span class="string">&quot;\t事件为: &quot;</span> + event));</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印的事件信息汇总后如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationStartingEvent</span><br><span class="line">        事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent</span><br><span class="line">        事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationContextInitializedEvent</span><br><span class="line">        事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationPreparedEvent</span><br><span class="line">        事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.web.servlet.context.ServletWebServerInitializedEvent</span><br><span class="line">        事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.context.event.ContextRefreshedEvent</span><br><span class="line">        事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationStartedEvent</span><br><span class="line">        事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.availability.AvailabilityChangeEvent</span><br><span class="line">        事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationReadyEvent</span><br><span class="line">        事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.availability.AvailabilityChangeEvent</span><br><span class="line">        事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.availability.AvailabilityChangeEvent</span><br><span class="line">        事件类型为: <span class="keyword">class</span> <span class="title class_">org</span>.springframework.context.event.ContextClosedEvent</span><br></pre></td></tr></table></figure><p>主类推断</p><p>主类推断在构造方法中可以看到：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    <span class="comment">// 主类推断</span></span><br><span class="line">    <span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推断逻辑由 deduceMainApplicationClass() 方法完成，利用反射调用该方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">deduceMainApplicationClass</span> <span class="operator">=</span> SpringApplication.class.getDeclaredMethod(<span class="string">&quot;deduceMainApplicationClass&quot;</span>);</span><br><span class="line">    deduceMainApplicationClass.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;\t主类是: &quot;</span> + deduceMainApplicationClass.invoke(spring));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">主类是: <span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a39.A39_1</span><br></pre></td></tr></table></figure><h2 id="39-2-SpringApplication-run-的分析"><a href="#39-2-SpringApplication-run-的分析" class="headerlink" title="39.2 SpringApplication#run() 的分析"></a>39.2 SpringApplication#run() 的分析</h2><p>第一步：获取 SpringApplicationRunListeners</p><p>在执行 run() 方法时，首先会获取到 SpringApplicationRunListeners，它是事件发布器的组合，能够在 SpringBoot 启动的各个阶段中发布事件。</p><p>SpringApplicationRunListeners 中使用 SpringApplicationRunListener 来描述单个事件发布器，SpringApplicationRunListener 是一个接口，它有且仅有一个实现类 EventPublishingRunListener。</p><p>在 SpringBoot 中，事件发布器都是在配置文件中读取，从 META-INF&#x2F;spring.factories 中读取，该文件中有这样一句：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Run Listeners</span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">org.springframework.boot.context.event.EventPublishingRunListener</span><br></pre></td></tr></table></figure><p>自行实现从 META-INF&#x2F;spring.factories 配置文件中读取事件发布器信息，并发布各种事件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A39_2</span> &#123;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SpringApplication</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>();</span><br><span class="line">        app.addListeners(i -&gt; System.out.println(i.getClass()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取时间发送器实现类名</span></span><br><span class="line">        List&lt;String&gt; names = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">            SpringApplicationRunListener.class,</span><br><span class="line">            A39_2.class.getClassLoader()</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            <span class="comment">// System.out.println(name);</span></span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(name);</span><br><span class="line">            Constructor&lt;?&gt; constructor = clazz.getConstructor(SpringApplication.class, String[].class);</span><br><span class="line">            <span class="type">SpringApplicationRunListener</span> <span class="variable">publisher</span> <span class="operator">=</span> (SpringApplicationRunListener) constructor.newInstance(app, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发布事件</span></span><br><span class="line">            <span class="type">DefaultBootstrapContext</span> <span class="variable">bootstrapContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultBootstrapContext</span>();</span><br><span class="line">            <span class="comment">// spring boot 开始启动</span></span><br><span class="line">            publisher.starting(bootstrapContext);</span><br><span class="line">            <span class="comment">// 环境信息准备完毕</span></span><br><span class="line">            publisher.environmentPrepared(bootstrapContext, <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>());</span><br><span class="line">            <span class="comment">// 创建 spring 容器，调用初始化器之后发布此事件</span></span><br><span class="line">            <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">            publisher.contextPrepared(context);</span><br><span class="line">            <span class="comment">// 所有 bean definition 加载完毕</span></span><br><span class="line">            publisher.contextLoaded(context);</span><br><span class="line">            <span class="comment">// spring 容器初始化完毕（调用 refresh() 方法后）</span></span><br><span class="line">            context.refresh();</span><br><span class="line">            publisher.started(context, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// spring boot 启动完毕</span></span><br><span class="line">            publisher.ready(context, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 启动过程中出现异常，spring boot 启动出错</span></span><br><span class="line">            publisher.failed(context, <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;出错了&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 SpringBoot 启动过程中，总共发布 7 种事件。</p><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationStartingEvent</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationEnvironmentPreparedEvent</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationContextInitializedEvent</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationPreparedEvent</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.context.event.ContextRefreshedEvent</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationStartedEvent</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.availability.AvailabilityChangeEvent</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationReadyEvent</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.availability.AvailabilityChangeEvent</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">org</span>.springframework.boot.context.event.ApplicationFailedEvent</span><br></pre></td></tr></table></figure><p>但打印出的事件种类并不止 7 种，这是因为包含了其他事件发布器发布的事件，EventPublishingRunListener 发布的事件的全限定类名包含 boot.context.event，根据这个条件重新计算，恰好 7 个。</p><p>第八到十一步：完成 Spring 容器的创建</p><p>第八步：创建容器。在构造 SpringApplication 时已经推断出应用的类型，使用应用类型直接创建即可。</p><p>第九步：准备容器。回调在构造 SpringApplication 时添加的初始化器。</p><p>第十步：加载 Bean 定义。从配置类、XML 配置文件读取 BeanDefinition，或者扫描某一包路径下的 BeanDefinition。</p><p>第十一步：调用 ApplicationContext 的 refresh() 方法，完成 Spring 容器的创建。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SpringApplication</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>();</span><br><span class="line">    app.addInitializers(applicationContext -&gt; System.out.println(<span class="string">&quot;执行初始化器增强...&quot;</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 8. 创建容器&quot;</span>);</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> createApplicationContext(WebApplicationType.SERVLET);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 9. 准备容器&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (ApplicationContextInitializer initializer : app.getInitializers()) &#123;</span><br><span class="line">        initializer.initialize(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 10. 加载 Bean 定义&quot;</span>);</span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getDefaultListableBeanFactory();</span><br><span class="line">    <span class="type">AnnotatedBeanDefinitionReader</span> <span class="variable">reader1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(beanFactory);</span><br><span class="line">    <span class="type">XmlBeanDefinitionReader</span> <span class="variable">reader2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReader</span>(beanFactory);</span><br><span class="line">    <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(beanFactory);</span><br><span class="line"></span><br><span class="line">    reader1.register(Config.class);</span><br><span class="line">    reader2.loadBeanDefinitions(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;b03.xml&quot;</span>));</span><br><span class="line">    scanner.scan(<span class="string">&quot;indi.lcp.a39.sub&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 11. refresh 容器&quot;</span>);</span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name: &quot;</span> + name + <span class="string">&quot; 来源: &quot;</span> + beanFactory.getBeanDefinition(name).getResourceDescription());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> GenericApplicationContext <span class="title function_">createApplicationContext</span><span class="params">(WebApplicationType type)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SERVLET:</span><br><span class="line">            context = <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REACTIVE:</span><br><span class="line">            context = <span class="keyword">new</span> <span class="title class_">AnnotationConfigReactiveWebServerApplicationContext</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NONE:</span><br><span class="line">            context = <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及到的配置类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean4</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean5</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean5 <span class="title function_">bean5</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean5</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML 配置文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;bean4&quot;</span> class=<span class="string">&quot;indi.lcp.a39.A39_3.Bean4&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>indi.lcp.a39.sub 包下的 Bean 信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.lcp.a39.sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean7</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出的 Bean 信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">name: org.springframework.context.annotation.internalConfigurationAnnotationProcessor 来源: <span class="literal">null</span></span><br><span class="line">name: org.springframework.context.annotation.internalAutowiredAnnotationProcessor 来源: <span class="literal">null</span></span><br><span class="line">name: org.springframework.context.annotation.internalCommonAnnotationProcessor 来源: <span class="literal">null</span></span><br><span class="line">name: org.springframework.context.event.internalEventListenerProcessor 来源: <span class="literal">null</span></span><br><span class="line">name: org.springframework.context.event.internalEventListenerFactory 来源: <span class="literal">null</span></span><br><span class="line">name: a39_3.Config 来源: <span class="literal">null</span></span><br><span class="line">name: bean4 来源: <span class="keyword">class</span> <span class="title class_">path</span> resource [b03.xml]</span><br><span class="line">name: bean7 来源: file [D:\Code\IdeaCode\advanced-spring\boot\target\classes\indi\lcp\a39\sub\Bean7.class]</span><br><span class="line">name: org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory 来源: <span class="literal">null</span></span><br><span class="line">name: bean5 来源: indi.lcp.a39.A39_3$Config</span><br><span class="line">name: servletWebServerFactory 来源: indi.lcp.a39.A39_3$Config</span><br></pre></td></tr></table></figure><p>第二步：封装启动 args</p><p>调用 DefaultApplicationArguments 的构造方法，传入 args 即可：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. 封装启动 args&quot;</span>);</span><br><span class="line">    <span class="type">DefaultApplicationArguments</span> <span class="variable">arguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第十二步：执行 Runner</p><p>在 SpringBoot 启动成功后，可以执行一些 Runner，进行一些预处理或测试。Runner 有两种，分别是 CommandLineRunner 和 ApplicationRunner：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationRunner</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们都是函数式接口，内部的抽象方法长得也很像，只不过：</p><p>CommandLineRunner 直接接收启动参数；</p><p>ApplicationRunner 则是接收封装后的 ApplicationArguments，即 第二步 封装的对象。</p><p>在配置类中添加这两种类型的 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CommandLineRunner <span class="title function_">commandLineRunner</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> args -&gt; System.out.println(<span class="string">&quot;commandLineRunner()...&quot;</span> + Arrays.toString(args));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ApplicationRunner <span class="title function_">applicationRunner</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> args -&gt; &#123;</span><br><span class="line">        <span class="comment">// 获取原始参数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;applicationRunner()...&quot;</span> </span><br><span class="line">                           + Arrays.toString(args.getSourceArgs()));</span><br><span class="line">        <span class="comment">// 获取选项名称，参数中带有 `--` 的参数</span></span><br><span class="line">        System.out.println(args.getOptionNames());</span><br><span class="line">        <span class="comment">// 获取选项值</span></span><br><span class="line">        System.out.println(args.getOptionValues(<span class="string">&quot;server.port&quot;</span>));</span><br><span class="line">        <span class="comment">// 获取非选项参数</span></span><br><span class="line">        System.out.println(args.getNonOptionArgs());</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 Runner：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. 封装启动 args&quot;</span>);</span><br><span class="line">    <span class="type">DefaultApplicationArguments</span> <span class="variable">arguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 12. 执行 runner&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (CommandLineRunner runner : context.getBeansOfType(CommandLineRunner.class).values()) &#123;</span><br><span class="line">        runner.run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ApplicationRunner runner : context.getBeansOfType(ApplicationRunner.class).values()) &#123;</span><br><span class="line">        runner.run(arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法时，需要添加程序参数 –server.port&#x3D;8080 debug：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MmI4Yjg1YmYyNGVmNTdjNDM0OTM3YThhYjExZjcxNjRfR3dSNTdHemJEOERjOVQ3UzFJUUREV0c5NlFoMkJWU21fVG9rZW46SDA4cmJLUHFXb3cyMUF4OWhFUWNZdlVYbjJkXzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <span class="number">12.</span> 执行 runner</span><br><span class="line"><span class="title function_">commandLineRunner</span><span class="params">()</span>...[--server.port=<span class="number">8080</span>, debug]</span><br><span class="line">applicationRunner()...[--server.port=<span class="number">8080</span>, debug]</span><br><span class="line">[server.port]</span><br><span class="line">[<span class="number">8080</span>]</span><br><span class="line">[debug]</span><br></pre></td></tr></table></figure><p>第三步：准备 Environment 添加命令行参数</p><p>Environment 即环境对象，是对配置信息的抽象，配置信息的来源有多种，比如：系统环境变量、properties 配置文件、YAML 配置文件等等。</p><p>SpringBoot 提供了名为 ApplicationEnvironment 的类表示环境对象，它是 Spring 中 StandardEnvironment 环境对象的子类。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MGFlYjc2Mzc5MjI4NGY1OTFiNzUxNTBjMzI5ODBkNTBfdlZ4WHd3RVJ3STJyQVU1dEpMVE5qVFl3cmxBRGNqNkRfVG9rZW46UndLVWJLNzhnb2dWTzN4OGY1bGNPYlZSbmtlXzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><p>默认情况下，创建的 ApplicationEnvironment 对象中配置信息的来源只有两个：</p><ul><li>系统属性</li><li>系统变量</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lcp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/1/28 12:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Step3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationEnvironment</span>();</span><br><span class="line">        env.getPropertySources().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">PropertiesPropertySource &#123;name=<span class="string">&#x27;systemProperties&#x27;</span>&#125;</span><br><span class="line">SystemEnvironmentPropertySource &#123;name=<span class="string">&#x27;systemEnvironment&#x27;</span>&#125;    </span><br></pre></td></tr></table></figure><p>针对相同名称的配置信息，按照来源的先后顺序获取。</p><p>获取 JAVA_HOME 的配置信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationEnvironment</span>();</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;JAVA_HOME&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">D:\environment\JDK1<span class="number">.8</span></span><br></pre></td></tr></table></figure><p>由于 PropertiesPropertySource 中并不存在名为 JAVA_HOME 的配置信息，因此从系统环境变量 SystemEnvironmentPropertySource 中获取 JAVA_HOME 的配置信息。</p><p>在 IDEA 的 Run&#x2F;Debug Configurations 中的 VM options 添加 -DJAVA_HOME&#x3D;abc，使得 PropertiesPropertySource 中存在名为 JAVA_HOME 的配置信息：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=N2FjM2ZhMjFjMjM5ZWI4N2U3N2EwYmMwYzRhNWJlZTJfeVNqelljY3ZFYVVnTGZQSVVRZHVPQ3RNam1POUU3ck9fVG9rZW46UDZmR2J5UEFDb3VyYWh4cmpaRGNGVkkybmhmXzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><p>之后再运行 main() 方法，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">abc</span><br></pre></td></tr></table></figure><p>如果想从配置文件 application.properties 中读取配置信息，可以添加配置信息的来源。配置文件的优先级最低，添加来源时调用 addLast() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationEnvironment</span>();</span><br><span class="line">    env.getPropertySources().addLast(<span class="keyword">new</span> <span class="title class_">ResourcePropertySource</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;application.properties&quot;</span>)));</span><br><span class="line">    env.getPropertySources().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;author.name&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">author.name=<span class="string">&quot;lcp&quot;</span></span><br><span class="line">PropertiesPropertySource &#123;name=<span class="string">&#x27;systemProperties&#x27;</span>&#125;</span><br><span class="line">SystemEnvironmentPropertySource &#123;name=<span class="string">&#x27;systemEnvironment&#x27;</span>&#125;</span><br><span class="line">ResourcePropertySource &#123;name=<span class="string">&#x27;class path resource [application.properties]&#x27;</span>&#125;</span><br><span class="line"><span class="string">&quot;lcp&quot;</span></span><br></pre></td></tr></table></figure><p>而在 SpringBoot 中，这里 只 添加 SimpleCommandLinePropertySource，并且它的优先级最高，使用 addFirst() 方法添加：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationEnvironment</span>();</span><br><span class="line">    env.getPropertySources().addLast(<span class="keyword">new</span> <span class="title class_">ResourcePropertySource</span>(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;application.properties&quot;</span>)));</span><br><span class="line">    env.getPropertySources().addFirst(<span class="keyword">new</span> <span class="title class_">SimpleCommandLinePropertySource</span>(args));</span><br><span class="line">    env.getPropertySources().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;author.name&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法前，需要添加程序参数 –author.name&#x3D;默烦：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NzBiMTc3MTA0ZWMzMmM0NDAwOTk3ZWMzNzIzYWJmYTNfdXh3QXcwM0cxWk9yVU1qQm11NVdMY0ZBNkgzTWc1RGtfVG9rZW46SkVMaWJOSkhQb0pMT1B4SDJxRGM4OHZabmdoXzE3MTk4MTE0NjA6MTcxOTgxNTA2MF9WNA" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SimpleCommandLinePropertySource &#123;name=<span class="string">&#x27;commandLineArgs&#x27;</span>&#125;</span><br><span class="line">PropertiesPropertySource &#123;name=<span class="string">&#x27;systemProperties&#x27;</span>&#125;</span><br><span class="line">SystemEnvironmentPropertySource &#123;name=<span class="string">&#x27;systemEnvironment&#x27;</span>&#125;</span><br><span class="line">ResourcePropertySource &#123;name=<span class="string">&#x27;class path resource [application.properties]&#x27;</span>&#125;</span><br><span class="line">默烦</span><br></pre></td></tr></table></figure><p>第四步：添加 ConfigurationPropertySources</p><p>有一 step4.properties 文件，其内容如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">user.first-name=George</span><br><span class="line">user.middle_name=Walker</span><br><span class="line">user.lastName=Bush</span><br></pre></td></tr></table></figure><p>尝试读取文件中的内容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationEnvironment</span>();</span><br><span class="line">    env.getPropertySources().addLast(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ResourcePropertySource</span>(<span class="string">&quot;step4&quot;</span>, <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;step4.properties&quot;</span>))</span><br><span class="line">    );</span><br><span class="line">    env.getPropertySources().forEach(System.out::println);</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;user.first-name&quot;</span>));</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;user.middle-name&quot;</span>));</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;user.last-name&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>step4.properties 文件中配置信息的 key 是 user.middle_name，但在读取时，使用的是 user.middle-name；还有 user.lastName 的 key，但读取时使用 user.last-name。能读取成功吗？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PropertiesPropertySource &#123;name=<span class="string">&#x27;systemProperties&#x27;</span>&#125;</span><br><span class="line">SystemEnvironmentPropertySource &#123;name=<span class="string">&#x27;systemEnvironment&#x27;</span>&#125;</span><br><span class="line">ResourcePropertySource &#123;name=<span class="string">&#x27;step4&#x27;</span>&#125;</span><br><span class="line">George</span><br><span class="line"><span class="literal">null</span></span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure><p>显然是不行的，为了能读取成功，需要实现 松散绑定，添加 ConfigurationPropertySources：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    ConfigurationPropertySources.attach(env);</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">ConfigurationPropertySourcesPropertySource &#123;name=<span class="string">&#x27;configurationProperties&#x27;</span>&#125;</span><br><span class="line">PropertiesPropertySource &#123;name=<span class="string">&#x27;systemProperties&#x27;</span>&#125;</span><br><span class="line">SystemEnvironmentPropertySource &#123;name=<span class="string">&#x27;systemEnvironment&#x27;</span>&#125;</span><br><span class="line">ResourcePropertySource &#123;name=<span class="string">&#x27;step4&#x27;</span>&#125;</span><br><span class="line">George</span><br><span class="line">Walker</span><br><span class="line">Bush</span><br></pre></td></tr></table></figure><p>第五步：使用 EnvironmentPostProcessorApplicationListener 进行环境对象后置处理</p><p>在第三步中 只 添加 SimpleCommandLinePropertySource，读取 properties、YAML 配置文件的源就是在第五步中添加的。</p><p>完成这样功能需要使用到 EnvironmentPostProcessor，其具体实现是 ConfigDataEnvironmentPostProcessor。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SpringApplication</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>();</span><br><span class="line">    <span class="type">ApplicationEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationEnvironment</span>();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 增强前&quot;</span>);</span><br><span class="line">    env.getPropertySources().forEach(System.out::println);</span><br><span class="line">    <span class="type">ConfigDataEnvironmentPostProcessor</span> <span class="variable">processor1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigDataEnvironmentPostProcessor</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DeferredLogs</span>(), <span class="keyword">new</span> <span class="title class_">DefaultBootstrapContext</span>()</span><br><span class="line">    );</span><br><span class="line">    processor1.postProcessEnvironment(env, app);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 增强后&quot;</span>);</span><br><span class="line">    env.getPropertySources().forEach(System.out::println);</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;author.name&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomValuePropertySourceEnvironmentPostProcessor</span> <span class="variable">processor2</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RandomValuePropertySourceEnvironmentPostProcessor</span>(<span class="keyword">new</span> <span class="title class_">DeferredLog</span>());</span><br><span class="line">    processor2.postProcessEnvironment(env, app);</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 增强前</span><br><span class="line">PropertiesPropertySource &#123;name=<span class="string">&#x27;systemProperties&#x27;</span>&#125;</span><br><span class="line">SystemEnvironmentPropertySource &#123;name=<span class="string">&#x27;systemEnvironment&#x27;</span>&#125;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 增强后</span><br><span class="line">PropertiesPropertySource &#123;name=<span class="string">&#x27;systemProperties&#x27;</span>&#125;</span><br><span class="line">SystemEnvironmentPropertySource &#123;name=<span class="string">&#x27;systemEnvironment&#x27;</span>&#125;</span><br><span class="line">OriginTrackedMapPropertySource &#123;name=<span class="string">&#x27;Config resource &#x27;</span><span class="keyword">class</span> <span class="title class_">path</span> resource [application.properties]<span class="string">&#x27; via location &#x27;</span>optional:classpath:/<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line"><span class="string">&quot;lcp&quot;</span></span><br></pre></td></tr></table></figure><p>EnvironmentPostProcessor 还有一个有趣的实现：RandomValuePropertySourceEnvironmentPostProcessor，该实现提供了随机值的生成。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 再次增强后&quot;</span>);</span><br><span class="line">    env.getPropertySources().forEach(System.out::println);</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;random.string&quot;</span>));</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;random.int&quot;</span>));</span><br><span class="line">    System.out.println(env.getProperty(<span class="string">&quot;random.uuid&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 再次增强后</span><br><span class="line">PropertiesPropertySource &#123;name=<span class="string">&#x27;systemProperties&#x27;</span>&#125;</span><br><span class="line">SystemEnvironmentPropertySource &#123;name=<span class="string">&#x27;systemEnvironment&#x27;</span>&#125;</span><br><span class="line">RandomValuePropertySource &#123;name=<span class="string">&#x27;random&#x27;</span>&#125;</span><br><span class="line">OriginTrackedMapPropertySource &#123;name=<span class="string">&#x27;Config resource &#x27;</span><span class="keyword">class</span> <span class="title class_">path</span> resource [application.properties]<span class="string">&#x27; via location &#x27;</span>optional:classpath:/<span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">5ef4038a709215938cbd3e1c031f66dd</span><br><span class="line"><span class="number">1481116109</span></span><br><span class="line">18548e0b-8bad-458b-b38e-bf793aa24ced</span><br></pre></td></tr></table></figure><p>在 SpringBoot 中的实现是不会采取上述示例代码的方式来添加后置处理器，同样会从 META-INF&#x2F;spring.factories 配置文件中读取并初始化后置处理器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Environment Post Processors</span><br><span class="line">org.springframework.boot.env.EnvironmentPostProcessor=\</span><br><span class="line">org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor,\</span><br><span class="line">org.springframework.boot.context.config.ConfigDataEnvironmentPostProcessor,\</span><br><span class="line">org.springframework.boot.env.RandomValuePropertySourceEnvironmentPostProcessor,\</span><br><span class="line">org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor,\</span><br><span class="line">org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor,\</span><br><span class="line">org.springframework.boot.reactor.DebugAgentEnvironmentPostProcessor</span><br></pre></td></tr></table></figure><p>SpringBoot 中读取 META-INF&#x2F;spring.factories 配置文件初始化环境后置处理器，再执行处理逻辑的功能由 EnvironmentPostProcessorApplicationListener 完成。它是一个事件监听器，同样是在 META-INF&#x2F;spring.factories 配置文件中读取并初始化的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.ClearCachesApplicationListener,\</span><br><span class="line">org.springframework.boot.builder.ParentContextCloserApplicationListener,\</span><br><span class="line">org.springframework.boot.context.FileEncodingApplicationListener,\</span><br><span class="line">org.springframework.boot.context.config.AnsiOutputApplicationListener,\</span><br><span class="line">org.springframework.boot.context.config.DelegatingApplicationListener,\</span><br><span class="line">org.springframework.boot.context.logging.LoggingApplicationListener,\</span><br><span class="line">org.springframework.boot.env.EnvironmentPostProcessorApplicationListener</span><br></pre></td></tr></table></figure><p>要想该监听器成功监听到事件，需要在第五步中发布一个事件，而事件的发布由第一步获取的事件发布器完成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SpringApplication</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>();</span><br><span class="line">    app.addListeners(<span class="keyword">new</span> <span class="title class_">EnvironmentPostProcessorApplicationListener</span>());</span><br><span class="line">    <span class="type">ApplicationEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationEnvironment</span>();</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; names = SpringFactoriesLoader.loadFactoryNames(EnvironmentPostProcessor.class, Step5.class.getClassLoader());</span><br><span class="line">    names.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="type">EventPublishingRunListener</span> <span class="variable">publisher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EventPublishingRunListener</span>(app, args);</span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 增强前&quot;</span>);</span><br><span class="line">    env.getPropertySources().forEach(System.out::println);</span><br><span class="line">    publisher.environmentPrepared(<span class="keyword">new</span> <span class="title class_">DefaultBootstrapContext</span>(), env);</span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 增强后&quot;</span>);</span><br><span class="line">    env.getPropertySources().forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">org.springframework.boot.cloud.CloudFoundryVcapEnvironmentPostProcessor</span><br><span class="line">org.springframework.boot.context.config.ConfigDataEnvironmentPostProcessor</span><br><span class="line">org.springframework.boot.env.RandomValuePropertySourceEnvironmentPostProcessor</span><br><span class="line">org.springframework.boot.env.SpringApplicationJsonEnvironmentPostProcessor</span><br><span class="line">org.springframework.boot.env.SystemEnvironmentPropertySourceEnvironmentPostProcessor</span><br><span class="line">org.springframework.boot.reactor.DebugAgentEnvironmentPostProcessor</span><br><span class="line">org.springframework.boot.autoconfigure.integration.IntegrationPropertiesEnvironmentPostProcessor</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 增强前</span><br><span class="line">PropertiesPropertySource &#123;name=<span class="string">&#x27;systemProperties&#x27;</span>&#125;</span><br><span class="line">SystemEnvironmentPropertySource &#123;name=<span class="string">&#x27;systemEnvironment&#x27;</span>&#125;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 增强后</span><br><span class="line">PropertiesPropertySource &#123;name=<span class="string">&#x27;systemProperties&#x27;</span>&#125;</span><br><span class="line">OriginAwareSystemEnvironmentPropertySource &#123;name=<span class="string">&#x27;systemEnvironment&#x27;</span>&#125;</span><br><span class="line">RandomValuePropertySource &#123;name=<span class="string">&#x27;random&#x27;</span>&#125;</span><br><span class="line">OriginTrackedMapPropertySource &#123;name=<span class="string">&#x27;Config resource &#x27;</span><span class="keyword">class</span> <span class="title class_">path</span> resource [application.properties]<span class="string">&#x27; via location &#x27;</span>optional:classpath:/<span class="string">&#x27;&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>配置文件中 EnvironmentPostProcessor 的实现有很多，但根据上述打印出的信息，生效的并不多，是否生效与项目的依赖配置有关。</p><p>第六步：绑定 spring.main 前缀的配置信息到 SpringApplication 对象</p><p>使用 @ConfigurationProperties 注解可以指定一个前缀，SpringBoot 将根据指定的前缀和属性名称在配置文件中寻找对应的信息并完成注入，其底层是利用 Binder 实现的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SpringApplication</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>();</span><br><span class="line">    <span class="type">ApplicationEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationEnvironment</span>();</span><br><span class="line">    env.getPropertySources().addLast(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ResourcePropertySource</span>(<span class="string">&quot;step4&quot;</span>, <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;step4.properties&quot;</span>))</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> Binder.get(env).bind(<span class="string">&quot;user&quot;</span>, User.class).get();</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">existUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    Binder.get(env).bind(<span class="string">&quot;user&quot;</span>, Bindable.ofInstance(existUser));</span><br><span class="line">    System.out.println(existUser);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String middleName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">&#125;</span><br><span class="line">Step6.User(firstName=George, middleName=Walker, lastName=Bush)</span><br><span class="line">Step6.User(firstName=George, middleName=Walker, lastName=Bush)</span><br></pre></td></tr></table></figure><p>在第六步中，绑定 spring.main 前缀的配置信息到 SpringApplication 对象也是利用了 Binder。</p><p>假设 step6.properties 配置文件的信息如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.main.banner-mode=off</span><br><span class="line">spring.main.lazy-initialization=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>绑定 spring.main 开头的配置信息到 SpringApplication 对象中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SpringApplication</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>();</span><br><span class="line">    <span class="type">ApplicationEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationEnvironment</span>();</span><br><span class="line">    env.getPropertySources().addLast(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ResourcePropertySource</span>(<span class="string">&quot;step6&quot;</span>, <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;step6.properties&quot;</span>))</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">SpringApplication</span>&gt; clazz = app.getClass();</span><br><span class="line">    <span class="type">Field</span> <span class="variable">bannerMode</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;bannerMode&quot;</span>);</span><br><span class="line">    bannerMode.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Field</span> <span class="variable">lazyInitialization</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;lazyInitialization&quot;</span>);</span><br><span class="line">    lazyInitialization.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    System.out.println(bannerMode.get(app));</span><br><span class="line">    System.out.println(lazyInitialization.get(app));</span><br><span class="line">    Binder.get(env).bind(<span class="string">&quot;spring.main&quot;</span>, Bindable.ofInstance(app));</span><br><span class="line">    System.out.println(bannerMode.get(app));</span><br><span class="line">    System.out.println(lazyInitialization.get(app));</span><br><span class="line">&#125;</span><br><span class="line">CONSOLE</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">OFF</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>第七步：打印 Banner</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApplicationEnvironment</span>();</span><br><span class="line">    <span class="type">SpringApplicationBannerPrinter</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplicationBannerPrinter</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DefaultResourceLoader</span>(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SpringBootBanner</span>()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    printer.print(env, Step7.class, System.out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外还可以自定义文字和图片 Banner，文字 Banner 的文件类型需要是 txt，图片 Banner 的文件类型需要是 gif。</p><p>文字 Banner：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试文字 banner</span></span><br><span class="line">    env.getPropertySources().addLast(<span class="keyword">new</span> <span class="title class_">MapPropertySource</span>(</span><br><span class="line">        <span class="string">&quot;custom&quot;</span>,</span><br><span class="line">        Collections.singletonMap(<span class="string">&quot;spring.banner.location&quot;</span>, <span class="string">&quot;banner1.txt&quot;</span>)</span><br><span class="line">    ));</span><br><span class="line">    printer.print(env, Step7.class, System.out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文字 Banner 可以从 网站 上自定义。</p><p>图片 Banner：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试图片 banner</span></span><br><span class="line">    env.getPropertySources().addLast(<span class="keyword">new</span> <span class="title class_">MapPropertySource</span>(</span><br><span class="line">        <span class="string">&quot;custom&quot;</span>,</span><br><span class="line">        Collections.singletonMap(<span class="string">&quot;spring.banner.image.location&quot;</span>, <span class="string">&quot;banner2.gif&quot;</span>)</span><br><span class="line">    ));</span><br><span class="line">    printer.print(env, Step7.class, System.out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 Spring 或 SpringBoot 的版本号可以使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;SpringBoot: &quot;</span> + SpringBootVersion.getVersion());</span><br><span class="line">System.out.println(<span class="string">&quot;Spring: &quot;</span> + SpringVersion.getVersion());</span><br></pre></td></tr></table></figure><p>步骤总结</p><ol><li>得到 SpringApplicationRunListeners 事件发布器</li></ol><ul><li>发布 Application Starting 事件</li></ul><ol><li>封装启动 args</li><li>准备 Environment 添加命令行参数</li><li>ConfigurationPropertySources 处理</li></ol><ul><li>发布 Application Environment 已准备事件</li></ul><ol><li>通过 EnvironmentPostProcessorApplicationListener 进行 env 后处理</li></ol><ul><li>application.properties 由 StandardConfigDataLocationResolver 解析</li><li>spring.application.json</li></ul><ol><li>绑定 spring.main 到 SpringApplication 对象</li><li>打印 Banner</li><li>创建容器</li><li>准备容器</li></ol><ul><li>发布 Application Context 已初始化事件</li></ul><ol><li>加载 Bean 定义</li></ol><ul><li>发布 Application Prepared 事件</li></ul><ol><li>refresh 容器</li></ol><ul><li>发布 Application Started 事件</li></ul><ol><li>执行 Runner</li></ol><ul><li>发布 Application Ready 事件</li><li>这其中有异常，发布 Application Failed 事件</li></ul><h1 id="Tomcat-内嵌容器"><a href="#Tomcat-内嵌容器" class="headerlink" title="Tomcat 内嵌容器"></a>Tomcat 内嵌容器</h1><p>Tomcat 基本结构：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Server</span><br><span class="line">└───Service</span><br><span class="line">    ├───Connector (协议, 端口)</span><br><span class="line">    └───Engine</span><br><span class="line">        └───Host(虚拟主机 localhost)</span><br><span class="line">            ├───Context1 (应用 <span class="number">1</span>, 可以设置虚拟路径, / 即 url 起始路径; 项目磁盘路径, 即 docBase)</span><br><span class="line">            │   │   index.html</span><br><span class="line">            │   └───WEB-INF</span><br><span class="line">            │       │   web.xml (servlet, filter, listener) <span class="number">3.0</span></span><br><span class="line">            │       ├───classes (servlet, controller, service ...)</span><br><span class="line">            │       ├───jsp</span><br><span class="line">            │       └───lib (第三方 jar 包)</span><br><span class="line">            └───Context2 (应用 <span class="number">2</span>)</span><br><span class="line">                │   index.html</span><br><span class="line">                └───WEB-INF</span><br><span class="line">                        web.xml</span><br></pre></td></tr></table></figure><h2 id="40-1-内嵌-Tomcat-的使用"><a href="#40-1-内嵌-Tomcat-的使用" class="headerlink" title="40.1 内嵌 Tomcat 的使用"></a>40.1 内嵌 Tomcat 的使用</h2><p>内嵌 Tomcat 的使用分为 6 步：</p><ol><li>创建 Tomcat</li><li>创建项目文件夹，即 docBase 文件夹</li><li>创建 Tomcat 项目，在 Tomcat 中称为 Context</li><li>编程添加 Servlet</li><li>启动 Tomcat</li><li>创建连接器，设置监听端口</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 Tomcat</span></span><br><span class="line">    <span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line">    tomcat.setBaseDir(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 创建项目文件夹，即 docBase 文件夹</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">docBase</span> <span class="operator">=</span> Files.createTempDirectory(<span class="string">&quot;boot.&quot;</span>).toFile();</span><br><span class="line">    docBase.deleteOnExit();</span><br><span class="line">    <span class="comment">// 3. 创建 tomcat 项目，在 tomcat 中称为 Context</span></span><br><span class="line">    <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> tomcat.addContext(<span class="string">&quot;&quot;</span>, docBase.getAbsolutePath());</span><br><span class="line">    <span class="comment">// 4. 编程添加 Servlet</span></span><br><span class="line">    context.addServletContainerInitializer((set, servletContext) -&gt; &#123;</span><br><span class="line">        <span class="type">HelloServlet</span> <span class="variable">servlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloServlet</span>();</span><br><span class="line">        <span class="comment">// 还要设置访问 Servlet 的路径</span></span><br><span class="line">        servletContext.addServlet(<span class="string">&quot;hello&quot;</span>, servlet).addMapping(<span class="string">&quot;/hello&quot;</span>);</span><br><span class="line">    &#125;, Collections.emptySet());</span><br><span class="line">    <span class="comment">// 5. 启动 tomcat</span></span><br><span class="line">    tomcat.start();</span><br><span class="line">    <span class="comment">// 6. 创建连接器，设置监听端口</span></span><br><span class="line">    <span class="type">Connector</span> <span class="variable">connector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Connector</span>(<span class="keyword">new</span> <span class="title class_">Http11Nio2Protocol</span>());</span><br><span class="line">    connector.setPort(<span class="number">8080</span>);</span><br><span class="line">    tomcat.setConnector(connector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自行实现的 Servlet 需要继承 HttpServlet，并重写 doGet() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8117441197359625079L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req,</span></span><br><span class="line"><span class="params">                         HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        resp.getWriter().print(<span class="string">&quot;&lt;h3&gt;hello&lt;/h3&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，在浏览器访问 localhost:8080&#x2F;hello，页面显示 hello。</p><h2 id="40-2-与-Spring-整合"><a href="#40-2-与-Spring-整合" class="headerlink" title="40.2 与 Spring 整合"></a>40.2 与 Spring 整合</h2><p>首先肯定需要一个 Spring 容器，选择不支持内嵌 Tomcat 的 Spring 容器，使其使用前文中的 Tomcat：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> WebApplicationContext <span class="title function_">getApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 使用不支持内嵌 Tomcat 的 Spring 容器</span></span><br><span class="line">    <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">    context.register(Config.class);</span><br><span class="line">    context.refresh();</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器中注册了 Config Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServletRegistrationBean <span class="title function_">registrationBean</span><span class="params">(DispatcherServlet dispatcherServlet)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DispatcherServlet <span class="title function_">dispatcherServlet</span><span class="params">(WebApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 必须为 DispatcherServlet 提供 AnnotationConfigWebApplicationContext，</span></span><br><span class="line"><span class="comment">         * 否则会选择 XmlWebApplicationContext 实现</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>(applicationContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RequestMappingHandlerAdapter <span class="title function_">requestMappingHandlerAdapter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">RequestMappingHandlerAdapter</span> <span class="variable">handlerAdapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerAdapter</span>();</span><br><span class="line">        handlerAdapter.setMessageConverters(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">MappingJackson2HttpMessageConverter</span>()));</span><br><span class="line">        <span class="keyword">return</span> handlerAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RestController</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">        <span class="meta">@GetMapping(&quot;hello2&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> Map&lt;String,Object&gt; <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.singletonMap(<span class="string">&quot;hello2&quot;</span>, <span class="string">&quot;hello2, spring!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tomcat 在添加 Servlet 时，添加 DispatcherServlet：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">springContext</span> <span class="operator">=</span> getApplicationContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 编程添加 Servlet</span></span><br><span class="line">    context.addServletContainerInitializer((set, servletContext) -&gt; &#123;</span><br><span class="line">        <span class="type">HelloServlet</span> <span class="variable">servlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloServlet</span>();</span><br><span class="line">        <span class="comment">// 还要设置访问 Servlet 的路径</span></span><br><span class="line">        servletContext.addServlet(<span class="string">&quot;hello&quot;</span>, servlet).addMapping(<span class="string">&quot;/hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DispatcherServlet</span> <span class="variable">dispatcherServlet</span> <span class="operator">=</span> springContext.getBean(DispatcherServlet.class);</span><br><span class="line">        servletContext.addServlet(<span class="string">&quot;dispatcherServlet&quot;</span>, dispatcherServlet).addMapping(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;, Collections.emptySet());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法，在浏览器中访问 localhost:8080&#x2F;hello2，页面上显示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;hello2&quot;</span>:<span class="string">&quot;hello2, spring!&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>添加 Servlet 时只添加了一个 DispatcherServlet，但 Spring 容器中可能存在多个 Servlet，这些 Servlet 也应该被添加，因此可以获取 ServletRegistrationBean 类型的 Bean 并执行 &#96;&#96; 方法，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">springContext</span> <span class="operator">=</span> getApplicationContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 编程添加 Servlet</span></span><br><span class="line">    context.addServletContainerInitializer((set, servletContext) -&gt; &#123;</span><br><span class="line">        <span class="type">HelloServlet</span> <span class="variable">servlet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloServlet</span>();</span><br><span class="line">        <span class="comment">// 还要设置访问 Servlet 的路径</span></span><br><span class="line">        servletContext.addServlet(<span class="string">&quot;hello&quot;</span>, servlet).addMapping(<span class="string">&quot;/hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring 容器中可能存在多个 Servlet</span></span><br><span class="line">        <span class="keyword">for</span> (ServletRegistrationBean registrationBean : springContext.getBeansOfType(ServletRegistrationBean.class).values()) &#123;</span><br><span class="line">            registrationBean.onStartup(servletContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, Collections.emptySet());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法，在浏览器中访问 localhost:8080&#x2F;hello2，页面显示同样的内容。</p><h1 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h1><h2 id="41-1-自动配置类原理"><a href="#41-1-自动配置类原理" class="headerlink" title="41.1 自动配置类原理"></a>41.1 自动配置类原理</h2><p>有以下四个类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 模拟第三方配置类</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration1</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟第三方配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration2</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>其中 AutoConfiguration1 和 AutoConfiguration2 用来模拟第三方配置类，注意它们并没有被 @Configuration 注解标记，因此在未进行其他操作时，不会被添加到 Spring 容器中。</p><p>然后编写自己的配置类，使用 @Import 注解将第三方配置类添加到 Spring 容器中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfiguration1.class, AutoConfiguration2.class&#125;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">config</span><br><span class="line">org.springframework.context.annotation.ConfigurationClassPostProcessor</span><br><span class="line">indi.lcp.a41.A41$AutoConfiguration1</span><br><span class="line">bean1</span><br><span class="line">indi.lcp.a41.A41$AutoConfiguration2</span><br><span class="line">bean2</span><br></pre></td></tr></table></figure><p>如果有多个第三方配置类，难不成到一个个地导入？</p><p>可以使用导入选择器 ImportSelector，重写 selectImports() 方法，返回需要自动装配的 Bean 的全限定类名数组：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;AutoConfiguration1.class.getName(), AutoConfiguration2.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样的方式相比最初的方式并没有本质区别，甚至更麻烦，还多了一个类。如果 selectImports() 方法返回的全限定类名可以从文件中读取，就更方便了。</p><p>在当前项目的类路径下创建 META-INF&#x2F;spring.factories 文件，约定一个 key，对应的 value 即为需要指定装配的 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 内部类作为 key 时，最后以 $ 符号分割</span><br><span class="line">indi.lcp.a41.A41$MyImportSelector=\</span><br><span class="line">  indi.lcp.a41.A41.AutoConfiguration1, \</span><br><span class="line">  indi.lcp.a41.A41.AutoConfiguration2</span><br></pre></td></tr></table></figure><p>修改 selectImports() 方法实现逻辑：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        List&lt;String&gt; names = SpringFactoriesLoader.loadFactoryNames(MyImportSelector.class, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> names.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出同样的结果。</p><p>SpringFactoriesLoader.loadFactoryNames() 不仅只扫描当前项目类型路径下的 META-INF&#x2F;spring.factories 文件，而是会扫描包括 Jar 包里类路径下的 META-INF&#x2F;spring.factories 文件。</p><p>针对 SpringBoot 来说，自动装配的 Bean 使用如下语句加载：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>SpringBoot 2.7.0 及其以后版本的自动装配</p><p>在 SpringBoot 2.7.0 及其以后的版本中，SpringBoot 不再通过读取 META-INF&#x2F;spring.factories 文件中 key 为 org.springframework.boot.autoconfigure.EnableAutoConfiguration 的 values 来实现自动装配。</p><p>为了更贴合 SPI 机制，SpringBoot 将读取 META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件中的内容，该文件中每一行都表示需要自动装配的 Bean 的全限定类名，可以使用 # 作为注释。其加载方式使用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader());</span><br></pre></td></tr></table></figure><p>其中 AutoConfiguration 是一个注解，它的全限定类名为 org.springframework.boot.autoconfigure.AutoConfiguration。</p><p>也就是说可以自定义一个注解，创建 META-INF&#x2F;spring&#x2F;full-qualified-annotation-name.imports 文件，在文件里声明需要自动装配的类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> indi.lcp.a41;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAutoConfiguration &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> indi.lcp.a41;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A41</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean3</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 META-INF&#x2F;spring&#x2F;indi.lcp.a41.MyAutoConfiguration.imports 文件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.a41.A41$Bean3</span><br></pre></td></tr></table></figure><p>修改 selectImports() 方法实现逻辑：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(MyImportSelector.class, <span class="literal">null</span>));</span><br><span class="line">        <span class="comment">// 读取新版自动装配文件</span></span><br><span class="line">        ImportCandidates.load(MyAutoConfiguration.class, <span class="literal">null</span>).forEach(names::add);</span><br><span class="line">        <span class="keyword">return</span> names.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，Spring 容器中的 Bean 多了 一个：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.a41.A41$Bean3</span><br></pre></td></tr></table></figure><p>定义了冲突的 Bean</p><p>第三方装配了 Bean1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration1</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>(<span class="string">&quot;第三方&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户又自行定义了 Bean1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>(<span class="string">&quot;本项目&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改测试的 main() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    System.out.println(context.getBean(Bean1.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终谁会生效呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">A41.Bean1(name=本项目)</span><br></pre></td></tr></table></figure><p>用户自行定义的 Bean 生效了，这是因为：@Import 导入的 Bean 先于配置类中 @Bean 定义的 Bean 执行，后者覆盖前者，使得用户自定义的 Bean 生效。</p><p>但在 SpringBoot 中不是这样的，当后续添加的 Bean 想覆盖先前添加的 Bean，会出现错误。模拟 SpringBoot 的设置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    <span class="comment">// 默认是 true，SpringBoot 修改为 false，使得无法进行覆盖</span></span><br><span class="line">    context.getDefaultListableBeanFactory().setAllowBeanDefinitionOverriding(<span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> org.springframework.beans.factory.support.BeanDefinitionOverrideException: Invalid bean definition with name <span class="string">&#x27;bean1&#x27;</span> defined in indi.lcp.a41.A41$Config: Cannot register bean definition [Root bean: class [<span class="literal">null</span>]; scope=; <span class="keyword">abstract</span>=<span class="literal">false</span>; lazyInit=<span class="literal">null</span>; autowireMode=<span class="number">3</span>; dependencyCheck=<span class="number">0</span>; autowireCandidate=<span class="literal">true</span>; primary=<span class="literal">false</span>; factoryBeanName=config; factoryMethodName=bean1; initMethodName=<span class="literal">null</span>; destroyMethodName=(inferred); defined in indi.lcp.a41.A41$Config] <span class="keyword">for</span> bean <span class="string">&#x27;bean1&#x27;</span>: There is already [Root bean: class [<span class="literal">null</span>]; scope=; <span class="keyword">abstract</span>=<span class="literal">false</span>; lazyInit=<span class="literal">null</span>; autowireMode=<span class="number">3</span>; dependencyCheck=<span class="number">0</span>; autowireCandidate=<span class="literal">true</span>; primary=<span class="literal">false</span>; factoryBeanName=indi.lcp.a41.A41$AutoConfiguration1; factoryMethodName=bean1; initMethodName=<span class="literal">null</span>; destroyMethodName=(inferred); defined in <span class="keyword">class</span> <span class="title class_">path</span> resource [indi/lcp/a41/A41$AutoConfiguration1.class]] bound.</span><br></pre></td></tr></table></figure><p>那这样是合理的吗？</p><p>显然不是。比如 SpringBoot 默认的数据连接池是 Hikari，如果用户想换成 Druid，岂不是做不到？</p><p>实际情况下是能做到的，这又是怎么做到的呢？</p><p>首先需要使用户的配置类中定义的 Bean 先于 @Import 导入的 Bean 添加到 Spring 容器中，只需将选择器 MyImportSelector 实现的 ImportSelector 接口更换成其子接口 DeferredImportSelector 即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行 main() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> org.springframework.beans.factory.support.BeanDefinitionOverrideException: Invalid bean definition with name <span class="string">&#x27;bean1&#x27;</span> defined in <span class="keyword">class</span> <span class="title class_">path</span> resource [indi/lcp/a41/A41$AutoConfiguration1.class]: Cannot register bean definition [Root bean: class [<span class="literal">null</span>]; scope=; <span class="keyword">abstract</span>=<span class="literal">false</span>; lazyInit=<span class="literal">null</span>; autowireMode=<span class="number">3</span>; dependencyCheck=<span class="number">0</span>; autowireCandidate=<span class="literal">true</span>; primary=<span class="literal">false</span>; factoryBeanName=indi.lcp.a41.A41$AutoConfiguration1; factoryMethodName=bean1; initMethodName=<span class="literal">null</span>; destroyMethodName=(inferred); defined in <span class="keyword">class</span> <span class="title class_">path</span> resource [indi/lcp/a41/A41$AutoConfiguration1.class]] <span class="keyword">for</span> bean <span class="string">&#x27;bean1&#x27;</span>: There is already [Root bean: class [<span class="literal">null</span>]; scope=; <span class="keyword">abstract</span>=<span class="literal">false</span>; lazyInit=<span class="literal">null</span>; autowireMode=<span class="number">3</span>; dependencyCheck=<span class="number">0</span>; autowireCandidate=<span class="literal">true</span>; primary=<span class="literal">false</span>; factoryBeanName=config; factoryMethodName=bean1; initMethodName=<span class="literal">null</span>; destroyMethodName=(inferred); defined in indi.lcp.a41.A41$Config] bound.</span><br></pre></td></tr></table></figure><p>尽管还是出现了异常，但异常信息中显示的是在配置类定义的 Bean 已存在，第三方装配的 Bean 无法再添加，这表明 Bean 的添加顺序修改成功。</p><p>最后在第三方定义的 Bean 上添加 @ConditionalOnMissingBean 注解，表示容器中存在同名的 Bean 时忽略该 Bean 的添加：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration1</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>(<span class="string">&quot;第三方&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行 main() 方法，不再出现异常：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">A41.Bean1(name=本项目)</span><br></pre></td></tr></table></figure><h2 id="41-2-Aop-自动配置"><a href="#41-2-Aop-自动配置" class="headerlink" title="41.2 Aop 自动配置"></a>41.2 Aop 自动配置</h2><p>确保当前模块下已导入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>使用 AopAutoConfiguration 自动装配与 AOP 相关的 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAopAuto</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">        <span class="comment">// 注册常用后置处理器</span></span><br><span class="line">        AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">        context.registerBean(Config.class);</span><br><span class="line">        context.refresh();</span><br><span class="line">        Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;AopAutoConfiguration.class.getName()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">indi.lcp.a41.TestAopAuto$Config</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration$AspectJAutoProxyingConfiguration$CglibAutoProxyConfiguration</span><br><span class="line">org.springframework.aop.config.internalAutoProxyCreator</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration$AspectJAutoProxyingConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration</span><br></pre></td></tr></table></figure><p>以 indi.lcp.a41.TestAopAuto$Config 为分割线，上方是添加的一些后置处理器，下方就是 AOP 自动装配添加的 Bean。</p><p>在配置类 AopAutoConfiguration 中，使用注解判断配置类是否生效。首先是最外层的 AopAutoConfiguration：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfiguration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;auto&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopAutoConfiguration</span> &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 @ConditionalOnProperty 注解配置的信息：如果配置文件中存在 前缀 为 spring.aop，名称 为 auto 的 key，并且其对应的 value 是 true 时，配置类 AopAutoConfiguration 生效；如果配置文件中未显式配置，该配置类也生效。</p><p>不使用配置文件，使用 StandardEnvironment 指定 spring.aop.auto 的值为 false：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    <span class="type">StandardEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">    env.getPropertySources().addLast(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SimpleCommandLinePropertySource</span>(<span class="string">&quot;--spring.aop.auto=false&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">    context.setEnvironment(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br><span class="line">indi.lcp.a41.TestAopAuto$Config</span><br></pre></td></tr></table></figure><p>如果 spring.aop.auto 的值是 true，又会成功添加上 AOP 自动装配的 Bean。</p><p>再看 AopAutoConfiguration 的内部类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(Advice.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AspectJAutoProxyingConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingClass(&quot;org.aspectj.weaver.Advice&quot;)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClassProxyingConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其内部存在两个类：AspectJAutoProxyingConfiguration 和 ClassProxyingConfiguration。</p><p>使用了 @ConditionalOnClass 注解判断 Advice.class 存在时，AspectJAutoProxyingConfiguration 生效；使用 @ConditionalOnMissingClass 注解判断 org.aspectj.weaver.Advice 不存在时，ClassProxyingConfiguration 生效。</p><p>由于先前导入了 spring-boot-starter-aop 依赖，Advice.class 是存在的，AspectJAutoProxyingConfiguration 将生效。</p><p>AspectJAutoProxyingConfiguration 内部又有两个配置类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;false&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JdkDynamicAutoProxyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CglibAutoProxyConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个配置类通过使用 @ConditionalOnProperty 注解判断配置文件中是否存在 spring.aop.proxy-target-class 配置来让对应的配置类生效。</p><p>由于并未显式 配置，因此 CglibAutoProxyConfiguration 将生效。</p><p>无论哪个配置类生效，它们都被 @EnableAspectJAutoProxy 标记，这个注解相当于是添加了些配置的 @Import 注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(&#123;AspectJAutoProxyRegistrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向 Spring 容器中添加 AspectJAutoProxyRegistrar 类型的 Bean。</p><p>AspectJAutoProxyRegistrar 实现了 ImportBeanDefinitionRegistrar 接口，可以使用编程的方式来注册一些 Bean：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AspectJAutoProxyRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary() 方法是注册 Bean 的主要逻辑：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title function_">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry, (Object)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title function_">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终注册了 AnnotationAwareAspectJAutoProxyCreator。</p><p>使用 org.springframework.aop.config.internalAutoProxyCreator 作为名称，获取 AnnotationAwareAspectJAutoProxyCreator 类型的 Bean，并查看其 proxyTargetClass 属性是否为 true：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    <span class="type">AnnotationAwareAspectJAutoProxyCreator</span> <span class="variable">creator</span> <span class="operator">=</span></span><br><span class="line">        context.getBean(<span class="string">&quot;org.springframework.aop.config.internalAutoProxyCreator&quot;</span>, AnnotationAwareAspectJAutoProxyCreator.class);</span><br><span class="line">    System.out.println(creator.isProxyTargetClass()); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【补充】ImportBeanDefinitionRegistrar 接口</p><p>将 Bean 注入到 Spring 的大致流程是：</p><p>利用 BeanDefinitionReader 读取配置文件或注解信息，为每一个 Bean 生成一个 BeanDefinition</p><p>将 BeanDefinition 注册到 BeanDefinitionRegistry 中</p><p>当需要创建 Bean 对象时，从 BeanDefinitionRegistry 中取出对应的 BeanDefinition，利用这个 BeanDefinition 来创建 Bean</p><p>如果创建的 Bean 是单例的，Spring 会将这个 Bean 保存到 SingletonBeanRegistry 中，即三级缓存中的第一级缓存，需要时直接从这里获取，而不是重复创建</p><p>也就是说 Spring 是通过 BeanDefinition 去创建 Bean 的，而 BeanDefinition 会被注册到 BeanDefinitionRegistry 中，因此可以拿到 BeanDefinitionRegistry 直接向里面注册 BeanDefinition 达到将 Bean 注入到 Spring 的目标。</p><p>ImportBeanDefinitionRegistrar 接口就可以直接拿到 BeanDefinitionRegistry：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry, BeanNameGenerator importBeanNameGenerator)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.registerBeanDefinitions(importingClassMetadata, registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口需要搭配 @Import 注解使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();</span></span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    <span class="comment">// AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span></span><br><span class="line"></span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">    context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    Arrays.stream(context.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">    System.out.println(context.getBean(User.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;MyImportBeanDefinitionRegistrar.class&#125;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 构建 BeanDefinition</span></span><br><span class="line">        <span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(User.class)</span><br><span class="line">                .addPropertyValue(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lcp&quot;</span>)</span><br><span class="line">                .addPropertyValue(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>)</span><br><span class="line">                .getBeanDefinition();</span><br><span class="line">        <span class="comment">// 注册构建好的 BeanDefinition</span></span><br><span class="line">        registry.registerBeanDefinition(<span class="string">&quot;user&quot;</span>, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： 使用时一定要确保 Spring 容器中存在 ConfigurationClassPostProcessor 类型的 Bean。</p><p>除此之外，使用 BeanDefinitionRegistryPostProcessor 接口也能拿到 BeanDefinitionRegistry：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry var1)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="41-3-数据库相关的自动配置"><a href="#41-3-数据库相关的自动配置" class="headerlink" title="41.3 数据库相关的自动配置"></a>41.3 数据库相关的自动配置</h2><p>确保当前模块下已导入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.3</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>DataSource 自动配置</p><p>自行实现导入选择器，并使用 @Import 注解进行导入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">                DataSourceAutoConfiguration.class.getName(),</span><br><span class="line">                MybatisAutoConfiguration.class.getName(),</span><br><span class="line">                DataSourceTransactionManagerAutoConfiguration.class.getName(),</span><br><span class="line">                TransactionAutoConfiguration.class.getName()</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main() 方法中打印导入的 Bean 信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    <span class="type">StandardEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">    env.getPropertySources().addLast(<span class="keyword">new</span> <span class="title class_">SimpleCommandLinePropertySource</span>(</span><br><span class="line">        <span class="string">&quot;--spring.datasource.url=jdbc:mysql://localhost:3306/advanced_spring&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--spring.datasource.username=root&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--spring.datasource.password=123456&quot;</span></span><br><span class="line">    ));</span><br><span class="line">    context.setEnvironment(env);</span><br><span class="line">    AnnotationConfigUtils.registerAnnotationConfigProcessors(context.getDefaultListableBeanFactory());</span><br><span class="line">    context.registerBean(Config.class);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resourceDescription</span> <span class="operator">=</span> context.getBeanDefinition(name).getResourceDescription();</span><br><span class="line">        <span class="keyword">if</span> (resourceDescription != <span class="literal">null</span>)</span><br><span class="line">            System.out.println(name + <span class="string">&quot; 来源: &quot;</span> + resourceDescription);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未使用配置文件，而是使用 StandardEnvironment 设置了一些数据库连接信息。</p><p>最后只打印有明确来源的 Bean 信息，其中有一条：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataSource 来源: <span class="keyword">class</span> <span class="title class_">path</span> resource [org/springframework/boot/autoconfigure/jdbc/DataSourceConfiguration$Hikari.class]</span><br></pre></td></tr></table></figure><p>名叫 dataSource 的 Bean 的来源为什么是 DataSourceConfiguration，而不是 DataSourceAutoConfiguration 呢？</p><p>查看 DataSourceAutoConfiguration 的源码，实现与 AopAutoConfiguration 类似，都是通过注解来判断需要导入哪些 Bean，有两个关键的内部类 EmbeddedDatabaseConfiguration 和 PooledDataSourceConfiguration：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfiguration(before = SqlInitializationAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; DataSource.class, EmbeddedDatabaseType.class &#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(type = &quot;io.r2dbc.spi.ConnectionFactory&quot;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(DataSourceProperties.class)</span></span><br><span class="line"><span class="meta">@Import(DataSourcePoolMetadataProvidersConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="meta">@Conditional(EmbeddedDatabaseCondition.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;)</span></span><br><span class="line">    <span class="meta">@Import(EmbeddedDataSourceConfiguration.class)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EmbeddedDatabaseConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">    <span class="meta">@Conditional(PooledDataSourceCondition.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;)</span></span><br><span class="line">    <span class="meta">@Import(&#123; DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,</span></span><br><span class="line"><span class="meta">             DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.OracleUcp.class,</span></span><br><span class="line"><span class="meta">             DataSourceConfiguration.Generic.class, DataSourceJmxConfiguration.class &#125;)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PooledDataSourceConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们都被 @Conditional 注解标记。当项目支持内嵌数据源时，EmbeddedDatabaseConfiguration 生效；当项目支持基于数据库连接池的数据源时，PooledDataSourceConfiguration 生效。</p><p>SpringBoot 默认的数据库连接池是 Hikari，因此 PooledDataSourceConfiguration 生效，最终使用 @Import 导入一系列 Bean，导入的这些 Bean 都是 DataSourceConfiguration 的内部类，因此dataSource 的 Bean 的来源是 DataSourceConfiguration。</p><p>在 DataSourceConfiguration 中，通过 @ConditionalOnClass 注解判断某些 Class 是否存在来使某种数据库连接池生效。</p><p>由于导入了 mybatis-spring-boot-starter，其内部依赖 mybatis-spring-boot-jdbc，而它又依赖了 HikariCP，因此最终数据库连接池 Hikari 生效：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(HikariDataSource.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(DataSource.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;, havingValue = &quot;com.zaxxer.hikari.HikariDataSource&quot;,</span></span><br><span class="line"><span class="meta">      matchIfMissing = true)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Hikari</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource.hikari&quot;)</span></span><br><span class="line">   HikariDataSource <span class="title function_">dataSource</span><span class="params">(DataSourceProperties properties)</span> &#123;</span><br><span class="line">      <span class="type">HikariDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> createDataSource(properties, HikariDataSource.class);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(properties.getName())) &#123;</span><br><span class="line">         dataSource.setPoolName(properties.getName());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dataSource;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Hikari#dataSource() 方法中，接受一个 DataSourceProperties 类型的参数，这要求 Spring 容器中存在 DataSourceProperties 类型的 Bean。</p><p>在最初的 DataSourceAutoConfiguration 自动配置类上有个 @EnableConfigurationProperties 注解，它将 DataSourceProperties 添加到容器中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(DataSourceProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// --snip-=</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 DataSourceProperties 中会绑定配置文件中以 spring.datasource 为前缀的配置：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceProperties</span> <span class="keyword">implements</span> <span class="title class_">BeanClassLoaderAware</span>, InitializingBean &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 DataSourceProperties 类型的 Bean，并打印其 url、username 和 password：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    <span class="type">StandardEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEnvironment</span>();</span><br><span class="line">    env.getPropertySources().addLast(<span class="keyword">new</span> <span class="title class_">SimpleCommandLinePropertySource</span>(</span><br><span class="line">        <span class="string">&quot;--spring.datasource.url=jdbc:mysql://localhost:3306/advanced_spring&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--spring.datasource.username=root&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--spring.datasource.password=123456&quot;</span></span><br><span class="line">    ));</span><br><span class="line">    context.setEnvironment(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">DataSourceProperties</span> <span class="variable">properties</span> <span class="operator">=</span> context.getBean(DataSourceProperties.class);</span><br><span class="line">    System.out.println(properties.getUrl());</span><br><span class="line">    System.out.println(properties.getUsername());</span><br><span class="line">    System.out.println(properties.getPassword());</span><br><span class="line">&#125;</span><br><span class="line">jdbc:mysql:<span class="comment">//localhost:3306/advanced_spring</span></span><br><span class="line">root</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>MyBatis 自动配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;SqlSessionFactory.class, SqlSessionFactoryBean.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate(DataSource.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;MybatisProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@AutoConfigureAfter(&#123;DataSourceAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisAutoConfiguration</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionTemplate <span class="title function_">sqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@Import(&#123;MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar.class&#125;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(&#123;MapperFactoryBean.class, MapperScannerConfigurer.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MapperScannerRegistrarNotFoundConfiguration</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MybatisAutoConfiguration 生效的条件有两个：</p><p>类路径下存在 SqlSessionFactory 和 SqlSessionFactoryBean</p><p>Spring 容器中有且仅有一个 DataSource 类型的 Bean</p><p>它还添加了 MybatisProperties 类型的 Bean 到 Spring 容器中，并与配置文件中以 mybatis 为前缀的信息绑定。</p><p>@AutoConfigureAfter 注解指定了当前自动配置类在 DataSourceAutoConfiguration 和 MybatisLanguageDriverAutoConfiguration 两个自动配置类解析完成之后再解析。</p><p>接下来遇到 sqlSessionFactory() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖 Spring 容器中的 DataSource，当容器中不存在 SqlSessionFactory 时，将其添加到 Spring 容器中。</p><p>然后是 sqlSessionTemplate() 方法，它与添加 SqlSessionFactory 到 Spring 容器的逻辑一样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionTemplate <span class="title function_">sqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SqlSessionTemplate 也是 SqlSession 的实现，提供了与当前线程绑定的 SqlSession。针对多个方法调用，如果它们来自同一个线程，那么获取到的 SqlSession 对象是同一个。这也是为什么有了 DefaultSqlSession 作为 SqlSession 的实现了，还需要 SqlSessionTemplate。</p><p>在 MyBatis 中，使用 MapperFactoryBean 将接口转换为对象，其核心是 getObject() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.getSqlSession().getMapper(<span class="built_in">this</span>.mapperInterface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法中获取了 sqlSession 对象，而获取的就是 SqlSessionTemplate 对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSession <span class="title function_">getSqlSession</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后来到 MapperScannerRegistrarNotFoundConfiguration 内部类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar.class&#125;)</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(&#123;MapperFactoryBean.class, MapperScannerConfigurer.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MapperScannerRegistrarNotFoundConfiguration</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 @ConditionalOnMissingBean 判断 Spring 容器中缺失 MapperFactoryBean 和 MapperScannerConfigurer 时，该配置类生效。生效时利用 @Import 导入 AutoConfiguredMapperScannerRegistrar：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguredMapperScannerRegistrar</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span>, EnvironmentAware, ImportBeanDefinitionRegistrar &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AutoConfiguredMapperScannerRegistrar 实现了 ImportBeanDefinitionRegistrar 接口，允许通过编程的方式加 Bean 添加到 Spring 容器中，而这里是去扫描 Mapper 接口，将其转换为对象添加到 Spring 容器中。</p><p>在 main() 所在类的包路径下创建 mapper 包，并新建三个接口，其中两个被 @Mapper 注解标记：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mapper1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mapper2</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Mapper3</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法，查看 Mapper1 和 Mapper2 是否被添加到 Spring 容器中。</p><p>结果是否定的。因为 没有设置要扫描的包路径 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">packageName</span> <span class="operator">=</span> TestDataSourceAuto.class.getPackage().getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;当前包名: &quot;</span> + packageName);</span><br><span class="line">    AutoConfigurationPackages.register(context.getDefaultListableBeanFactory(),</span><br><span class="line">            packageName);</span><br><span class="line"></span><br><span class="line">    context.refresh();</span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">resourceDescription</span> <span class="operator">=</span> context.getBeanDefinition(name).getResourceDescription();</span><br><span class="line">        <span class="keyword">if</span> (resourceDescription != <span class="literal">null</span>)</span><br><span class="line">            System.out.println(name + <span class="string">&quot; 来源: &quot;</span> + resourceDescription);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line">当前包名: indi.lcp.a41</span><br><span class="line">mapper1 来源: file [D:\Code\IdeaCode\advanced-spring\boot\target\classes\indi\lcp\a41\mapper\Mapper1.class]</span><br><span class="line">mapper2 来源: file [D:\Code\IdeaCode\advanced-spring\boot\target\classes\indi\lcp\a41\mapper\Mapper2.class]</span><br></pre></td></tr></table></figure><p>@MapperScan 注解与 MybatisAutoConfiguration 在功能上很类似，只不过：</p><p>@MapperScan 可以指定具体的扫描路径，未指定时会把引导类范围内的所有接口当做 Mapper 接口；</p><p>MybatisAutoConfiguration 关注所有被 @Mapper 注解标记的接口，忽略未被 @Mapper 标记的接口。</p><p>事务自动配置</p><p>事务自动配置与 DataSourceTransactionManagerAutoConfiguration、TransactionAutoConfiguration 有关。</p><p>DataSourceTransactionManagerAutoConfiguration 配置了 DataSourceTransactionManager 用来执行事务的提交、回滚操作。</p><p>TransactionAutoConfiguration 在功能上对标 @EnableTransactionManagement，包含以下三个 Bean：</p><p>BeanFactoryTransactionAttributeSourceAdvisor：事务切面类，包含通知和切点</p><p>TransactionInterceptor：事务通知类，由它在目标方法调用前后加入事务操作</p><p>AnnotationTransactionAttributeSource：解析 @Transactional 及事务属性，还包含了切点功能</p><p>如果自定义了 DataSourceTransactionManager 或是在引导类加了 @EnableTransactionManagement，则以自定义为准。</p><h2 id="41-4-MVC-自动配置"><a href="#41-4-MVC-自动配置" class="headerlink" title="41.4 MVC 自动配置"></a>41.4 MVC 自动配置</h2><p>MVC 的自动配置需要用到四个类：</p><p>配置内嵌 Tomcat 服务器工厂：ServletWebServerFactoryAutoConfiguration</p><p>配置 DispatcherServlet：DispatcherServletAutoConfiguration</p><p>配置 WebMVC 各种组件：WebMvcAutoConfiguration</p><p>配置 MVC 的错误处理：ErrorMvcAutoConfiguration</p><p>查看自动配置与 MVC 相关的 Bean 的信息、来源：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMvcAuto</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigServletWebServerApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigServletWebServerApplicationContext</span>();</span><br><span class="line">        context.registerBean(Config.class);</span><br><span class="line">        context.refresh();</span><br><span class="line">        <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> context.getBeanDefinition(name).getResourceDescription();</span><br><span class="line">            <span class="keyword">if</span> (source != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(name + <span class="string">&quot; 来源:&quot;</span> + source);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;</span><br><span class="line">                    <span class="comment">// 配置内嵌 Tomcat 服务器工厂</span></span><br><span class="line">                    ServletWebServerFactoryAutoConfiguration.class.getName(),</span><br><span class="line">                    <span class="comment">// 配置 DispatcherServlet</span></span><br><span class="line">                    DispatcherServletAutoConfiguration.class.getName(),</span><br><span class="line">                    <span class="comment">// 配置 WebMVC 各种组件</span></span><br><span class="line">                    WebMvcAutoConfiguration.class.getName(),</span><br><span class="line">                    <span class="comment">// 配置 MVC 的错误处理</span></span><br><span class="line">                    ErrorMvcAutoConfiguration.class.getName()</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="41-5-自定义自动配置类"><a href="#41-5-自定义自动配置类" class="headerlink" title="41.5 自定义自动配置类"></a>41.5 自定义自动配置类</h2><p>在 SpringBoot 自动装配时添加自定义组件分为两步：</p><p>在类路径下自定义 META-INF&#x2F;spring.factories 文件，以 org.springframework.boot.autoconfigure.EnableAutoConfiguration 为 key，设置需要自动装配的自定义组件的全限定类名为 value</p><p>编写配置类，在配置类上使用 @EnableAutoConfiguration 注解，并将其添加到 Spring 容器中</p><p>在实际项目开发中，省略第二步，SpringBoot 的会自动扫描。</p><p>SpringBoot 2.7.0 及其以后版本</p><p>在类路径下自定义 META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件，文件中 每一行 表示需要进行自动装配的类的全限定类名，因此不能随意换行。</p><p>在这个文件中，以 # 开头的行表示注释。</p><h1 id="条件装配底层"><a href="#条件装配底层" class="headerlink" title="条件装配底层"></a>条件装配底层</h1><h2 id="42-1-Conditional"><a href="#42-1-Conditional" class="headerlink" title="42.1 @Conditional"></a>42.1 @Conditional</h2><p>在 SpringBoot 的自动配置中，经常看到 @Conditional 注解的使用，使用该注解可以按条件加载配置类。</p><p>@Conditional 注解并不具备条件判断功能，而是通过指定的 Class 列表来进行判断，指定的 Class 需要实现 Condition 接口。</p><p>假设有这样一个需求：通过判断类路径下是否存在 com.alibaba.druid.pool.DruidDataSource 类来加载不同的配置类，当存在 DruidDataSource 时，加载 AutoConfiguration1，反之加载 AutoConfiguration2。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;AutoConfiguration1.class.getName(), AutoConfiguration2.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyCondition1</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        <span class="comment">// 存在 Druid 依赖</span></span><br><span class="line">        <span class="keyword">return</span> ClassUtils.isPresent(<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyCondition2</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        <span class="comment">// 不存在 Druid 依赖</span></span><br><span class="line">        <span class="keyword">return</span> !ClassUtils.isPresent(<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟第三方的配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Conditional(MyCondition1.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration1</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟第三方的配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Conditional(MyCondition2.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration2</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时并未导入 druid 依赖，AutoConfiguration2 应该生效，运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">config</span><br><span class="line">org.springframework.context.annotation.ConfigurationClassPostProcessor</span><br><span class="line">indi.lcp.a42.A42$AutoConfiguration1</span><br><span class="line">bean1</span><br></pre></td></tr></table></figure><p>导入 druid 依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.2</span><span class="number">.15</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>再次运行 main() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">config</span><br><span class="line">org.springframework.context.annotation.ConfigurationClassPostProcessor</span><br><span class="line">indi.lcp.a42.A42$AutoConfiguration1</span><br><span class="line">bean1</span><br></pre></td></tr></table></figure><h2 id="42-2-ConditionalOnXxx"><a href="#42-2-ConditionalOnXxx" class="headerlink" title="42.2 @ConditionalOnXxx"></a>42.2 @ConditionalOnXxx</h2><p>在 SpringBoot 的自动配置中，经常看到 @ConditionalOnXxx 注解的使用，这种注解是将某个 @Conditional 的判断进行了封装，比如 ConditionalOnClass 就是用于判断某个 Class 是否存在。</p><p>因此针对上文中的代码可以做出修改：</p><p>自定义 @ConditionalOnClass 注解，填入需要判断的全限定类名和判断条件；</p><p>移除模拟的第三方配置上的 @Conditional 注解，而是使用自定义的 @ConditionalOnClass；</p><p>Condition 接口的使用类重写的 matches() 方法利用 @ConditionalOnClass 注解进行条件判断。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line">    context.registerBean(<span class="string">&quot;config&quot;</span>, Config.class);</span><br><span class="line">    context.registerBean(ConfigurationClassPostProcessor.class);</span><br><span class="line">    context.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;AutoConfiguration1.class.getName(), AutoConfiguration2.class.getName()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; attributes = metadata.getAnnotationAttributes(ConditionalOnClass.class.getName());</span><br><span class="line">        Optional&lt;Map&lt;String, Object&gt;&gt; optional = Optional.ofNullable(attributes);</span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> optional.map(i -&gt; String.valueOf(i.get(<span class="string">&quot;className&quot;</span>))).orElse(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> optional.map(i -&gt; i.get(<span class="string">&quot;exists&quot;</span>))</span><br><span class="line">            .map(String::valueOf)</span><br><span class="line">            .map(Boolean::parseBoolean).orElse(<span class="literal">false</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">present</span> <span class="operator">=</span> ClassUtils.isPresent(className, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> exists == present;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Conditional(MyCondition.class)</span></span><br><span class="line"><span class="keyword">private</span> <span class="meta">@interface</span> ConditionalOnClass &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * true 判断存在 false 判断不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要判断的类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">className</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(className = &quot;com.alibaba.druid.pool.DruidDataSource&quot;, exists = true)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration1</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">bean1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(className = &quot;com.alibaba.druid.pool.DruidDataSource&quot;, exists = false)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AutoConfiguration2</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">bean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Bean2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在导入 druid 依赖或未导入 druid 依赖的情况下运行 main() 方法，控制台打印结果与【42.1 @Conditional】一样。</p><h1 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h1><p>FactoryBean 是一个接口，可以实现该接口，并指定一个泛型，在重写的方法指定泛型类型对象的创建，然后将实现类交由 Spring 管理，最后 Spring 容器中会增加泛型类型的 Bean。这个 Bean 并不是完全受 Spring 管理，或者说部分受 Spring 管理。</p><p>为什么这么说呢？</p><p>首先定义一个 Bean2，交由 Spring 管理，但它不是重点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义 Bean1，它未交由 Spring 管理，但是在其内部注入了 Bean2、定义初始化方法、实现 Aware 接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean2</span><span class="params">(Bean2 bean2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bean2 = bean2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">getBean2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.bean2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;setBeanFactory(&#123;&#125;)&quot;</span>, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义 Bean1FactoryBean，实现 FactoryBean 接口，指定泛型为 Bean1，将其交由 Spring 管理，Bean 的名称是 bean1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component(&quot;bean1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1FactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Bean1&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Bean1 <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Bean1</span> <span class="variable">bean1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean1</span>();</span><br><span class="line">        log.debug(<span class="string">&quot;create bean: &#123;&#125;&quot;</span>, bean1);</span><br><span class="line">        <span class="keyword">return</span> bean1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Bean1.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种方式添加到 Spring 容器中的 Bean 的名称是 bean1，但 Bean 的类型不是 Bean1FactoryBean，或者 FactoryBean，而是 Bean1。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A43</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A43.class);</span><br><span class="line">        <span class="type">Bean1</span> <span class="variable">bean1</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;bean1&quot;</span>, Bean1.class);</span><br><span class="line">        System.out.println(bean1);</span><br><span class="line"></span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.a43.Bean1FactoryBean     - create bean: indi.lcp.a43.Bean1@2667f029 </span><br><span class="line">indi.lcp.a43.Bean1@2667f029</span><br></pre></td></tr></table></figure><p>Bean1 类型的 Bean 被成功添加到 Spring 容器中，但根据打印的日志信息可以看出这个 Bean 没有经历依赖注入阶段、没有回调 Aware 接口、没有经历初始化阶段，其创建是由重写的 getObject() 方法完成的。</p><p>这个 Bean 就真的没有经历 Spring Bean 的生命周期中的任何阶段吗？</p><p>定义 Bean1PostProcessor，实现 BeanPostProcessor 接口，在 bean1 初始化前后打印日志信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1PostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;bean1&quot;</span>.equals(beanName) &amp;&amp; bean <span class="keyword">instanceof</span> Bean1) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;before [&#123;&#125;] init&quot;</span>, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;bean1&quot;</span>.equals(beanName) &amp;&amp; bean <span class="keyword">instanceof</span> Bean1) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;after [&#123;&#125;] init&quot;</span>, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 main() 方法后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.a43.Bean1FactoryBean     - create bean: indi.lcp.a43.Bean1@6a28ffa4 </span><br><span class="line">indi.lcp.a43.Bean1PostProcessor   - after [bean1] init </span><br><span class="line">indi.lcp.a43.Bean1@6a28ffa4</span><br></pre></td></tr></table></figure><p>bean1 进行了初始化后的增强逻辑，但未进行初始化前的增强逻辑。</p><p>创建代理对象的时机就是在初始化后，因此由 FactoryBean 创建的 Bean 可以进行代理增强 。</p><p>FactoryBean 接口</p><p>FactoryBean 接口中有三个可以被重写的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">OBJECT_TYPE_ATTRIBUTE</span> <span class="operator">=</span> <span class="string">&quot;factoryBeanObjectType&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><p>getObject() 用于构造 Bean 对象</p><p>getObjectType() 用于返回 Bean 对象的类型，以便可以通过类型从容器中获取 Bean</p><p>isSingleton() 每次获取的 Bean 对象是否是单例的</p><p>从容器中获取 Bean 时可以通过名称获取、可以通过类型获取、也可以通过名称和类型一起获取。如果重写的 getObjectType() 方法返回了 null，那么 仅仅 类型从容器中获取 Bean 时，将抛出 NoSuchBeanDefinitionException 异常，并提示没有指定类型的 Bean。</p><p>如果重写的 isSingleton() 方法返回 true，那么每次从容器中获取 Bean 对象都是同一个，反之则不是。</p><p>注意： 由 FactoryBean 构造的单例 Bean 不会存放在 DefaultSingletonBeanRegistry 的 singletonFactories 中，而是在 AbstractAutowireCapableBeanFactory 的 factoryBeanInstanceCache 中。</p><p>获取 FactoryBean 类型的 Bean</p><p>肯定不能简单地通过名称获取，那会返回其泛型参数类型的 Bean，那通过类型获取呢？比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context.getBean(Bean1FactoryBean.class)</span><br></pre></td></tr></table></figure><p>答案是可行的。</p><p>除此之外，还可以在名称前添加 &amp;，然后通过名称来获取（有点指针的味道？）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">context.getBean(<span class="string">&quot;&amp;bean1&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="Indexed"><a href="#Indexed" class="headerlink" title="@Indexed"></a>@Indexed</h1><p>Spring 在进行组件扫描时，会遍历项目中依赖的所有 Jar 包中类路径下所有的文件，找到被 @Component 及其衍生注解标记的类，然后把它们组装成 BeanDefinition 添加到 Spring 容器中。</p><p>如果扫描的返回过大，势必会大大地影响项目启动速度。</p><p>为了优化扫描速度，引入以下依赖，Spring 将扫描过程提前到编译期：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-context-indexer&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;<span class="literal">true</span>&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>现有如下类信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean3</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个类都与 A44 存放于同一包路径下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A44</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">        <span class="comment">// 组件扫描核心类</span></span><br><span class="line">        <span class="type">ClassPathBeanDefinitionScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(beanFactory);</span><br><span class="line">        scanner.scan(A44.class.getPackage().getName());</span><br><span class="line"></span><br><span class="line">        Arrays.stream(beanFactory.getBeanDefinitionNames()).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bean2</span><br><span class="line">bean3</span><br><span class="line">bean1</span><br><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br></pre></td></tr></table></figure><p>这没什么奇怪的，bean1、bean2 和 bean3 都被添加到 Spring 容器中。</p><p>在编译生成的 target 目录下的 classes&#x2F;META-INF&#x2F;spring.components 文件里有以下信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.a44.Bean1=org.springframework.stereotype.Component</span><br><span class="line">indi.lcp.a44.Bean2=org.springframework.stereotype.Component</span><br><span class="line">indi.lcp.a44.Bean3=org.springframework.stereotype.Component</span><br></pre></td></tr></table></figure><p>如果删除最后两条信息，再次运行 main() 方法呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bean1</span><br><span class="line">org.springframework.context.annotation.internalConfigurationAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory</span><br></pre></td></tr></table></figure><p>此时只有 bean1 被添加到 Spring 容器中，也就是说会先以 spring.components 文件中的信息为主。</p><p>那 spring.components 是怎么什么的？</p><p>它是在引入 spring-context-indexer 依赖后，在编译期根据类是否被 @Indexed 注解标记，生成 spring.components 文件及内容。</p><p>到目前为止，虽然都没显式使用 @Indexed 注解，但它包含在 @Component 注解中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Component &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结</p><p>导入 spring-context-indexer 依赖后，在编译期根据 @Indexed 生成 META-INF&#x2F;spring.components 文件。</p><p>Spring 在扫描组件时，如果发现 META-INF&#x2F;spring.components 文件存在，以它为准加载 BeanDefinition，反之遍历包含 Jar 包类路径下所有 class 信息。</p><h1 id="代理进一步理解"><a href="#代理进一步理解" class="headerlink" title="代理进一步理解"></a>代理进一步理解</h1><p>在 Spring 的代理中，依赖注入和初始化针对的是目标对象，代理对象和目标对象是两个对象，两者的成员变量不会共享。</p><p>确保项目中已导入以下依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>依赖注入和初始化针对的是目标对象</p><p>现有如下类信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Bean2 bean2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> initialized;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean2</span><span class="params">(Bean2 bean2)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;setBean2(Bean2 bean2)&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.bean2 = bean2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">        initialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Bean2 <span class="title function_">getBean2</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;getBean2()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInitialized</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;isInitialized()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> initialized;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为 Bean1 中的每个方法定制一个前置通知：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对 Bean1 中所有的方法进行匹配</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* indi.lcp.a45.Bean1.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一 SpringBoot 主启动类，它与 Bean1、Bean2 和 MyAspect 在同一包路径下，确保它们能被自动添加到 Spring 容器中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A45</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A45.class, args);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 main() 方法，控制台输出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">indi.lcp.a45.Bean1                - setBean2(Bean2 bean2) </span><br><span class="line">indi.lcp.a45.Bean1                - init </span><br></pre></td></tr></table></figure><p>Bean1 中的依赖注入和初始化被成功执行，但 并没有被增强。</p><p>由于 Bean1 被增强了，从 Spring 容器中获取的对象将是代理对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A45.class, args);</span><br><span class="line">    <span class="type">Bean1</span> <span class="variable">proxy</span> <span class="operator">=</span> context.getBean(Bean1.class);</span><br><span class="line"></span><br><span class="line">    proxy.setBean2(<span class="keyword">new</span> <span class="title class_">Bean2</span>());</span><br><span class="line">    proxy.init();</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">before</span><br><span class="line">indi.lcp.a45.Bean1                - setBean2(Bean2 bean2) </span><br><span class="line">before</span><br><span class="line">indi.lcp.a45.Bean1                - init </span><br></pre></td></tr></table></figure><p>主动调用的 setBean2() 和 init() 方法 都被增强。</p><p>代理对象与目标对象的成员变量不共享</p><p>尝试打印代理对象和目标对象的成员变量信息（直接访问，不使用方法）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A45.class, args);</span><br><span class="line">    <span class="type">Bean1</span> <span class="variable">proxy</span> <span class="operator">=</span> context.getBean(Bean1.class);</span><br><span class="line">    </span><br><span class="line">    showProxyAndTarget(proxy);</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showProxyAndTarget</span><span class="params">(Bean1 proxy)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; 代理中的成员变量&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;\tinitialized = &quot;</span> + proxy.initialized);</span><br><span class="line">    System.out.println(<span class="string">&quot;\tbean2 = &quot;</span> + proxy.bean2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (proxy <span class="keyword">instanceof</span> Advised) &#123;</span><br><span class="line">        <span class="type">Advised</span> <span class="variable">advised</span> <span class="operator">=</span> (Advised) proxy;</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; 目标中的成员变量&quot;</span>);</span><br><span class="line">        <span class="type">Bean1</span> <span class="variable">target</span> <span class="operator">=</span> (Bean1) advised.getTargetSource().getTarget();</span><br><span class="line">        System.out.println(<span class="string">&quot;\tinitialized = &quot;</span> + target.initialized);</span><br><span class="line">        System.out.println(<span class="string">&quot;\tbean2 = &quot;</span> + target.bean2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt; 代理中的成员变量</span><br><span class="line">        initialized = <span class="type">false</span></span><br><span class="line">        <span class="variable">bean2</span> <span class="operator">=</span> <span class="literal">null</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt; 目标中的成员变量</span><br><span class="line">        initialized = <span class="type">true</span></span><br><span class="line">        <span class="variable">bean2</span> <span class="operator">=</span> indi.lcp.a45.Bean2@771db12c</span><br></pre></td></tr></table></figure><p>由于依赖注入和初始化只针对目标对象，因此代理对象中的成员变量的值都是初始值。</p><p>在实际应用过程中，不会直接去访问成员变量，而是通过方法去访问：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(A45.class, args);</span><br><span class="line">    <span class="type">Bean1</span> <span class="variable">proxy</span> <span class="operator">=</span> context.getBean(Bean1.class);</span><br><span class="line"></span><br><span class="line">    showProxyAndTarget(proxy);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    System.out.println(proxy.getBean2());</span><br><span class="line">    System.out.println(proxy.isInitialized());</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">before</span><br><span class="line">indi.lcp.a45.Bean1                - getBean2() </span><br><span class="line">indi.lcp.a45.Bean2@771db12c</span><br><span class="line">before</span><br><span class="line">indi.lcp.a45.Bean1                - isInitialized() </span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>通过方法访问代理对象的成员变量时，这些方法会被增强，同时代理对象中的方法又会去调用目标对象的方法，从而读取出正确的值。</p><p>只会对能被重写的方法进行增强</p><p>在 Bean1 中增加几个方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1() 成员方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m2() final 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m3() static 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m4</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m4() private 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// static、final、private 修饰的方法不会被增强</span></span><br><span class="line">    proxy.m1();</span><br><span class="line">    proxy.m2();</span><br><span class="line">    Bean1.m3();</span><br><span class="line">    <span class="type">Method</span> <span class="variable">m4</span> <span class="operator">=</span> Bean1.class.getDeclaredMethod(<span class="string">&quot;m4&quot;</span>);</span><br><span class="line">    m4.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    m4.invoke(proxy);</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br><span class="line">before</span><br><span class="line"><span class="title function_">m1</span><span class="params">()</span> 成员方法</span><br><span class="line">m2() <span class="keyword">final</span> 方法</span><br><span class="line">m3() <span class="keyword">static</span> 方法</span><br><span class="line">m4() <span class="keyword">private</span> 方法</span><br></pre></td></tr></table></figure><p>能被重写的成员方法成功被增强，但被 final 修饰的、被 static 修饰的方法和私有方法由于无法被重写，因此它们不能被增强。如果想增强这些方法，可以使用 AspectJ 编译器增强或者 Agent 类加载。</p><h1 id="Value-注入底层"><a href="#Value-注入底层" class="headerlink" title="@Value 注入底层"></a>@Value 注入底层</h1><p>现有一 Bean1 类如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;JAVA_HOME&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String home;</span><br><span class="line">    <span class="meta">@Value(&quot;18&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要解析 @Value(“${JAVA_HOME}”) 和 @Value(“18”) 的值，其中 JAVA_HOME 以系统环境变量填充，18 为整型。</p><p>解析分为两步：</p><ol><li>获取 @Value 注解中 value 属性值；</li><li>解析属性值</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A46</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A46.class);</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getDefaultListableBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="type">ContextAnnotationAutowireCandidateResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>();</span><br><span class="line">        resolver.setBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        test1(context, resolver);</span><br><span class="line">        test2(context, resolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(AnnotationConfigApplicationContext context,</span></span><br><span class="line"><span class="params">                              ContextAnnotationAutowireCandidateResolver resolver)</span> &#123;</span><br><span class="line">        <span class="type">DependencyDescriptor</span> <span class="variable">dd1</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;home&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 获取 @Value 的内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> resolver.getSuggestedValue(dd1).toString();</span><br><span class="line">        System.out.println(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析 $&#123;&#125;</span></span><br><span class="line">        value = context.getEnvironment().resolvePlaceholders(value);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$&#123;JAVA_HOME&#125;</span><br><span class="line">D:\environment\JDK1<span class="number">.8</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">(AnnotationConfigApplicationContext context,</span></span><br><span class="line"><span class="params">                          ContextAnnotationAutowireCandidateResolver resolver)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd1</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;age&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 获取 @Value 的内容</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> resolver.getSuggestedValue(dd1).toString();</span><br><span class="line">    System.out.println(<span class="string">&quot;@Value 的 value 属性值: &quot;</span> + value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 $&#123;&#125;</span></span><br><span class="line">    value = context.getEnvironment().resolvePlaceholders(value);</span><br><span class="line">    System.out.println(<span class="string">&quot;解析得到的值: &quot;</span> + value);</span><br><span class="line">    System.out.println(<span class="string">&quot;解析得到的值的类型: &quot;</span> + value.getClass());</span><br><span class="line">    <span class="comment">// 转成字段的类型</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">age</span> <span class="operator">=</span> context.getBeanFactory()</span><br><span class="line">        .getTypeConverter()</span><br><span class="line">        .convertIfNecessary(value, dd1.getDependencyType());</span><br><span class="line">    System.out.println(<span class="string">&quot;转换后的类型: &quot;</span> + age.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Value</span> 的 value 属性值: <span class="number">18</span></span><br><span class="line">解析得到的值: <span class="number">18</span></span><br><span class="line">解析得到的值的类型: <span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">转换后的类型: <span class="keyword">class</span> <span class="title class_">java</span>.lang.Integer</span><br></pre></td></tr></table></figure><p>EL 表达式的解析</p><p>假设有如下几个类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;@bean3&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Bean3 bean3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;bean3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bean3</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean4</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;&#x27;hello, &#x27; + &#x27;$&#123;JAVA_HOME&#125;&#x27;&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样要求解析 @Value 中的 value 属性值。</p><p>如果沿用 test2() 方法进行解析，控制台打印出：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value</span> 的 value 属性值: #&#123;<span class="meta">@bean3</span>&#125;</span><br><span class="line">解析得到的值: #&#123;<span class="meta">@bean3</span>&#125;</span><br><span class="line">解析得到的值的类型: <span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> org.springframework.beans.ConversionNotSupportedException: Failed to convert value of type <span class="string">&#x27;java.lang.String&#x27;</span> to required type <span class="string">&#x27;indi.lcp.a46.A46$Bean3&#x27;</span>; nested exception is java.lang.IllegalStateException: Cannot convert value of type <span class="string">&#x27;java.lang.String&#x27;</span> to required type <span class="string">&#x27;indi.lcp.a46.A46$Bean3&#x27;</span>: no matching editors or conversion strategy found</span><br></pre></td></tr></table></figure><p>最后一步数据转换出了问题，无法将 String 转换成 A46$Bean3 类型，也就是说解析 @bean3 失败了，程序仍然把它当成字符串，而不是注入的 Bean。</p><p>为了解析成功，需要在转换前解析 #{}：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    test3(context, resolver, Bean2.class.getDeclaredField(<span class="string">&quot;bean3&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    test3(context, resolver, Bean4.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">(AnnotationConfigApplicationContext context,</span></span><br><span class="line"><span class="params">                          ContextAnnotationAutowireCandidateResolver resolver,</span></span><br><span class="line"><span class="params">                          Field field)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(field, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 获取 @Value 的内容</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> resolver.getSuggestedValue(dd1).toString();</span><br><span class="line">    System.out.println(<span class="string">&quot;@Value 的 value 属性值: &quot;</span> + value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 $&#123;&#125;</span></span><br><span class="line">    value = context.getEnvironment().resolvePlaceholders(value);</span><br><span class="line">    System.out.println(<span class="string">&quot;解析得到的值: &quot;</span> + value);</span><br><span class="line">    System.out.println(<span class="string">&quot;解析得到的值的类型: &quot;</span> + value.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 #&#123;&#125;</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean3</span> <span class="operator">=</span> context.getBeanFactory()</span><br><span class="line">        .getBeanExpressionResolver()</span><br><span class="line">        .evaluate(value, <span class="keyword">new</span> <span class="title class_">BeanExpressionContext</span>(context.getBeanFactory(), <span class="literal">null</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型转换</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> context.getBeanFactory()</span><br><span class="line">        .getTypeConverter()</span><br><span class="line">        .convertIfNecessary(bean3, dd1.getDependencyType());</span><br><span class="line">    System.out.println(<span class="string">&quot;转换后的类型: &quot;</span> + result.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Value</span> 的 value 属性值: #&#123;<span class="meta">@bean3</span>&#125;</span><br><span class="line">解析得到的值: #&#123;<span class="meta">@bean3</span>&#125;</span><br><span class="line">解析得到的值的类型: <span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">转换后的类型: <span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a46.A46$Bean3</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"><span class="meta">@Value</span> 的 value 属性值: #&#123;<span class="string">&#x27;hello, &#x27;</span> + <span class="string">&#x27;$&#123;JAVA_HOME&#125;&#x27;</span>&#125;</span><br><span class="line">解析得到的值: #&#123;<span class="string">&#x27;hello, &#x27;</span> + <span class="string">&#x27;D:\environment\JDK1.8&#x27;</span>&#125;</span><br><span class="line">解析得到的值的类型: <span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br><span class="line">转换后的类型: <span class="keyword">class</span> <span class="title class_">java</span>.lang.String</span><br></pre></td></tr></table></figure><h1 id="Autowired-注入底层"><a href="#Autowired-注入底层" class="headerlink" title="@Autowired 注入底层"></a>@Autowired 注入底层</h1><h2 id="47-1-注入方式"><a href="#47-1-注入方式" class="headerlink" title="47.1 注入方式"></a>47.1 注入方式</h2><p>按成员变量类型注入</p><p>现有一 Bean1 类如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要被注入的对象所在类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;bean2&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从容器中获取需要被注入的 Bean 对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A47_1</span>&#123;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A47_1.class);</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getDefaultListableBeanFactory();</span><br><span class="line">        </span><br><span class="line">        <span class="type">DependencyDescriptor</span> <span class="variable">dd1</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;bean2&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">        System.out.println(beanFactory.doResolveDependency(dd1, <span class="string">&quot;bean1&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.a47.A47_1$Bean2@222545dc</span><br></pre></td></tr></table></figure><p>按参数类型注入</p><p>对 Bean1 进行修改：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBean2</span><span class="params">(Bean2 bean2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bean2 = bean2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 setBean2() 方法的 Bean2 类型参数进行注入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">setBean2</span> <span class="operator">=</span> Bean1.class.getDeclaredMethod(<span class="string">&quot;setBean2&quot;</span>, Bean2.class);</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd2</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(<span class="keyword">new</span> <span class="title class_">MethodParameter</span>(setBean2, <span class="number">0</span>), <span class="literal">false</span>);</span><br><span class="line">    System.out.println(beanFactory.doResolveDependency(dd2, <span class="string">&quot;bean1&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.a47.A47_1$Bean2@222545dc</span><br></pre></td></tr></table></figure><p>包装为 Optional<bean2></bean2></p><p>对 Bean1 进行修改：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Optional&lt;Bean2&gt; bean3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接按照以下方式获取 DependencyDescriptor 对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DependencyDescriptor</span> <span class="variable">dd3</span> <span class="operator">=</span> </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;bean3&quot;</span>), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>其 dd3.getDependencyType() 方法将返回 Optional 的 Class 对象，这显然是不对的。</p><p>Spring 提供为 DependencyDescriptor 提供了解决这个问题的方法，即“增加嵌套等级”来获取内嵌类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dd3.increaseNestingLevel();</span><br></pre></td></tr></table></figure><p>执行 increaseNestingLevel() 方法后，dd3.getDependencyType() 方法返回的 Bean2 的 Class 对象。</p><p>因此注入 Optional<bean2>类型的成员变量应该按照：</bean2></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd3</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;bean3&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (Optional.class.equals(dd3.getDependencyType())) &#123;</span><br><span class="line">        dd3.increaseNestingLevel();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> beanFactory.doResolveDependency(dd3, <span class="string">&quot;bean1&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(Optional.ofNullable(result));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Optional[indi.lcp.a47.A47_1$Bean2@222545dc]</span><br></pre></td></tr></table></figure><p>注入 Optional 对象和使用 @Autowired(required &#x3D; false) 的作用是一样的，当容器中不存在目标 Bean 时，不会抛出 NoSuchBeanDefinitionException 异常。</p><p>包装为 ObjectFactory<bean2></bean2></p><p>对 Bean1 进行修改：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectFactory&lt;Bean2&gt; bean4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入 ObjectFactory<bean2>类型的对象与注入 Optional<bean2>类型的对象类似，只不过 ObjectFactory 提供了 延迟注入 的能力，也就是说 Bean2 对象不会立即被注入，而是在需要时才被注入。</bean2></bean2></p><p>ObjectFactory 是一个函数式接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ObjectFactory</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入的应该是 ObjectFactory 对象，在调用该对象的 getObject() 方法时，Bean2 对象才被注入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd4</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;bean4&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (ObjectFactory.class.equals(dd4.getDependencyType())) &#123;</span><br><span class="line">        dd4.increaseNestingLevel();</span><br><span class="line">        ObjectFactory&lt;Bean2&gt; objectFactory = () -&gt;</span><br><span class="line">            (Bean2) beanFactory.doResolveDependency(dd4, <span class="string">&quot;bean1&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(objectFactory.getObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.a47.A47_1$Bean2@222545dc</span><br></pre></td></tr></table></figure><p>与 ObjectFactory 类似的还有个名为 ObjectProvider 的接口，后者继承了前者。</p><p>与 ObjectFactory 相比，ObjectProvider 提供了类似于 Optional 的安全注入功能，当容器中不存在目标 Bean 时， 不会抛出 NoSuchBeanDefinitionException 异常。ObjectProvider 提供的 getIfAvailable() 在获取不存在的 Bean 时，不会抛出异常，而是返回 null。</p><p>对 @Lazy 的处理</p><p>对 Bean1 进行修改，在成员变量 bean2 上使用 @Lazy 注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Lazy</span></span><br><span class="line">    <span class="keyword">private</span> Bean2 bean2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 @Lazy 注解标记的成员变量，注入的对象不再是目标对象，而是其代理对象，因此不能使用 DefaultListableBeanFactory 对象的 doResolveDependency() 方法来获取注入的对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd5</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;bean2&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="type">ContextAnnotationAutowireCandidateResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>();</span><br><span class="line">    resolver.setBeanFactory(beanFactory);</span><br><span class="line">    <span class="comment">// 根据 @Lazy 创建代理对象</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> resolver.getLazyResolutionProxyIfNecessary(dd5, <span class="string">&quot;bean1&quot;</span>);</span><br><span class="line">    System.out.println(proxy);</span><br><span class="line">    System.out.println(proxy.getClass());</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.a47.A47_1$Bean2@222545dc</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">indi</span>.lcp.a47.A47_1$Bean2$$EnhancerBySpringCGLIB$$d631a20c</span><br></pre></td></tr></table></figure><p>@Lazy 实现的 延迟注入 （前面讲的 ObjectFactory 和 ObjectProvider 也有延迟注入功能，但与 @Lazy 的实现不一样）不是不注入，而是注入目标对象的代理对象，当使用到代理对象中的方法时，代理对象就会去 Spring 容器中寻找真正的目标对象，然后调用目标对象对应的方法。</p><p>@Lazy 的实现细节可以在 ContextAnnotationAutowireCandidateResolver 中看到：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span> </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">QualifierAnnotationAutowireCandidateResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getLazyResolutionProxyIfNecessary</span><span class="params">(DependencyDescriptor descriptor, </span></span><br><span class="line"><span class="params">                                                    <span class="meta">@Nullable</span> String beanName)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果有 @Lazy 注解，就创建代理对象</span></span><br><span class="line">        <span class="keyword">return</span> (isLazy(descriptor) ? </span><br><span class="line">                buildLazyResolutionProxy(descriptor, beanName) : <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isLazy</span><span class="params">(DependencyDescriptor descriptor)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Annotation ann : descriptor.getAnnotations()) &#123;</span><br><span class="line">            <span class="comment">// 获取 @Lazy 注解信息</span></span><br><span class="line">            <span class="type">Lazy</span> <span class="variable">lazy</span> <span class="operator">=</span> AnnotationUtils.getAnnotation(ann, Lazy.class);</span><br><span class="line">            <span class="keyword">if</span> (lazy != <span class="literal">null</span> &amp;&amp; lazy.value()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">MethodParameter</span> <span class="variable">methodParam</span> <span class="operator">=</span> descriptor.getMethodParameter();</span><br><span class="line">        <span class="keyword">if</span> (methodParam != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// --snip--</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">buildLazyResolutionProxy</span><span class="params">(<span class="keyword">final</span> DependencyDescriptor descriptor, </span></span><br><span class="line"><span class="params">                                              <span class="keyword">final</span> <span class="meta">@Nullable</span> String beanName)</span> &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">        <span class="comment">// 获取代理对象</span></span><br><span class="line">        <span class="keyword">return</span> pf.getProxy(dlbf.getBeanClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充：包装为 Provider<bean2></bean2></p><p>Provider 接口是由 JSR-330 提出，要想使用此接口，需要导入以下依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.inject&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;</span><br><span class="line">    &lt;!--  不要惊讶，版本号就是 <span class="number">1</span>  --&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>对 Bean1 进行修改：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean1</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Provider&lt;Bean2&gt; bean5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入 Provider 类型的对象与注入 ObjectFactory<bean2>类型的对象极其相似，Provider 也提供了 延迟注入 的能力，注入的是 Provider 对象，在调用该对象的 get() 方法时，Bean2 对象才被注入：</bean2></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Bean1.class.getDeclaredField(<span class="string">&quot;bean5&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (Provider.class.equals(dd6.getDependencyType())) &#123;</span><br><span class="line">        dd6.increaseNestingLevel();</span><br><span class="line">        Provider&lt;Bean2&gt; provider = () -&gt;</span><br><span class="line">            (Bean2)  beanFactory.doResolveDependency(dd6, <span class="string">&quot;bean1&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(provider.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">indi.lcp.a47.A47_1$Bean2@222545dc</span><br></pre></td></tr></table></figure><p>Optional 类型、ObjectFactory 类型、ObjectProvider 类型、JSR-330 提供的类型的注入逻辑可在 DefaultListableBeanFactory#resolveDependency() 方法中看到：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">resolveDependency</span><span class="params">(DependencyDescriptor descriptor,</span></span><br><span class="line"><span class="params">                                <span class="meta">@Nullable</span> String requestingBeanName,</span></span><br><span class="line"><span class="params">                                <span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames,</span></span><br><span class="line"><span class="params">                                <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">    descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());</span><br><span class="line">    <span class="keyword">if</span> (Optional.class == descriptor.getDependencyType()) &#123;</span><br><span class="line">        <span class="comment">// 对 Optional 的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ObjectFactory.class == descriptor.getDependencyType() ||</span><br><span class="line">            ObjectProvider.class == descriptor.getDependencyType()) &#123;</span><br><span class="line">        <span class="comment">// 对 ObjectFactory、ObjectProvider 的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;</span><br><span class="line">        <span class="comment">// 对 JSR-330 提供的类型的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="47-2-类型匹配细节"><a href="#47-2-类型匹配细节" class="headerlink" title="47.2 类型匹配细节"></a>47.2 类型匹配细节</h2><p>无论是 @Value 注入，还是 @Autowired 注入，最终都会调用 DefaultListableBeanFactory#doResolveDependency() 方法。</p><p>现有如下几个类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Dao</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;dao1&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Dao1</span> <span class="keyword">implements</span> <span class="title class_">Dao</span>&lt;Student&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;dao2&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Dao2</span> <span class="keyword">implements</span> <span class="title class_">Dao</span>&lt;Teacher&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;service1&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service1</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;service2&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service2</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;service3&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service3</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一目标类 Target，对其进行依赖注入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Service[] serviceArray;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Service&gt; serviceList;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ConfigurableApplicationContext applicationContext;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Dao&lt;Teacher&gt; dao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;service2&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组类型</p><p>Spring 容器中肯定不存在数组类型且元素类型为 Service 的 Bean 对象，因此注入的 Service 数组应当是容器中 Service 类型的 Bean 数组：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A47_2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(A47_2.class);</span><br><span class="line">        <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> context.getDefaultListableBeanFactory();</span><br><span class="line"></span><br><span class="line">        testArray(beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testArray</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">        <span class="type">DependencyDescriptor</span> <span class="variable">dd1</span> <span class="operator">=</span> </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Target.class.getDeclaredField(<span class="string">&quot;serviceArray&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (dd1.getDependencyType().isArray()) &#123;</span><br><span class="line">            <span class="comment">// 获取数组中的元素类型</span></span><br><span class="line">            Class&lt;?&gt; componentType = dd1.getDependencyType().getComponentType();</span><br><span class="line">            System.out.println(componentType);</span><br><span class="line">            String[] names = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(</span><br><span class="line">                beanFactory, </span><br><span class="line">                componentType</span><br><span class="line">            );</span><br><span class="line">            List&lt;Object&gt; beans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> dd1.resolveCandidate(name, componentType, beanFactory);</span><br><span class="line">                beans.add(bean);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">array</span> <span class="operator">=</span> beanFactory.getTypeConverter()</span><br><span class="line">                .convertIfNecessary(beans, dd1.getDependencyType());</span><br><span class="line">            System.out.println(array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">indi</span>.lcp.a47.A47_2$Service</span><br><span class="line">service3</span><br><span class="line">service2</span><br><span class="line">service1</span><br><span class="line">[Lindi.lcp.a47.A47_2$Service;@<span class="number">49139829</span></span><br></pre></td></tr></table></figure><p>相关源码可在 DefaultListableBeanFactory#resolveMultipleBeans() 方法中看到。</p><p>List 类型</p><p>注入 List<service>类型数据的逻辑与注入 Service[] 类型数据的逻辑类似，只不过在容器中寻找目标 Bean 时不再通过数组元素类型，而是通过 List 的泛型类型：</service></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd2</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Target.class.getDeclaredField(<span class="string">&quot;serviceList&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (List.class.equals(dd2.getDependencyType())) &#123;</span><br><span class="line">        <span class="comment">// 获取泛型信息</span></span><br><span class="line">        Class&lt;?&gt; resolve = dd2.getResolvableType().getGeneric().resolve();</span><br><span class="line">        System.out.println(resolve);</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        String[] names = </span><br><span class="line">            BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, resolve);</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> dd2.resolveCandidate(name, resolve, beanFactory);</span><br><span class="line">            list.add(bean);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">indi</span>.lcp.a47.A47_2$Service</span><br><span class="line">[indi.lcp.a47.A47_2$Service3@35e2d654, indi.lcp.a47.A47_2$Service2@1bd4fdd, indi.lcp.a47.A47_2$Service1@55183b20]</span><br></pre></td></tr></table></figure><p>注意： 对于注入的集合类型数据，注入的类型必须是 Collection 及其 子接口，比如不支持直接注入 ArrayList 类型的数据。</p><p>相关源码可在 DefaultListableBeanFactory#resolveMultipleBeans() 方法中看到：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">resolveMultipleBeans</span><span class="params">(DependencyDescriptor descriptor, </span></span><br><span class="line"><span class="params">                                    <span class="meta">@Nullable</span> String beanName,</span></span><br><span class="line"><span class="params">                                    <span class="meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, </span></span><br><span class="line"><span class="params">                                    <span class="meta">@Nullable</span> TypeConverter typeConverter)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line">    <span class="keyword">if</span> (descriptor <span class="keyword">instanceof</span> StreamDependencyDescriptor) &#123;</span><br><span class="line">                <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (type.isArray()) &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Collection.class.isAssignableFrom(type) &amp;&amp; type.isInterface()) &#123;</span><br><span class="line">        <span class="comment">// 就是这里的判断</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Map.class == type) &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看到，@Autowired 还支持 Map 类型数据的注入，此时注入的 Map 的 key 是 Bean 的名称，value 是 Bean 对象，这种方式常常配合策略模式使用。需要注意的是，只支持注入 Map 接口，不支持其子类。</p><p>特殊类型 ConfigurableApplicationContext</p><p>ConfigurableApplicationContext 是 ApplicationContext 接口的子接口。</p><p>需要注意的是，在 Spring 容器中并不存在 ConfigurableApplicationContext 类型、或 ApplicationContext 类型的 Bean。</p><p>Spring 容器中的所有单例 Bean 对象存放在 DefaultListableBeanFactory 中，在 DefaultListableBeanFactory 父类 DefaultSingletonBeanRegistry 中有一成员变量：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title class_">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title class_">SingletonBeanRegistry</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>singletonObjects 用于存放 Spring 容器中的所有单例 Bean 对象。</p><p>类似 ApplicationContext、BeanFactory 类型的对象则是放在 DefaultListableBeanFactory 中的 resolvableDependencies 中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultListableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractAutowireCapableBeanFactory</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ConfigurableListableBeanFactory</span>, BeanDefinitionRegistry, Serializable &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; resolvableDependencies = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些特殊对象是在调用 ApplicationContext 的 refresh() 方法时添加到 resolvableDependencies 中的。可在 AbstractApplicationContext 的 refresh() 方法中看到：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span></span><br><span class="line">    <span class="comment">// MessageSource registered (and found for autowiring) as a bean.</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="built_in">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="built_in">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此在注入诸如 ConfigurableApplicationContext 特殊类型的对象时，不能直接使用 getBean() 方法获取，而是应该从 resolvableDependencies 集合中获取。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testApplicationContext</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(</span><br><span class="line">        Target.class.getDeclaredField(<span class="string">&quot;applicationContext&quot;</span>), </span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    );</span><br><span class="line">    <span class="type">Field</span> <span class="variable">resolvableDependencies</span> <span class="operator">=</span> </span><br><span class="line">        DefaultListableBeanFactory.class.getDeclaredField(<span class="string">&quot;resolvableDependencies&quot;</span>);</span><br><span class="line">    resolvableDependencies.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Object&gt; dependencies = </span><br><span class="line">        (Map&lt;Class&lt;?&gt;, Object&gt;) resolvableDependencies.get(beanFactory);</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : dependencies.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 左边类型                      右边类型</span></span><br><span class="line">        <span class="keyword">if</span> (entry.getKey().isAssignableFrom(dd3.getDependencyType())) &#123;</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">org.springframework.beans.factory.support.DefaultListableBeanFactory@<span class="number">7364985f</span>: defining beans</span><br><span class="line"> [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,</span><br><span class="line">org.springframework.context.annotation.internalAutowiredAnnotationProcessor,</span><br><span class="line">org.springframework.context.annotation.internalCommonAnnotationProcessor,</span><br><span class="line">org.springframework.context.event.internalEventListenerProcessor,</span><br><span class="line">org.springframework.context.event.internalEventListenerFactory,</span><br><span class="line">a47_2,service3,service2,service1,dao2,dao1]; root of factory hierarchy</span><br></pre></td></tr></table></figure><p>泛型类型</p><p>容器中 Dao 类型的 Bean 有多个，而依赖注入的是 Dao<teacher>类型的对象，因此需要判断容器中的 Bean 对象泛型类型是否为指定类型。判断逻辑可以使用 ContextAnnotationAutowireCandidateResolver 的 isAutowireCandidate() 方法：</teacher></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testGeneric</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd4</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Target.class.getDeclaredField(<span class="string">&quot;dao&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">    Class&lt;?&gt; type = dd4.getDependencyType();</span><br><span class="line">    <span class="type">ContextAnnotationAutowireCandidateResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>();</span><br><span class="line">    resolver.setBeanFactory(beanFactory);</span><br><span class="line">    <span class="comment">// 循环所有的目标类型 Bean 名称</span></span><br><span class="line">    <span class="keyword">for</span> (String name : BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, type)) &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> beanFactory.getMergedBeanDefinition(name);</span><br><span class="line">        <span class="comment">// 对比 BeanDefinition 的泛型与 DependencyDescriptor 的泛型是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (resolver.isAutowireCandidate(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(bd, name), dd4)) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(dd4.resolveCandidate(name, type, beanFactory));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dao2</span><br><span class="line">indi.lcp.a47.A47_2$Dao2@74f0ea28</span><br></pre></td></tr></table></figure><p>@Qualifier</p><p>当容器中存在多个相同类型的 Bean 对象，在执行依赖注入时可以使用 @Qualifier 注解来指定需要注入的 Bean 对象的名称。判断逻辑同样使用 ContextAnnotationAutowireCandidateResolver 的 isAutowireCandidate() 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testQualifier</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd5</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Target.class.getDeclaredField(<span class="string">&quot;service&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">    Class&lt;?&gt; type = dd5.getDependencyType();</span><br><span class="line">    <span class="type">ContextAnnotationAutowireCandidateResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>();</span><br><span class="line">    resolver.setBeanFactory(beanFactory);</span><br><span class="line">    <span class="keyword">for</span> (String name : BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, type)) &#123;</span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> beanFactory.getMergedBeanDefinition(name);</span><br><span class="line">        <span class="comment">// DependencyDescriptor 对象中包含了 @Qualifier 注解信息</span></span><br><span class="line">        <span class="keyword">if</span> (resolver.isAutowireCandidate(<span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(bd, name), dd5)) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(dd5.resolveCandidate(name, type, beanFactory));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">service2</span><br><span class="line">indi.lcp.a47.A47_2$Service2@1bd4fdd</span><br></pre></td></tr></table></figure><p>@Primary</p><p>当容器中存在多个相同类型的 Bean 对象时，在执行依赖注入时除了可以使用 @Qualifier 注解外，还可以在被注入的 Bean 对象所在类上使用 @Primary 注解，指定执行依赖注入时使用的主要 Bean 对象。</p><p>如果 Bean 对象的所在类 被 @Primary 注解标记，那么在构造 BeanDefinition 时就会记录这个信息。</p><p>通常情况下，@Primary 注解只有一个作用在同种类型的 Bean 上，存在多个时，Spring 依旧无法区分。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target1</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;service1&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service1</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@Component(&quot;service2&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service2</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;service3&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service3</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPrimary</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Target1.class.getDeclaredField(<span class="string">&quot;service&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    Class&lt;?&gt; type = dd.getDependencyType();</span><br><span class="line">    <span class="keyword">for</span> (String name : BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, type)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory.getMergedBeanDefinition(name).isPrimary()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;primary: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">primary: service2</span><br></pre></td></tr></table></figure><p>默认规则</p><p>当容器中存在多个相同类型的 Bean 对象时，除了使用 @Qualifier 或 @Primary 注解外，@Autowired 注解还支持按照成员变量名称进行匹配。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Target2</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Service service3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;service1&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service1</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@Component(&quot;service2&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service2</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;service3&quot;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Service3</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testDefault</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="type">DependencyDescriptor</span> <span class="variable">dd</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DependencyDescriptor</span>(Target2.class.getDeclaredField(<span class="string">&quot;service3&quot;</span>), <span class="literal">false</span>);</span><br><span class="line">    Class&lt;?&gt; type = dd.getDependencyType();</span><br><span class="line">    <span class="keyword">for</span> (String name : BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, type)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(dd.getDependencyName())) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;default: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: service3</span><br></pre></td></tr></table></figure></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><div class="post_share"><div class="social-share" data-image="/img/img11.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/01/VUE3%E5%AD%A6%E4%B9%A0/" title="VUE3学习总结"><img class="cover" src="/img/img11.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">VUE3学习总结</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/01/minio%E7%9A%84%E4%BD%BF%E7%94%A8/" title="minio的使用"><img class="cover" src="/img/img06.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">minio的使用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/07/01/minio%E7%9A%84%E4%BD%BF%E7%94%A8/" title="minio的使用"><img class="cover" src="/img/img06.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-02</div><div class="title">minio的使用</div></div></a></div><div><a href="/2024/07/01/%E6%B5%85%E8%B0%88%E5%88%A9%E7%94%A8AOP%E5%AE%9E%E7%8E%B0%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD/" title="浅谈利用AOP实现记录日志功能"><img class="cover" src="/img/img11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-02</div><div class="title">浅谈利用AOP实现记录日志功能</div></div></a></div><div><a href="/2024/07/01/%E5%9C%A8%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%BA%94%E5%AF%B9%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/" title="在日常开发遇到的不同场景下的应对思路总结"><img class="cover" src="/img/img03.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-02</div><div class="title">在日常开发遇到的不同场景下的应对思路总结</div></div></a></div><div><a href="/2024/07/01/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95-%E6%80%BB%E7%BB%93/" title="面试中的算法-总结"><img class="cover" src="/img/img03.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-02</div><div class="title">面试中的算法-总结</div></div></a></div><div><a href="/2024/07/01/%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%9B%9E%E9%A1%BE%E7%9F%A5%E8%AF%86/" title="在面试中回顾知识"><img class="cover" src="/img/img01.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-02</div><div class="title">在面试中回顾知识</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">李从浦</div><div class="author-info__description">志不强者智不达，言不信者行不果</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/licongpu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/licongpu" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="mailto:2816863923@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a><a class="social-icon" href="https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e" target="_blank" title="飞书"><i class="fa-sharp fa-solid fa-bookmark" style="color:#4a7dbe"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">一起学习,共同进步</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.</span> <span class="toc-text">容器接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-BeanFactory%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 BeanFactory介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-BeanFactory-%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 BeanFactory 作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3DefaultListableBeanFactory"><span class="toc-number">1.3.</span> <span class="toc-text">1.3DefaultListableBeanFactory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1DefaultListableBeanFactory%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.3.1DefaultListableBeanFactory简单介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.3.2源码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4ApplicationContext"><span class="toc-number">1.4.</span> <span class="toc-text">1.4ApplicationContext</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1MessageSource"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.4.1MessageSource</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2ResourcePatternResolver"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.4.2ResourcePatternResolver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3EnvironmentCapable"><span class="toc-number">1.4.3.</span> <span class="toc-text">1.4.3EnvironmentCapable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-4ApplicationEventPublisher"><span class="toc-number">1.4.4.</span> <span class="toc-text">1.4.4ApplicationEventPublisher</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">容器实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-BeanFactory-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 BeanFactory 的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-ApplicationContext-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 ApplicationContext 的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-ClassPathXmlApplicationContext"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 ClassPathXmlApplicationContext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-FileSystemXmlApplicationContext"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 FileSystemXmlApplicationContext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-AnnotationConfigApplicationContext"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3 AnnotationConfigApplicationContext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-AnnotationConfigServletWebServerApplicationContext"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.2.4 AnnotationConfigServletWebServerApplicationContext</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-BeanFactory-%E6%8E%A5%E5%8F%A3%E4%BD%93%E7%B3%BB"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 BeanFactory 接口体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E8%AF%BB%E5%8F%96-BeanDefinition"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 读取 BeanDefinition</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-ApplicationContext-%E6%8E%A5%E5%8F%A3%E4%BD%93%E7%B3%BB"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 ApplicationContext 接口体系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.</span> <span class="toc-text">Bean 的生命周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bean-%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">Bean 后置处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%B8%B8%E8%A7%81%E7%9A%84-Bean-%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 常见的 Bean 后置处理器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-AutowiredAnnotationBeanPostProcessor"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 AutowiredAnnotationBeanPostProcessor</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BeanFactory-%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">BeanFactory 后置处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%B8%B8%E8%A7%81%E7%9A%84-BeanFactory-%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 常见的 BeanFactory 后置处理器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 模拟实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E6%B3%A8%E5%86%8C%E5%88%9B%E5%BB%BA%E5%AE%8C%E6%88%90%E7%9A%84-Bean"><span class="toc-number">5.3.</span> <span class="toc-text">5.3. 注册创建完成的 Bean</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Aware-%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.</span> <span class="toc-text">Aware 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-Aware-%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.1.</span> <span class="toc-text">6.1. Aware 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-InitializingBean"><span class="toc-number">6.2.</span> <span class="toc-text">6.2. InitializingBean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E5%A4%B1%E6%95%88%E7%9A%84-Autowired-%E6%B3%A8%E8%A7%A3"><span class="toc-number">6.3.</span> <span class="toc-text">6.3. 失效的 @Autowired 注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E9%94%80%E6%AF%81"><span class="toc-number">7.</span> <span class="toc-text">初始化与销毁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Scope"><span class="toc-number">8.</span> <span class="toc-text">Scope</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-Scope-%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%8E%E9%94%80%E6%AF%81"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 Scope 的类型与销毁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-Scope-%E5%A4%B1%E6%95%88%E5%88%86%E6%9E%90"><span class="toc-number">8.2.</span> <span class="toc-text">8.2. Scope 失效分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AspectJ-%E7%BC%96%E8%AF%91%E5%99%A8%E5%A2%9E%E5%BC%BA"><span class="toc-number">9.</span> <span class="toc-text">AspectJ 编译器增强</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Agent-%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">10.</span> <span class="toc-text">Agent 类加载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">11.</span> <span class="toc-text">动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">11.1.</span> <span class="toc-text">JDK 动态代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-CGLib-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">11.2.</span> <span class="toc-text">11.2. CGLib 动态代理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86"><span class="toc-number">12.</span> <span class="toc-text">JDK 动态代理原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-JDK-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%A8%A1%E6%8B%9F"><span class="toc-number">12.1.</span> <span class="toc-text">12.1 JDK 动态代理的模拟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E6%BA%90%E7%A0%81"><span class="toc-number">12.2.</span> <span class="toc-text">12.2 代理类的源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-JDK-%E4%BB%A3%E7%90%86%E7%B1%BB%E5%AD%97%E8%8A%82%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">12.3.</span> <span class="toc-text">12.3 JDK 代理类字节码生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-4-JDK-%E5%8F%8D%E5%B0%84%E4%BC%98%E5%8C%96"><span class="toc-number">12.4.</span> <span class="toc-text">12.4 JDK 反射优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CGLib-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%8E%9F%E7%90%86"><span class="toc-number">13.</span> <span class="toc-text">CGLib 动态代理原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-CGLib-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%A8%A1%E6%8B%9F"><span class="toc-number">13.1.</span> <span class="toc-text">13.1 CGLib 动态代理的模拟</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-MethodProxy"><span class="toc-number">13.2.</span> <span class="toc-text">13.2 MethodProxy</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MethodProxy-%E5%8E%9F%E7%90%86"><span class="toc-number">14.</span> <span class="toc-text">MethodProxy 原理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JDK-%E5%92%8C-CGLib-%E7%9A%84%E7%BB%9F%E4%B8%80"><span class="toc-number">15.</span> <span class="toc-text">JDK 和 CGLib 的统一</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1-advisor"><span class="toc-number">15.1.</span> <span class="toc-text">15.1. advisor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-%E5%88%87%E9%9D%A2%E4%B8%8E%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">15.2.</span> <span class="toc-text">15.2 切面与代理对象的创建</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%87%E7%82%B9%E5%8C%B9%E9%85%8D"><span class="toc-number">16.</span> <span class="toc-text">切点匹配</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E-Aspect-%E5%88%B0-Advisor"><span class="toc-number">17.</span> <span class="toc-text">从 @Aspect 到 Advisor</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AnnotationAwareAspectJAutoProxyCreator"><span class="toc-number">17.1.</span> <span class="toc-text">AnnotationAwareAspectJAutoProxyCreator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-2-%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA"><span class="toc-number">17.2.</span> <span class="toc-text">17.2. 代理对象创建时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-3-%E9%AB%98%E7%BA%A7%E5%88%87%E9%9D%A2%E8%BD%AC%E4%BD%8E%E7%BA%A7%E5%88%87%E9%9D%A2"><span class="toc-number">17.3.</span> <span class="toc-text">17.3 高级切面转低级切面</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%80%9A%E7%9F%A5%E8%B0%83%E7%94%A8"><span class="toc-number">18.</span> <span class="toc-text">静态通知调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#18-1-%E7%BB%9F%E4%B8%80%E8%BD%AC%E6%8D%A2%E6%88%90%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5"><span class="toc-number">18.1.</span> <span class="toc-text">18.1 统一转换成环绕通知</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-2-%E8%B0%83%E7%94%A8%E9%93%BE%E6%89%A7%E8%A1%8C"><span class="toc-number">18.2.</span> <span class="toc-text">18.2 调用链执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-3-%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E8%B0%83%E7%94%A8%E9%93%BE"><span class="toc-number">18.3.</span> <span class="toc-text">18.3 模拟实现调用链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-4-%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">18.4.</span> <span class="toc-text">18.4 代理对象调用流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%80%9A%E7%9F%A5%E8%B0%83%E7%94%A8"><span class="toc-number">19.</span> <span class="toc-text">动态通知调用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RequestMappingHandlerMapping-%E4%B8%8E-RequestMappingHandlerAdapter"><span class="toc-number">20.</span> <span class="toc-text">RequestMappingHandlerMapping 与 RequestMappingHandlerAdapter</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#20-1-DispatcherServlet-%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">20.1.</span> <span class="toc-text">20.1 DispatcherServlet 的初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-2-RequestMappingHandlerMapping"><span class="toc-number">20.2.</span> <span class="toc-text">20.2 RequestMappingHandlerMapping</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-3-RequestMappingHandlerAdapter"><span class="toc-number">20.3.</span> <span class="toc-text">20.3 RequestMappingHandlerAdapter</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">21.</span> <span class="toc-text">参数解析器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-1-RequestParam"><span class="toc-number">21.1.</span> <span class="toc-text">21.1. @RequestParam</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-2-PathVariable"><span class="toc-number">21.2.</span> <span class="toc-text">21.2 @PathVariable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-3-RequestHeader"><span class="toc-number">21.3.</span> <span class="toc-text">21.3 @RequestHeader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-4-CookieValue"><span class="toc-number">21.4.</span> <span class="toc-text">21.4 @CookieValue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-5-Value"><span class="toc-number">21.5.</span> <span class="toc-text">21.5 @Value</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-6-HttpServletRequest"><span class="toc-number">21.6.</span> <span class="toc-text">21.6 HttpServletRequest</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-7-ModelAttribute"><span class="toc-number">21.7.</span> <span class="toc-text">21.7 @ModelAttribute</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-8-RequestBody"><span class="toc-number">21.8.</span> <span class="toc-text">21.8 @RequestBody</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E5%90%8D"><span class="toc-number">22.</span> <span class="toc-text">获取参数名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">23.</span> <span class="toc-text">对象绑定与类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#23-1-%E4%B8%89%E7%A7%8D%E8%BD%AC%E6%8D%A2%E6%8E%A5%E5%8F%A3"><span class="toc-number">23.1.</span> <span class="toc-text">23.1 三种转换接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-2-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">23.2.</span> <span class="toc-text">23.2 使用示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-3-%E7%BB%91%E5%AE%9A%E5%99%A8%E5%B7%A5%E5%8E%82"><span class="toc-number">23.3.</span> <span class="toc-text">23.3 绑定器工厂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-4-Spring-%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7"><span class="toc-number">23.4.</span> <span class="toc-text">23.4 Spring 的泛型操作技巧</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ControllerAdvice-%E4%B9%8B-InitBinder"><span class="toc-number">24.</span> <span class="toc-text">ControllerAdvice 之 @InitBinder</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">25.</span> <span class="toc-text">控制器方法执行流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ControllerAdvice-%E4%B9%8B-ModelAttribute"><span class="toc-number">26.</span> <span class="toc-text">ControllerAdvice 之 @ModelAttribute</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">27.</span> <span class="toc-text">返回值处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#27-1-ModelAndView"><span class="toc-number">27.1.</span> <span class="toc-text">27.1 ModelAndView</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="toc-number">27.2.</span> <span class="toc-text">27.2 字符串类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-3-ModelAttribute"><span class="toc-number">27.3.</span> <span class="toc-text">27.3 @ModelAttribute</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-4-HttpEntity"><span class="toc-number">27.4.</span> <span class="toc-text">27.4 HttpEntity</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-5-HttpHeaders"><span class="toc-number">27.5.</span> <span class="toc-text">27.5 HttpHeaders</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-6-ResponseBody"><span class="toc-number">27.6.</span> <span class="toc-text">27.6 @ResponseBody</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="toc-number">28.</span> <span class="toc-text">消息转换器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ControllerAdvice-%E4%B9%8B-ResponseBodyAdvice"><span class="toc-number">29.</span> <span class="toc-text">ControllerAdvice 之 ResponseBodyAdvice</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">30.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ControllerAdvice-%E4%B9%8B-ExceptionHandler"><span class="toc-number">31.</span> <span class="toc-text">ControllerAdvice 之 @ExceptionHandler</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Tomcat-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">32.</span> <span class="toc-text">Tomcat 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#32-1-Tomcat-%E7%9A%84%E9%94%99%E8%AF%AF%E9%A1%B5%E5%A4%84%E7%90%86"><span class="toc-number">32.1.</span> <span class="toc-text">32.1 Tomcat 的错误页处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-2-BasicErrorController"><span class="toc-number">32.2.</span> <span class="toc-text">32.2 BasicErrorController</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BeanNameUrlHandlerMapping-%E4%B8%8E-SimpleControllerHandlerAdapter"><span class="toc-number">33.</span> <span class="toc-text">BeanNameUrlHandlerMapping 与 SimpleControllerHandlerAdapter</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#33-1-%E5%8A%9F%E8%83%BD%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">33.1.</span> <span class="toc-text">33.1 功能与使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0"><span class="toc-number">33.2.</span> <span class="toc-text">33.2 自定义实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RouterFunctionMapping-%E4%B8%8E-HandlerFunctionAdapter"><span class="toc-number">34.</span> <span class="toc-text">RouterFunctionMapping 与 HandlerFunctionAdapter</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SimpleUrlHandlerMapping-%E4%B8%8EHttpRequestHandlerAdapter"><span class="toc-number">35.</span> <span class="toc-text">SimpleUrlHandlerMapping 与HttpRequestHandlerAdapter</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#35-1-%E5%8A%9F%E8%83%BD%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">35.1.</span> <span class="toc-text">35.1 功能与使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-2-%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">35.2.</span> <span class="toc-text">35.2 资源解析器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-3-%E6%AC%A2%E8%BF%8E%E9%A1%B5%E5%A4%84%E7%90%86"><span class="toc-number">35.3.</span> <span class="toc-text">35.3 欢迎页处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-4-%E6%98%A0%E5%B0%84%E5%99%A8%E4%B8%8E%E9%80%82%E9%85%8D%E5%99%A8%E6%80%BB%E7%BB%93"><span class="toc-number">35.4.</span> <span class="toc-text">35.4 映射器与适配器总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MVC-%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">36.</span> <span class="toc-text">MVC 处理流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Boot-%E9%AA%A8%E6%9E%B6%E9%A1%B9%E7%9B%AE"><span class="toc-number">37.</span> <span class="toc-text">Boot 骨架项目</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Boot-War-%E9%A1%B9%E7%9B%AE"><span class="toc-number">38.</span> <span class="toc-text">Boot War 项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#38-1-%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">38.1.</span> <span class="toc-text">38.1 项目的构建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-2-%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="toc-number">38.2.</span> <span class="toc-text">38.2 项目的测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Boot-%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">39.</span> <span class="toc-text">Boot 启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#39-1-SpringApplication-%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">39.1.</span> <span class="toc-text">39.1 SpringApplication 的构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-2-SpringApplication-run-%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">39.2.</span> <span class="toc-text">39.2 SpringApplication#run() 的分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Tomcat-%E5%86%85%E5%B5%8C%E5%AE%B9%E5%99%A8"><span class="toc-number">40.</span> <span class="toc-text">Tomcat 内嵌容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#40-1-%E5%86%85%E5%B5%8C-Tomcat-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">40.1.</span> <span class="toc-text">40.1 内嵌 Tomcat 的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-2-%E4%B8%8E-Spring-%E6%95%B4%E5%90%88"><span class="toc-number">40.2.</span> <span class="toc-text">40.2 与 Spring 整合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">41.</span> <span class="toc-text">自动配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-1-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%8E%9F%E7%90%86"><span class="toc-number">41.1.</span> <span class="toc-text">41.1 自动配置类原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-2-Aop-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">41.2.</span> <span class="toc-text">41.2 Aop 自动配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-3-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">41.3.</span> <span class="toc-text">41.3 数据库相关的自动配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-4-MVC-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">41.4.</span> <span class="toc-text">41.4 MVC 自动配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-5-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-number">41.5.</span> <span class="toc-text">41.5 自定义自动配置类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%A3%85%E9%85%8D%E5%BA%95%E5%B1%82"><span class="toc-number">42.</span> <span class="toc-text">条件装配底层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#42-1-Conditional"><span class="toc-number">42.1.</span> <span class="toc-text">42.1 @Conditional</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-2-ConditionalOnXxx"><span class="toc-number">42.2.</span> <span class="toc-text">42.2 @ConditionalOnXxx</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FactoryBean"><span class="toc-number">43.</span> <span class="toc-text">FactoryBean</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Indexed"><span class="toc-number">44.</span> <span class="toc-text">@Indexed</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3"><span class="toc-number">45.</span> <span class="toc-text">代理进一步理解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Value-%E6%B3%A8%E5%85%A5%E5%BA%95%E5%B1%82"><span class="toc-number">46.</span> <span class="toc-text">@Value 注入底层</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Autowired-%E6%B3%A8%E5%85%A5%E5%BA%95%E5%B1%82"><span class="toc-number">47.</span> <span class="toc-text">@Autowired 注入底层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#47-1-%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">47.1.</span> <span class="toc-text">47.1 注入方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-2-%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D%E7%BB%86%E8%8A%82"><span class="toc-number">47.2.</span> <span class="toc-text">47.2 类型匹配细节</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/07/01/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1/" title="网络规划与设计"><img src="/img/img10.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="网络规划与设计"></a><div class="content"><a class="title" href="/2024/07/01/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1/" title="网络规划与设计">网络规划与设计</a><time datetime="2024-07-01T07:57:05.362Z" title="发表于 2024-07-01 15:57:05">2024-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/01/%E5%8C%BB%E5%AD%A6%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/" title="医学数据分析与挖掘"><img src="/img/img11.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="医学数据分析与挖掘"></a><div class="content"><a class="title" href="/2024/07/01/%E5%8C%BB%E5%AD%A6%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/" title="医学数据分析与挖掘">医学数据分析与挖掘</a><time datetime="2024-07-01T07:54:38.223Z" title="发表于 2024-07-01 15:54:38">2024-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/01/%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%9B%9E%E9%A1%BE%E7%9F%A5%E8%AF%86/" title="在面试中回顾知识"><img src="/img/img01.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="在面试中回顾知识"></a><div class="content"><a class="title" href="/2024/07/01/%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%9B%9E%E9%A1%BE%E7%9F%A5%E8%AF%86/" title="在面试中回顾知识">在面试中回顾知识</a><time datetime="2024-07-01T05:45:06.774Z" title="发表于 2024-07-01 13:45:06">2024-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/01/%E5%9C%A8%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%BA%94%E5%AF%B9%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/" title="在日常开发遇到的不同场景下的应对思路总结"><img src="/img/img03.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="在日常开发遇到的不同场景下的应对思路总结"></a><div class="content"><a class="title" href="/2024/07/01/%E5%9C%A8%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%BA%94%E5%AF%B9%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/" title="在日常开发遇到的不同场景下的应对思路总结">在日常开发遇到的不同场景下的应对思路总结</a><time datetime="2024-07-01T05:39:45.572Z" title="发表于 2024-07-01 13:39:45">2024-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" title="计算机网络学习总结"><img src="/img/img05.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="计算机网络学习总结"></a><div class="content"><a class="title" href="/2024/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" title="计算机网络学习总结">计算机网络学习总结</a><time datetime="2024-07-01T05:38:15.217Z" title="发表于 2024-07-01 13:38:15">2024-07-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 李从浦</div><div class="footer_custom_text">欢迎使用我的博客,期待一同进步</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="true" data-text="懒,羊,羊,大,王,的,博,客" data-fontsize="15px" data-random="false" async></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(btf.removeGlobalFnEvent("pjax"),btf.removeGlobalFnEvent("themeChange"),document.getElementById("rightside").classList.remove("rightside-show"),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>