<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>医学数据分析与挖掘 | 青山入我怀</title><meta name="author" content="李从浦"><meta name="copyright" content="李从浦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="学习自成都中医药大学林薇老师主讲的《医学数据分析与挖掘》 这几篇老文章都是我之前用飞书云文档写的，因转换格式问题，之前已写完的文档图片太多了，不想一一转化了，大家可以访问我的飞书云文档来查看这些图片–https:&#x2F;&#x2F;miu7shl031o.feishu.cn&#x2F;drive&#x2F;folder&#x2F;WJiBfqX9klvKNEdpTHccfrEQn3e 第一章: 概论 从案例出发： 探索生存质量 《—-》中医症"><meta property="og:type" content="article"><meta property="og:title" content="医学数据分析与挖掘"><meta property="og:url" content="http://licongpu.github.io/2024/07/01/%E5%8C%BB%E5%AD%A6%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/index.html"><meta property="og:site_name" content="青山入我怀"><meta property="og:description" content="学习自成都中医药大学林薇老师主讲的《医学数据分析与挖掘》 这几篇老文章都是我之前用飞书云文档写的，因转换格式问题，之前已写完的文档图片太多了，不想一一转化了，大家可以访问我的飞书云文档来查看这些图片–https:&#x2F;&#x2F;miu7shl031o.feishu.cn&#x2F;drive&#x2F;folder&#x2F;WJiBfqX9klvKNEdpTHccfrEQn3e 第一章: 概论 从案例出发： 探索生存质量 《—-》中医症"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://licongpu.github.io/img/img09.jpg"><meta property="article:published_time" content="2024-07-01T07:54:38.223Z"><meta property="article:modified_time" content="2024-07-01T14:01:42.602Z"><meta property="article:author" content="李从浦"><meta property="article:tag" content="期末"><meta property="article:tag" content="数据分析"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://licongpu.github.io/img/img09.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://licongpu.github.io/2024/07/01/%E5%8C%BB%E5%AD%A6%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:50},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体中文",cht_to_chs:"你已切换为简体中文",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#a29bfe",bgDark:"#7f8fa6",position:"bottom-left"},infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"医学数据分析与挖掘",isPost:!0,isHome:!1,isHighlightShrink:!0,isToc:!0,postUpdate:"2024-07-01 22:01:42"}</script><script>(e=>{e.saveToLocal={set:(e,t,o)=>{if(0===o)return;const a={value:t,expiry:Date.now()+864e5*o};localStorage.setItem(e,JSON.stringify(a))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!(Date.now()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=(e,t={})=>new Promise(((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},Object.keys(t).forEach((e=>{n.setAttribute(e,t[e])})),document.head.appendChild(n)})),e.getCSS=(e,t=!1)=>new Promise(((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},document.head.appendChild(n)})),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('/img/img09.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="青山入我怀"><span class="site-name">青山入我怀</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">医学数据分析与挖掘</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-07-01T07:54:38.223Z" title="发表于 2024-07-01 15:54:38">2024-07-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9C%9F%E6%9C%AB/">期末</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9C%9F%E6%9C%AB/%E8%AF%BE%E5%86%85%E7%9F%A5%E8%AF%86/">课内知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">24.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>84分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>学习自成都中医药大学林薇老师主讲的《医学数据分析与挖掘》</p><p>这几篇老文章都是我之前用飞书云文档写的，因转换格式问题，之前已写完的文档图片太多了，不想一一转化了，大家可以访问我的飞书云文档来查看这些图片–<a target="_blank" rel="noopener" href="https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e">https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e</a></p><h1 id="第一章-概论"><a href="#第一章-概论" class="headerlink" title="第一章: 概论"></a>第一章: 概论</h1><ol><li><h2 id="从案例出发："><a href="#从案例出发：" class="headerlink" title="从案例出发："></a>从案例出发：</h2></li><li><p>探索生存质量 《—-》中医症型</p></li></ol><p>关联规则：</p><p>大量的数据中发现特征之间或数据之间的相互依赖关系</p><ol><li>人脸数据爬取与识别</li></ol><p>分类与回归：</p><p>分类是指利用已有样本，也就是训练集，来建立数学模型并进行分类</p><p>回归则是过论因变量和自变量之间的关系，也就是目标变量与预测器的关系</p><ol><li>中医体质的划分</li></ol><p>聚类：</p><p>指在预先不知道类别标签的情况下，恨据信息的相似度原则进行信息聚集的方法</p><ol><li>App推送</li></ol><p>智能推荐：</p><p>联系用户和信息，并利用信息分类用户的兴趣偏好，为用户推荐感兴趣的内容</p><ol><li>癌症预测</li></ol><p>时间序列：</p><p>强调的是进行一定时间段内的连续遥感观测，提取图像有关特征，并分析其变化过程</p><p>与发展规模</p><ol><li><h2 id="医学数据分析与挖掘的通用流程-知识发现的核心部分"><a href="#医学数据分析与挖掘的通用流程-知识发现的核心部分" class="headerlink" title="医学数据分析与挖掘的通用流程 (知识发现的核心部分)"></a>医学数据分析与挖掘的通用流程 (知识发现的核心部分)</h2></li></ol><ul><li>目标分析</li></ul><p>医学数据背景应用的需求分析</p><ul><li>数据抽取</li></ul><p>网络爬虫、历史数据、实验数据</p><p>抽取标准： 相关性 可靠性 有效性</p><p>衡量数据质量的标准： 资料完整无缺 数据准确无误</p><p>常见抽样类型：随机抽样、等距抽样、分层抽样、按起始顺序抽样、分类抽样</p><ul><li>数据探索</li></ul><p>集中趋势、离散趋势、异常值分析、缺失值分析、相关分析、周期性分析</p><ul><li>数据预处理</li></ul><p>数据清洗、数据转换、数据集成、数据约减</p><ul><li>数据建模与评价</li></ul><p>关联规则、分类和回归、聚类分折、智能推荐、时间序列</p><ul><li>模型反馈</li></ul><p>知识及确立的模型部署在应用中不断反馈和迭代</p><ol><li><h2 id="常用数据分析与挖掘的工具"><a href="#常用数据分析与挖掘的工具" class="headerlink" title="常用数据分析与挖掘的工具"></a>常用数据分析与挖掘的工具</h2></li></ol><ul><li>Python</li></ul><p>Python是一种面向对象、解释性的计算机程序设计语言，它拥有高效的数据结构</p><ul><li>R</li></ul><p>R是一种由统计计算基金会支持的用于统计计算和图形的编程语言和自由软件环境</p><ul><li>MATLAB</li></ul><p>MATLAB意为矩阵工厂（矩阵实验室），软件主要面对科学计算、可视化以及交互式程序设计的高科技计算环境</p><ul><li>SPSS</li></ul><p>SPSS采用类似EXCEL表格的方式输入与管理数据数据接口较为通用，能方便的从其他数据库中读入数据，输出结果十分美观。</p><ol><li><h2 id="第一章相关试题"><a href="#第一章相关试题" class="headerlink" title="第一章相关试题"></a>第一章相关试题</h2></li><li><p>建立一个模型，通过这个模型根据已知的变量值来预测其他某个变量值属于数据挖掘的哪一类任务？()</p></li></ol><p>A根据内容检索</p><p>B建模描述</p><p>C预测建模</p><p>D寻找模式和规则</p><ol><li>在抽样方法中,当合适的样本容量很难确定时,可以使用的抽样方法是:()</li></ol><p>A有放回的简单随机抽样</p><p>B无放回的简单随机抽样</p><p>C分层抽样</p><p>D渐进抽样</p><ol><li>舆情研判,信息科学侧重( ),社会和管理科学侧重突发群体事件管理中的群体心理行为及舆论控制研究,新闻传播学侧重对舆论的本体进行规律性的探索和研究.</li></ol><p>A舆论的本体进行规律性的探索和研究</p><p>B舆论控制研究</p><p>C互联网文本挖掘和分析技术</p><p>D用户行为分析</p><ol><li>协同过滤分析用户兴趣,在用户群中找到指定用户的相似(兴趣)用户,综合这些用户对某一信息的评价,形成系统对该指定用户对此信息的喜好程度( ),并将这些用户喜欢的项推荐给有相似兴趣的用户。</li></ol><p>A相似</p><p>B相同</p><p>C推荐</p><p>D预测</p><ol><li>大数据科学关注大数据网络发展和运营过程中( )大数据的规律及其与自然和社会活动之间的关系。</li></ol><p>A大数据网络发展和运营过程</p><p>B规划建设运营管理</p><p>C规律和验证</p><p>D发现和验证</p><ol><li>什么是KDD?()</li></ol><p>A数据挖掘与知识发现</p><p>B领域知识发现</p><p>C文档知识发现</p><p>D动态知识发现</p><ol><li>使用交互式的和可视化的技术,对数据进行探索属于数据挖掘的哪一类任务?()</li></ol><p>A探索性数据分析</p><p>B建模描述</p><p>C预测建模</p><p>D寻找模式和规则</p><ol><li>在受试人群中，根据人群的某些体征比如面色红润，口苦，疲乏，舌苔黄腻，畏寒怕冷等特征将这些人的体质分为平和体质，湿热体质，阳虚体质等等。属于数据挖掘的哪一类任务（）</li></ol><p>A分类</p><p>B回归</p><p>C关联规则</p><p>D聚类</p><ol><li>数据挖掘的挖掘方法包括:( )</li></ol><p>A聚类分析</p><p>B回归分析</p><p>C神经网络</p><p>D决策树算法</p><p>E关联规则分析</p><ol><li>抽取数据的标准有( )</li></ol><p>A相关性</p><p>B可靠性</p><p>C有效性</p><p>D实效性</p><p>E准确性</p><ol><li>数据挖掘的主要任务是从数据中发现潜在的规则,从而能更好的完成描述数据、预测数据等任务√</li><li>数据取样时,除了要求抽样时严把质量关外,还要求抽样数据必须在足够范围内有代表性。√</li><li>模型的具体化就是预测公式,公式可以产生与观察值有相似结构的输出,这就是预测值。√</li><li>Web数据挖掘是通过数据库的一些属性来预测另一个属性,它在验证用户提出的假设过程中提取信息。×</li><li>数据质量的标准有两个方面,一是资料完整无缺,各类指标项齐全;二是数据准确无误,且反应的都是在正常状态下的水平。√</li><li>在随机抽样这种操作中,首先将样本总体&#x2F;分成若干层次(或者说分成若干个子集)。每个层次中的观测值都具有相同的被选用的概率,但对不同的层次可以设定不同的概率。×</li><li>Python解释器易于扩展,可以使用C语言或C++,来扩展新的功能和数据类型,也可用于可定制化软件中的扩展程序语言。√</li><li>在选定主成分之后,还需要结合应用,对主成分进行解释,给出主成分的实际意义。√</li><li>医学数据分析与挖掘作为知识发现的核心部分,主要有以下几个步骤目标分析,数据抽取,数据探索,数据预处理,数据建模与评价以及模型反馈。√</li><li>进行降维处理、缺失值处理等,都是数据预处理要解决的问题。√</li></ol><h1 id="第二章：数据特征分析"><a href="#第二章：数据特征分析" class="headerlink" title="第二章：数据特征分析"></a>第二章：数据特征分析</h1><ol><li><h2 id="数据类型（各层要熟悉）"><a href="#数据类型（各层要熟悉）" class="headerlink" title="数据类型（各层要熟悉）"></a>数据类型（各层要熟悉）</h2></li></ol><p><img src="blob:https://miu7shl031o.feishu.cn/19add1df-27cc-4c56-b116-405a0217e8bf" alt="img"></p><p>区间：对于区间属性，值之间的差是有意义的，即存在测量单位。如日历日期、摄氏或华氏温度</p><p>比率：对于比率属性，差和比率都是有意义的。如绝对温度、货币量、计数、年龄、电流等</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YWJlMzczODY5NWUzMWJlZTI1Y2Q0MjMxNjk1MDNkNzJfODBBRDZlWmZaVFlkcm1xUU5aQUZ6VWYySWpGZm1oM1JfVG9rZW46WU1IY2JHUXd3b0JkMzl4Q0d6eWN4Tkxtbm5oXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>首选比率标度属性，可正向转换，一般不做相反方向的转化</p><ol><li><h2 id="数据的描述性特征"><a href="#数据的描述性特征" class="headerlink" title="数据的描述性特征"></a>数据的描述性特征</h2></li></ol><h3 id="数据集中趋势"><a href="#数据集中趋势" class="headerlink" title="数据集中趋势"></a>数据集中趋势</h3><p>指这组数据向某一中心值靠拢的程度，它反映了一组数据中心点的位置所在</p><h3 id="常用的表示数据集中趋势的度量"><a href="#常用的表示数据集中趋势的度量" class="headerlink" title="常用的表示数据集中趋势的度量"></a>常用的表示数据集中趋势的度量</h3><ul><li>算数平均值</li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NzI2ZDViYzMzZGYxZjk3NjEzMjAwMzU1OWI4MjFmZTVfU0JxNzhuUmNqRDZONXpZWDRkNFFwTDJXbUtNRGM3MTFfVG9rZW46VXVUaGJFcVU3b083dWR4NkxEaWNjR1BsbmpjXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>优点: ⑴反应灵敏 ⑵计算严密 ⑶计算简单 ⑷简明易解 ⑸适合运算 ⑹受抽样影响少</p><p>缺点: ⑴ 易受极端值影响，可以采用修剪平均数； ⑵ 若数据模糊不清，则无法计算平均数</p><ul><li>中位数</li></ul><p>优点: ⑴中位数计算不依靠数据本身，反应不够灵敏，极端值变化对中 位数无影响；⑵快速估计数据值</p><p>缺点:中位数没有均数稳定，计算要先排列数据，不能够进一步计算</p><ul><li>众数</li></ul><p>一组数据中出现最多的数</p><p>优点: 简单而不受极端值影响</p><p>缺点: 受分组与数据影响而不稳定,可靠性较差，一组数据可能没有众数或有几个众数</p><ul><li>k百分位数</li></ul><p>将一组数据从小到大排序，并计算相应的累计百分比，处于k%位置的值 称为第k百分位数，用xk%表示</p><p>xk%将数据分成两部分，大约有k%的数据小于或等于xk% ， 有(100－k)%的数据大于或等于xk%</p><ul><li>四分位数</li></ul><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NjZkN2YyMmJiMjU0YjEyZTAwZTlhMGE4MzFkMTMyZmRfNVVUeTRIbmI0Mkw5VHFoWDRTRFdBRm5kaUtoMFkzT2NfVG9rZW46UmZ4VGIwUXRBb2FiZUZ4alAxbWNPblRvbkJTXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>Q1又称“较小四分位数”，即25百分位数</p><p>Q2 即50百分位数，就是中位</p><p>Q3 又称“较大四分位数”，即75百分位数</p><h3 id="数据离散趋势"><a href="#数据离散趋势" class="headerlink" title="数据离散趋势"></a>数据离散趋势</h3><p>是各变量值远离其中心值的程度(离中程度、变异程度)</p><h3 id="描述数据离散趋势的度量"><a href="#描述数据离散趋势的度量" class="headerlink" title="描述数据离散趋势的度量"></a>描述数据离散趋势的度量</h3><p>反映各变量值远离其中心值的程度、反映各变量值的稳定性和均匀性、反映集中趋势指标的代表性</p><ul><li>极差</li></ul><p>是一组数据中最大值与最小值之差，又称范围误差或全距，用R表示</p><p>优点：计算方便，容易理解</p><p>缺点：</p><p>易受极端值左右，</p><p>受数据量大小的影响，不够稳定，</p><p>不能反映组内其他观察值的变异情况。</p><ul><li>四分位数极差</li></ul><p>又称内距，是总体中数据居中的50%个体散布的范围，可看作中间1&#x2F;2数据的极差</p><p>公式 IQR&#x3D;Q3-Q1</p><p>优缺点 受极端值的影响相对小，比极差稳定，但没有利用所有数据的信息。</p><ul><li>平均绝对离差</li></ul><p>是数据集合中各个数值与平均值的距离总和，然后取其平均数</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OTAyN2NlOWQ5MjVmODU3YTkzNDFkNzcyNTMzMmQ1ZmFfUEx5c1pralVsOUF2Vmp3SXpZUW5qTVVjOVpxM0tpdkVfVG9rZW46QXl4bWJscXc0b0Fjajd4bXhweGNRNDhDbkhkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>缺点: 带有绝对值符号</p><ul><li>方差和标准差</li></ul><p>计算每个样本值与全体样本平均数之差的平方和的平均数，称为方差</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MDY4Nzc1ZmQ1MTRkZGQ0YWU3NTEzNWIyYTI5NDE5M2ZfVmJkM1pKRmFrR3UySVg1MFdDeHhoazV1cGhGYmNWM3NfVG9rZW46QnpONmJPZlc4b2RqSEl4N1VNRWNraTZ6bkFjXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>标准差反映观察值对均数的变异程度、说明均数的代表性、常与均数配套来使用</p><ul><li>离散系数</li></ul><p>又称变异系数，是标准差与平均数之比。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTJkNjA0NWQ4OWI4YjE5M2Y5ZGM5N2Y0OTdjMzM0N2RfbXlYbndJVWFCN0plbDliREEwcjFJU21LNFpKUjV4V2tfVG9rZW46SGtraWJkc3hZb2d5c1B4eDFFYmNlMU5KbkFiXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li><h2 id="数据的相关分析"><a href="#数据的相关分析" class="headerlink" title="数据的相关分析"></a>数据的相关分析</h2></li></ol><h3 id="数值型属性间关系"><a href="#数值型属性间关系" class="headerlink" title="数值型属性间关系"></a>数值型属性间关系</h3><p>确定性关系：函数关系，两变量是一一对应的确定关系 如：圆面积与圆半径</p><p>非确定性关系：两类现象在发展变化方向与大小方面存在一定联系。一个变量的取值不能由另一个变量唯一确定。 如：体重与体表面积</p><h3 id="相关分析-（分析两个数值型属性之间的相关性）"><a href="#相关分析-（分析两个数值型属性之间的相关性）" class="headerlink" title="相关分析 （分析两个数值型属性之间的相关性）"></a>相关分析 （分析两个数值型属性之间的相关性）</h3><ol><li>散点图：将两个属性的成对数据，绘制在直角坐标系中得到的一系列点</li></ol><p>目的：观察两个数值型属性之间是否相关、相关的变现形式以及密切程度</p><p>正线性相关、负线性相关、零相关</p><ol><li>相关系数：是描述两个数值型属性间相关关系的密切程度与相关方向的指标。（高中的线性回归方程）</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NmNjYzU3MGQ3N2UxMmRiNjc2MGIyYTQwYTJhMmY4NTVfcE1GSHRRWGVoeFN2SGlFbzBlUmJmZzc2SDFoeFc3NjNfVG9rZW46V0JhMGJ4Mk9qb3RycmV4djBCYWNEUTN1bnRnXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>没有单位，-1≤r≤1</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=Yzg2OTZmYjM4NzgyYmQ5ZjYxZjJiMDM4ZjkzMTdkMWVfTEhNM01sZktGMUZKYWE1M1p2U1ptVm5pSHBoenpnd3dfVG9rZW46QTNNT2I0Mmtvb0ZOazF4Wm1Oa2M0bmdXbjZjXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>两变量间存在直线相关关系，并不表示一定是因果 关系，可能是伴随关系。</p><h3 id="卡方（χ2）检验（推断两个标称属性之间的独立性）"><a href="#卡方（χ2）检验（推断两个标称属性之间的独立性）" class="headerlink" title="卡方（χ2）检验（推断两个标称属性之间的独立性）"></a>卡方（χ2）检验（推断两个标称属性之间的独立性）</h3><p>建立检验假设，确定显著性水平</p><p>计算检验统计量χ2值</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ODRiMjFhYWRiZmVlYTI2M2EzYzVlYWYzZWI4YWNiN2ZfV0ZNQkFkNkF0YkhRZFdDV3YzaHB5REw2aVd2OFJ5S2tfVG9rZW46THpjUmI0NGZmb0EzbU94UFhvY2N1WDZYbnhjXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=M2ExMmI3MDBlNTE5YTNiMGE3ZjQ2YTdmYTE1MzFkZDVfOGxnNGNpclBNUE9wcEdJbWNTN2FPcUNhOVdjVkhqRUtfVG9rZW46SDQ1ZWJSbGRnb2pFUDl4U2syTmN5ME9XbjdkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li><h2 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h2></li></ol><p>由于维度较多，数据呈现出越来越稀疏的分布特点，再加上不</p><p>同维度之间有一定的相关性，增加了数据挖掘算法的复杂度(维灾难)</p><p>用较少数量的、彼此不相关的新维度（主成分)代替原来的维度，并能够解释数据所包含的大部分信息</p><h3 id="形式化描述"><a href="#形式化描述" class="headerlink" title="形式化描述"></a>形式化描述</h3><p>n 个p维样本组成的数据集合可以表示为一个n×p的矩阵X</p><h3 id="主成分分析的主要步骤"><a href="#主成分分析的主要步骤" class="headerlink" title="主成分分析的主要步骤"></a>主成分分析的主要步骤</h3><ol><li>给定10个二维数据 （x1 , x2 ） ，表示成10×2的矩阵形式</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OTQ1YjFkMWQ5NzkyNDk0ZWU2ODc4NjJiYmFkOGUzMjJfbnIxaks5Uk1XdFpEUzRTOENmWW8wZVV6MWJLUkhWQXVfVG9rZW46VjdwVGJTenp1b3dTNjZ4UXpkY2N0cVhqbmtkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li>将X的每一行（维）进行零均值化</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YjllYTg2NzVkNWE0ZTBhNzNjYzU3YTY4YjE2ZjA1ZTdfVjRjZmJjRmhSWk5KYWEyeG43ZWRMdG5WYm1ET3lxYnRfVG9rZW46SE9GaWJrandYb05mYkd4WUxkSGNwc3JNbmZjXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li>求样本协方差阵C</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MGM0ZjUyMjY2MDQ3YTZiMTJlMzA4YzI1MDJjMTNmODNfNndiT2lEUlhENzVkRUtQaWFXZVp5VUx5N0RvVHZkbEFfVG9rZW46U0ZzUmJ6ZTJ3bzgzNkh4ZXdpWWNEcDBCbnZkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li>计算协方差阵C的特征值及对应的标准正交特征向量</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YmQ5MDQ0YjkwN2JiMDc2YmQ3MmM2Y2Y0ZjExNTE0YzFfa3ZJWEFoZzdiVGdyV2JQTVRmZ0RiY3A5cE9BR3k3aGVfVG9rZW46SGdSY2J6MWJJb1cwd1F4RkhUNWNZYmdybnliXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li>将特征向量根据对应特征值大小从上到下按行排列成矩阵</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YTUwYWVlNTZjMzNiMTY3ZmE3MzM0OGRhYzAzYjU0ZDZfOXNtNmtDNGVwazNweFVCUzNQZ3NhR0RZUVd5NURpc0JfVG9rZW46TTJVV2JHSDJnb0FzVXV4bHh3MWM4YTl4bmljXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li>将样本投影到新的坐标系上</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NzlmMmZjMTI3MjUyODYyZGU3MGZjZDBjZmI0NGUwZWRfcEpiWEw4dDh3OFNlZHRBSlpYUVp6djNWM044NDRsRjBfVG9rZW46UE5zZGJab3kzb3Y3c214S0pqQ2NvUWxIbjZYXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li>确定提取主成分的数目</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OGQ5MDI3YjlmM2MxMzNhOWIxYjM4YjA3NzA1ZmQ3ODVfTkp6YzV3RVRuUTJlU1B6WHZPRkxEazQ5UXpNMmo5NFZfVG9rZW46VVNOUWI0enpYb3JwNFN4MVNER2MzNGdyblVnXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li><h2 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h2></li></ol><p>假 设 检 验 的 步 骤</p><ul><li>提出原假设（Null hypothesis） 与备择假设（Alternative hypothesis）</li><li>确定适当的检验统计量， 并计算检验统计量的值</li><li>规定显著性水平α</li><li>作出统计决策</li></ul><ol><li><h2 id="独立样本t检验"><a href="#独立样本t检验" class="headerlink" title="独立样本t检验"></a>独立样本t检验</h2></li></ol><p>应用条件</p><p>独立性(Independence)</p><p>组内变量值 间彼此独立一基础性条件</p><p>正态性(Normality)</p><p>不同组样本均来自正态总体一第一条件</p><p>方差齐性(Homogeneity&#x2F;.Equality of variance)</p><p>独立样本均数比较时，两样本对应的总体方差相同一第二条件</p><ol><li><h2 id="第二章相关试题"><a href="#第二章相关试题" class="headerlink" title="第二章相关试题"></a>第二章相关试题</h2></li><li><p>下列有关个人信息的指标,属于序数属性的是()</p></li></ol><p>A学历</p><p>B民族</p><p>C职业</p><p>D考试成绩</p><ol><li>下列说法错误的是()。</li></ol><p>A有时为了数据分析的方便,可将高级属性转化为比他低级的属性,一般不能做相反方向的转化。</p><p>B数据属性转化顺序:标称属性→序数属性→区间标度属性→比率属性</p><p>C数据属性的类型大的来说分为定性和定量两种。</p><p>D实际工作中,首选比率属性,其次是区间标度属性,再次是序数属性,最后是标称属性。</p><ol><li>下列属于二元属性的是()</li></ol><p>A血压值</p><p>B流感病毒检测结果</p><p>C身高</p><p>D血型</p><ol><li>肝炎病人的住院天数是()</li></ol><p>A区间标度属性</p><p>B比率标度属性</p><p>C标称属性</p><p>D序数属性</p><ol><li>一组数据中出现次数最多的变量值称为()。</li></ol><p>A算术平均值</p><p>B众数</p><p>C中位数</p><p>D标准差</p><ol><li>离散趋势是指 () 。</li></ol><p>A变量值的远离其中心值的程度</p><p>B变量值的平均水平</p><p>C变量值的分配</p><p>D变量值的大小</p><ol><li>主成分分析后每一个新的变量可以表示为()</li></ol><p>A某个原变量</p><p>B新变量的线性组合</p><p>C原来部分变量的线性组合</p><p>D原来所有变量的线性组合</p><ol><li>标准差数值越小,则()。</li></ol><p>A反映变量值越集中,算术平均值代表性越好。</p><p>B反映变量值越分散,算术平均值代表性越差。</p><p>C反映变量值越集中,算术平均值代表性越差。</p><p>D反映变量值越分散,算术平均值代表性越好。</p><ol><li>当两组或多组资料的变异度进行比较时,应采用离散系数的情况是()</li></ol><p>A均数相差悬殊</p><p>B标准差相差悬殊</p><p>C度量单位不同</p><p>D资料来自不同地区</p><p>E资料来自不同时期</p><ul><li>离散系数（Coefficient of Variation，CV）是衡量数据离散程度的统计量，它是标准差与均数的比值，用来比较不同数据集的变异程度。当均数相差悬殊时，直接比较标准差的大小可能不具有可比性，因为标准差会随着均数的增大而增大。此时，使用离散系数可以消除均数差异的影响，更公平地比较不同数据集的变异度。</li></ul><ol><li>下列指标中属于集中趋势指标的有()</li></ol><p>A算术平均值</p><p>B众数</p><p>C中位数</p><p>D百分位数</p><p>E极差</p><ol><li>比率标度属性能提供关于顺序、差异以及比率关系的信息,关键之处在于“真正零值”能够被定义。√</li><li>当资料分布的末端无确切数据时不能计算算术平均值。√</li><li>样本量增大时,极差可能会增大√</li><li>方差的单位与原始数据的单位相同×</li><li>卡方检验中,卡方统计量用来衡量所有单元格的观测值与理论值的差异大小。√</li><li>卡方检验中,卡方统计量越大,越有理由拒绝H0。√</li><li>相关系数∣r∣越接近于0,说明相关的密切程度越强。×</li><li>在选定主成分之后,还需要结合应用,对主成分进行解释,给出主成分的实际意义。√</li><li>主成分分析是一种统计方法,通过正交变换将一组可能存在相关性的变量转换为一组线性无关的变量,转换后的这组向量称为主成分。√</li><li>主成分分析方法是一种数据降维的方法。√</li></ol><h1 id="第三章：数据处理"><a href="#第三章：数据处理" class="headerlink" title="第三章：数据处理"></a>第三章：数据处理</h1><ol><li><h2 id="数据的清洗"><a href="#数据的清洗" class="headerlink" title="数据的清洗"></a>数据的清洗</h2></li></ol><h3 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h3><p>数据缺失机制分为以下三种：</p><ul><li>完全随机缺失</li><li>随机缺失</li><li>非随机缺失</li></ul><p>处理缺失值的方法可分为3类：删除记录、数据插补和不处理</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YTcxOTFkYjI4MjgxZWU4ZTE0YzI1ZDFkODZiODFjZjlfNVNQTVc0dXpTWHVJVkJ3dlQ5NFhiaHlkNGdDd0twcGRfVG9rZW46UEVVY2JsdEUyb2pkaXh4MWZLQmNXZm44blFkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>主要讲的两个插值方法</p><p>拉格朗日插值法</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTgwYzNlNmUzZTE3MGRmNzUzYzhiNGVmMzJlYjk2NzVfZVRnN2JLZVIyc0ZVVXZCek5iZmFWSklncEtBOVRuNGZfVG9rZW46QWY3bmJBVDlBb3ZTUDJ4SEtHc2M3ODkwbnpoXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>牛顿插值法</p><p>具有承袭性和易于变动节点的 特点。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NmY3YzUzMTg5ZWNlMGI4ODc4ZGVkYjFiMWQ4ZDhkYzlfT0dtVmZ3MnUzRHEzeFI4dHIwQXQ3cnlDb1V1ZUZKMm5fVG9rZW46QTRlS2I1Qlo5b2RwN0p4cHVqYWM4eW9sbjdkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><h3 id="重复值处理"><a href="#重复值处理" class="headerlink" title="重复值处理"></a>重复值处理</h3><p>记录重复</p><p>在某企业的药品发货记录表中，利用列表（list）对用品名称去重，查看所有的品牌名称：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">delRep</span>(<span class="params">list1</span>):</span><br><span class="line">     list2 = []</span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> list1</span><br><span class="line">         <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> list2:</span><br><span class="line">             list2.append(i)     //老师说这个append会考个两分的</span><br><span class="line">     <span class="keyword">return</span> list2</span><br><span class="line"> names = <span class="built_in">list</span>(data[<span class="string">&#x27;品牌名称&#x27;</span>]) <span class="comment"># 提取品牌名称</span></span><br><span class="line"> name = delRep(names) <span class="comment"># 使用自定义的去重函数去重</span></span><br></pre></td></tr></table></figure><p>还可以利用集合（set）元素为唯一的特性去重:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;去重前品牌总数为：&#x27;</span>, <span class="built_in">len</span>(names)) </span><br><span class="line">name_set = <span class="built_in">set</span>(names) <span class="comment"># 利用set的特性去重 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;去重后品牌总数为：&#x27;</span>, <span class="built_in">len</span>(name_set）</span><br></pre></td></tr></table></figure><p>pandas提供了一个名为drop_duplicates的去重方法。该方法只对 DataFrame或Series类型有效。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.DataFrame.drop_duplicates(subset=<span class="literal">None</span>,keep=<span class="string">&#x27;first&#x27;</span>,inplace=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MjI2ZTk0YTNiZTUyNDcyYjA0MjZkNTY1MjAyYzFmNWVfVXZHQ2kzYTI3YlprVkd4VUNuTVh1ZnNiR0VvcVlYd1JfVG9rZW46QXRFcGJFeFdWb081ek54S1RXMWNuNzRlbjZkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>属性内容重复</p><p>属性内容重复是指数据中存在一个或多个属性名称不同，但数据完全相同。当需要去除 连续型属性重复时，可以利用属性间的相似度，去除两个相似度为1的属性的其中一个</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">corr_ = data[[<span class="string">&#x27;品牌标签&#x27;</span>, <span class="string">&#x27;仓库标签&#x27;</span>]].corr(method=<span class="string">&#x27;kendall&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;kendall相似度为：\n&#x27;</span>, corr_）</span><br></pre></td></tr></table></figure><p>除了使用相似度矩阵进行属性去重之外，可以通过pandas库的DataFrame.equals()方法进行属性去重。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.DataFrame.equals(other)</span><br></pre></td></tr></table></figure><h3 id="异常值处理"><a href="#异常值处理" class="headerlink" title="异常值处理"></a>异常值处理</h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjJmM2MwMzA4ZGM0ZGViYWFjYWM3YzNiNTUwZmEyOWVfWk5vSHNOS1paZEhseWtGYnBrVDZnUm1PYzFuS0wxVnZfVG9rZW46VDc0ZWJJU0lCb0dST2V4cnIxVGNlNk92bkpmXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li><h2 id="数据的变换"><a href="#数据的变换" class="headerlink" title="数据的变换"></a>数据的变换</h2></li></ol><h3 id="简单函数变换"><a href="#简单函数变换" class="headerlink" title="简单函数变换"></a>简单函数变换</h3><p>简单函数变换是对原始数据进行某些数学函数变换，常用的包括平方、开方、取对数、差分运算等。</p><h3 id="最小-最大标准化"><a href="#最小-最大标准化" class="headerlink" title="最小-最大标准化"></a>最小-最大标准化</h3><p>最小-最大标准化也称为离差标准化，是对原始数据的线性变换，将数值映射到[0,1]之间。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NTI5N2IxOTJkZWE1MWVmY2QwM2U5ZWQ3ZjcxN2RmODVfS1Ayaks4S3ExRzJlZXlZU2pTbThBanlYVkpXNHZubGtfVG9rZW46TG5NQWI1VGRwb3RyVnV4RHVYRGNJTm44bnlwXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>其中， max为样本数据的最大值， min为样本数据的最小值。max-min 为极差。</p><h3 id="零-均值标准化"><a href="#零-均值标准化" class="headerlink" title="零-均值标准化"></a>零-均值标准化</h3><p>零-均值标准化也叫标准差标准化，经过处理的数据的均值为0，标准差为1。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NjI1MWNhOWNjNWZlZjZmM2Y3ZDY1YTA4YjI5MDQ0ZjFfU0YzZHFFZ0NhazV2TDNPYnBwSFl1SjBWRUtvNjZwOVlfVG9rZW46QjJ4VGJMOENQb2JQcVp4RzBxd2NCRnd1bkhoXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>其中x为原始数据的均值，S为原始数据的标准差，零-均值标准化是当前用得最多的数据标准化方法。</p><h3 id="小数定标标准化"><a href="#小数定标标准化" class="headerlink" title="小数定标标准化"></a>小数定标标准化</h3><p>通过移动属性值的小数位数，将属性值映射到[-1,1]之间，移动的小数位数 取决于属性值绝对值的最大值</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=M2I2YjY0ZGIyNTM2Zjc4NmFhOGRjNmYxNjBhZjFhOGRfeG41QnlKODV5b1pTOHI5SjFFbldaemhtZHdHYmpXSDBfVG9rZW46Wld4OWIzcnExb0Q3Smh4blYzUmNmRkhxblRnXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>其中k为属性值中绝对值最大的数值的位数。</p><h3 id="数据离散化"><a href="#数据离散化" class="headerlink" title="数据离散化"></a>数据离散化</h3><p>將连续的数据进行分段，使其变为一段段离散化的区间</p><p>离散化的方法：</p><p>无监督学习的方式</p><p>有监督学习的方式</p><p>分段的原则有星于等距离、等频率、聚类或优化的方法</p><p>离散化的过程:</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YmJiZjUwNzY3MTA5MjNiN2FjNzkzZGNiNDNmMmM3ODZfVWFxVWRyUEVGbGV4R3FaSWpKRXJMUXQyTTdjdk1GTVJfVG9rZW46Unp6MmJTWVRpb1hIT2F4T3p3bmNSS1NWblFnXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>常用的离散化方法：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MmNjN2U1YmFkNGVhYWJmYjc5NmFhNjYzOWJmZTM3ZjJfblZIWDQ1S3VpWHJZcXI2bWhCb2E4Tlpva0FuQkhSeG9fVG9rZW46SzduNWJkMklob3NDTzJ4NEUwM2MwTUlwblllXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><h3 id="独热编码（重点，可能考到代码）"><a href="#独热编码（重点，可能考到代码）" class="headerlink" title="独热编码（重点，可能考到代码）"></a>独热编码（重点，可能考到代码）</h3><p>独热编码即One-Hot编码，又称一位有效编码，是处理类型数据较好的方法，主要是使用N位状态寄存器来对N个状态进行编码，每个状态都有它独立的寄存器位，并且在任意时候都只有一个编码位有效。</p><p>独热编码有以下优点：</p><ul><li>将离散型属性的取值扩展到欧氏空间，离散型属性的某个取值就对应欧氏空间的某个点。</li><li>对离散型属性使用独热编码，可以让属性之间的距离计算更为合理。</li></ul><p>在Python中使用scikit-learn库中preprocessing模块的OneHotEncoder函数进行独热编码</p><p>以书上的 示例2-16为参考记忆代码:–亲测可以跑通</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">enc=preprocessing.OneHotEncoder() <span class="comment">#这行代码创建了一个OneHotEncoder类的实例，并将这个实例赋值给变量enc。OneHotEncoder是preprocessing模块中用于进行独热编码的类。</span></span><br><span class="line">productData=np.array([[<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]]) <span class="comment">#这行代码使用numpy库创建了一个二维数组productData。这个数组包含了5行3列的数据，每行代表一个产品的数据，每列代表一个特征。</span></span><br><span class="line">enc.fit(productData)  <span class="comment">#这行代码使用fit方法来拟合OneHotEncoder实例enc。fit方法会根据输入的数据来学习如何进行独热编码，即确定哪些特征是分类特征，以及每个分类特征中有多少个不同的类别。</span></span><br><span class="line">Ohe=enc.transform(productData)  <span class="comment">#这行代码使用transform方法来转换productData数组。transform方法将原始数据转换为独热编码形式。转换后的数据存储在变量Ohe中。</span></span><br><span class="line"><span class="built_in">print</span> (Ohe.toarray())</span><br></pre></td></tr></table></figure><ol><li><h2 id="数据的合并"><a href="#数据的合并" class="headerlink" title="数据的合并"></a>数据的合并</h2></li></ol><h3 id="多表合并"><a href="#多表合并" class="headerlink" title="多表合并"></a>多表合并</h3><ul><li>堆叠合并数据</li></ul><p>使用pandas库的concat函数可以实现横向堆叠和纵向堆叠，concat函数的基本使用格式 和常用参数说明如下：</p><p>分为横向堆叠和纵向堆叠</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MWIwOTI5ZDY3Yzk0MDNlYjFhZGVjZWIxMTc2N2E2MjBfZENlcktVbUtqaWsyTHppM09GOXZqSEpnNU9YUmZVWWpfVG9rZW46QnVNZ2JLMGNyb1E2bE94M2J6NWNNWDdGblhkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>使用pandas库的concat函数可以实现横向堆叠和纵向堆叠</p><p>除了concat函数之外，pandas库的append()方法也可以用于纵向合并两张表</p><ul><li>主键合并数据</li></ul><p>主键合并，即通过一个或多个键将两个数据集的行连接起来。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=Mjc5ZTI2MDFiZDU0ZTgxY2YwZGI4ZmVjYzg4YjcyZGRfWkJkbVRXUnpXQkhDMWZuUmFOSWtkZkxENDQ0OWQ0RE5fVG9rZW46VFlUNGIwVlVLb29hMDh4OGlua2MzdFAwblRjXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>pandas库中的merge函数（pandas.merge（））和join()方法（pandas.DataFrame.join（））都可以实现主键合并，但两者的实现方式并不相同</p><p>使用join()方 法时，两个主键的名字必须相同</p><ul><li>重叠合并数据</li></ul><p>数据分析和处理过程中偶尔会出现两份数据的内容几乎一致的情况，但是某些属性在其中 一张表上是完整的，而在另外一张表上的数据则是缺失的。这时除了使用将数据一对一比较， 然后进行填充的方法外，还有一种方法就是重叠合并</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=M2IyZGJhMWZlZWI4ZjRjMjY2OTY3OGM4NWRkMzMyNmFfNGFpYUdYaDBOWm5lb1dmRzVENkFENXJaMVA1MDRwMmhfVG9rZW46SzdaTGJyYThGb21VbG94WmhhZGNYdWpabjJlXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><h3 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h3><p>分组是使用特定的条件将元数据进行划分为多个组。聚合是对每个分组中的数据执行某些</p><p>操作，最后将计算结果进行整合。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmFjZjkzMTU4YTI5NjQ1Y2E3YzI4YTExMjQ1ZTk0OGZfS2pSMmg0d2V0RXF3bVRzTHYwSG1oQUhtVVJNenNtamNfVG9rZW46UTRLS2J4Sm9MbzBlc3J4Wk1MaGNIa1Vnbk12XzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li>使用groupby0方法拆分数据</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.DataFrame.groupby（）</span><br></pre></td></tr></table></figure><ol><li>使用agg()方法聚合数据</li></ol><p>agg()方法和aggregate()方法都支持对每个分组应用某函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.DataFrame.agg（）</span><br><span class="line">pandas.DataFrame.aggregate（）</span><br></pre></td></tr></table></figure><ol><li>使用apply()方法聚合数据</li></ol><p>apply()方法类似于agg()方法，能够将函数应用于每一列。不同之处在于，与agg()方法相比， apply()方法传入的函数只能够作用于整个DataFrame或Series，而无法像agg()方法一样能够对不 同字段应用不同函数来获取不同结果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pandas.DataFrame.apply（）</span><br></pre></td></tr></table></figure><ol><li>使用transform()方法聚合数据</li></ol><p>transform()方法能够对整个DataFrame的所有元素进行操作。</p><p>以药品详情表为例，对销量和售价使用pandas库的transform()方法进行翻倍：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">detail[[<span class="string">&#x27;counts&#x27;</span>, <span class="string">&#x27;amounts&#x27;</span>]].transform(<span class="keyword">lambda</span> x: x * <span class="number">2</span>).head(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><ol><li><h2 id="第三章相关试题"><a href="#第三章相关试题" class="headerlink" title="第三章相关试题"></a>第三章相关试题</h2></li><li><p>( )的目的缩小数据的取值范围,使其更适合于数据挖掘算法的需要,并且能够得到和原始数据相同的分析结果</p></li></ol><p>A数据清洗</p><p>B数据集成</p><p>C数据变换</p><p>D数据归约</p><ol><li>将原始数据进行集成、变换、维度规约、数值规约是在以下哪个步骤的任务?()</li></ol><p>A频繁模式挖掘</p><p>B分类和预测</p><p>C数据预处理</p><p>D数据流挖掘</p><ol><li>下面哪种不属于数据预处理的方法? ()</li></ol><p>A变量代换</p><p>B离散化</p><p>C聚集</p><p>D估计遗漏值</p><ol><li>假设12个销售价格记录组已经排序如下:5, 10,11,13, 15,35, 50, 55,72,92,204, 215 使用如下每种方法将它们划分成四个箱。等频(等深)划分时,15在第几个箱子内?()</li></ol><p>A第一个</p><p>B第二个</p><p>C第三个</p><p>D第四个</p><ol><li>以下哪种方法不属于特征选择的标准方法:()</li></ol><p>A嵌入</p><p>B过滤</p><p>C包装</p><p>D抽样</p><ol><li>下面哪个属于映射数据到新的空间的方法?()</li></ol><p>A傅立叶变换</p><p>B特征加权</p><p>C渐进抽样</p><p>D维归约</p><ol><li>数据仓库是随着时间变化的,下面的描述不正确的是()</li></ol><p>A数据仓库随时间的变化不断增加新的数据内容</p><p>B捕捉到的新数据会覆盖原来的快照</p><p>C数据仓库随事件变化不断删去旧的数据内容</p><p>D数据仓库中包含大量的综合数据,这些综合数据会随着时间的变化不断地进行重新综合</p><ol><li>MapReduce的Map函数产生很多的( )</li></ol><p>Akey</p><p>Bvalue</p><p>C&lt;key,value&gt;</p><p>DHash</p><ol><li>噪声数据的产生原因主要有:()</li></ol><p>A数据采集设备有问题</p><p>B在数据录入过程中发生了人为或计算机错误</p><p>C数据传输过程中发生错误</p><p>D由于命名规则或数据代码不同而引起的不一致</p><p>E数据资料自然产生</p><ol><li>进行多表合并时,使用pandas库的可以实现横向堆叠和纵向堆叠()</li></ol><p>Aconcat函数</p><p>Bappend()方法</p><p>Cmerge函数</p><p>Djoin()方法</p><p>Egroupby()</p><ol><li>对遗漏数据的处理方法主要有:忽略该条记录;手工填补遗漏值;利用默认值填补遗漏值;利用均值填补遗漏值;利用同类别均值填补遗漏值;利用最可能的值填充遗漏值。√</li><li>数据规范化指将数据按比例缩放(如更换大单位),使之落入一个特定的区域(如0—1)以提高数据挖掘效率的方法。规范化的常用方法有:最大—最小规范化、零-均值规范化、小数定标规范化。√</li><li>原始业务数据来自多个数据库或数据仓库,它们的结构和规则可能是不同的,这将导致原始数据非常的杂乱、不可用,即使在同一个数据库中,也可能存在重复的和不完整的数据信息,为了使这些数据能够符合数据挖掘的要求,提高效率和得到清晰的结果,必须进行数据的预处理。√</li><li>孤立点在数据挖掘时总是被视为异常、无用数据而丢弃。×</li><li>维归约可以去掉不重要的属性,减少数据立方体的维数,从而减少数据挖掘处理的数据量,提高挖掘效率。√</li><li>分组是使用特定的条件将元数据进行划分为多个组。√</li><li>agg()方法和aggregate()方法都支持对每个分组应用某函数,但是不包括Python内置函数或自定义函数×</li><li>特征离散化以后,起到了简化了模型的作用,降低了模型过拟合的风险。√</li><li>最小-最大标准化也称为离差标准化,是对原始数据的线性变换,将数值映射到[0,1]之间。√</li><li>处理缺失值的方法可分为3类:删除记录、数据插补和不处理。√</li></ol><h1 id="第四章-关联规则挖掘"><a href="#第四章-关联规则挖掘" class="headerlink" title="第四章: 关联规则挖掘"></a>第四章: 关联规则挖掘</h1><ol><li><h2 id="基于候选项集产生-测试策略的频繁模式挖掘算法"><a href="#基于候选项集产生-测试策略的频繁模式挖掘算法" class="headerlink" title="基于候选项集产生-测试策略的频繁模式挖掘算法"></a>基于候选项集产生-测试策略的频繁模式挖掘算法</h2></li></ol><p>关联规则分析</p><p>关联规则分析也称为购物篮分析，目的是从大量数据中找出各项之间的关联关系，如关联规则“面包&#x3D;&gt;牛奶”，其中面包称为规则的前项，而牛奶称为后项。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmRkNDA3NTE5ODNjNjExMDVjMzIyOWVhZDkwNDgxYWZfZDI2NEJnbUtYVmVUeW5oNkY2YWNuRnlUS2F5UmZKVWNfVG9rZW46QmdhNGJISjNnbzA3OEl4Q3RRU2M3VmdxbnlkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>重点记忆Apriori</p><h3 id="Apriori算法"><a href="#Apriori算法" class="headerlink" title="Apriori算法"></a>Apriori算法</h3><p>关联规则和频繁项集</p><p>支持度（Support）：项集A、B同时发生的概率称为关联规则的支持度。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MDZlMjQ0NzdkMDEzMTY3MWIwMDY1YzI1ZDgxMWMzZDVfQ3FYcGxBQjZCajRsNWpCa0RTa2liQnVEdlFZRDhsZkJfVG9rZW46SWpQUGJkWEppb3c5eTN4azF0V2NuQWNubmltXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>置信度（可信度Confidence）：项集A发生，则项集B发生的概率为关联规则的置信度</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YWYwM2JkODg0OTY2MjliZDExMThlYTQ3MGQ1ODkxMTFfZ2kyREk0NER5bFhVZ2ZkUkVmemU2OXZiQzVmT01RMVNfVG9rZW46SnB0U2J5Y09ub0piYm94VmlaTGNBc2Q3bktlXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>提升度：含有A的条件下，同时含有B的概率，与B总体发生的概率之比。也 就是A对B的置信度与B总体发生的概率之比</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NmU4YWY2NzNkZWQ5NTczZjBlNTQ4MzE2NjRlOWRiNzhfcjg1SXB4UjhoV1J4SU9sOUk5d2dBZ0d2eFFrUHhVelRfVG9rZW46T3oyWGI5Skd0bzJ6T1Z4ZmtKRGNiOHh3bkVkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>强关联规则：</p><ol><li>先寻找满足最小支持度的频繁项集</li><li>然后在频繁项集中寻找满足最小置信度的关联规则</li></ol><p>最小支持度和最小置信度:</p><p>最小支持度是用户或专家定义的衡量支持度的一个阈值，表示项目集在统计意义上 的最低重要性；最小置信度是用户或专家定义的衡量置信度的一个阈值，表示关联规则 的最低可靠性。同时满足最小支持度阈值和最小置信度阈值的规则称作强规则</p><p>项集与频繁项集:</p><p>项集是项的集合。包含k个项的项集称为k项集，如集合{人参、附子、甘草}是一个3 项集。 项集的出现频数是所有包含项集的事务计数，又称作绝对支持度或支持度计数。如 果项集I的相对支持度满足预定义的最小支持度阈值，则I是频繁项集。</p><p>Apriori算法的主要思想是找出存在于事务数据集中的最大的频繁项集，再利 用得到的最大频繁项集与预先设定的最小置信度阈值生成强关联规则。</p><p>Apriori的性质</p><p>频繁项集的所有非空子集也必须是频繁项集。根据该性质可以得出：向不是频 繁项集的项集 中添加事务 ，新的项集 一定也不是频繁项</p><p>步骤:</p><ul><li>设定最小支持度和最小置信度</li><li>根据最小支持度找出所有的频繁项集</li><li>根据最小的置信度发现强关联规则</li></ul><p>按ppt上的案例应该可以快速入门这一算法</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NTcxYWI1OGE5YmU3ODQxNTIxNzAxNzQ0YTllMTQyZDRfVW9XcDRKVll4ZjZRRkxIcFdqRUFHVXV2VVBkYVdvczJfVG9rZW46WWt5M2JuOG5SbzFyMzZ4NXFGaWNJZEtibmpoXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MzA5NTVjYThiM2ZiYzAzNzI4YTEzMDA5NTRjNTE3YzNfZ20wMG1ncm1FbHFHZmgwM09YSmxDVUxEQXlvQ1pyRk5fVG9rZW46SlZGTmI0R0RGb003ZFF4aEg1bGNrWWFwbnVGXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YjE1MTMxZTE5NzEyNmVlZmI2NWFiN2VhMzlmZjAxY2VfZWdBVVYzR09odXBDeWJBN3E4c2ZxNlBoTjdmMW5HRHVfVG9rZW46QzVRcGJQVnlsb3RpeXJ4Wm1ZSGM4U052bk9lXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTA5MDBkNjg3NjkzMjg5OGQzOGQzNzliODQ1ZjQwZjZfcm1iQU5Xc1VzcVNNeFZlOWhJWTFxZ2l6OGRpc3lrcmlfVG9rZW46SlJmTWJKeEw5b2NnSDB4Vjl5cWN5OU1abmdkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li><h2 id="基于Apriori算法的中医证型关联规则挖掘"><a href="#基于Apriori算法的中医证型关联规则挖掘" class="headerlink" title="基于Apriori算法的中医证型关联规则挖掘"></a>基于Apriori算法的中医证型关联规则挖掘</h2></li></ol><p>不必理会，看不懂</p><ol><li><h2 id="不需要产生候选项集的-频繁模式挖掘算法"><a href="#不需要产生候选项集的-频繁模式挖掘算法" class="headerlink" title="不需要产生候选项集的 频繁模式挖掘算法"></a>不需要产生候选项集的 频繁模式挖掘算法</h2></li></ol><h3 id="FP-growth算法"><a href="#FP-growth算法" class="headerlink" title="FP-growth算法"></a>FP-growth算法</h3><p>流程:</p><p>首先构造FP树，然后利用它来挖掘频繁 项集。在构造FP树时，需要对数据集扫 描两边，第一遍扫描用来统计频率， 第二遍扫描至考虑频繁项集</p><h3 id="多层关联规则挖掘算法"><a href="#多层关联规则挖掘算法" class="headerlink" title="多层关联规则挖掘算法"></a>多层关联规则挖掘算法</h3><p>多层关联规则（Multilevel Rules）是一种基于概念分层的关联规则挖掘方法，概念 层次结构通常用概念树来表示，按照一般到特殊的顺序以偏序的形式排列</p><ol><li><h2 id="第四章相关试题"><a href="#第四章相关试题" class="headerlink" title="第四章相关试题"></a>第四章相关试题</h2></li><li><p>某超市研究销售纪录数据后发现,买啤酒的人很大概率也会购买尿布,这种属于数据挖掘的哪类问题?()</p></li></ol><p>A关联规则发现</p><p>B聚类</p><p>C分类</p><p>D自然语言处理</p><ol><li>设X&#x3D;{1,2,3}是频繁项集,则可由X产生( )个关联规则.</li></ol><p>A4</p><p>B5</p><p>C6</p><p>D7</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">由于 𝑋X 包含<span class="number">3</span>个项，我们可以生成以下子集 𝑌：</span><br><span class="line">&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;（单个项集）</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">1</span>,<span class="number">3</span>&#125;, &#123;<span class="number">2</span>,<span class="number">3</span>&#125; （两个项的组合）</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;（整个项集本身）</span><br><span class="line">对于每个子集 𝑌Y，我们都可以生成一个关联规则 𝑌⇒𝑍Y⇒Z，其中 𝑍Z 是 𝑋X 中不在 𝑌Y 中的项集。</span><br><span class="line">具体来说：</span><br><span class="line">对于 𝑌=&#123;<span class="number">1</span>&#125;Y=&#123;<span class="number">1</span>&#125;，可以生成 &#123;<span class="number">1</span>&#125;⇒&#123;<span class="number">2</span>,<span class="number">3</span>&#125;。</span><br><span class="line">对于 𝑌=&#123;<span class="number">2</span>&#125;Y=&#123;<span class="number">2</span>&#125;，可以生成 &#123;<span class="number">2</span>&#125;⇒&#123;<span class="number">1</span>,<span class="number">3</span>&#125;。</span><br><span class="line">对于 𝑌=&#123;<span class="number">3</span>&#125;Y=&#123;<span class="number">3</span>&#125;，可以生成 &#123;<span class="number">3</span>&#125;⇒&#123;<span class="number">1</span>,<span class="number">2</span>&#125;。</span><br><span class="line">对于 𝑌=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;Y=&#123;<span class="number">1</span>,<span class="number">2</span>&#125;，可以生成 &#123;<span class="number">1</span>,<span class="number">2</span>&#125;⇒&#123;<span class="number">3</span>&#125;。</span><br><span class="line">对于 𝑌=&#123;<span class="number">1</span>,<span class="number">3</span>&#125;Y=&#123;<span class="number">1</span>,<span class="number">3</span>&#125;，可以生成 &#123;<span class="number">1</span>,<span class="number">3</span>&#125;⇒&#123;<span class="number">2</span>&#125;。</span><br><span class="line">对于 𝑌=&#123;<span class="number">2</span>,<span class="number">3</span>&#125;Y=&#123;<span class="number">2</span>,<span class="number">3</span>&#125;，可以生成 &#123;<span class="number">2</span>,<span class="number">3</span>&#125;⇒&#123;<span class="number">1</span>&#125;。</span><br><span class="line">对于 𝑌=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;，通常不生成规则，因为没有剩余的项集可以作为规则的后件。</span><br></pre></td></tr></table></figure><ol><li>考虑下面的频繁3—项集的集合:{1,2,3},{1,2,4},{1,2,5},{1,3,4},{1,3,5},{2,3,4},{2,3,5},{3,4,5}假定数据集中只有5个项,采用合并策略,由候选产生过程得到4-项集不包含( )</li></ol><p>A1,2,3,4</p><p>B1,2,3,5</p><p>C1,2,4,5</p><p>D1,3,4,5</p><ul><li>合并两个频繁k-项集，以生成一个新的k+1-项集，前提是这两个k-项集有(k-1)个共同的项。</li></ul><ol><li>在图集合中发现一组公共子结构,这样的任务称为( )</li></ol><p>A频繁子集挖掘</p><p>B频繁子图挖掘</p><p>C频繁数据项挖掘</p><p>D频繁模式挖掘</p><ol><li>下面购物篮能够提取的3—项集的最大数量是多少()</li></ol><table><thead><tr><th>TID</th><th>项集</th></tr></thead><tbody><tr><td>1</td><td>牛奶，啤酒,尿布</td></tr><tr><td>2</td><td>面包,黄油，牛奶</td></tr><tr><td>3</td><td>牛奶，尿布，饼干</td></tr><tr><td>4</td><td>面包，黄油,饼干</td></tr><tr><td>5</td><td>啤酒,饼干,尿布</td></tr><tr><td>6</td><td>牛奶,尿布,面包,黄油</td></tr><tr><td>7</td><td>面包，黄油，尿布</td></tr><tr><td>8</td><td>啤酒，尿布</td></tr><tr><td>9</td><td>牛奶，尿布，面包，黄油</td></tr><tr><td>10</td><td>啤酒，饼干</td></tr></tbody></table><p>A1</p><p>B2</p><p>C3</p><p>D4</p><ol><li>可用作数据挖掘分析中的关联规则算法有().</li></ol><p>A决策树、对数回归、关联模式</p><p>BK均值法、SOM神经网络</p><p>CApriori算法、FP-Tree算法</p><p>DRBF神经网络、K均值法、决策</p><ol><li>关联规则的评价指标是:().</li></ol><p>A均方误差、均方根误差</p><p>BKappa统计、显著性检验</p><p>C支持度、置信度</p><p>D平均绝对误差、相对误差</p><ol><li>分析顾客就医行为,以便有针对性的向其推荐感兴趣的就医服务,属于()问题。</li></ol><p>A关联规则挖掘</p><p>B分类与回归</p><p>C聚类分析</p><p>D时序预测</p><ol><li>利用Apriori算法计算频繁项集可以有效降低计算频繁集的时间复杂度。在以下的购物篮中产生支持度不小于3的候选3—项集,在候选2-项集中需要剪枝的是( ) 。</li></ol><table><thead><tr><th>TID</th><th>项集</th></tr></thead><tbody><tr><td>1</td><td>面包、牛奶</td></tr><tr><td>2</td><td>面包、尿布、啤酒、鸡蛋</td></tr><tr><td>3</td><td>牛奶、尿布、啤酒、可乐</td></tr><tr><td>4</td><td>面包、牛奶、尿布、啤酒</td></tr><tr><td>5</td><td>面包、牛奶、尿布、可乐</td></tr></tbody></table><p>A啤酒、尿布</p><p>B啤酒、面包</p><p>C面包、尿布</p><p>D啤酒、牛奶</p><p>E面包、牛奶</p><ol><li>Apriori算法的计算复杂度受( )影响。</li></ol><p>A支持度阀值</p><p>B项数(维度)</p><p>C事务数</p><p>D事务平均宽度</p><p>E极差</p><ol><li>比率标度属性能提供关于顺序、差异以及比率关系的信息,关键之处在于“真正零值”能够被定义。√</li><li>当资料分布的末端无确切数据时不能计算算术平均值√</li><li>在图集合中发现一组公共子结构,这样的任务称为频繁子图挖掘。√</li><li>决策树方法通常用于关联规则挖掘。×</li><li>Apriori算法是一种典型的关联规则挖掘算法。√</li><li>关联规则挖掘过程是发现满足最小支持度的所有项集代表的规则。×</li><li>可信度是对关联规则的准确度的衡量×</li><li>利用先验原理可以帮助减少频繁项集产生时需要探查的候选项个数。√</li><li>先验原理可以表述为:如果一个项集是频繁的,那包含它的所有项集（应该是非空子集）也是频繁的×</li><li>回归分析通常用于挖掘关联规则。×</li></ol><h1 id="第五章-分类与回归算法"><a href="#第五章-分类与回归算法" class="headerlink" title="第五章: 分类与回归算法"></a>第五章: 分类与回归算法</h1><ol><li><h2 id="分类与回归概述"><a href="#分类与回归概述" class="headerlink" title="分类与回归概述"></a>分类与回归概述</h2></li></ol><p>分类：分类算法构造一个分类模型，模型的输入为样本的属性值，输出为对应的类别，将每个样本映射到预先定义好的类别。</p><p>回归: 回归算法则是建立两种或两种以上变量间相互依赖的函数模型，然后使用函数模型预测目标的值。</p><h3 id="常用的分类与回归算法"><a href="#常用的分类与回归算法" class="headerlink" title="常用的分类与回归算法"></a>常用的分类与回归算法</h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTVlOTc3MDI0NGIwOGE0MTIyNzZhODhjMWMyZGJkNmNfVFpWdTQ3cFZSZlBRc0FPcWMxN0NvZU5MSDJpM1daVjlfVG9rZW46WEJDRmI3blBMb0Nkemx4RkowQmNPNExZblhmXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><h3 id="最近邻分类"><a href="#最近邻分类" class="headerlink" title="最近邻分类"></a>最近邻分类</h3><p>K近邻（K-Nearest Neighbor，KNN）算法是一种常用的监督学习方法 。其原理非常简单：对于给定测试样本，基于指定的距离度量找出 训练集中与其最近的k个样本，然后基于这k个“邻居”的信息来进行预测</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MTljNTc4YzA4NmE1MDMyMzZiMDUwM2JmZjk4YWNiMTdfZXJoWk1yQWY5bTI4RGhOdnJZSGlDUVpxVkVCZTFOejdfVG9rZW46SHFoaWJsbTJXb09WSXB4cTNuRGNqZjg4bmxlXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>确定预测样本类别： 1. 投票法 2. 平均法</p><p>使用scikit-learn库中neighbors模块的KNeighborsClassifier类可以实现K近 邻算法对数据进行分类</p><p>具体使用实例(亲测可跑通)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入所需的库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report, accuracy_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据集</span></span><br><span class="line">iris = load_iris()</span><br><span class="line">X = iris.data  <span class="comment"># 特征数据</span></span><br><span class="line">y = iris.target  <span class="comment"># 标签数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化KNeighborsClassifier对象</span></span><br><span class="line"><span class="comment"># n_neighbors=3 表示选择最近的3个邻居</span></span><br><span class="line"><span class="comment"># weights=&#x27;uniform&#x27; 表示所有邻居的权重相同</span></span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">3</span>, weights=<span class="string">&#x27;uniform&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">knn.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测测试集</span></span><br><span class="line">y_pred = knn.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评估模型</span></span><br><span class="line">accuracy = accuracy_score(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Accuracy: <span class="subst">&#123;accuracy:<span class="number">.2</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印分类报告</span></span><br><span class="line"><span class="built_in">print</span>(classification_report(y_test, y_pred))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化KNN决策边界（可选）</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了可视化，我们只取两个特征</span></span><br><span class="line">X = iris.data[:, :<span class="number">2</span>]  <span class="comment"># 只取前两个特征</span></span><br><span class="line">y = iris.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">knn.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建网格以绘制决策边界</span></span><br><span class="line">x_min, x_max = X[:, <span class="number">0</span>].<span class="built_in">min</span>() - <span class="number">1</span>, X[:, <span class="number">0</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">y_min, y_max = X[:, <span class="number">1</span>].<span class="built_in">min</span>() - <span class="number">1</span>, X[:, <span class="number">1</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class="number">0.1</span>),</span><br><span class="line">                     np.arange(y_min, y_max, <span class="number">0.1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测网格点的类别</span></span><br><span class="line">Z = knn.predict(np.c_[xx.ravel(), yy.ravel()])</span><br><span class="line">Z = Z.reshape(xx.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制决策边界和训练样本</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.contourf(xx, yy, Z, alpha=<span class="number">0.4</span>)</span><br><span class="line">plt.scatter(X_train[:, <span class="number">0</span>], X_train[:, <span class="number">1</span>], c=y_train, edgecolors=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Feature 1&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Feature 2&#x27;</span>)</span><br><span class="line">plt.xlim(xx.<span class="built_in">min</span>(), xx.<span class="built_in">max</span>())</span><br><span class="line">plt.ylim(yy.<span class="built_in">min</span>(), yy.<span class="built_in">max</span>())</span><br><span class="line">plt.xticks(())</span><br><span class="line">plt.yticks(())</span><br><span class="line">plt.title(<span class="string">&#x27;3-Class classification (K = 3)&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="线性回归模型"><a href="#线性回归模型" class="headerlink" title="线性回归模型"></a>线性回归模型</h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=M2ExNjdjZmY3ODk3MWNkZjM4YTc0YjczODA5NzViYzlfWDBFUzJDNm0xblQzTFRxZEVOVXZsSWdwamltYno3QUhfVG9rZW46UnozRWJodGs3b0Zoa1N4YVdlVmNxcmI2bmtiXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>使用scikit-learn库中linear_model模块的LinearRegression类可以建立 线性回归模型</p><p>下面是一个实例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入所需的库</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error, r2_score</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一些示例数据</span></span><br><span class="line"><span class="comment"># 假设我们有一组数据点，x是特征，y是目标变量</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">X = <span class="number">2</span> * np.random.rand(<span class="number">100</span>, <span class="number">1</span>)  <span class="comment"># 100个样本，1个特征</span></span><br><span class="line">y = <span class="number">4</span> + <span class="number">3</span> * X + np.random.randn(<span class="number">100</span>, <span class="number">1</span>)  <span class="comment"># y = 4 + 3x + 噪声</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化LinearRegression对象</span></span><br><span class="line">lr = LinearRegression()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">lr.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测测试集</span></span><br><span class="line">y_pred = lr.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评估模型</span></span><br><span class="line">mse = mean_squared_error(y_test, y_pred)</span><br><span class="line">r2 = r2_score(y_test, y_pred)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Mean squared error: <span class="subst">&#123;mse:<span class="number">.2</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Coefficient of determination (R^2): <span class="subst">&#123;r2:<span class="number">.2</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印模型参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Slope (weight): <span class="subst">&#123;lr.coef_&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Intercept: <span class="subst">&#123;lr.intercept_&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="逻辑回归模型"><a href="#逻辑回归模型" class="headerlink" title="逻辑回归模型"></a>逻辑回归模型</h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=OGQ0YWJjNGU4ZTdlODg2NDk1ZWYzZmE2NTM4YWJhY2JfZHJwMGlLanRwaFFsVFFhcG1wRWdhYTE4UTlHaU9uRUxfVG9rZW46Q2l3SWIxQXltb3RBaDF4TWVyMmNpWFpDbmVoXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>使用scikit-learn库中linear_model模块的LogisticRegression类可以建立逻 辑回归模型</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入所需的库</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_classification</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score, confusion_matrix, classification_report</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一些示例二分类数据</span></span><br><span class="line">X, y = make_classification(n_samples=<span class="number">1000</span>, n_features=<span class="number">20</span>,</span><br><span class="line">                           n_informative=<span class="number">2</span>, n_redundant=<span class="number">10</span>,</span><br><span class="line">                           random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化LogisticRegression对象</span></span><br><span class="line"><span class="comment"># 默认情况下，solver=&#x27;lbfgs&#x27;，penalty=&#x27;l2&#x27;（正则化项）</span></span><br><span class="line">log_reg = LogisticRegression(max_iter=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">log_reg.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测测试集</span></span><br><span class="line">y_pred = log_reg.predict(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 评估模型</span></span><br><span class="line">accuracy = accuracy_score(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Accuracy: <span class="subst">&#123;accuracy:<span class="number">.2</span>f&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印混淆矩阵</span></span><br><span class="line">conf_matrix = confusion_matrix(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Confusion Matrix:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(conf_matrix)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印分类报告</span></span><br><span class="line">class_report = classification_report(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Classification Report:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(class_report)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印模型的权重和截距</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Model Coefficients:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(log_reg.coef_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Intercept: <span class="subst">&#123;log_reg.intercept_&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><ol><li><h2 id="模型评价"><a href="#模型评价" class="headerlink" title="模型评价"></a>模型评价</h2></li></ol><h3 id="分类模型评价"><a href="#分类模型评价" class="headerlink" title="分类模型评价"></a>分类模型评价</h3><p>对于分类模型的评价，常用的模型评价指标包括了准确率、精确率、反馈率、混淆矩阵和ROC曲线等</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MTJhYmNmNzdiMGJlZWFjOTAxYzI5YjBjNzI3MWQ4ODdfaUx6VDg3VW82N0hoMlk3d2VkYmR1ckF3R2l6MUJpSjVfVG9rZW46VVBucWJTZUlJb2VwRDl4N3hwNmNMTE1tbkRmXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MjY5NzkxMzRiNzAyNzk5ZDU4NDU2NTMzOWMyZjlkNThfT1RCcXlZZmFYa1JPNzhiN2w1bGd2c3JuWHFLSm9vS3lfVG9rZW46TGU5a2JkY0V5b3NJS2N4WnRaU2NlR01sblZnXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjI2NDE5NzhkMDljNTFjM2I5ZGEzYTljNTc4NjE5ZmJfOXU2ZjVNdVg2TGs0NWhiOE9MbjdzVVl3ancycFN3SGJfVG9rZW46Q3lzMWJSM3V2b29reHV4c0VpMWMyR1k2bjlnXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGJhMTU0NDY1ZGYxODJiZGM0NDFiM2JiMWMyMjk5MjdfSlJ1a3BBYWlDeld0dXhmWnlXYXlWQ29DWFp0NzA3ZThfVG9rZW46RzVkN2J3dGxyb2dtYU54ZWpaWGNjQmhybkJoXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>接收者操作特征曲线（Receiver Operating Characteristic curve，ROC曲 线）是一种非常有效的模型评价方法，可为选定临界值给出定量提示。</p><h3 id="回归模型评价"><a href="#回归模型评价" class="headerlink" title="回归模型评价"></a>回归模型评价</h3><p>对于回归模型，常用的模型评价指标包括了绝对误差 与相对误差、误差分析中的综合指标（平均绝对误差、 均方误差、均方根误差）、平均绝对百分误差和 Kappa统计量等</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NWY5MDRjMDM1OTkzNzI0MGViYzFlNDYwODgzNTk2YzdfYmNITFZBMG1jRXF0Q2ZEaVlla281Y3NyeTNCdmlGNXVfVG9rZW46SmFuaGJlWVl3b1p4bmZ4Tkg0OGNHYVJPbkxnXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MDQ3ODM0ZTUzY2JjYjRhMGQ1YzFhMDNiMjI4NDZmNTFfbnVPbHJpVnZ5TnRDeHJTTDN5WGhyd2ZMZmRQQXg0RW5fVG9rZW46RlZIc2JzSElXb3pwVGZ4d3RrV2NKMnZsbndxXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>Kappa统计是比较两个或多个观测者对同一事物，或观测者对同一事物的两次 或多次观测结果是否一致，将由随机造成的一致性和实际观测的一致性之间的 差别大小作为评价基础的统计指标。</p><ol><li><h2 id="决策树算法"><a href="#决策树算法" class="headerlink" title="决策树算法"></a>决策树算法</h2></li></ol><p>决策树是一树状结构，它的每一个叶节点对应着一个分类，非叶节点 对应着在某个属性上的划分，根据样本在该属性上的不同取值将其划 分成若干个子集。</p><h3 id="纯度的度量"><a href="#纯度的度量" class="headerlink" title="纯度的度量"></a>纯度的度量</h3><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NTU1OWUyOGQ1ZDFlOWM1YWE5OWNmYmQwZTNjYTEyNmJfVHpjTHRFc0ZCRGxWcjNKZ1lOMVJSQkNJejJrQ0pETjFfVG9rZW46RjZKemIyNkZxb1h6Z254SXVMRmNJbzR4bkdiXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>常用的决策树算法:</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmY3MjUwZWE3YWRhODRlNjI3NzNmYjYyZmZiNGE2MmRfbk94UGZ1Wm9UQUJUQWtmWVVIQjc1SGFOR0ZHd0xjVDRfVG9rZW46Uk41bWIySGpCb0ZVUGZ4SUZabGNmOGg0blFiXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NmYzMWJiYjhkN2E1NThmYzJlYWY0ODE5MmY2YjVkNGJfZW9Kb1RYREFxMGpDTGtnUldQYno1d2NGNXFOYzM3R2NfVG9rZW46THhWbWJmM0xDb1lISHB4cE5GSWNqbDZtbkdoXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>使用scikit-learn库中tree模块的DecisionTreeClassifier类可以建立决策树模 型</p><ol><li><h2 id="支持向量机算法"><a href="#支持向量机算法" class="headerlink" title="支持向量机算法"></a>支持向量机算法</h2></li></ol><p>支持向量机（Support Vector Machines，SVM）的思想是 在样本空间中找到一个划分超平面，将不同类别的样本分开。</p><p>在样本空间中，划分超平面可通过线性方程来描述</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YTQxMzkxMmE0MGFjMWRiMDg4N2Q2Y2Q2M2E3OWZiNWNfb0NMTTl1cDFSUHlLYWY4dEF6ZTBNM2tMNGpXNXc1ZzhfVG9rZW46VkFTcGI2Y1M2b3hOSlV4V2d6S2MyMkVvbm9oXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MWJmNDgyZjk2Y2ZhZjM2ZDMyNmJlM2RiNGVhMGQ1MWZfMVZGaG5QT3VVRDMzOURqWEZiWm5jc2FWQm9KYzB5Y3FfVG9rZW46RFJqWGJkdFNSb01SenB4VEFyR2N4S1FPbmhkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><h3 id="线性支持向量机"><a href="#线性支持向量机" class="headerlink" title="线性支持向量机"></a>线性支持向量机</h3><p>基本步骤</p><ul><li>将原问题转化为凸优化问题</li><li>通过构建拉格朗日函数，将原问题对偶化。</li><li>对对偶化后的问题进行求解。</li></ul><h3 id="非线性支持向量机"><a href="#非线性支持向量机" class="headerlink" title="非线性支持向量机"></a>非线性支持向量机</h3><p>将样本从原始空间映射到一个更高维的特征空间，使得样本在这个特征空间内线性可分</p><p>然而由于映射后的特征空间维数可能很高，直接计算通常是很困难的， 为了避开这个障碍，会利用已知的核函数直接进行计算：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZThjYTYzZjMwNGJkYzAyYjdjOTIzMGNhMmE5NjI3OWRfZUNEcFNCdjJCMk5VTlN3ZXh3Skx5NlZZVGIyajNOd0hfVG9rZW46SFkxeWI1UkZRbzFGZUh4R0VSMGNrUkVoblNjXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>使用scikit-learn库中svm模块的SVC类可以实现支持向量机算法对 数据进行分类</p><ol><li><h2 id="集成学习算法"><a href="#集成学习算法" class="headerlink" title="集成学习算法"></a>集成学习算法</h2></li></ol><p>集成学习算法通过组合多种学习算法来获得比任何单独的学习算法具 有更好的预测性能的估计器。对于训练集数据，我们通过训练若干个 个体学习器（individual learner），通过一定的结合策略，就可以最终 形成一个强学习器，以达到博采众长的目的</p><p>Bagging的个体弱学习器的训练集是通过随机采样得到的。通过T次的 随机采样，我们就可以得到T个采样集，对于这T个采样集，我们可以 分别独立的训练出T个弱学习器，再对这T个弱学习器通过集合策略来 得到最终的强学习器</p><h3 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h3><p>Bagging的个体弱学习器的训练集是通过随机采样得到的。通过T次的 随机采样，我们就可以得到T个采样集，对于这T个采样集，我们可以 分别独立的训练出T个弱学习器，再对这T个弱学习器通过集合策略来 得到最终的强学习器</p><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><p>随机森林（Random Forest，RF）是Bagging的一个拓展，RF在以决策树 为基分类器构建Bagging学习器的基础上，进一步在决策树的训练过程 中引入了随机属性选择</p><h3 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h3><p>Boosting（提升）是一个可将弱学习器提升为强学习器的算法。这个 算法的工作机制为：赋予一个相等的初始权重给每个训练样本；迭代 地学习k个分类器，学习得到弱学习器1之后，更新权重，使得后面的 分类器更关注误分类的训练样本；最后的分类器组合每个个体分类器 的表决结果</p><p>使用scikit-learn库中ensemble模块的GradientBoostingClassifier类可以建 立梯度提升决策树模型</p><h3 id="梯度提升机"><a href="#梯度提升机" class="headerlink" title="梯度提升机"></a>梯度提升机</h3><p>梯度提升机（Gradient Boosting Machine，GBM）是一种Boosting的方法，其提高 模型精度的方法与传统Boosting对正确、错误样本进行加权不同，该模型通过在残差减 少的梯度（Gradient）方向上建立一个新的模型，从而降低新模型的残差（Residual）。 即每个新模型的建立是为了使得之前模型的残差往梯度方向减少</p><h3 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h3><p>Stacking集成学习方法是指训练一个模型用于组合其他各个模型。首先 我们先训练多个不同的模型（初级学习器），然后把之前训练的各个 模型的输出为输入来训练一个模型（次级学习器），以得到一个最终 的输出</p><p>使用scikit-learn库中ensemble模块的StackingClassifier类可以建立 Stacking分类模型</p><ol><li><h2 id="丹参生长影响指标筛选"><a href="#丹参生长影响指标筛选" class="headerlink" title="丹参生长影响指标筛选"></a>丹参生长影响指标筛选</h2></li></ol><p>看不懂</p><ol><li><h2 id="肺癌转移影响因素及生存分析"><a href="#肺癌转移影响因素及生存分析" class="headerlink" title="肺癌转移影响因素及生存分析"></a>肺癌转移影响因素及生存分析</h2></li></ol><p>看不懂</p><ol><li><h2 id="第五章相关试题"><a href="#第五章相关试题" class="headerlink" title="第五章相关试题"></a>第五章相关试题</h2></li><li><p>下列问题,属于回归的是()</p></li></ol><p>A通过症状判别证型</p><p>B胃癌术后五年期生存率分析</p><p>C根据影像对病程分期</p><p>D根据患者证症推荐医生</p><p>我觉得这个答案应该是B，但是老师给的答案是C</p><ol><li>下列说法错误的是()。</li></ol><p>A支撑向量机可以用来进行拟合函数。</p><p>B支撑向量机可以用于多分类问题。</p><p>C支撑向量机需要大量训练样本。</p><p>D支撑向量机通过核函数将数据映射到高维空间,从而能够解决非线性问题。</p><ol><li>患者试纸检测结果是阳性,实际真实值是阴性,则试纸结果是()</li></ol><p>A TP</p><p>B TN</p><p>C FP</p><p>D FN</p><ul><li>TP (True Positive)：真正例，即检测结果为阳性且实际也是阳性。</li><li>TN (True Negative)：真负例，即检测结果为阴性且实际也是阴性。</li><li>FP (False Positive)：假正例，即检测结果为阳性但实际是阴性。</li><li>FN (False Negative)：假负例，即检测结果为阴性但实际是阳性。</li></ul><ol><li>在医学疾病筛查中,希望尽量小的是()</li></ol><p>A Recall</p><p>B Precision</p><p>C Accuracy</p><p>D 漏检率</p><ol><li>当Kappa(),说明已经取得相当满意的一致程度。</li></ol><p>A在区间[-1,1]内</p><p>B大于等于0.75时</p><p>CKappa&#x3D;1</p><p>DKappa&lt;0.4</p><ol><li>下面是SVM算法中需要指定的超参数 () 。</li></ol><p>A C</p><p>B alpha</p><p>C bias</p><p>D omiga</p><ol><li>ROC曲线下方的面积就是()</li></ol><p>A LOT</p><p>B TPR</p><p>C FPR</p><p>D AUC</p><ol><li>（）算法只适用于离散的描述属性。</li></ol><p>A ID3</p><p>B C4.5</p><p>C CART决策树</p><p>D SLIQ</p><ol><li>常见的非线性映射核有()</li></ol><p>ARBF核</p><p>B多项式核</p><p>Csigmoid核</p><p>D拉普拉斯核</p><p>ESobel核</p><ol><li>集成学习有如下几种方式()</li></ol><p>ABagging</p><p>BBoosting</p><p>CAdaboost</p><p>DStacking</p><p>EID3</p><ol><li>K近邻(K-Nearest Neighbor,KNN)算法是一种常用的监督学习方法。√</li><li>最近邻算法是K近邻算法的一个特例。√</li><li>决策树算法通常按照纯度的增加来选择拆分属性√</li><li>C4.5决策树生成算法相对于ID3算法的重要改进是使用信息增益率来选择节点属性。√</li><li>为了评价回归模型,一般让模型预测单个点的值进行评价以免受到噪声影响而不准×</li><li>当Kappa&gt;0时,说明有意义,Kappa愈大,说明一致性愈好。√</li><li>Bagging算法中个体学习器间存在强依赖关系。×</li><li>Bagging的个体弱学习器的训练集是通过随机采样得到的。√</li><li>随机森林RF算法是Stacking的一个拓展×</li><li>均方误差开根号后就变成均方根误差√</li></ol><h1 id="第六章-聚类算法"><a href="#第六章-聚类算法" class="headerlink" title="第六章: 聚类算法"></a>第六章: 聚类算法</h1><ol><li><h2 id="聚类算法概述"><a href="#聚类算法概述" class="headerlink" title="聚类算法概述"></a>聚类算法概述</h2></li></ol><p>与分类不同，聚类分析是在没有给定划分类别的情况下，根据数据相似度进行样本分组 的一种方法。聚类的输入是一组未被标记的样本，聚类根据数据自身的距离或相似度将他们 划分为若干组，划分的原则是组内样本最小化而组间（外部）距离最大化。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NDRkYzJjMTYzMGIxNDhlMDY2NjZiMzI2MDg4N2RjMmFfTjVBbnF3Nzk1c3Y5MjVWNzAzejU5WDF6MjdoRUNTMFBfVG9rZW46UVN4WWJTVFZqb0I0cWd4M1VidWNBNDdkbnNlXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><h3 id="距离度量"><a href="#距离度量" class="headerlink" title="距离度量"></a>距离度量</h3><p>常见距离度量有：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=NjI5YTlhOGQ0MDExZjAwNmJjNDIzZTU1NjA0MDhhMGVfUVQ3bkQySlVMTkxiZ2s1Rkx5RDZoaXhibk9uaVp6YktfVG9rZW46VFZ0NWJlUXNib2xKTUd4RGVrSGNuOHRYbjk0XzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><h3 id="聚类算法评价指标"><a href="#聚类算法评价指标" class="headerlink" title="聚类算法评价指标"></a>聚类算法评价指标</h3><p>聚类分析仅根据样本数据本身将样本分组，组内的对象相互之间是相似的（相关的），而 不同组中的对象是不同的（不相关的）。组内的相似性越大，组间差别越大，聚类效果就越好。</p><p>常见评价法有：</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2U2ZjFjZThjNmFjNjNhOWYxODg3OGVmMGVjNjhjMmZfcVJrNGhLaVN3RTQxQ0l6ZExoMUlxcm9mcXJYelRHVFpfVG9rZW46U0NKRGI2OHhBb0lrTEJ4eXpHRmNUcUk1bnFkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li><h2 id="基于划分的聚类算法"><a href="#基于划分的聚类算法" class="headerlink" title="基于划分的聚类算法"></a>基于划分的聚类算法</h2></li></ol><h3 id="K-Means聚类"><a href="#K-Means聚类" class="headerlink" title="K-Means聚类"></a>K-Means聚类</h3><p>K-Means算法是典型的基于距离的非层次聚类算法，在最小化误差函数的基础上将数据划分 为预定的类数K，采用距离作为相似性的衡量指标，即认为两个对象的距离越近，相似度就越大。</p><p>1.相似度度量</p><p>2.算法过程</p><p>K均值算法的具体步骤如下：</p><p>（1）从N个样本数据中随机选取K个对象作为初始的聚类中心。</p><p>（2）分别计算每个样本到各个聚类中心的距离，将对象分配到距离最近的聚类中。</p><p>（3）所有对象分配完成后，重新计算K个聚类的中心。</p><p>（4）与前一次计算得到的K个聚类中心比较，如果聚类中心发生变化，转步骤（2），否则转步骤 （5）</p><p>（5）当质心不发生变化时停止并输出聚类结果</p><p>3.目标函数</p><p>使用误差平方和准则（Sum Squared Error，SSE）作为度量聚类质量的目标函数， 对于两种不同的聚类结果，选择误差平方和较小的分类结果</p><p>4.具体实现</p><p>使用scikit-learn库中cluster模块的KMeans类可以实现K-Means聚类算法对数据进行聚类</p><h3 id="二分K均值聚类"><a href="#二分K均值聚类" class="headerlink" title="二分K均值聚类"></a>二分K均值聚类</h3><ul><li>使用小批量的样本而不是整个数据集对群集质心进行更新</li><li>通过 MiniBatchKMeans 类实现的</li><li>优化的主配置是“ n _ clusters ”超参数，设置为数据中估计的群集数量</li></ul><h3 id="K中心点算法"><a href="#K中心点算法" class="headerlink" title="K中心点算法"></a>K中心点算法</h3><ul><li>为每个簇随意选择一个代表对象</li><li>剩余对象根据其与代表对象的距离分配给最近的一个簇</li><li>反复用非代表对象来代替代表对象，改进聚类质量</li></ul><ol><li><h2 id="信用卡风险识别模型"><a href="#信用卡风险识别模型" class="headerlink" title="信用卡风险识别模型"></a>信用卡风险识别模型</h2></li></ol><p>看不懂</p><ol><li><h2 id="基于层次的聚类算法"><a href="#基于层次的聚类算法" class="headerlink" title="基于层次的聚类算法"></a>基于层次的聚类算法</h2></li></ol><h3 id="层次聚类"><a href="#层次聚类" class="headerlink" title="层次聚类"></a>层次聚类</h3><p>试图在不同层次上对样本集进行划分 进而达到形成树形的聚类结构</p><p>在运用层次聚类法时，需要对类与类之间的距离做出规定，按照规定的不同，形成了基于 最短距离、最长距离和平均距离的层次聚类法</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MTVkNWE0YmUxN2Y5YjEyZTU3MWMyMDk4YjEzNTUzMmFfVHhMMXVhVkdSakU5NU1HaVJ5ajNDY3hCNU5qWWFWakJfVG9rZW46TXhFUmJVdDJSb2xubFB4MnU1S2NPNlIybmpiXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>聚集系统法具体步骤</p><p>（1） 输入样本集合、对聚类簇函数做出规定给出聚类的簇数。</p><p>（2） 将每个样本点作为单独的一簇。</p><p>（3） 计算任何两个簇之间的距离。</p><p>（4） 按照距离最近原则合并簇。</p><p>（5） 若当前聚类簇数未到达规定的聚类簇数，则返回步骤（3） 否则聚类结束。</p><p>（6） 输出聚类结果。</p><p>使用scikit-learn库中cluster模块的AgglomerativeClustering类可以实现层次聚类算法对数 据进行聚类</p><h3 id="BIRCH算法"><a href="#BIRCH算法" class="headerlink" title="BIRCH算法"></a>BIRCH算法</h3><p>阶段一：扫描数据库，构造一棵能够存放 于内存中的CF树。</p><p>阶段二：选用一个聚类算法对CF树的叶 节点聚类，把稀疏的簇当做离群点删除， 把稠密的簇合并为更大的簇</p><p>CF</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjJkMTg0MWI2MjQ5YTEzNmMwY2NjMDhkMjMzODBjYjJfMGJTZlVoZ3hxbjY3SEhVYzhMNUZGeTdLNDZkYjFrc0ZfVG9rZW46Q1k0a2I3aHY5b2FvQ0h4cnpNUGNxUldlblplXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ul><li>从根节点root 开始递归往下，计算当前条目与要插入数据点之间 的距离，寻找距 离最小的那个路径，直到找到与该数据点最接近 的叶节点中的条目。</li><li>比较计算出的距离是否小于阈值T，如果小于则当前条目吸收该数 据点；反之，则 继续第三步。</li><li>判断当前条目所在叶节点的条目个数是否小于L，如果是，则直接 将数据点插入作 为该数据点的新条目，否则需要分裂该叶节点。</li></ul><ol><li><h2 id="道地药材文本数据挖掘"><a href="#道地药材文本数据挖掘" class="headerlink" title="道地药材文本数据挖掘"></a>道地药材文本数据挖掘</h2></li></ol><p>看不懂</p><ol><li><h2 id="基于密度的聚类算法"><a href="#基于密度的聚类算法" class="headerlink" title="基于密度的聚类算法"></a>基于密度的聚类算法</h2></li></ol><p>密度聚类</p><p>以样本点在空间分布上的稠密程度为依据进 行聚类 p若区域中的样本密度大于某个阈值，则将相 应的样本点划入与之相近的簇中</p><h3 id="DBSCAN算法"><a href="#DBSCAN算法" class="headerlink" title="DBSCAN算法"></a>DBSCAN算法</h3><p>（1） 输入样本集合、初始化距离参数 ，数目参数 。</p><p>（2） 确定核心对象集合。</p><p>（3） 在核心对象集合中，随机选择一个核心对象作为种子。</p><p>（4） 依据簇划分原则生成一个簇，并更新核心对象集合。</p><p>（5） 若核心对象集合为空，则算法结束，否则返回步骤（3）。</p><p>（6） 输出聚类结果</p><p>使用scikit-learn库中cluster模块的DBSCAN类可以实现密度聚类算法对数据进行聚类</p><h3 id="OPTICS算法"><a href="#OPTICS算法" class="headerlink" title="OPTICS算法"></a>OPTICS算法</h3><ul><li>为聚类分析生成一个增广的簇排序</li><li>排序代表了各样本点基于密度的聚类结构</li></ul><p>对象p的核心距离是 指是p成为核心对象 的最小E’ 。如果p不 是核心对象，那么p 的核心距离没有任何 意义。</p><p>对象q到对象p的可达距离是 指p的核心距离和p与q之间 欧几里得距离之间的较大值。 如果p不是核心对象，p和q 之间的可达距离没有意义</p><p>基本过程:</p><p>（1） 创建两个队列，有序队列和结果队列。</p><p>（2） 如果所有样本集D中所有点都处理完毕，则算法结束。否则，选择一个未处理（即不在结果队列中）且为核心对象的样本点，找到其所 有直接密度可达样本点，如果该样本点不存在于结果队列中，则将其放 入有序队列中，并按可达距离排序；</p><p>（3）如果有序队列为空，则跳至步骤2，否则，从有序队列中取出第一 个样本点（即可达距离最小的样本点）进行拓展，并将取出的样本点保 存至结果队列中，如果它不存在结果队列当中的话。</p><p>（4）算法结束，输出结果队列中的有序样本点。</p><ol><li><h2 id="第六章相关试题"><a href="#第六章相关试题" class="headerlink" title="第六章相关试题"></a>第六章相关试题</h2></li><li><p>当不知道数据所带标签时,可以使用哪种技术促使带同类标签的数据与带其他标签的数据相分离?()</p></li></ol><p>A分类</p><p>B聚类</p><p>C关联分析</p><p>D回归</p><ol><li>通过聚集多个分类器的预测来提高分类准确率的技术称为 ()</li></ol><p>A组合(ensemble)</p><p>B聚集(aggregate)</p><p>C合并(combination)</p><p>D投票(voting)</p><ol><li>简单地将数据对象集划分成不重叠的子集,使得每个数据对象恰在一个子集中,这种聚类类型称作()</li></ol><p>A层次聚类</p><p>B划分聚类</p><p>C非互斥聚类</p><p>D模糊聚类</p><ol><li>在基本K均值算法里,当邻近度函数采用()的时候,合适的质心是簇中各点的中位数.</li></ol><p>A曼哈顿距离</p><p>B平方欧几里德距离</p><p>C余弦距离</p><p>D切比雪夫距离</p><ol><li>DBSCAN是一种()。</li></ol><p>A分类器</p><p>B聚类算法</p><p>C关联分析算法</p><p>D特征选择算法</p><ol><li>将两个簇的邻近度定义为不同簇的所有点对的平均逐对邻近度,它是一种凝聚层次聚类技术。</li></ol><p>AMIN(单链)</p><p>BMAX(全链)</p><p>C组平均</p><p>DWard方法</p><ol><li>将两个簇的邻近度定义为两个簇合并时导致的平方误差的增量,它是一种凝聚层次聚类技术。</li></ol><p>AMIN(单链)</p><p>BMAX(全链)</p><p>C组平均</p><p>DWard方法</p><ol><li>关于K均值和DBSCAN的比较,以下说法不正确的是()。</li></ol><p>AK均值丢弃被它识别为噪声的对象,而DBSCAN一般聚类所有对象</p><p>BK均值使用簇的基于原型的概念,而DBSCAN使用基于密度的概念。</p><p>CK均值很难处理非球形的簇和不同大小的簇,DBSCAN可以处理不同大小和不同形状的簇</p><p>DK均值可以发现不是明显分离的簇,即便簇有重叠也可以发现,但是DBSCAN会合并有重叠的簇。</p><ol><li>以下属于聚类算法的是()。</li></ol><p>AK—Means</p><p>BDBSCAN</p><p>CApriori</p><p>DKNN</p><p>EBayes</p><ol><li>都属于簇有效性的监督度量。</li></ol><p>A轮廓系数</p><p>B共性分类相关系数</p><p>C熵</p><p>DF度量</p><p>E余弦距离</p><ol><li>聚类是指将物理或抽象对象的集合分组成为由类似的对象组成的多个类的过程√</li><li>用于分类的离散化方法之间的根本区别在于是否使用类信息。√</li><li>简单地将数据对象集划分成不重叠的子集,使得每个数据对象恰在一个子集中,这种聚类类型称作划分聚类。√</li><li>在基本K均值算法里,当邻近度函数采用曼哈顿距离的时候,合适的质心是簇中各点的中位数。√</li><li>聚类是这样的过程:它找出描述并区分数据类或概念的模型(或函数),以便能够使用模型预测类标记未知的对象类。×</li><li>在聚类分析当中,簇内的相似性越大,簇间的差别越大,聚类的效果就越差。×</li><li>聚类分析可以看作是一种非监督的分类。√</li><li>K均值是一种产生划分聚类的基于密度的聚类算法,簇的个数由算法自动地确定×</li><li>基于邻近度的离群点检测方法不能处理具有不同密度区域的数据集。√</li><li>如果一个对象不强属于任何簇,那么该对象是基于聚类的离群点。√</li></ol><h1 id="第七章：算法应用，看一遍即可，重点记住题"><a href="#第七章：算法应用，看一遍即可，重点记住题" class="headerlink" title="第七章：算法应用，看一遍即可，重点记住题"></a>第七章：算法应用，看一遍即可，重点记住题</h1><h2 id="第七章相关试题"><a href="#第七章相关试题" class="headerlink" title="第七章相关试题"></a>第七章相关试题</h2><ol><li>关于随机抽样,下列说法正确的是()。</li></ol><p>A抽样时应使得总体中的每一个个体都有同等机会被抽取</p><p>B研究者在抽样时应精心挑选个体,以使样本更能代表总体</p><p>C随机抽样即随意抽取个体</p><p>D为确保样本具有更好的代表性,样本量越大越好</p><ol><li>报上登出了国内20家大医院的名单,名单按他们在近三年中病人死亡率的高低排序。专家指出不能把名单排列的顺序作为评价医院医疗水平的标准。以下各项,如果是真的,都能做论据支持专家的结论,除了哪一项()。</li></ol><p>A这20家医院中,有5家医院依靠国家资助从国外引进了多项先进、大型和配套的医疗设备,其余15家都没有。</p><p>B有些医院,留病人住院的时间长,病人死亡率因此较高;有些医院,往往较早地动员患绝症而救治无望的病人出院,病人死亡率因此较低。</p><p>C这20家医院中,有2家老人医院和3家儿童医院。</p><p>D20家医院中,有2家是肿瘤医院。</p><ol><li>下列哪项检验不适用χ2检验()。</li></ol><p>A两样本均值比较</p><p>B两样本率比较</p><p>C构成比比较</p><p>D拟合优度检验</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A. 两样本均值比较 - 这通常使用t检验或ANOVA（方差分析）来完成，而不是χ<span class="number">2</span>检验。</span><br><span class="line">B. 两样本率比较 - 可以使用χ<span class="number">2</span>检验来分析两个独立样本的分类变量频率是否相同。</span><br><span class="line">C. 构成比比较 - 这通常指的是比较不同类别的构成比例，χ<span class="number">2</span>检验可以用于此目的。</span><br><span class="line">D. 拟合优度检验 - 这是检验实际观测值与理论值是否一致的检验，χ<span class="number">2</span>检验是常用的方法之一。</span><br></pre></td></tr></table></figure><ol><li>为研究矽肺患者肺功能的变化情况,某医院对I、II期肺硅沉着病患者各35名测定其肺活量,得到I期患者的均值2700ml,标准差137ml;II期患者均值2800ml,标准差125ml,欲求I、II期肺硅沉着病患者的肺活量是否有显著性差异,宜采用什么统计方法()。</li></ol><p>Aχ2检验</p><p>Bt检验</p><p>Clogit回归</p><p>D秩和检验</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A. χ<span class="number">2</span>检验 - 适用于分类数据的关联性检验，不适用于比较两个独立样本的均值。</span><br><span class="line">B. t检验 - 适用于比较两个独立样本的均值，特别是当样本量较小（通常小于<span class="number">30</span>）且数据近似正态分布时。由于这里每组样本量为<span class="number">35</span>，且没有提到数据分布，如果数据近似正态分布，t检验是合适的。</span><br><span class="line">C. logit回归 - 用于二分类结果变量的回归分析，不适用于比较两个独立样本的均值。</span><br><span class="line">D. 秩和检验 - 又称为Mann-Whitney U检验，适用于两个独立样本的非参数比较，当数据不满足正态分布或方差不齐时使用。</span><br></pre></td></tr></table></figure><ol><li>下表为某项指标频数分布表，描述其集中趋势宜采用什么指标（）。</li></ol><table><thead><tr><th>组段</th><th>频数</th><th>频率</th><th>百分比（%）</th></tr></thead><tbody><tr><td>10~</td><td>35</td><td>0.35</td><td>35</td></tr><tr><td>20~</td><td>45</td><td>0.45</td><td>45</td></tr><tr><td>30~</td><td>15</td><td>0.15</td><td>15</td></tr><tr><td>40~</td><td>4</td><td>0.04</td><td>4</td></tr><tr><td>50~60</td><td>1</td><td>0.01</td><td>1</td></tr><tr><td>合计</td><td>100</td><td>1</td><td>100</td></tr></tbody></table><p>A算数均数</p><p>B几何均数</p><p>C中位数</p><p>D百分位数</p><ol><li>某医生研究复方哌唑嗪对高血压的治疗效果，以复方降压片为对照，结果如下表，问两种药物效果有无显著性差别，宜采用何种统计方法（）。</li></ol><table><thead><tr><th></th><th>治疗例数</th><th>有效例数</th><th>有效率（%）</th></tr></thead><tbody><tr><td>复方哌唑嗪</td><td>40</td><td>35</td><td>87.5</td></tr><tr><td>复方降压片</td><td>30</td><td>20</td><td>66.67</td></tr></tbody></table><p>Aχ2检验</p><p>Bt检验</p><p>C方差分析</p><p>D秩和检验</p><ol><li>某地区某病患病率20%,随机从该地抽出50人,则患病人数的数学期望和方差分别为多少()。</li></ol><p>A25和8</p><p>B10和2.8</p><p>C25和64</p><p>D10和8</p><ol><li>已知σ2时,区间（）的含义是()。</li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YWFjMWFmYzgyMzk4YTRiMDM3MjMxN2I3OGVlMmZiZGFfa1d3SExCT3FiNktrOUttN3BFZXc2R2RsTGxINGlYYmlfVG9rZW46TkFYbmJiRldkb0pxZ0h4UE94UmNORWdubnhkXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><p>A95%的总体均值在此范围内</p><p>B样本均值的95%置信区间</p><p>C95%的样本均值在此范围内</p><p>D总体均值的95%置信区间</p><ol><li>下列选项中,哪几项是实验设计的基本原则()。</li></ol><p>A盲法的原则</p><p>B对照的原则</p><p>C重复的原则</p><p>D随机化的原则</p><p>E多中心的原则</p><ol><li>下列有关直线回归的论述中,正确的是()。</li></ol><p>A满足所有点距离直线垂直距离平方和最小</p><p>B满足残差平方和最小</p><p>C拟合方法为最小二乘法</p><p>D满足所有点距离直线竖直距离平方和最小</p><p>E满足所有点距离直线的绝对值距离最小</p><ol><li>LSTM网络在分类上属于深度学习方法。√</li><li>OR值、RR值属于病因学指标。√</li><li>样条方法属于非线性方法。√</li><li>机器学习方法在分类上属于深度学习的一种。×</li><li>线性回归分析中,决定系数R2是衡量拟合效果优劣的一个指标。√</li><li>线性回归系数与pearson相关系数在假设检验上是等效的。√</li><li>同一个资料,计算相关系数与回归系数,两个系数的正负号是相反的。×</li><li>在做回归分析时,需要先做散点图查看分布和趋势。√</li><li>回归分析要求样本满足残差独立性√</li><li>深度学习方法可以用于回归也可以用于分类。√</li></ol><h1 id="期末考试题"><a href="#期末考试题" class="headerlink" title="期末考试题:"></a>期末考试题:</h1><ol><li>单选题(2分)</li></ol><p>（）作为知识发现的核心部分，指的是从数据集合中自动抽取隐藏在数据中的那些有价值的信息的过程</p><p>A数据挖掘</p><p>B人工智能</p><p>C机器学习</p><p>D模式识别</p><p><strong>正确答案： A</strong></p><ol><li>单选题(2分)</li></ol><p>（）是指在大量的数据中发现特征之间或数据之间的相互依赖关系。</p><p>A分类</p><p>B回归</p><p>C关联规则</p><p>D聚类</p><p><strong>正确答案： C</strong></p><ol><li>单选题 (2分)</li></ol><p>在受试人群中，根据人群的某些体征比如面色红润，口苦，疲乏，舌苔黄腻，畏寒怕冷等特征将这些人的体质分为平和体质，湿热体质，阳虚体质等等。属于数据挖掘的哪一类任务（）</p><p>A分类</p><p>B回归</p><p>C关联规则</p><p>D聚类</p><p><strong>正确答案： D</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">这里的关键区别在于是否有预先定义的标签：</span><br><span class="line">如果我们已经有了体质类型的标签，并且我们的目标是训练一个模型，以便能够根据新的体征特征预测体质类型，那么这是一个分类问题。</span><br><span class="line">如果我们没有标签，而是希望算法根据体征特征自动将人群分组，那么这是一个聚类问题。</span><br></pre></td></tr></table></figure><ol><li>单选题 (2分)</li></ol><p>（ ）用于联系用户和信息，并利用信息分类用户的兴趣偏好，为用户推荐感兴趣的内容</p><p>A聚类</p><p>B智能推荐</p><p>C时间序列分析</p><p>D回归</p><p><strong>正确答案： B</strong></p><ol><li>单选题 (2分)</li></ol><p>下列数据属于序数属性的是（）。</p><p>A红细胞计数</p><p>B门诊就诊人数</p><p>C患者的病情分级</p><p>D住院患者费用支付方式</p><p><strong>正确答案： C</strong></p><ol><li>单选题 (2分)</li></ol><p>某年某地六岁女孩成长发育情况如下：身高均数为119cm，标准差为4.56cm，体重均数为20kg，标准差为1.16kg，欲比较两者的变异程度，应选用的指标是（）。</p><p>A算数平均数</p><p>B标准差</p><p>C离散系数</p><p>D极差</p><p>本题得分： 2分</p><p><strong>正确答案： C</strong></p><ol><li>单选题 (2分)</li></ol><p>算术平均值与中位数相比，其特点是（）。</p><p>A不易受极端值的影响</p><p>B能充分利用数据的信息</p><p>C更适用于开口数据（无确切端点值）资料</p><p>D更适用于分布不明确资料</p><p>本题得分： 2分</p><p><strong>正确答案： B</strong></p><ol><li>单选题 (2分)</li></ol><p>对3×2表资料做卡方检验，其自由度为（B）。</p><p>A1</p><p>B2</p><p>C3</p><p>D4</p><p><strong>正确答案： B</strong></p><ol><li>单选题 (2分)</li></ol><p>Mapreduce适用于 （）。</p><p>A任意应用程序</p><p>B任意可在windows servet2008上运行的程序</p><p>C可以串行处理的应用程序</p><p>D可以并行处理的应用程序</p><p><strong>正确答案： D</strong></p><ol><li>单选题 (2分)</li></ol><p>将原始数据进行集成、变换、维度规约、数值规约是在以下哪个步骤的任务？( )</p><p>A 频繁模式挖掘</p><p>B分类和预测</p><p>C数据预处理</p><p>D数据流挖掘</p><p><strong>正确答案： C</strong></p><ol><li>单选题 (2分)</li></ol><p>下面哪种不属于数据预处理的方法？ （）</p><p>A变量代换</p><p>B离散化</p><p>C聚集</p><p>D估计遗漏值</p><p><strong>正确答案： D</strong></p><ol><li>单选题 (2分)</li></ol><p>假设12个销售价格记录组已经排序如下:5, 10， 11， 13, 15， 35, 50, 55， 72， 92， 204, 215 使用如下每种方法将它们划分成四个箱。等频(等深)划分时,15在第几个箱子内？ ( ）</p><p>A第一个</p><p>B第二个</p><p>C第三个</p><p>D第四个</p><p><strong>正确答案： B</strong></p><ol><li>单选题 (2分)</li></ol><p>发现关联规则的算法通常要经过以下三个步骤：连接数据，作数据准备；给定最小支持度和（ ）,利用数据挖掘工具提供的算法发现关联规则；可视化显示、理解、评估关联规则。</p><p>A最小兴趣度</p><p>B最小置信度</p><p>C最大支持度</p><p>D最小可信度</p><p><strong>正确答案： B</strong></p><ol><li>单选题 (2分)</li></ol><p>规则I-〉j，“有可能”，等于所有包含I的购物篮中同时包含J的购物篮的比例,为（ ）。</p><p>A置信度</p><p>B可信度</p><p>C兴趣度</p><p>D支持度</p><p><strong>正确答案： A</strong></p><ol><li>单选题 (2分)</li></ol><p>考虑下面的频繁3—项集的集合：｛1，2,3｝,{1，2,4｝，{1，2，5｝，｛1,3，4｝,｛1，3,5},｛2,3,4},｛2,3,5｝，{3，4,5}假定数据集中只有5个项，采用合并策略,由候选产生过程得到4-项集不包含(）。</p><p>A1,2，3，4</p><p>B1,2，3，5</p><p>C1,2，4，5</p><p>D1,3，4，5</p><p><strong>正确答案： C</strong></p><ol><li>单选题 (2分)</li></ol><p>在图集合中发现一组公共子结构，这样的任务称为 ( )。</p><p>A频繁子集挖掘</p><p>B频繁子图挖掘</p><p>C频繁数据项挖掘</p><p>D频繁模式挖掘</p><p><strong>正确答案： B</strong></p><ol><li>单选题 (2分)</li></ol><p>关于聚类的目标，下面说法不正确的是（）。</p><p>A使聚类内部对象之间的距离尽可能小</p><p>B使它们之间具有很低的相似度</p><p>C常见的距离度量有：幂距离</p><p>D距离或相似性度量对于聚类算法是非常重要的</p><p><strong>正确答案： B</strong></p><ol><li>单选题 (2分)</li></ol><p>假设在城市中，要从一个十字路口到另一个十字路口，驾驶距离显然不是两点间的直线距离，实际驾驶距离就是 ( ）。</p><p>A幂距离</p><p>B切比雪夫距离</p><p>C欧式距离</p><p>D曼哈顿距离</p><p><strong>正确答案： D</strong></p><ol><li>单选题 (2分)</li></ol><p>余弦相似度更加关注两个向量在（）上的差异</p><p>A大小</p><p>B方向</p><p>C密度</p><p>D距离</p><p><strong>正确答案： B</strong></p><ol><li>单选题 (2分)</li></ol><p>刻画k均值聚类的特点，采用的是哪一类准则函数来作为聚类的准则函数。（ ）</p><p>A均值</p><p>B误差平方和准则（Sum Squared Error，SSE）</p><p>C方差</p><p>D标准差</p><p><strong>正确答案： B</strong></p><ol><li>单选题 (2分)</li></ol><p>当Kappa（ ），说明已经取得相当满意的一致程度。</p><p>A在区间[-1,1]内</p><p>B大于等于0.75时</p><p>CKappa&#x3D;1</p><p>DKappa&lt;0.4</p><p><strong>正确答案： B</strong></p><ol><li>单选题 (2分)</li></ol><p>下面是SVM算法中需要指定的超参数 （）。</p><p>AC</p><p>Balpha</p><p>Cbias</p><p>Domiga</p><p><strong>正确答案： A</strong></p><ol><li>单选题 (2分)</li></ol><p>ROC曲线下方的面积就是（ ）。</p><p>ALOT</p><p>BTPR</p><p>CFPR</p><p>DAUC</p><p><strong>正确答案： D</strong></p><ol><li>单选题 (2分)</li></ol><p>（）算法只适用于离散的描述属性。</p><p>AID3</p><p>BC4.5</p><p>CCART决策树</p><p>DSLIQ</p><p><strong>正确答案： A</strong></p><ol><li>多选题 (4分)</li></ol><p>集成学习有如下几种方式（）。</p><p>ABagging</p><p>BBoosting</p><p>CAdaboost</p><p>DStacking</p><p>EID3</p><p><strong>正确答案： A,B,D (少选不得分)</strong></p><ol><li>多选题 (4分)</li></ol><p>数据挖掘的主要功能包括概念描述、趋势分析、孤立点分析及（ ）等方面。</p><p>A挖掘频繁模式</p><p>B分类和预测</p><p>C聚类分析</p><p>D偏差分析</p><p>E抽样</p><p><strong>正确答案： A,B,C,D (少选不得分)</strong></p><ol><li>多选题 (4分)</li></ol><p>下列属于定量属性的是（）</p><p>A区间标度属性</p><p>B比率标度属性</p><p>C二元属性</p><p>D多元属性</p><p>E序数属性</p><p><strong>正确答案： A,B (少选不得分)</strong></p><ol><li>多选题 (4分)</li></ol><p>数据预处理方法主要有（ ）。</p><p>A数据清洗</p><p>B数据集成</p><p>C数据变换</p><p>D数据归约</p><p>E数据分析</p><p><strong>正确答案： A,B,C,D (少选不得分)</strong></p><ol><li>多选题 (4分)</li></ol><p>下表是一个购物篮，假定支持度阈值为40％，其中( )是频繁闭项集。</p><table><thead><tr><th>ID</th><th>项集</th></tr></thead><tbody><tr><td>1</td><td>面包、牛奶、尿布</td></tr><tr><td>2</td><td>面包、牛奶、尿布、啤酒</td></tr><tr><td>3</td><td>牛奶、尿布、鸡蛋</td></tr><tr><td>4</td><td>面包、尿布、啤酒、鸡蛋</td></tr><tr><td>5</td><td>啤酒、鸡蛋</td></tr></tbody></table><p>A面包、牛奶、尿布</p><p>B面包、啤酒</p><p>C尿布、啤酒</p><p>D啤酒、鸡蛋</p><p>E面包、尿布、啤酒、鸡蛋</p><p><strong>正确答案： A,D (少选不得分)</strong></p><ol><li>多选题 (4分)</li></ol><p>K-平均算法的聚类过程为()。</p><p>A任意选择k个对象作为初始的簇中心</p><p>B计算其它对象与这k个中心的距离，然后把每个对象归入离它“最近”的簇</p><p>C计算各簇中对象的平均值，然后重新选择簇中心(离平均值“最近”的对象值</p><p>D重复第2第3步直到簇中心不再变化为止</p><p><strong>正确答案： A,B,C,D (少选不得分)</strong></p><ol><li>判断题</li></ol><p>数据探索主要包括：集中趋势、离散趋势、异常值分析、缺失值分析、相关分析、周期性分析等。（）</p><p><strong>正确答案： 正确</strong></p><ol><li>判断题</li></ol><p>抽取数据的标准有，相关性，可靠性，有效性。（）</p><p><strong>正确答案： 正确</strong></p><ol><li>判断题</li></ol><p>在主成分分析中，每个主成分都是原始变量的线性组合，且各个主成分之间线性无关。（）</p><p><strong>正确答案： 正确</strong></p><ol><li>判断题</li></ol><p>确定保留哪些主成分，通常既考虑累计贡献率又考虑特征值大小。（）</p><p><strong>正确答案： 正确</strong></p><ol><li>判断题</li></ol><p>pandas库中的merge函数和join()方法都可以实现主键合并。（）</p><p><strong>正确答案： 正确</strong></p><ol><li>判断题</li></ol><p>数据清洗(Data cleaning)是 对数据进行重新审查和校验的过程，目的在于删除重复信息、纠正存在的错误，并提供数据一致性。（）</p><p><strong>正确答案： 正确</strong></p><ol><li>判断题</li></ol><p>transform()方法能够对整个DataFrame的所有元素进行操作。（）</p><p><strong>正确答案： 正确</strong></p><ol><li>判断题</li></ol><p>同时满足最小支持度阈值和最大置信度阈值的规则称作强规则。（）</p><p><strong>正确答案： 错误</strong></p><ol><li>判断题</li></ol><p>FP-growth算法在求每个潜在的频繁项集时都需要扫描一次数据集。（）</p><p><strong>正确答案： 错误</strong></p><ol><li>判断题</li></ol><p>基于划分的算法最明显的优点就是，只需要扫描两遍数据库T，I&#x2F;O开销比Apriori算法增加。（）</p><p><strong>正确答案： 错误</strong></p><ol><li>判断题</li></ol><p>多层关联规则（Multilevel Rules）是一种基于概念分层的关联规则挖掘方法，概念分层是一种映射，它将低层概念映射到高层概念。（）</p><p><strong>正确答案： 正确</strong></p><ol><li>判断题</li></ol><p>BIRCH是一种分类器。（）</p><p><strong>正确答案： 错误</strong></p><ol><li>判断题</li></ol><p>组平均将两个簇的邻近度定义为不同簇的所有点对的平均逐对邻近度，它是一种凝聚层次聚类技术。（）</p><p><strong>正确答案： 正确</strong></p><ol><li>判断题</li></ol><p>DBSCAN在最坏情况下的时间复杂度是O(m2)。（）</p><p><strong>正确答案： 正确</strong></p><ol><li>判断题</li></ol><p>K均值丢弃被它识别为噪声的对象，而DBSCAN一般聚类所有对象。（）</p><p><strong>正确答案： 错误</strong></p><h1 id="摘选于讨论区中的问题，可能是考试中会出现的内容"><a href="#摘选于讨论区中的问题，可能是考试中会出现的内容" class="headerlink" title="摘选于讨论区中的问题，可能是考试中会出现的内容"></a>摘选于讨论区中的问题，可能是考试中会出现的内容</h1><p>代码出题方式为填空，所以可以重点记忆标记的代码行</p><ol><li><h2 id="医学数据中，尤其是中医学数据中，如何来清洗数据。"><a href="#医学数据中，尤其是中医学数据中，如何来清洗数据。" class="headerlink" title="医学数据中，尤其是中医学数据中，如何来清洗数据。"></a>医学数据中，尤其是中医学数据中，如何来清洗数据。</h2></li></ol><p>选自林薇老师的回答：</p><p>在Python中，可以使用pandas库进行数据清洗，例如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line"><span class="comment"># 删除重复行</span></span><br><span class="line">df = df.drop_duplicates()</span><br><span class="line"><span class="comment"># 填充缺失值</span></span><br><span class="line">df.fillna(<span class="number">0</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><ol><li><h2 id="使用Python实现Apriori算法："><a href="#使用Python实现Apriori算法：" class="headerlink" title="使用Python实现Apriori算法："></a>使用Python实现Apriori算法：</h2></li></ol><p>选自林薇老师的示例：</p><p>使用Python实现Apriori算法的示例代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mlxtend.frequent_patterns <span class="keyword">import</span> apriori</span><br><span class="line"><span class="keyword">from</span> mlxtend.frequent_patterns <span class="keyword">import</span> association_rules</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设我们有以下事务数据集</span></span><br><span class="line">dataset = [[<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;橙子&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;橙子&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;橙子&#x27;</span>, <span class="string">&#x27;香蕉&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;橙子&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;橙子&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;橙子&#x27;</span>],</span><br><span class="line">            [<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;香蕉&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Apriori算法找到频繁项集</span></span><br><span class="line">frequent_itemsets = apriori(dataset, min_support=<span class="number">0.5</span>, use_colnames=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成关联规则</span></span><br><span class="line">rules = association_rules(frequent_itemsets, metric=<span class="string">&quot;confidence&quot;</span>, min_threshold=<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;频繁项集：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(frequent_itemsets)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n关联规则：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(rules)</span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先使用<code>mlxtend.frequent_patterns.apriori</code>函数来找到频繁项集。<code>min_support</code>参数设置为0.5，表示项集在数据集中出现的最小支持度。<code>use_colnames</code>参数设置为True，表示使用列名作为项集的标识符。然后，我们使用<code>mlxtend.frequent_patterns.association_rules</code>函数来生成关联规则。在这个例子中，我们使用<code>confidence</code>作为度量标准，并设置最小阈值为0.7。最后，我们打印出频繁项集和关联规则的结果。</p><ol><li><h2 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h2></li></ol><p>选自林薇老师的示例代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># 从CSV文件中读取数据</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;input.csv&#x27;</span>)</span><br><span class="line"><span class="comment"># 数据转换</span></span><br><span class="line"><span class="comment"># 假设我们要将&#x27;column_name&#x27;列中的字符串转换为整数</span></span><br><span class="line">df[<span class="string">&#x27;column_name&#x27;</span>] = df[<span class="string">&#x27;column_name&#x27;</span>].astype(<span class="built_in">int</span>)</span><br><span class="line"><span class="comment"># 将转换后的数据保存到新的CSV文件中</span></span><br><span class="line">df.to_csv(<span class="string">&#x27;output.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><ol><li><h2 id="要实现文本分类、python常见代码是什么"><a href="#要实现文本分类、python常见代码是什么" class="headerlink" title="要实现文本分类、python常见代码是什么"></a>要实现文本分类、python常见代码是什么</h2></li></ol><p>选自林薇老师的示例代码</p><p>假设我们有一些文档，需要将它们分类为两个类别（类别1和类别2）。我们可以首先将文档转化为向量形式（即词袋模型），然后使用Scikit-learn的逻辑回归模型进行分类。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 假设我们有以下文档：</span></span><br><span class="line">documents = [</span><br><span class="line">    <span class="string">&#x27;This is a document about the first topic.&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;This document is about the second topic.&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;And this one is about the third topic.&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Is this document about the first or the second topic?&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;This is the second document.&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Is this document about the first or the second topic?&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;This document is about the first topic.&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;I wonder if this document is about the first or the second topic?&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;This is the third document.&#x27;</span></span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将文档转化为向量形式：</span></span><br><span class="line">vectorizer = CountVectorizer()</span><br><span class="line">vectorized_docs = vectorizer.fit_transform(documents)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 划分训练集和测试集：</span></span><br><span class="line">train_docs, test_docs = vectorized_docs[:-<span class="number">2</span>], vectorized_docs[-<span class="number">2</span>:]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用逻辑回归模型进行训练：</span></span><br><span class="line">classifier = LogisticRegression()</span><br><span class="line">classifier.fit(train_docs, [<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;third&#x27;</span>, <span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;third&#x27;</span>])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 对测试集进行预测：</span></span><br><span class="line">predicted = classifier.predict(test_docs)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出预测结果：</span></span><br><span class="line"><span class="built_in">print</span>(predicted)</span><br></pre></td></tr></table></figure><p>这个例子中，我们使用了逻辑回归模型，但实际上还有很多其他的模型可以选择，比如支持向量机（SVM）、朴素贝叶斯、决策树等。此外，还可以使用深度学习模型，如卷积神经网络（CNN）或递归神经网络（RNN）等。在选择模型时，需要根据具体的问题和数据来进行权衡。</p><ol><li><h2 id="简述拉格朗日插值法和牛顿差值法的异同"><a href="#简述拉格朗日插值法和牛顿差值法的异同" class="headerlink" title="简述拉格朗日插值法和牛顿差值法的异同"></a>简述拉格朗日插值法和牛顿差值法的异同</h2></li></ol><p>相同点：</p><ol><li>插值原理：拉格朗日插值法和牛顿插值法都是基于插值原理，即通过在已知数据点之间构建一个多项式函数来逼近这些点。</li><li>多项式性质：两种方法得到的结果都是多项式函数，这些多项式函数通过已知数据点，并且满足插值条件。</li></ol><p>不同点：</p><ol><li><p>插值多项式的构造方式：拉格朗日插值法通过构造一个基于拉格朗日基函数的插值多项式来进行插值。而牛顿插值法则是通过计算差商并构建牛顿插值多项式来进行插值。</p></li><li><p>运算量与复杂性：拉格朗日插值法在每次增加一个新的插值节点时，都需要重新计算所有的基函数因此其计算量相对较大，尤其是在插值节点较多的情况下。而牛顿插值法则通过差商表的逐步构建，可以在增加新的插值节点时只更新部分差商，因此其计算量相对较小。</p></li><li><p>数值稳定性：在某些情况下，拉格朗日插值法可能会出现龙格现象(Runge’s Phenomenon)，即插值多项式在插值区间的端点附近可能会出现较大的振荡。而牛颅插值法则在某些情况下表现出更好的数值稳定性。</p></li><li><h2 id="如何将异常值处理与缺失值处理的方法联系起来"><a href="#如何将异常值处理与缺失值处理的方法联系起来" class="headerlink" title="如何将异常值处理与缺失值处理的方法联系起来"></a>如何将异常值处理与缺失值处理的方法联系起来</h2></li><li><p>原因关联：异常值和缺失值有时可能源于相同的原因。例如，某些数据可能因为测量设备故障、数据录入错误或其他原因而同时出现异常或缺失。因此，在处理这些值时，可能需要同时考虑异常值和缺失值的处理方法。</p></li><li><p>处理方法的互补性：在某些情况下，可以使用异常值处理方法来处理缺失值，反之亦然。例如，如果数据集中的某个特征是数值型的，那么可以使用该特征的均值、中位数或众数来填充缺失值或替换异常值。同样，插值法既可以用于填充缺失值，也可以用于替换异常值。</p></li><li><p>处理顺序的灵活性：在某些情况下，可能需要先处理异常值，然后再处理缺失值。例如，如果异常值对后续的数据分析产生较大影响，那么可以先将其替换或删除，然后再对剩余的缺失值进行处理。反之，如果缺失值的数量较多，可能会对后续的数据分析产生较大影响，那么可以先填充缺失值，然后再对可能出现的异常值进行处理。</p></li><li><h2 id="独热编码（one-hot-encoding）和标签编码（label-encoding）的区别"><a href="#独热编码（one-hot-encoding）和标签编码（label-encoding）的区别" class="headerlink" title="独热编码（one-hot encoding）和标签编码（label encoding）的区别"></a>独热编码（one-hot encoding）和标签编码（label encoding）的区别</h2></li></ol><p>独热编码和标签编码是常用的分类数据编码方式。标签编码将每个类别映射为整数值，保留了顺序关系，但可能引入假设关系。独热编码将每个类别转换为二进制向量，适用于无序类别数据，不会引入假设关系。标签编码维持数据维度不变，而独热编码会增加维度。标签编码适用于有序类别数据，而独热编码适用于无序类别数据。</p><ol><li><h2 id="机器学习中常见编码方式：标签编码、序列编码、独热编码、频数编码、目标编码的区别与联系，如何在python中实现"><a href="#机器学习中常见编码方式：标签编码、序列编码、独热编码、频数编码、目标编码的区别与联系，如何在python中实现" class="headerlink" title="机器学习中常见编码方式：标签编码、序列编码、独热编码、频数编码、目标编码的区别与联系，如何在python中实现"></a>机器学习中常见编码方式：标签编码、序列编码、独热编码、频数编码、目标编码的区别与联系，如何在python中实现</h2></li><li><p>标签编码：</p></li></ol><p>①将类别型变量映射为整数标签，适用于有序类别数据。</p><p>②保留了类别之间的顺序关系。</p><p>③Python实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line">encoder = LabelEncoder()</span><br><span class="line">encoded_labels = encoder.fit_transform(labels)</span><br></pre></td></tr></table></figure><ol><li>序列编码：</li></ol><p>①将序列数据中的词汇或符号编码为整数序列。</p><p>②用于处理文本或时间序列数据。</p><p>③Python实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.preprocessing.text <span class="keyword">import</span> Tokenizer</span><br><span class="line">tokenizer = Tokenizer()</span><br><span class="line">tokenizer.fit_on_texts(texts)</span><br><span class="line">sequences = tokenizer.texts_to_sequences(texts)</span><br></pre></td></tr></table></figure><ol><li>独热编码：</li></ol><p>①将每个类别转换为二进制向量，适用于无序类别数据。</p><p>②不会引入类别之间的顺序关系。</p><p>③Python实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"> encoded_features = OneHotEncoder().fit_transform(features.reshape(-<span class="number">1</span>, <span class="number">1</span>)).toarray()</span><br></pre></td></tr></table></figure><ol><li>频数编码：</li></ol><p>①将每个类别映射为其出现的频率，用于有序或无序类别数据。</p><p>②可以帮助模型学习类别的频率信息。</p><p>③Python实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">freq_encoding = df[<span class="string">&#x27;category&#x27;</span>].value_counts(normalize=<span class="literal">True</span>)</span><br><span class="line"> df[<span class="string">&#x27;category_freq_encoded&#x27;</span>] = df[<span class="string">&#x27;category&#x27;</span>].<span class="built_in">map</span>(freq_encoding)</span><br></pre></td></tr></table></figure><ol><li>目标编码：</li></ol><p>①将类别型变量的每个类别的目标变量均值编码为数值。</p><p>②用于处理分类问题的特征编码。</p><p>③Python实现：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> category_encoders <span class="keyword">as</span> ce</span><br><span class="line"> encoder = ce.TargetEncoder()</span><br><span class="line"> encoded_features = encoder.fit_transform(features, target)</span><br></pre></td></tr></table></figure><ol><li><h2 id="python中，进行缺失值处理的时候，请简单描述牛顿插值法和拉格朗日插值法的示例代码"><a href="#python中，进行缺失值处理的时候，请简单描述牛顿插值法和拉格朗日插值法的示例代码" class="headerlink" title="python中，进行缺失值处理的时候，请简单描述牛顿插值法和拉格朗日插值法的示例代码"></a>python中，进行缺失值处理的时候，请简单描述牛顿插值法和拉格朗日插值法的示例代码</h2></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#牛顿插值法：</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">newton_interpolation</span>(<span class="params">x, y, x_new</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(x)</span><br><span class="line">    f = np.zeros((n, n))</span><br><span class="line">    <span class="comment"># 初始化f矩阵</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        f[i, <span class="number">0</span>] = y[i]</span><br><span class="line">    <span class="comment"># 计算差商</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-j):</span><br><span class="line">            f[i, j] = (f[i+<span class="number">1</span>, j-<span class="number">1</span>] - f[i, j-<span class="number">1</span>]) / (x[i+j] - x[i])</span><br><span class="line">    <span class="comment"># 计算插值结果</span></span><br><span class="line">    result = f[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        term = f[<span class="number">0</span>, i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            term *= (x_new - x[j])</span><br><span class="line">        result += term</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">x = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">y = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>])</span><br><span class="line">x_new = <span class="number">2.5</span></span><br><span class="line"><span class="comment"># 插值</span></span><br><span class="line">result = newton_interpolation(x, y, x_new)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;牛顿插值结果:&quot;</span>, result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#拉格朗日插值法：</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lagrange_interpolation</span>(<span class="params">x, y, x_new</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(x)</span><br><span class="line">    result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        term = y[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i != j:</span><br><span class="line">                term *= (x_new - x[j]) / (x[i] - x[j])</span><br><span class="line">        result += term</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">x = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">y = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>])</span><br><span class="line">x_new = <span class="number">2.5</span></span><br><span class="line"><span class="comment"># 插值</span></span><br><span class="line">result = lagrange_interpolation(x, y, x_new)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;拉格朗日插值结果:&quot;</span>, result)</span><br></pre></td></tr></table></figure><ol><li><h2 id="Pandas提供了更强大的聚合功能，如groupby-和agg-函数，允许根据某些列对数据进行分组并应用聚合函数。试举例说明"><a href="#Pandas提供了更强大的聚合功能，如groupby-和agg-函数，允许根据某些列对数据进行分组并应用聚合函数。试举例说明" class="headerlink" title="Pandas提供了更强大的聚合功能，如groupby()和agg()函数，允许根据某些列对数据进行分组并应用聚合函数。试举例说明"></a>Pandas提供了更强大的聚合功能，如<code>groupby()</code>和<code>agg()</code>函数，允许根据某些列对数据进行分组并应用聚合函数。试举例说明</h2></li></ol><p>使用pandas中的groupby()函数和agg()函数可以对数据执行聚合操作。以”Product”和”Region”两列对销售额进行求和和平均值的计算。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># Create a sample data frame</span></span><br><span class="line">data = &#123;<span class="string">&#x27;Product&#x27;</span>: [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;C&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;Region&#x27;</span>: [<span class="string">&#x27;East&#x27;</span>, <span class="string">&#x27;East&#x27;</span>, <span class="string">&#x27;West&#x27;</span>, <span class="string">&#x27;West&#x27;</span>, <span class="string">&#x27;East&#x27;</span>, <span class="string">&#x27;West&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;Sales&#x27;</span>: [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"><span class="comment"># Group by &#x27;Product&#x27; and &#x27;Region&#x27;, and compute sum and mean of &#x27;Sales&#x27;</span></span><br><span class="line">grouped = df.groupby([<span class="string">&#x27;Product&#x27;</span>, <span class="string">&#x27;Region&#x27;</span>])[<span class="string">&#x27;Sales&#x27;</span>].agg([<span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(grouped)</span><br></pre></td></tr></table></figure><p>从输出结果可以看出，groupby()函数根据”Product”和”Region”两列对数据进行分组，agg()函数计算了每组数据的”Sales”列的总和和平均值。</p><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=MDRjY2M2MjI5ZjIwMTg3MzA1YTgxMzRhYzE3NTY5NDhfODdGbEFGdzdmYVRFbFVGNDhoc0wxTU1USkN5MXQybTJfVG9rZW46TjhlVGJBald1bzIzRmh4ZlJFbmM2R0YxbmhnXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><ol><li><h2 id="关联规则算法实现"><a href="#关联规则算法实现" class="headerlink" title="关联规则算法实现"></a>关联规则算法实现</h2></li></ol><p>示例数据集</p><p>dataset &#x3D; [[‘牛奶’, ‘面包’, ‘黄油’],</p><p>​ [‘面包’, ‘黄油’, ‘尿布’],</p><p>​ [‘牛奶’, ‘尿布’, ‘鸡蛋’, ‘黄油’],</p><p>​ [‘面包’, ‘牛奶’, ‘尿布’, ‘鸡蛋’],</p><p>​ [‘面包’, ‘尿布’, ‘黄油’, ‘鸡蛋’]]</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mlxtend.frequent_patterns <span class="keyword">import</span> apriori</span><br><span class="line"><span class="keyword">from</span> mlxtend.frequent_patterns <span class="keyword">import</span> association_rules</span><br><span class="line"><span class="keyword">from</span> mlxtend.preprocessing <span class="keyword">import</span> TransactionEncoder</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据集</span></span><br><span class="line">data = [[<span class="string">&#x27;牛奶&#x27;</span>, <span class="string">&#x27;面包&#x27;</span>, <span class="string">&#x27;黄油&#x27;</span>],</span><br><span class="line">           [<span class="string">&#x27;面包&#x27;</span>, <span class="string">&#x27;黄油&#x27;</span>, <span class="string">&#x27;尿布&#x27;</span>],</span><br><span class="line">           [<span class="string">&#x27;牛奶&#x27;</span>, <span class="string">&#x27;尿布&#x27;</span>, <span class="string">&#x27;鸡蛋&#x27;</span>, <span class="string">&#x27;黄油&#x27;</span>],</span><br><span class="line">           [<span class="string">&#x27;面包&#x27;</span>, <span class="string">&#x27;牛奶&#x27;</span>, <span class="string">&#x27;尿布&#x27;</span>, <span class="string">&#x27;鸡蛋&#x27;</span>],</span><br><span class="line">           [<span class="string">&#x27;面包&#x27;</span>, <span class="string">&#x27;尿布&#x27;</span>, <span class="string">&#x27;黄油&#x27;</span>, <span class="string">&#x27;鸡蛋&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 TransactionEncoder 将数据集转换为适合Apriori算法的格式</span></span><br><span class="line">te = TransactionEncoder()</span><br><span class="line">te_ary= te.fit(data).transform(data)</span><br><span class="line">df = pd.DataFrame(te_ary, columns=te.columns_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 Apriori 算法计算频繁项集</span></span><br><span class="line">frequent_itemsets = apriori(df, min_support=<span class="number">0.4</span>, use_colnames=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用association_rules函数生成关联规则</span></span><br><span class="line">rules=association_rules(frequent_itemsets,metric=<span class="string">&quot;confidence&quot;</span>,min_threshold=<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;频繁项集：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(frequent_itemsets)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n关联规则：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(rules)</span><br></pre></td></tr></table></figure><ol><li><h2 id="利用Apriori算法对中药组方进行关联规则分析"><a href="#利用Apriori算法对中药组方进行关联规则分析" class="headerlink" title="利用Apriori算法对中药组方进行关联规则分析"></a>利用Apriori算法对中药组方进行关联规则分析</h2></li></ol><p>示例数据集</p><p>dataset &#x3D; [[‘当归’, ‘川芎’, ‘人参’],</p><p>​ [‘川芎’, ‘人参’, ‘茯苓’],</p><p>​ [‘当归’, ‘茯苓’, ‘甘草’, ‘人参’],</p><p>​ [‘川芎’, ‘当归’, ‘茯苓’, ‘甘草’],</p><p>​ [‘川芎’, ‘茯苓’, ‘人参’, ‘甘草’]]</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> apyori <span class="keyword">import</span> apriori</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据集</span></span><br><span class="line">dataset = [[<span class="string">&#x27;当归&#x27;</span>, <span class="string">&#x27;川芎&#x27;</span>, <span class="string">&#x27;人参&#x27;</span>],</span><br><span class="line">           [<span class="string">&#x27;川考&#x27;</span>, <span class="string">&#x27;人参&#x27;</span>, <span class="string">&#x27;茯苓&#x27;</span>],</span><br><span class="line">           [<span class="string">&#x27;当归&#x27;</span>, <span class="string">&#x27;茯苓&#x27;</span>, <span class="string">&#x27;甘草&#x27;</span>, <span class="string">&#x27;人参&#x27;</span>],</span><br><span class="line">           [<span class="string">&#x27;川芎&#x27;</span>, <span class="string">&#x27;当归&#x27;</span>, <span class="string">&#x27;茯苓&#x27;</span>, <span class="string">&#x27;甘草&#x27;</span>],</span><br><span class="line">           [<span class="string">&#x27;川芎&#x27;</span>, <span class="string">&#x27;茯苓&#x27;</span>, <span class="string">&#x27;人参&#x27;</span>, <span class="string">&#x27;甘草&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用Apriori算法</span></span><br><span class="line">min_support = <span class="number">0.3</span>  <span class="comment"># 设置最小支持度阈值</span></span><br><span class="line">min_confidence = <span class="number">0.7</span>  <span class="comment"># 设置最小置信度阈值</span></span><br><span class="line">min_lift = <span class="number">1.2</span>  <span class="comment"># 设置最小提升度阈值</span></span><br><span class="line">min_length = <span class="number">2</span>  <span class="comment"># 设置最小项集长度</span></span><br><span class="line"></span><br><span class="line">results = <span class="built_in">list</span>(apriori(dataset, min_support=min_support, min_confidence=min_confidence, min_lift=min_lift, min_length=min_length))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出频繁项集和关联规则</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;频繁项集：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> results:</span><br><span class="line">    <span class="built_in">print</span>(item.items, <span class="string">&quot;Support:&quot;</span>, <span class="built_in">round</span>(item.support, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n关联规则：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> rule <span class="keyword">in</span> results:</span><br><span class="line">    <span class="keyword">for</span> outcome <span class="keyword">in</span> rule.ordered_statistics:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;, &quot;</span>.join(item <span class="keyword">for</span> item <span class="keyword">in</span> outcome.items_base), <span class="string">&quot;=&gt;&quot;</span>, <span class="string">&quot;, &quot;</span>.join(item <span class="keyword">for</span> item <span class="keyword">in</span> outcome.items_add), <span class="string">&quot;Confidence:&quot;</span>, <span class="built_in">round</span>(outcome.confidence, <span class="number">4</span>), <span class="string">&quot;Lift:&quot;</span>, <span class="built_in">round</span>(outcome.lift, <span class="number">4</span>))</span><br></pre></td></tr></table></figure><ol><li><h2 id="利用fp-growth算法进行中药组方关联规则挖掘"><a href="#利用fp-growth算法进行中药组方关联规则挖掘" class="headerlink" title="利用fp-growth算法进行中药组方关联规则挖掘"></a>利用fp-growth算法进行中药组方关联规则挖掘</h2></li></ol><p>模拟中医药方剂的数据集</p><p>data &#x3D; [</p><p>​ [‘黄连’, ‘黄芩’, ‘黄柏’, ‘栀子’],</p><p>​ [‘麻黄’, ‘桂枝’, ‘杏仁’, ‘甘草’],</p><p>​ [‘银花’, ‘连翘’, ‘桔梗’, ‘薄荷’],</p><p>[‘川芎’, ‘麻黄’, ‘桔梗’, ‘杏仁’],</p><p>… 添加更多方剂</p><p>]</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mlxtend.preprocessing <span class="keyword">import</span> TransactionEncoder</span><br><span class="line"><span class="keyword">from</span> mlxtend.frequent_patterns <span class="keyword">import</span> fpgrowth Graph</span><br><span class="line"><span class="keyword">from</span> mlxtend.frequent_patterns <span class="keyword">import</span> association_rules</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟数据集</span></span><br><span class="line">data = [</span><br><span class="line">    [<span class="string">&#x27;黄连&#x27;</span>, <span class="string">&#x27;黄芩&#x27;</span>, <span class="string">&#x27;黄柏&#x27;</span>, <span class="string">&#x27;栀子&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;麻黄&#x27;</span>, <span class="string">&#x27;桂枝&#x27;</span>, <span class="string">&#x27;杏仁&#x27;</span>, <span class="string">&#x27;甘草&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;银花&#x27;</span>, <span class="string">&#x27;连翘&#x27;</span>, <span class="string">&#x27;桔梗&#x27;</span>, <span class="string">&#x27;薄荷&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;川芎&#x27;</span>, <span class="string">&#x27;麻黄&#x27;</span>, <span class="string">&#x27;桔梗&#x27;</span>, <span class="string">&#x27;杏仁&#x27;</span>],</span><br><span class="line">    <span class="comment"># ...添加更多方剂</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据预处理</span></span><br><span class="line">te = TransactionEncoder()</span><br><span class="line">te_ary = te.fit(data).transform(data)</span><br><span class="line">df = pd.DataFrame(te_ary, columns=te.columns_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># FP-growth模型</span></span><br><span class="line">frequent_itemsets = fpgrowth(df, use_colnames=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成关联规则</span></span><br><span class="line">rules = association_rules(frequent_itemsets, metric=<span class="string">&quot;lift&quot;</span>, min_threshold=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印关联规则</span></span><br><span class="line"><span class="built_in">print</span>(rules)</span><br></pre></td></tr></table></figure><ol><li><h2 id="寻找针灸治疗功能性胃肠病的选穴规律关联规则"><a href="#寻找针灸治疗功能性胃肠病的选穴规律关联规则" class="headerlink" title="寻找针灸治疗功能性胃肠病的选穴规律关联规则"></a>寻找针灸治疗功能性胃肠病的选穴规律关联规则</h2></li></ol><p><img src="https://miu7shl031o.feishu.cn/space/api/box/stream/download/asynccode/?code=YTQ1YjQxOGZlN2YxM2I1OTZkNGQ0ZmE5NzE2Yzg3YzVfTUlCY2dXWkU3N2VLSms2WUFvMjNQZTRER1lacmdJd2xfVG9rZW46SldNOWJHdnJRb05lS2l4Q3pLemNZOGdmbnJnXzE3MTk4MjA0NTI6MTcxOTgyNDA1Ml9WNA" alt="img"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dataset = [</span><br><span class="line">    [<span class="string">&#x27;公孙&#x27;</span>, <span class="string">&#x27;解溪&#x27;</span>, <span class="string">&#x27;太仓&#x27;</span>, <span class="string">&#x27;足三里&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;公孙&#x27;</span>, <span class="string">&#x27;劳宫&#x27;</span>, <span class="string">&#x27;通里&#x27;</span>, <span class="string">&#x27;大陵&#x27;</span>, <span class="string">&#x27;膻中&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;公孙&#x27;</span>, <span class="string">&#x27;厉兑&#x27;</span>, <span class="string">&#x27;胃俞&#x27;</span>, <span class="string">&#x27;大都&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;公孙&#x27;</span>, <span class="string">&#x27;内关&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;公孙&#x27;</span>, <span class="string">&#x27;天枢&#x27;</span>, <span class="string">&#x27;水分&#x27;</span>, <span class="string">&#x27;内庭&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;公孙&#x27;</span>, <span class="string">&#x27;天枢&#x27;</span>, <span class="string">&#x27;水分&#x27;</span>, <span class="string">&#x27;内庭&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;公孙&#x27;</span>, <span class="string">&#x27;中脘&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;公孙&#x27;</span>, <span class="string">&#x27;巨阙&#x27;</span>, <span class="string">&#x27;中脘&#x27;</span>, <span class="string">&#x27;厉兑&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;公孙&#x27;</span>, <span class="string">&#x27;中脘&#x27;</span>, <span class="string">&#x27;太白&#x27;</span>, <span class="string">&#x27;中魁&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;公孙&#x27;</span>, <span class="string">&#x27;中脘&#x27;</span>, <span class="string">&#x27;足三里&#x27;</span>, <span class="string">&#x27;解溪&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;劳宫&#x27;</span>, <span class="string">&#x27;中魁&#x27;</span>, <span class="string">&#x27;中脘&#x27;</span>, <span class="string">&#x27;足三里&#x27;</span>, <span class="string">&#x27;大陵&#x27;</span>, <span class="string">&#x27;支沟&#x27;</span>, <span class="string">&#x27;上脘&#x27;</span>, <span class="string">&#x27;脾俞&#x27;</span>, <span class="string">&#x27;胃俞&#x27;</span>, <span class="string">&#x27;中脘&#x27;</span>, <span class="string">&#x27;太白&#x27;</span>, <span class="string">&#x27;下脘&#x27;</span>, <span class="string">&#x27;食关&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;中脘&#x27;</span>, <span class="string">&#x27;太白&#x27;</span>, <span class="string">&#x27;下脘&#x27;</span>, <span class="string">&#x27;食关&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;劳宫&#x27;</span>, <span class="string">&#x27;中渚&#x27;</span>, <span class="string">&#x27;支沟&#x27;</span>, <span class="string">&#x27;中脘&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;脾俞&#x27;</span>, <span class="string">&#x27;章门&#x27;</span>, <span class="string">&#x27;期门&#x27;</span>, <span class="string">&#x27;太白&#x27;</span>, <span class="string">&#x27;中脘&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;俞府&#x27;</span>, <span class="string">&#x27;灵墟&#x27;</span>, <span class="string">&#x27;巨阙&#x27;</span>, <span class="string">&#x27;率谷&#x27;</span>, <span class="string">&#x27;神藏&#x27;</span>]</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"><span class="comment"># 数据预处理：转换数据格式</span></span><br><span class="line">te = TransactionEncoder()</span><br><span class="line">transaction_te = te.fit(dataset).transform(dataset)</span><br><span class="line">df = pd.DataFrame(transaction_te, columns=te.columns_)</span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="comment"># 设置最小支持度（例如：0.2，表示项集在所有事务中出现的频率至少为20%）</span></span><br><span class="line">min_support = <span class="number">0.2</span></span><br><span class="line"><span class="comment"># 设置最小置信度（例如：0.7，表示规则的置信度至少为70%）</span></span><br><span class="line">min_confidence = <span class="number">0.25</span></span><br><span class="line"><span class="comment"># 找出频繁项集</span></span><br><span class="line">frequent_items = fpgrowth(df, min_support, use_colnames=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 生成关联规则</span></span><br><span class="line">rules = association_rules(frequent_items, metric=<span class="string">&quot;confidence&quot;</span>, min_threshold=<span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># 打印频繁项集和关联规则</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;频繁项集:\n&quot;</span>, frequent_items)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;关联规则:\n&quot;</span>, rules[[<span class="string">&#x27;antecedents&#x27;</span>, <span class="string">&#x27;consequents&#x27;</span>, <span class="string">&#x27;support&#x27;</span>, <span class="string">&#x27;confidence&#x27;</span>, <span class="string">&#x27;lift&#x27;</span>]])</span><br></pre></td></tr></table></figure><ol><li><h2 id="针灸治疗头痛"><a href="#针灸治疗头痛" class="headerlink" title="针灸治疗头痛"></a>针灸治疗头痛</h2></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> mlxtend.preprocessing <span class="keyword">import</span> TransactionEncoder</span><br><span class="line"><span class="keyword">from</span> mlxtend.frequent_patterns <span class="keyword">import</span> apriori, association_rules</span><br><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]  <span class="comment"># 指定默认字体为黑体</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span>  <span class="comment"># 解决保存图像时负号&#x27;-&#x27;显示为方块的问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 针灸处方数据</span></span><br><span class="line">data = [</span><br><span class="line">    [<span class="string">&#x27;眉冲&#x27;</span>, <span class="string">&#x27;颞颥&#x27;</span>, <span class="string">&#x27;涌泉&#x27;</span>, <span class="string">&#x27;风门&#x27;</span>, <span class="string">&#x27;小海&#x27;</span>, <span class="string">&#x27;水沟&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;期门&#x27;</span>, <span class="string">&#x27;水沟&#x27;</span>, <span class="string">&#x27;神道&#x27;</span>, <span class="string">&#x27;涌泉&#x27;</span>, <span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>,<span class="string">&#x27;人迎&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;腕骨&#x27;</span>,<span class="string">&#x27;小海&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;目窗&#x27;</span>,<span class="string">&#x27;天冲&#x27;</span>,<span class="string">&#x27;风池&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;神庭&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;人迎&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;曲差&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;神道&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;本神&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;通天&#x27;</span>,<span class="string">&#x27;神道&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;承灵&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;目窗&#x27;</span>,<span class="string">&#x27;天冲&#x27;</span>,<span class="string">&#x27;风池&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;神道&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>,<span class="string">&#x27;人迎&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;命门&#x27;</span>,<span class="string">&#x27;目窗&#x27;</span>,<span class="string">&#x27;天冲&#x27;</span>,<span class="string">&#x27;风池&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;大杼&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>,<span class="string">&#x27;风府&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;风门&#x27;</span>,<span class="string">&#x27;神道&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;目窗&#x27;</span>,<span class="string">&#x27;天冲&#x27;</span>,<span class="string">&#x27;风池&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;悬厘&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;风府&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;阳白&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;攒竹&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>,<span class="string">&#x27;人迎&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;温溜&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;清冷渊&#x27;</span>,<span class="string">&#x27;人迎&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;消泺&#x27;</span>,<span class="string">&#x27;目窗&#x27;</span>,<span class="string">&#x27;天冲&#x27;</span>,<span class="string">&#x27;风池&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;小海&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;丰隆&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;束骨&#x27;</span>,<span class="string">&#x27;人迎&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;人迎&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;目窗&#x27;</span>,<span class="string">&#x27;天冲&#x27;</span>,<span class="string">&#x27;风池&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;孔最&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;商丘&#x27;</span>,<span class="string">&#x27;目窗&#x27;</span>,<span class="string">&#x27;天冲&#x27;</span>,<span class="string">&#x27;风池&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;百会&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;后顶&#x27;</span>,<span class="string">&#x27;目窗&#x27;</span>,<span class="string">&#x27;天冲&#x27;</span>,<span class="string">&#x27;风池&#x27;</span>,<span class="string">&#x27;悬颅&#x27;</span>,<span class="string">&#x27;水沟&#x27;</span>,<span class="string">&#x27;涌泉&#x27;</span>,<span class="string">&#x27;风门&#x27;</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用TransactionEncoder转换数据</span></span><br><span class="line">te = TransactionEncoder()</span><br><span class="line">te_ary = te.fit(data).transform(data)</span><br><span class="line">df = pd.DataFrame(te_ary, columns=te.columns_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出频繁项集</span></span><br><span class="line">frequent_itemsets = apriori(df, min_support=<span class="number">0.02</span>, use_colnames=<span class="literal">True</span>)  <span class="comment"># 根据数据量调整min_support</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算关联规则</span></span><br><span class="line">rules = association_rules(frequent_itemsets, metric=<span class="string">&quot;confidence&quot;</span>, min_threshold=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印关联规则</span></span><br><span class="line"><span class="built_in">print</span>(rules[[<span class="string">&#x27;antecedents&#x27;</span>, <span class="string">&#x27;consequents&#x27;</span>, <span class="string">&#x27;support&#x27;</span>, <span class="string">&#x27;confidence&#x27;</span>, <span class="string">&#x27;lift&#x27;</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建网络图</span></span><br><span class="line">G = nx.DiGraph()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加节点和边</span></span><br><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> rules.iterrows():</span><br><span class="line">    antecedents = <span class="built_in">list</span>(row[<span class="string">&#x27;antecedents&#x27;</span>])  <span class="comment"># 将frozenset转换为list</span></span><br><span class="line">    consequents = <span class="built_in">list</span>(row[<span class="string">&#x27;consequents&#x27;</span>])  <span class="comment"># 将frozenset转换为list</span></span><br><span class="line">    <span class="comment"># 为每个关联规则添加一条边，同时检查antecedents和consequents是否已经存在于图中</span></span><br><span class="line">    <span class="keyword">for</span> ante <span class="keyword">in</span> antecedents:</span><br><span class="line">        <span class="keyword">if</span> ante <span class="keyword">not</span> <span class="keyword">in</span> G:</span><br><span class="line">            G.add_node(ante)</span><br><span class="line">        <span class="keyword">for</span> conseq <span class="keyword">in</span> consequents:</span><br><span class="line">            <span class="keyword">if</span> conseq <span class="keyword">not</span> <span class="keyword">in</span> G:</span><br><span class="line">                G.add_node(conseq)</span><br><span class="line">            <span class="keyword">if</span> ante != conseq:</span><br><span class="line">                G.add_edge(ante, conseq, weight=row[<span class="string">&#x27;confidence&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制网络图</span></span><br><span class="line">pos = nx.spring_layout(G)</span><br><span class="line">edge_colors = [G[u][v][<span class="string">&#x27;weight&#x27;</span>] <span class="keyword">for</span> u, v <span class="keyword">in</span> G.edges()]</span><br><span class="line">nx.draw(G, pos, with_labels=<span class="literal">True</span>, node_color=<span class="string">&#x27;skyblue&#x27;</span>, node_size=<span class="number">700</span>, edge_color=edge_colors, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ol><li><h2 id="成人自闭症进行聚类实现"><a href="#成人自闭症进行聚类实现" class="headerlink" title="成人自闭症进行聚类实现"></a>成人自闭症进行聚类实现</h2></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载文件</span></span><br><span class="line">file_path = <span class="string">&#x27;F:\\下载\\autism_screening成人自闭症.csv&#x27;</span></span><br><span class="line">autism_data = pd.read_csv(file_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计数据中各列中缺失值的数量</span></span><br><span class="line">missing_values = autism_data.isnull().<span class="built_in">sum</span>()</span><br><span class="line">missing_values</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用平均年龄填充“年龄”列中的缺失值</span></span><br><span class="line">autism_data[<span class="string">&#x27;age&#x27;</span>].fillna(autism_data[<span class="string">&#x27;age&#x27;</span>].mean(), inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次统计数据中各列中缺失值的数量，确定缺失值是否填充</span></span><br><span class="line">missing_values_after_filling = autism_data.isnull().<span class="built_in">sum</span>()</span><br><span class="line">missing_values_after_filling</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择聚类的特征</span></span><br><span class="line">features = [<span class="string">&#x27;A1_Score&#x27;</span>, <span class="string">&#x27;A2_Score&#x27;</span>, <span class="string">&#x27;A3_Score&#x27;</span>, <span class="string">&#x27;A4_Score&#x27;</span>, <span class="string">&#x27;A5_Score&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;A6_Score&#x27;</span>, <span class="string">&#x27;A7_Score&#x27;</span>, <span class="string">&#x27;A8_Score&#x27;</span>, <span class="string">&#x27;A9_Score&#x27;</span>, <span class="string">&#x27;A10_Score&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;result&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将每个特征的数据标准化为平均值为0，标准差为1的类</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">autism_data[features] = scaler.fit_transform(autism_data[features])</span><br><span class="line"></span><br><span class="line">autism_data[features].head()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = <span class="string">&#x27;SimHei&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确定要测试的 k 个值的范围</span></span><br><span class="line">k_values = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个列表来存储每个 k 值的聚类效果值</span></span><br><span class="line">inertia_list = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历 k 值并拟合模型</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> k_values:</span><br><span class="line">    kmeans = KMeans(n_clusters=k, random_state=<span class="number">42</span>)</span><br><span class="line">    kmeans.fit(autism_data[features])</span><br><span class="line">    inertia_list.append(kmeans.inertia_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制“肘部曲线”</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">plt.plot(k_values, inertia_list, marker=<span class="string">&#x27;o&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;肘部曲线图&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;value of K&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Distortion&#x27;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数来运行 KMean 并绘制给定 k 值的聚类</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_clusters</span>(<span class="params">data, feature1, feature2, k_values</span>):</span><br><span class="line">    plt.figure(figsize=(<span class="number">15</span>, <span class="number">8</span>))</span><br><span class="line">    <span class="keyword">for</span> i, k <span class="keyword">in</span> <span class="built_in">enumerate</span>(k_values, <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 进行 KMeans 聚类</span></span><br><span class="line">        kmeans = KMeans(n_clusters=k, random_state=<span class="number">42</span>)</span><br><span class="line">        data[<span class="string">&#x27;cluster&#x27;</span>] = kmeans.fit_predict(data[[feature1, feature2]])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 绘制聚类结果</span></span><br><span class="line">        plt.subplot(<span class="number">1</span>, <span class="built_in">len</span>(k_values), i)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="comment"># 根据聚类结果绘制散点图</span></span><br><span class="line">            plt.scatter(data[data[<span class="string">&#x27;cluster&#x27;</span>] == j][feature1],</span><br><span class="line">                        data[data[<span class="string">&#x27;cluster&#x27;</span>] == j][feature2],</span><br><span class="line">                        label=<span class="string">f&#x27;Cluster <span class="subst">&#123;j&#125;</span>&#x27;</span>)</span><br><span class="line">        plt.xlabel(feature1)</span><br><span class="line">        plt.ylabel(feature2)</span><br><span class="line">        plt.title(<span class="string">f&#x27;KMeans Clustering with <span class="subst">&#123;k&#125;</span> Clusters&#x27;</span>)</span><br><span class="line">        plt.legend()</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择要进行聚类的特征</span></span><br><span class="line">feature1 = <span class="string">&#x27;result&#x27;</span>  <span class="comment"># x轴</span></span><br><span class="line">feature2 = <span class="string">&#x27;age&#x27;</span>  <span class="comment"># y轴</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义要绘制的 k 值</span></span><br><span class="line">k_values = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制不同 k 值的聚类</span></span><br><span class="line">plot_clusters(autism_data, feature1, feature2, k_values)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 k=3 运行k均值聚类</span></span><br><span class="line">kmeans = KMeans(n_clusters=<span class="number">3</span>, random_state=<span class="number">42</span>)</span><br><span class="line">autism_data[<span class="string">&#x27;cluster&#x27;</span>] = kmeans.fit_predict(autism_data[features])</span><br><span class="line"></span><br><span class="line">autism_data[[<span class="string">&#x27;cluster&#x27;</span>] + features].head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先获取每个聚类的中心点</span></span><br><span class="line">cluster_centers = kmeans.cluster_centers_</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看每个聚类的中心点</span></span><br><span class="line">cluster_centers_df = pd.DataFrame(cluster_centers, columns=features)</span><br><span class="line">cluster_centers_df.index.name = <span class="string">&#x27;Cluster&#x27;</span></span><br><span class="line">cluster_centers_df.reset_index(inplace=<span class="literal">True</span>)</span><br><span class="line">cluster_centers_df</span><br><span class="line"><span class="comment"># 计算每个聚类中出现的自闭症次数（Class / ASD列）</span></span><br><span class="line">cluster_class_counts = autism_data.groupby([<span class="string">&#x27;cluster&#x27;</span>, <span class="string">&#x27;Class/ASD&#x27;</span>]).size().unstack().fillna(<span class="number">0</span>)</span><br><span class="line">cluster_class_counts</span><br></pre></td></tr></table></figure><ol><li><h2 id="贝叶斯分类"><a href="#贝叶斯分类" class="headerlink" title="贝叶斯分类"></a>贝叶斯分类</h2></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入高斯朴素贝叶斯分类器</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"><span class="comment"># 导入计算分类模型的准确率的库</span></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据集</span></span><br><span class="line">data = pd.read_excel(<span class="string">&quot;F:\Desktop\表1.xlsx&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data.head())</span><br><span class="line"><span class="comment"># 分离特征和标签</span></span><br><span class="line">X = data[[<span class="string">&#x27;身高（英尺）&#x27;</span>, <span class="string">&#x27;体重（磅）&#x27;</span>, <span class="string">&#x27;脚掌（英寸）&#x27;</span>]]</span><br><span class="line">y = data[<span class="string">&#x27;性别&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据集划分为训练集和测试集</span></span><br><span class="line"><span class="comment"># 训练集包含80%的数据，测试集包含20%的数据</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化高斯朴素贝叶斯分类器</span></span><br><span class="line">nb_classifier = GaussianNB()</span><br><span class="line"><span class="comment"># 拟合数据</span></span><br><span class="line">nb_classifier.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测测试集中的数据，以验证分类器准确率</span></span><br><span class="line">y_pred = nb_classifier.predict(X_test)</span><br><span class="line">accuracy = accuracy_score(y_test, y_pred)</span><br><span class="line"><span class="built_in">print</span>(accuracy)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入预测数据</span></span><br><span class="line">test_data = pd.read_excel(<span class="string">&quot;F:\Desktop\表2.xlsx&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测数据表2的性别属性</span></span><br><span class="line">test_data[<span class="string">&#x27;性别预测&#x27;</span>] = nb_classifier.predict(test_data[[<span class="string">&#x27;身高（英尺）&#x27;</span>, <span class="string">&#x27;体重（磅）&#x27;</span>, <span class="string">&#x27;脚掌（英寸）&#x27;</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示预测结果</span></span><br><span class="line">test_data[[<span class="string">&#x27;记录&#x27;</span>, <span class="string">&#x27;性别预测&#x27;</span>]]</span><br></pre></td></tr></table></figure></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%9C%9F%E6%9C%AB/">期末</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">数据分析</a></div><div class="post_share"><div class="social-share" data-image="/img/img09.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/01/%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%9B%9E%E9%A1%BE%E7%9F%A5%E8%AF%86/" title="在面试中回顾知识"><img class="cover" src="/img/img10.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">在面试中回顾知识</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/01/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1/" title="网络规划与设计"><img class="cover" src="/img/img04.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">网络规划与设计</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/07/01/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1/" title="网络规划与设计"><img class="cover" src="/img/img04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-01</div><div class="title">网络规划与设计</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">李从浦</div><div class="author-info__description">志不强者智不达，言不信者行不果</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/licongpu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/licongpu" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="mailto:2816863923@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a><a class="social-icon" href="https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e" target="_blank" title="飞书"><i class="fa-sharp fa-solid fa-bookmark" style="color:#4a7dbe"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">一起学习,共同进步</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">第一章: 概论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E6%A1%88%E4%BE%8B%E5%87%BA%E5%8F%91%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">从案例出发：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BB%E5%AD%A6%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98%E7%9A%84%E9%80%9A%E7%94%A8%E6%B5%81%E7%A8%8B-%E7%9F%A5%E8%AF%86%E5%8F%91%E7%8E%B0%E7%9A%84%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86"><span class="toc-number">1.2.</span> <span class="toc-text">医学数据分析与挖掘的通用流程 (知识发现的核心部分)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">1.3.</span> <span class="toc-text">常用数据分析与挖掘的工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%9B%B8%E5%85%B3%E8%AF%95%E9%A2%98"><span class="toc-number">1.4.</span> <span class="toc-text">第一章相关试题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%89%B9%E5%BE%81%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">第二章：数据特征分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%90%84%E5%B1%82%E8%A6%81%E7%86%9F%E6%82%89%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">数据类型（各层要熟悉）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8F%8F%E8%BF%B0%E6%80%A7%E7%89%B9%E5%BE%81"><span class="toc-number">2.2.</span> <span class="toc-text">数据的描述性特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%AD%E8%B6%8B%E5%8A%BF"><span class="toc-number">2.2.1.</span> <span class="toc-text">数据集中趋势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%AD%E8%B6%8B%E5%8A%BF%E7%9A%84%E5%BA%A6%E9%87%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">常用的表示数据集中趋势的度量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%A6%BB%E6%95%A3%E8%B6%8B%E5%8A%BF"><span class="toc-number">2.2.3.</span> <span class="toc-text">数据离散趋势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E6%95%B0%E6%8D%AE%E7%A6%BB%E6%95%A3%E8%B6%8B%E5%8A%BF%E7%9A%84%E5%BA%A6%E9%87%8F"><span class="toc-number">2.2.4.</span> <span class="toc-text">描述数据离散趋势的度量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E7%9B%B8%E5%85%B3%E5%88%86%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">数据的相关分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%9E%8B%E5%B1%9E%E6%80%A7%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.1.</span> <span class="toc-text">数值型属性间关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%88%86%E6%9E%90-%EF%BC%88%E5%88%86%E6%9E%90%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%80%BC%E5%9E%8B%E5%B1%9E%E6%80%A7%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E5%85%B3%E6%80%A7%EF%BC%89"><span class="toc-number">2.3.2.</span> <span class="toc-text">相关分析 （分析两个数值型属性之间的相关性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%A1%E6%96%B9%EF%BC%88%CF%872%EF%BC%89%E6%A3%80%E9%AA%8C%EF%BC%88%E6%8E%A8%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%A0%87%E7%A7%B0%E5%B1%9E%E6%80%A7%E4%B9%8B%E9%97%B4%E7%9A%84%E7%8B%AC%E7%AB%8B%E6%80%A7%EF%BC%89"><span class="toc-number">2.3.3.</span> <span class="toc-text">卡方（χ2）检验（推断两个标称属性之间的独立性）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90"><span class="toc-number">2.4.</span> <span class="toc-text">主成分分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.4.1.</span> <span class="toc-text">形式化描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E7%9A%84%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.4.2.</span> <span class="toc-text">主成分分析的主要步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C"><span class="toc-number">2.5.</span> <span class="toc-text">假设检验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E6%A0%B7%E6%9C%ACt%E6%A3%80%E9%AA%8C"><span class="toc-number">2.6.</span> <span class="toc-text">独立样本t检验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%9B%B8%E5%85%B3%E8%AF%95%E9%A2%98"><span class="toc-number">2.7.</span> <span class="toc-text">第二章相关试题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">第三章：数据处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B8%85%E6%B4%97"><span class="toc-number">3.1.</span> <span class="toc-text">数据的清洗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%A4%84%E7%90%86"><span class="toc-number">3.1.1.</span> <span class="toc-text">缺失值处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E5%80%BC%E5%A4%84%E7%90%86"><span class="toc-number">3.1.2.</span> <span class="toc-text">重复值处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%80%BC%E5%A4%84%E7%90%86"><span class="toc-number">3.1.3.</span> <span class="toc-text">异常值处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%98%E6%8D%A2"><span class="toc-number">3.2.</span> <span class="toc-text">数据的变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%87%BD%E6%95%B0%E5%8F%98%E6%8D%A2"><span class="toc-number">3.2.1.</span> <span class="toc-text">简单函数变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F-%E6%9C%80%E5%A4%A7%E6%A0%87%E5%87%86%E5%8C%96"><span class="toc-number">3.2.2.</span> <span class="toc-text">最小-最大标准化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6-%E5%9D%87%E5%80%BC%E6%A0%87%E5%87%86%E5%8C%96"><span class="toc-number">3.2.3.</span> <span class="toc-text">零-均值标准化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%95%B0%E5%AE%9A%E6%A0%87%E6%A0%87%E5%87%86%E5%8C%96"><span class="toc-number">3.2.4.</span> <span class="toc-text">小数定标标准化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="toc-number">3.2.5.</span> <span class="toc-text">数据离散化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E7%83%AD%E7%BC%96%E7%A0%81%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%8C%E5%8F%AF%E8%83%BD%E8%80%83%E5%88%B0%E4%BB%A3%E7%A0%81%EF%BC%89"><span class="toc-number">3.2.6.</span> <span class="toc-text">独热编码（重点，可能考到代码）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%90%88%E5%B9%B6"><span class="toc-number">3.3.</span> <span class="toc-text">数据的合并</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%A1%A8%E5%90%88%E5%B9%B6"><span class="toc-number">3.3.1.</span> <span class="toc-text">多表合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E8%81%9A%E5%90%88"><span class="toc-number">3.3.2.</span> <span class="toc-text">分组聚合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9B%B8%E5%85%B3%E8%AF%95%E9%A2%98"><span class="toc-number">3.4.</span> <span class="toc-text">第三章相关试题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E6%8C%96%E6%8E%98"><span class="toc-number">4.</span> <span class="toc-text">第四章: 关联规则挖掘</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%80%99%E9%80%89%E9%A1%B9%E9%9B%86%E4%BA%A7%E7%94%9F-%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5%E7%9A%84%E9%A2%91%E7%B9%81%E6%A8%A1%E5%BC%8F%E6%8C%96%E6%8E%98%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">基于候选项集产生-测试策略的频繁模式挖掘算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Apriori%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.1.</span> <span class="toc-text">Apriori算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EApriori%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%AD%E5%8C%BB%E8%AF%81%E5%9E%8B%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E6%8C%96%E6%8E%98"><span class="toc-number">4.2.</span> <span class="toc-text">基于Apriori算法的中医证型关联规则挖掘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BA%A7%E7%94%9F%E5%80%99%E9%80%89%E9%A1%B9%E9%9B%86%E7%9A%84-%E9%A2%91%E7%B9%81%E6%A8%A1%E5%BC%8F%E6%8C%96%E6%8E%98%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">不需要产生候选项集的 频繁模式挖掘算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FP-growth%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.1.</span> <span class="toc-text">FP-growth算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%B1%82%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E6%8C%96%E6%8E%98%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.2.</span> <span class="toc-text">多层关联规则挖掘算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%9B%B8%E5%85%B3%E8%AF%95%E9%A2%98"><span class="toc-number">4.4.</span> <span class="toc-text">第四章相关试题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%86%E7%B1%BB%E4%B8%8E%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">第五章: 分类与回归算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E4%B8%8E%E5%9B%9E%E5%BD%92%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">分类与回归概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.1.</span> <span class="toc-text">常用的分类与回归算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E9%82%BB%E5%88%86%E7%B1%BB"><span class="toc-number">5.1.2.</span> <span class="toc-text">最近邻分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.1.3.</span> <span class="toc-text">线性回归模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.1.4.</span> <span class="toc-text">逻辑回归模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BB%B7"><span class="toc-number">5.2.</span> <span class="toc-text">模型评价</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BB%B7"><span class="toc-number">5.2.1.</span> <span class="toc-text">分类模型评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BB%B7"><span class="toc-number">5.2.2.</span> <span class="toc-text">回归模型评价</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">决策树算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E5%BA%A6%E7%9A%84%E5%BA%A6%E9%87%8F"><span class="toc-number">5.3.1.</span> <span class="toc-text">纯度的度量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%E7%AE%97%E6%B3%95"><span class="toc-number">5.4.</span> <span class="toc-text">支持向量机算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA"><span class="toc-number">5.4.1.</span> <span class="toc-text">线性支持向量机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA"><span class="toc-number">5.4.2.</span> <span class="toc-text">非线性支持向量机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95"><span class="toc-number">5.5.</span> <span class="toc-text">集成学习算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bagging"><span class="toc-number">5.5.1.</span> <span class="toc-text">Bagging</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97"><span class="toc-number">5.5.2.</span> <span class="toc-text">随机森林</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Boosting"><span class="toc-number">5.5.3.</span> <span class="toc-text">Boosting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A2%AF%E5%BA%A6%E6%8F%90%E5%8D%87%E6%9C%BA"><span class="toc-number">5.5.4.</span> <span class="toc-text">梯度提升机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stacking"><span class="toc-number">5.5.5.</span> <span class="toc-text">Stacking</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B9%E5%8F%82%E7%94%9F%E9%95%BF%E5%BD%B1%E5%93%8D%E6%8C%87%E6%A0%87%E7%AD%9B%E9%80%89"><span class="toc-number">5.6.</span> <span class="toc-text">丹参生长影响指标筛选</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%82%BA%E7%99%8C%E8%BD%AC%E7%A7%BB%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0%E5%8F%8A%E7%94%9F%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-number">5.7.</span> <span class="toc-text">肺癌转移影响因素及生存分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%E7%9B%B8%E5%85%B3%E8%AF%95%E9%A2%98"><span class="toc-number">5.8.</span> <span class="toc-text">第五章相关试题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">第六章: 聚类算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">聚类算法概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%9D%E7%A6%BB%E5%BA%A6%E9%87%8F"><span class="toc-number">6.1.1.</span> <span class="toc-text">距离度量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87"><span class="toc-number">6.1.2.</span> <span class="toc-text">聚类算法评价指标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%88%92%E5%88%86%E7%9A%84%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">基于划分的聚类算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#K-Means%E8%81%9A%E7%B1%BB"><span class="toc-number">6.2.1.</span> <span class="toc-text">K-Means聚类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86K%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB"><span class="toc-number">6.2.2.</span> <span class="toc-text">二分K均值聚类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K%E4%B8%AD%E5%BF%83%E7%82%B9%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.3.</span> <span class="toc-text">K中心点算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E7%94%A8%E5%8D%A1%E9%A3%8E%E9%99%A9%E8%AF%86%E5%88%AB%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.3.</span> <span class="toc-text">信用卡风险识别模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%B1%82%E6%AC%A1%E7%9A%84%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">基于层次的聚类算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB"><span class="toc-number">6.4.1.</span> <span class="toc-text">层次聚类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BIRCH%E7%AE%97%E6%B3%95"><span class="toc-number">6.4.2.</span> <span class="toc-text">BIRCH算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%93%E5%9C%B0%E8%8D%AF%E6%9D%90%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98"><span class="toc-number">6.5.</span> <span class="toc-text">道地药材文本数据挖掘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%AF%86%E5%BA%A6%E7%9A%84%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95"><span class="toc-number">6.6.</span> <span class="toc-text">基于密度的聚类算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DBSCAN%E7%AE%97%E6%B3%95"><span class="toc-number">6.6.1.</span> <span class="toc-text">DBSCAN算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OPTICS%E7%AE%97%E6%B3%95"><span class="toc-number">6.6.2.</span> <span class="toc-text">OPTICS算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%E7%9B%B8%E5%85%B3%E8%AF%95%E9%A2%98"><span class="toc-number">6.7.</span> <span class="toc-text">第六章相关试题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%EF%BC%8C%E7%9C%8B%E4%B8%80%E9%81%8D%E5%8D%B3%E5%8F%AF%EF%BC%8C%E9%87%8D%E7%82%B9%E8%AE%B0%E4%BD%8F%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">第七章：算法应用，看一遍即可，重点记住题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%9B%B8%E5%85%B3%E8%AF%95%E9%A2%98"><span class="toc-number">7.1.</span> <span class="toc-text">第七章相关试题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">期末考试题:</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%91%98%E9%80%89%E4%BA%8E%E8%AE%A8%E8%AE%BA%E5%8C%BA%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E5%8F%AF%E8%83%BD%E6%98%AF%E8%80%83%E8%AF%95%E4%B8%AD%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">9.</span> <span class="toc-text">摘选于讨论区中的问题，可能是考试中会出现的内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BB%E5%AD%A6%E6%95%B0%E6%8D%AE%E4%B8%AD%EF%BC%8C%E5%B0%A4%E5%85%B6%E6%98%AF%E4%B8%AD%E5%8C%BB%E5%AD%A6%E6%95%B0%E6%8D%AE%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E6%9D%A5%E6%B8%85%E6%B4%97%E6%95%B0%E6%8D%AE%E3%80%82"><span class="toc-number">9.1.</span> <span class="toc-text">医学数据中，尤其是中医学数据中，如何来清洗数据。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Python%E5%AE%9E%E7%8E%B0Apriori%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">9.2.</span> <span class="toc-text">使用Python实现Apriori算法：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2"><span class="toc-number">9.3.</span> <span class="toc-text">数据转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%81%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E3%80%81python%E5%B8%B8%E8%A7%81%E4%BB%A3%E7%A0%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">9.4.</span> <span class="toc-text">要实现文本分类、python常见代码是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95%E5%92%8C%E7%89%9B%E9%A1%BF%E5%B7%AE%E5%80%BC%E6%B3%95%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">9.5.</span> <span class="toc-text">简述拉格朗日插值法和牛顿差值法的异同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E5%BC%82%E5%B8%B8%E5%80%BC%E5%A4%84%E7%90%86%E4%B8%8E%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%A4%84%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95%E8%81%94%E7%B3%BB%E8%B5%B7%E6%9D%A5"><span class="toc-number">9.6.</span> <span class="toc-text">如何将异常值处理与缺失值处理的方法联系起来</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8B%AC%E7%83%AD%E7%BC%96%E7%A0%81%EF%BC%88one-hot-encoding%EF%BC%89%E5%92%8C%E6%A0%87%E7%AD%BE%E7%BC%96%E7%A0%81%EF%BC%88label-encoding%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.7.</span> <span class="toc-text">独热编码（one-hot encoding）和标签编码（label encoding）的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%EF%BC%9A%E6%A0%87%E7%AD%BE%E7%BC%96%E7%A0%81%E3%80%81%E5%BA%8F%E5%88%97%E7%BC%96%E7%A0%81%E3%80%81%E7%8B%AC%E7%83%AD%E7%BC%96%E7%A0%81%E3%80%81%E9%A2%91%E6%95%B0%E7%BC%96%E7%A0%81%E3%80%81%E7%9B%AE%E6%A0%87%E7%BC%96%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB%EF%BC%8C%E5%A6%82%E4%BD%95%E5%9C%A8python%E4%B8%AD%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.8.</span> <span class="toc-text">机器学习中常见编码方式：标签编码、序列编码、独热编码、频数编码、目标编码的区别与联系，如何在python中实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python%E4%B8%AD%EF%BC%8C%E8%BF%9B%E8%A1%8C%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%A4%84%E7%90%86%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%AF%B7%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E7%89%9B%E9%A1%BF%E6%8F%92%E5%80%BC%E6%B3%95%E5%92%8C%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E6%B3%95%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">9.9.</span> <span class="toc-text">python中，进行缺失值处理的时候，请简单描述牛顿插值法和拉格朗日插值法的示例代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pandas%E6%8F%90%E4%BE%9B%E4%BA%86%E6%9B%B4%E5%BC%BA%E5%A4%A7%E7%9A%84%E8%81%9A%E5%90%88%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%A6%82groupby-%E5%92%8Cagg-%E5%87%BD%E6%95%B0%EF%BC%8C%E5%85%81%E8%AE%B8%E6%A0%B9%E6%8D%AE%E6%9F%90%E4%BA%9B%E5%88%97%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%88%86%E7%BB%84%E5%B9%B6%E5%BA%94%E7%94%A8%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E3%80%82%E8%AF%95%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">9.10.</span> <span class="toc-text">Pandas提供了更强大的聚合功能，如groupby()和agg()函数，允许根据某些列对数据进行分组并应用聚合函数。试举例说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.11.</span> <span class="toc-text">关联规则算法实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8Apriori%E7%AE%97%E6%B3%95%E5%AF%B9%E4%B8%AD%E8%8D%AF%E7%BB%84%E6%96%B9%E8%BF%9B%E8%A1%8C%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E5%88%86%E6%9E%90"><span class="toc-number">9.12.</span> <span class="toc-text">利用Apriori算法对中药组方进行关联规则分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8fp-growth%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E4%B8%AD%E8%8D%AF%E7%BB%84%E6%96%B9%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E6%8C%96%E6%8E%98"><span class="toc-number">9.13.</span> <span class="toc-text">利用fp-growth算法进行中药组方关联规则挖掘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E9%92%88%E7%81%B8%E6%B2%BB%E7%96%97%E5%8A%9F%E8%83%BD%E6%80%A7%E8%83%83%E8%82%A0%E7%97%85%E7%9A%84%E9%80%89%E7%A9%B4%E8%A7%84%E5%BE%8B%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99"><span class="toc-number">9.14.</span> <span class="toc-text">寻找针灸治疗功能性胃肠病的选穴规律关联规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%92%88%E7%81%B8%E6%B2%BB%E7%96%97%E5%A4%B4%E7%97%9B"><span class="toc-number">9.15.</span> <span class="toc-text">针灸治疗头痛</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E4%BA%BA%E8%87%AA%E9%97%AD%E7%97%87%E8%BF%9B%E8%A1%8C%E8%81%9A%E7%B1%BB%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.16.</span> <span class="toc-text">成人自闭症进行聚类实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB"><span class="toc-number">9.17.</span> <span class="toc-text">贝叶斯分类</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/07/01/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1/" title="网络规划与设计"><img src="/img/img04.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="网络规划与设计"></a><div class="content"><a class="title" href="/2024/07/01/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1/" title="网络规划与设计">网络规划与设计</a><time datetime="2024-07-01T07:57:05.362Z" title="发表于 2024-07-01 15:57:05">2024-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/01/%E5%8C%BB%E5%AD%A6%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/" title="医学数据分析与挖掘"><img src="/img/img09.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="医学数据分析与挖掘"></a><div class="content"><a class="title" href="/2024/07/01/%E5%8C%BB%E5%AD%A6%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%8C%96%E6%8E%98/" title="医学数据分析与挖掘">医学数据分析与挖掘</a><time datetime="2024-07-01T07:54:38.223Z" title="发表于 2024-07-01 15:54:38">2024-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/01/%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%9B%9E%E9%A1%BE%E7%9F%A5%E8%AF%86/" title="在面试中回顾知识"><img src="/img/img10.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="在面试中回顾知识"></a><div class="content"><a class="title" href="/2024/07/01/%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%9B%9E%E9%A1%BE%E7%9F%A5%E8%AF%86/" title="在面试中回顾知识">在面试中回顾知识</a><time datetime="2024-07-01T05:45:06.774Z" title="发表于 2024-07-01 13:45:06">2024-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/01/%E5%9C%A8%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%BA%94%E5%AF%B9%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/" title="在日常开发遇到的不同场景下的应对思路总结"><img src="/img/img02.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="在日常开发遇到的不同场景下的应对思路总结"></a><div class="content"><a class="title" href="/2024/07/01/%E5%9C%A8%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E5%BA%94%E5%AF%B9%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93/" title="在日常开发遇到的不同场景下的应对思路总结">在日常开发遇到的不同场景下的应对思路总结</a><time datetime="2024-07-01T05:39:45.572Z" title="发表于 2024-07-01 13:39:45">2024-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" title="计算机网络学习总结"><img src="/img/img07.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="计算机网络学习总结"></a><div class="content"><a class="title" href="/2024/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" title="计算机网络学习总结">计算机网络学习总结</a><time datetime="2024-07-01T05:38:15.217Z" title="发表于 2024-07-01 13:38:15">2024-07-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 李从浦</div><div class="footer_custom_text">欢迎使用我的博客,期待一同进步</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="true" data-text="懒,羊,羊,大,王,的,博,客" data-fontsize="15px" data-random="false" async></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(btf.removeGlobalFnEvent("pjax"),btf.removeGlobalFnEvent("themeChange"),document.getElementById("rightside").classList.remove("rightside-show"),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>