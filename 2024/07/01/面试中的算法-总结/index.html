<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>面试中的算法-总结 | 青山入我怀</title><meta name="author" content="李从浦"><meta name="copyright" content="李从浦"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="开设这个专栏主要是在面试中算法避免一些踩坑，首先，经过我本人亲自实践+网上各位大佬总结: 当我们刷算法题的时候，比如力扣、牛客这些网站，很多的题目只需要我们写出函数体（核心代码），平台就可以自动帮助我们补齐输入输出，进行调试，但，在笔试和面试中，往往需要自己写出可以运行的完整代码（ACM模式），这个时候，需要我们去了解一下自己所使用的语言下的输入输出如何去设计。 Leetcode hot100题解"><meta property="og:type" content="article"><meta property="og:title" content="面试中的算法-总结"><meta property="og:url" content="http://licongpu.github.io/2024/07/01/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95-%E6%80%BB%E7%BB%93/index.html"><meta property="og:site_name" content="青山入我怀"><meta property="og:description" content="开设这个专栏主要是在面试中算法避免一些踩坑，首先，经过我本人亲自实践+网上各位大佬总结: 当我们刷算法题的时候，比如力扣、牛客这些网站，很多的题目只需要我们写出函数体（核心代码），平台就可以自动帮助我们补齐输入输出，进行调试，但，在笔试和面试中，往往需要自己写出可以运行的完整代码（ACM模式），这个时候，需要我们去了解一下自己所使用的语言下的输入输出如何去设计。 Leetcode hot100题解"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://licongpu.github.io/img/img02.jpg"><meta property="article:published_time" content="2024-07-01T05:34:40.699Z"><meta property="article:modified_time" content="2024-07-17T08:52:48.759Z"><meta property="article:author" content="李从浦"><meta property="article:tag" content="JAVA"><meta property="article:tag" content="面试"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://licongpu.github.io/img/img02.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://licongpu.github.io/2024/07/01/%E9%9D%A2%E8%AF%95%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95-%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!1,top_n_per_article:1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlight.js",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:50},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:{chs_to_cht:"你已切换为繁体中文",cht_to_chs:"你已切换为简体中文",day_to_night:"你已切换为深色模式",night_to_day:"你已切换为浅色模式",bgLight:"#a29bfe",bgDark:"#7f8fa6",position:"bottom-left"},infinitegrid:{js:"https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js",buttonText:"加载更多"},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!1},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"面试中的算法-总结",isPost:!0,isHome:!1,isHighlightShrink:!0,isToc:!0,postUpdate:"2024-07-17 16:52:48"}</script><script>(e=>{e.saveToLocal={set:(e,t,o)=>{if(0===o)return;const a={value:t,expiry:Date.now()+864e5*o};localStorage.setItem(e,JSON.stringify(a))},get:e=>{const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!(Date.now()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=(e,t={})=>new Promise(((o,a)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},Object.keys(t).forEach((e=>{n.setAttribute(e,t[e])})),document.head.appendChild(n)})),e.getCSS=(e,t=!1)=>new Promise(((o,a)=>{const n=document.createElement("link");n.rel="stylesheet",n.href=e,t&&(n.id=t),n.onerror=a,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,o())},document.head.appendChild(n)})),e.activateDarkMode=()=>{document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=()=>{document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 7.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('/img/img02.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="青山入我怀"><span class="site-name">青山入我怀</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试中的算法-总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-07-01T05:34:40.699Z" title="发表于 2024-07-01 13:34:40">2024-07-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/JAVA/">JAVA</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>79分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>开设这个专栏主要是在面试中算法避免一些踩坑，首先，经过我本人亲自实践+网上各位大佬总结:</p><p>当我们刷算法题的时候，比如力扣、牛客这些网站，很多的题目只需要我们写出函数体（核心代码），平台就可以自动帮助我们补齐输入输出，进行调试，但，在笔试和面试中，往往需要自己写出可以运行的完整代码（ACM模式），这个时候，需要我们去了解一下自己所使用的语言下的输入输出如何去设计。</p><p>Leetcode hot100题解以及平时学习的一些算法模板以及例题全部放到云盘，欢迎大家获取</p><p><a target="_blank" rel="noopener" href="https://www.123pan.com/s/e7ipTd-RUh5H.html">https://www.123pan.com/s/e7ipTd-RUh5H.html</a></p><h2 id="核心代码模式与ACM模式"><a href="#核心代码模式与ACM模式" class="headerlink" title="核心代码模式与ACM模式"></a>核心代码模式与ACM模式</h2><p>当我们刷算法题的时候，比如力扣、牛客这些网站，很多的题目只需要我们写出函数体（核心代码），平台就可以自动帮助我们补齐输入输出，进行调试，但，在笔试和面试中，往往需要自己写出可以运行的完整代码（ACM模式），这个时候，需要我们去了解一下自己所使用的语言下的输入输出如何去设计。</p><p>首先给出几个注意事项：</p><p>1.笔试平台用的比较多的，比如牛客，赛码，可以提前去熟悉熟悉上面的操作。</p><p>2.有些笔试，需要自己写输入输出，有些，则不需要，但我们必须要把输入输出搞懂，这样就不怕是什么类型的笔试了，而且输入输出本身是不难的，学习一下就可以完全掌握。最好不要出现，算法题的核心思路会写，卡在了输入输出上，这样就很难受了。</p><p>3.有些笔试，还会让大伙自己设计测试用例，这个平时练习的时候也可以注意一下，主要核心的思想就是测试用例设计的几个原则。</p><p>4.不仅仅是笔试，有些面试，也会要求你写输入输出和测试用例。</p><h2 id="面试手撕代码的几种形式"><a href="#面试手撕代码的几种形式" class="headerlink" title="面试手撕代码的几种形式"></a>面试手撕代码的几种形式</h2><p>1.平台类</p><p>去面试官给定的平台上去面试，上面可以编写代码，调试和运行，这些平台有的写好了函数框架，有的是白板，需要自己写全部内容</p><p>2.自己的IDE</p><p>面试官要求候选人打开自己的ide，并共享桌面进行编写，这种肯定是要自己写全输入输出了</p><p>3.要求补齐测试用例</p><p>有些面试官，比如微软的面试官，可能会让你写完代码后，自己设计尽可能全面的测试用例，对你编写的代码进行测试。</p><h2 id="java处理输入输出"><a href="#java处理输入输出" class="headerlink" title="java处理输入输出"></a>java处理输入输出</h2><p>然后我是javaer，所以就给出java的acm模式处理输入输出的方式:</p><p>因为我之前参加算法比赛中，一般都是对时间卡的比较严格，所以都是用java的快读快写，但是笔试或者面试中手撕，一般不会要求那么严格，或者测试用例比较少，所以我么们直接使用Scanner就完全够用了</p><h3 id="情况1-全都是数字的输入，每行数字个数不定"><a href="#情况1-全都是数字的输入，每行数字个数不定" class="headerlink" title="情况1: 全都是数字的输入，每行数字个数不定"></a><strong>情况1: 全都是数字的输入，每行数字个数不定</strong></h3><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022127280.png" alt="image (4)" style="zoom:50%"><h3 id="情况2-每行第一个数字为确定的数字n，后面跟着n个数字"><a href="#情况2-每行第一个数字为确定的数字n，后面跟着n个数字" class="headerlink" title="情况2:每行第一个数字为确定的数字n，后面跟着n个数字"></a><strong>情况2:每行第一个数字为确定的数字n，后面跟着n个数字</strong></h3><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022127127.png" alt="image" style="zoom:50%"><h3 id="情况3-每行确定有n个数字的情况"><a href="#情况3-每行确定有n个数字的情况" class="headerlink" title="情况3: 每行确定有n个数字的情况"></a><strong>情况3: 每行确定有n个数字的情况</strong></h3><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022051417.png" alt="af53e94f-b92f-4994-9728-d7d91195b5db" style="zoom:50%"><h3 id="情况4-第一行是一个数字n-第二行是n个字符串"><a href="#情况4-第一行是一个数字n-第二行是n个字符串" class="headerlink" title="情况4: 第一行是一个数字n, 第二行是n个字符串"></a><strong>情况4: 第一行是一个数字n, 第二行是n个字符串</strong></h3><img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022052740.png" alt="cd792bb5-5f16-4379-b318-bcb270f57043" style="zoom:50%"> <img src="https://cdn.jsdelivr.net/gh/licongpu/mypic/img/202407022127888.png" alt="image (1)" style="zoom:50%"><h3 id="避坑点"><a href="#避坑点" class="headerlink" title="避坑点"></a>避坑点</h3><ul><li><strong>全局只能new出一个Scanner对象，如果有多个，会出现不可预见的问题！</strong></li><li>关于next() 函数、nextInt()函数、nextLine()函数：</li></ul><p>​ <strong>nextInt():</strong> 只读取整数类型数据， nextInt()在读取完输入后把光标放在读取数据的同一行，该数据的后面。</p><p>​ <strong>next():</strong> 只读取到空格，不能读取被空格分开的两个单词（也就是不能读取空格），并且在读取完后把光标放在读取数据的同一行，该数据的后面。（同上）</p><p>​ <strong>nextLine():</strong> 读取整行的数据包括单词间的空格，到回车结束（也就是从开始读一整行包括回车），读取结束后，光标放在下一行开头。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>不论是acm模式，还是核心代码模式，面试官考察的还是算法能力，要提高算法能力，说再多也没用，练就有效，像leetcode,牛客，洛谷，都是非常好的刷题网站，如果是零基础，并且要用java去应对笔试，我推荐去b站上搜索左程云老师，先入门，再刷题，每天坚持，无问西东。</p><h2 id="各类算法模板-只提供JAVA"><a href="#各类算法模板-只提供JAVA" class="headerlink" title="各类算法模板(只提供JAVA):"></a>各类算法模板(只提供JAVA):</h2><p>只记录比较死的模板。各类算法模板学习自–左程云老师</p><p>更多java模板以及例题我已经上传至云盘，欢迎获取 <a target="_blank" rel="noopener" href="https://www.123pan.com/s/e7ipTd-RUh5H.html">https://www.123pan.com/s/e7ipTd-RUh5H.html</a></p><h3 id="1-选择排序、插入排序、冒泡排序"><a href="#1-选择排序、插入排序、冒泡排序" class="headerlink" title="1.选择排序、插入排序、冒泡排序"></a>1.选择排序、插入排序、冒泡排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectBubbleInsert</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组中交换i和j位置的数</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择排序</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> minIndex, i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                        minIndex = i;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                                        minIndex = j;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        swap(arr, i, minIndex);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 冒泡排序</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; end &gt; <span class="number">0</span>; end--) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; end; i++) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                                        swap(arr, i, i + <span class="number">1</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入排序</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">                                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-二叉树及其三种序"><a href="#2-二叉树及其三种序" class="headerlink" title="2.二叉树及其三种序"></a>2.二叉树及其三种序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">                <span class="keyword">public</span> TreeNode left;</span><br><span class="line">                <span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">                        val = v;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> <span class="comment">// 先序打印所有节点，递归版</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode head)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(head.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                preOrder(head.left);</span><br><span class="line">                preOrder(head.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中序打印所有节点，递归版</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode head)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                inOrder(head.left);</span><br><span class="line">                System.out.print(head.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                inOrder(head.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序打印所有节点，递归版</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">posOrder</span><span class="params">(TreeNode head)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                posOrder(head.left);</span><br><span class="line">                posOrder(head.right);</span><br><span class="line">                System.out.print(head.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先序打印所有节点，非递归版</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode head)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">                        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">                        stack.push(head);</span><br><span class="line">                        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                                head = stack.pop();</span><br><span class="line">                                System.out.print(head.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                                <span class="keyword">if</span> (head.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                                        stack.push(head.right);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (head.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                                        stack.push(head.left);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 中序打印所有节点，非递归版</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode head)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">                        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">                        <span class="keyword">while</span> (!stack.isEmpty() || head != <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">                                        stack.push(head);</span><br><span class="line">                                        head = head.left;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        head = stack.pop();</span><br><span class="line">                                        System.out.print(head.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                                        head = head.right;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序打印所有节点，非递归版</span></span><br><span class="line">        <span class="comment">// 这是用两个栈的方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">posOrderTwoStacks</span><span class="params">(TreeNode head)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">                        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">                        Stack&lt;TreeNode&gt; collect = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">                        stack.push(head);</span><br><span class="line">                        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                                head = stack.pop();</span><br><span class="line">                                collect.push(head);</span><br><span class="line">                                <span class="keyword">if</span> (head.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                                        stack.push(head.left);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (head.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                                        stack.push(head.right);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (!collect.isEmpty()) &#123;</span><br><span class="line">                                System.out.print(collect.pop().val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h3 id="3-归并排序"><a href="#3-归并排序" class="headerlink" title="3.归并排序"></a>3.归并排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// mergeSort1为递归方法</span></span><br><span class="line">                        <span class="comment">// mergeSort2为非递归方法</span></span><br><span class="line">                        <span class="comment">// 用哪个都可以</span></span><br><span class="line">                        <span class="comment">// mergeSort1(nums);</span></span><br><span class="line">                        mergeSort2(nums);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">50001</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"><span class="comment">// 归并排序递归版</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">                sort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">                sort(arr, l, m);</span><br><span class="line">                sort(arr, m + <span class="number">1</span>, r);</span><br><span class="line">                merge(arr, l, m, r);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"> <span class="comment">// 归并排序非递归版</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> l, m, r, step = <span class="number">1</span>; step &lt; n; step &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                        l = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">while</span> (l &lt; n) &#123;</span><br><span class="line">                                m = l + step - <span class="number">1</span>;</span><br><span class="line">                                <span class="keyword">if</span> (m + <span class="number">1</span> &gt;= n) &#123;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                r = Math.min(l + (step &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">                                merge(arr, l, m, r);</span><br><span class="line">                                l = r + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> l;</span><br><span class="line">                <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> m + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (a &lt;= m &amp;&amp; b &lt;= r) &#123;</span><br><span class="line">                        help[i++] = arr[a] &lt;= arr[b] ? arr[a++] : arr[b++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (a &lt;= m) &#123;</span><br><span class="line">                        help[i++] = arr[a++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (b &lt;= r) &#123;</span><br><span class="line">                        help[i++] = arr[b++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (i = l; i &lt;= r; i++) &#123;</span><br><span class="line">                        arr[i] = help[i];</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="4-快速排序"><a href="#4-快速排序" class="headerlink" title="4.快速排序"></a>4.快速排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">         <span class="keyword">if</span> (nums.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                 quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> nums;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 随机快速排序</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 随机这一下，常数时间比较大</span></span><br><span class="line">         <span class="comment">// 但只有这一下随机，才能在概率上把快速排序的时间复杂度收敛到O(n * logn)</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> arr[l + (<span class="type">int</span>) (Math.random() * (r - l + <span class="number">1</span>))];</span><br><span class="line">         partition(arr, l, r, x);</span><br><span class="line">         <span class="comment">// 为了防止底层的递归过程覆盖全局变量</span></span><br><span class="line">         <span class="comment">// 这里用临时变量记录first、last</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> first;</span><br><span class="line">         <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> last;</span><br><span class="line">         quickSort(arr, l, left - <span class="number">1</span>);</span><br><span class="line">         quickSort(arr, right + <span class="number">1</span>, r);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 荷兰国旗问题</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> first, last;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 已知arr[l....r]范围上一定有x这个值</span></span><br><span class="line"> <span class="comment">// 划分数组 &lt;x放左边，==x放中间，&gt;x放右边</span></span><br><span class="line"> <span class="comment">// 把全局变量first, last，更新成==x区域的左右边界</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">         first = l;</span><br><span class="line">         last = r;</span><br><span class="line">         <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">         <span class="keyword">while</span> (i &lt;= last) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (arr[i] == x) &#123;</span><br><span class="line">                         i++;</span><br><span class="line">                 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; x) &#123;</span><br><span class="line">                         swap(arr, first++, i++);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         swap(arr, i, last--);</span><br><span class="line">                 &#125;</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">         arr[i] = arr[j];</span><br><span class="line">         arr[j] = tmp;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="5-含有嵌套的表达式求值"><a href="#5-含有嵌套的表达式求值" class="headerlink" title="5.含有嵌套的表达式求值"></a>5.含有嵌套的表达式求值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String str)</span> &#123;</span><br><span class="line">                where = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> f(str.toCharArray(), <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> where;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s[i....]开始计算，遇到字符串终止 或者 遇到)停止</span></span><br><span class="line">        <span class="comment">// 返回 : 自己负责的这一段，计算的结果</span></span><br><span class="line">        <span class="comment">// 返回之间，更新全局变量where，为了上游函数知道从哪继续！</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">char</span>[] s, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                ArrayList&lt;Integer&gt; numbers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                ArrayList&lt;Character&gt; ops = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.length &amp;&amp; s[i] != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                                cur = cur * <span class="number">10</span> + s[i++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                                <span class="comment">// 遇到了运算符 + - * /</span></span><br><span class="line">                                push(numbers, ops, cur, s[i++]);</span><br><span class="line">                                cur = <span class="number">0</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// i (.....)</span></span><br><span class="line">                                <span class="comment">// 遇到了左括号！</span></span><br><span class="line">                                cur = f(s, i + <span class="number">1</span>);</span><br><span class="line">                                i = where + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                push(numbers, ops, cur, <span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">                where = i;</span><br><span class="line">                <span class="keyword">return</span> compute(numbers, ops);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(ArrayList&lt;Integer&gt; numbers, ArrayList&lt;Character&gt; ops, <span class="type">int</span> cur, <span class="type">char</span> op)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> numbers.size();</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="number">0</span> || ops.get(n - <span class="number">1</span>) == <span class="string">&#x27;+&#x27;</span> || ops.get(n - <span class="number">1</span>) == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                        numbers.add(cur);</span><br><span class="line">                        ops.add(op);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">topNumber</span> <span class="operator">=</span> numbers.get(n - <span class="number">1</span>);</span><br><span class="line">                        <span class="type">char</span> <span class="variable">topOp</span> <span class="operator">=</span> ops.get(n - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span> (topOp == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                                numbers.set(n - <span class="number">1</span>, topNumber * cur);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                numbers.set(n - <span class="number">1</span>, topNumber / cur);</span><br><span class="line">                        &#125;</span><br><span class="line">                        ops.set(n - <span class="number">1</span>, op);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">(ArrayList&lt;Integer&gt; numbers, ArrayList&lt;Character&gt; ops)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> numbers.size();</span><br><span class="line">                <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> numbers.get(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                        ans += ops.get(i - <span class="number">1</span>) == <span class="string">&#x27;+&#x27;</span> ? numbers.get(i) : -numbers.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="6-最大公约数和最小公倍数"><a href="#6-最大公约数和最小公倍数" class="headerlink" title="6.最大公约数和最小公倍数"></a>6.最大公约数和最小公倍数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">gcd</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">lcm</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="type">long</span>) a / gcd(a, b) * b;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="7-返回无序数组中累加和为给定值的最长子数组长（一维构建前缀信息）"><a href="#7-返回无序数组中累加和为给定值的最长子数组长（一维构建前缀信息）" class="headerlink" title="7.返回无序数组中累加和为给定值的最长子数组长（一维构建前缀信息）"></a>7.返回无序数组中累加和为给定值的最长子数组长（一维构建前缀信息）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code02_LongestSubarraySumEqualsAim</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, aim;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key : 某个前缀和</span></span><br><span class="line">        <span class="comment">// value : 这个前缀和最早出现的位置</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">                <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">                <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">                        n = (<span class="type">int</span>) in.nval;</span><br><span class="line">                        in.nextToken();</span><br><span class="line">                        aim = (<span class="type">int</span>) in.nval;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                                in.nextToken();</span><br><span class="line">                                arr[i] = (<span class="type">int</span>) in.nval;</span><br><span class="line">                        &#125;</span><br><span class="line">                        out.println(compute());</span><br><span class="line">                &#125;</span><br><span class="line">                out.flush();</span><br><span class="line">                out.close();</span><br><span class="line">                br.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">                map.clear();</span><br><span class="line">                <span class="comment">// 重要 : 0这个前缀和，一个数字也没有的时候，就存在了</span></span><br><span class="line">                map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                        sum += arr[i];</span><br><span class="line">                        <span class="keyword">if</span> (map.containsKey(sum - aim)) &#123;</span><br><span class="line">                                ans = Math.max(ans, i - map.get(sum - aim));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (!map.containsKey(sum)) &#123;</span><br><span class="line">                                map.put(sum, i);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-一维差分"><a href="#8-一维差分" class="headerlink" title="8.一维差分"></a>8.一维差分</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/corporate-flight-bookings/">例题链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] corpFlightBookings(<span class="type">int</span>[][] bookings, <span class="type">int</span> n) &#123;</span><br><span class="line">                <span class="type">int</span>[] cnt=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span>[] book : bookings) &#123;</span><br><span class="line">                        cnt[book[<span class="number">0</span>]]+=book[<span class="number">2</span>];</span><br><span class="line">                        cnt[book[<span class="number">1</span>]+<span class="number">1</span>]-=book[<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; cnt.length; i++) &#123;</span><br><span class="line">                        cnt[i]+=cnt[i-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span>[] ans=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ans.length; i++) &#123;</span><br><span class="line">                        ans[i]=cnt[i+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="9-二维构建前缀信息"><a href="#9-二维构建前缀信息" class="headerlink" title="9.二维构建前缀信息"></a>9.二维构建前缀信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] sum;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="title function_">NumMatrix</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">                        sum = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, c = <span class="number">0</span>; c &lt; n; a++, c++) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>, d = <span class="number">0</span>; d &lt; m; b++, d++) &#123;</span><br><span class="line">                                        sum[a][b] = matrix[c][d];</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                                        sum[i][j] += sum[i][j - <span class="number">1</span>] + sum[i - <span class="number">1</span>][j] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRegion</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">                        c++;</span><br><span class="line">                        d++;</span><br><span class="line">                        <span class="keyword">return</span> sum[c][d] - sum[c][b] - sum[a][d] + sum[a][b];</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><h3 id="10-二维差分"><a href="#10-二维差分" class="headerlink" title="10.二维差分"></a>10.二维差分</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code03_DiffMatrixNowcoder</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span>[][] diff = <span class="keyword">new</span> <span class="title class_">long</span>[MAXN][MAXM];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">                diff[a][b] += k;</span><br><span class="line">                diff[c + <span class="number">1</span>][b] -= k;</span><br><span class="line">                diff[a][d + <span class="number">1</span>] -= k;</span><br><span class="line">                diff[c + <span class="number">1</span>][d + <span class="number">1</span>] += k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                                diff[i][j] += diff[i - <span class="number">1</span>][j] + diff[i][j - <span class="number">1</span>] - diff[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                                diff[i][j] = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">                <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">                <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">                        n = (<span class="type">int</span>) in.nval;</span><br><span class="line">                        in.nextToken();</span><br><span class="line">                        m = (<span class="type">int</span>) in.nval;</span><br><span class="line">                        in.nextToken();</span><br><span class="line">                        q = (<span class="type">int</span>) in.nval;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                                        in.nextToken();</span><br><span class="line">                                        add(i, j, i, j, (<span class="type">int</span>) in.nval);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, a, b, c, d, k; i &lt;= q; i++) &#123;</span><br><span class="line">                                in.nextToken();</span><br><span class="line">                                a = (<span class="type">int</span>) in.nval;</span><br><span class="line">                                in.nextToken();</span><br><span class="line">                                b = (<span class="type">int</span>) in.nval;</span><br><span class="line">                                in.nextToken();</span><br><span class="line">                                c = (<span class="type">int</span>) in.nval;</span><br><span class="line">                                in.nextToken();</span><br><span class="line">                                d = (<span class="type">int</span>) in.nval;</span><br><span class="line">                                in.nextToken();</span><br><span class="line">                                k = (<span class="type">int</span>) in.nval;</span><br><span class="line">                                add(a, b, c, d, k);</span><br><span class="line">                        &#125;</span><br><span class="line">                        build();</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                                out.print(diff[i][<span class="number">1</span>]);</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                                        out.print(<span class="string">&quot; &quot;</span> + diff[i][j]);</span><br><span class="line">                                &#125;</span><br><span class="line">                                out.println();</span><br><span class="line">                        &#125;</span><br><span class="line">                        clear();</span><br><span class="line">                &#125;</span><br><span class="line">                out.flush();</span><br><span class="line">                out.close();</span><br><span class="line">                br.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-滑动窗口"><a href="#11-滑动窗口" class="headerlink" title="11.滑动窗口"></a>11.滑动窗口</h3><p>以“<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">累加和大于等于target的最短子数组长度</a>”为例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>; r &lt; nums.length; r++) &#123;</span><br><span class="line">                        sum += nums[r];</span><br><span class="line">                        <span class="keyword">while</span> (sum - nums[l] &gt;= target) &#123;</span><br><span class="line">                                <span class="comment">// sum : nums[l....r]</span></span><br><span class="line">                                <span class="comment">// 如果l位置的数从窗口出去，还能继续达标，那就出去</span></span><br><span class="line">                                sum -= nums[l++];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">                                ans = Math.min(ans, r - l + <span class="number">1</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="12-二分答案法"><a href="#12-二分答案法" class="headerlink" title="12.二分答案法"></a>12.二分答案法</h3><p>以“<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/koko-eating-bananas/">爱吃香蕉的珂珂</a>”为例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code01_KokoEatingBananas</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 时间复杂度O(n * log(max))，额外空间复杂度O(1)</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">                <span class="comment">// 最小且达标的速度，范围[l,r]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> pile : piles) &#123;</span><br><span class="line">                        r = Math.max(r, pile);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// [l,r]不停二分</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                        <span class="comment">// m = (l + r) / 2</span></span><br><span class="line">                        m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span> (f(piles, m) &lt;= h) &#123;</span><br><span class="line">                                <span class="comment">// 达标！</span></span><br><span class="line">                                <span class="comment">// 记录答案，去左侧二分</span></span><br><span class="line">                                ans = m;</span><br><span class="line">                                <span class="comment">// l....m....r</span></span><br><span class="line">                                <span class="comment">// l..m-1</span></span><br><span class="line">                                r = m - <span class="number">1</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// 不达标</span></span><br><span class="line">                                l = m + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 香蕉重量都在piles</span></span><br><span class="line">        <span class="comment">// 速度就定成speed</span></span><br><span class="line">        <span class="comment">// 返回吃完所有的香蕉，耗费的小时数量</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> speed)</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> pile : piles) &#123;</span><br><span class="line">                        <span class="comment">// (a/b)结果向上取整，如果a和b都是非负数，可以写成(a+b-1)/b</span></span><br><span class="line">                        <span class="comment">// &quot;讲解032-位图&quot;讲了这种写法，不会的同学可以去看看</span></span><br><span class="line">                        <span class="comment">// 这里不再赘述</span></span><br><span class="line">                        ans += (pile + speed - <span class="number">1</span>) / speed;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="13-单调栈"><a href="#13-单调栈" class="headerlink" title="13.单调栈"></a>13.单调栈</h3><p>求每个位置左右两侧，离当前位置最近、且值严格小于&#x2F;大于的位置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">1000001</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] stack = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, r;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// arr[0...n-1]</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">         r = <span class="number">0</span>;</span><br><span class="line">         <span class="type">int</span> cur;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                 <span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; arr[stack[r - <span class="number">1</span>]] &gt;= arr[i]) &#123;</span><br><span class="line">                         cur=stack[--r];</span><br><span class="line">                         ans[cur][<span class="number">0</span>]=r&gt;<span class="number">0</span>?stack[r-<span class="number">1</span>]:-<span class="number">1</span>;</span><br><span class="line">                         ans[cur][<span class="number">1</span>]=i;</span><br><span class="line">                 &#125;</span><br><span class="line">                 stack[r++]=i;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//总结阶段</span></span><br><span class="line">         <span class="keyword">while</span> (r&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                 cur=stack[--r];</span><br><span class="line">                 ans[cur][<span class="number">0</span>]=r&gt;<span class="number">0</span>?stack[r-<span class="number">1</span>]:-<span class="number">1</span>;</span><br><span class="line">                 ans[cur][<span class="number">1</span>]=-<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//修正阶段</span></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">2</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                 <span class="keyword">if</span> (ans[i][<span class="number">1</span>]!=-<span class="number">1</span>&amp;&amp;arr[ans[i][<span class="number">1</span>]]==arr[i]) &#123;</span><br><span class="line">                         ans[i][<span class="number">1</span>]=ans[ans[i][<span class="number">1</span>]][<span class="number">1</span>];</span><br><span class="line">                 &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><h3 id="14-单调队列"><a href="#14-单调队列" class="headerlink" title="14.单调队列"></a>14.单调队列</h3><p>以“<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">滑动窗口最大值</a>”为例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] deque = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> h, t;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">                h = t = <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">                <span class="comment">// 先形成长度为k-1的窗口</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                        <span class="comment">// 大 -&gt; 小</span></span><br><span class="line">                        <span class="keyword">while</span> (h &lt; t &amp;&amp; arr[deque[t - <span class="number">1</span>]] &lt;= arr[i]) &#123;</span><br><span class="line">                                t--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        deque[t++] = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> n - k + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">                <span class="comment">// 当前窗口k-1长度</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = k - <span class="number">1</span>; l &lt; m; l++, r++) &#123;</span><br><span class="line">                        <span class="comment">// 少一个，要让r位置的数进来</span></span><br><span class="line">                        <span class="keyword">while</span> (h &lt; t &amp;&amp; arr[deque[t - <span class="number">1</span>]] &lt;= arr[r]) &#123;</span><br><span class="line">                                t--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        deque[t++] = r;</span><br><span class="line">                        <span class="comment">// 收集答案</span></span><br><span class="line">                        ans[l] = arr[deque[h]];</span><br><span class="line">                        <span class="comment">// l位置的数出去</span></span><br><span class="line">                        <span class="keyword">if</span> (deque[h] == l) &#123;</span><br><span class="line">                                h++;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="15-并查集模板"><a href="#15-并查集模板" class="headerlink" title="15.并查集模板"></a>15.并查集模板</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code02_UnionFindLuogu</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                        father[i] = i;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != father[i]) &#123;</span><br><span class="line">                        father[i] = find(father[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> father[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSameSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">                father[find(x)] = find(y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">                <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">                <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">                        n = (<span class="type">int</span>) in.nval;</span><br><span class="line">                        build();</span><br><span class="line">                        in.nextToken();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (<span class="type">int</span>) in.nval;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                                in.nextToken();</span><br><span class="line">                                <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> (<span class="type">int</span>) in.nval;</span><br><span class="line">                                in.nextToken();</span><br><span class="line">                                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) in.nval;</span><br><span class="line">                                in.nextToken();</span><br><span class="line">                                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) in.nval;</span><br><span class="line">                                <span class="keyword">if</span> (z == <span class="number">1</span>) &#123;</span><br><span class="line">                                        union(x, y);</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        out.println(isSameSet(x, y) ? <span class="string">&quot;Y&quot;</span> : <span class="string">&quot;N&quot;</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                out.flush();</span><br><span class="line">                out.close();</span><br><span class="line">                br.close();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="16-洪水填充问题"><a href="#16-洪水填充问题" class="headerlink" title="16.洪水填充问题"></a>16.洪水填充问题</h3><p>以“<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/">岛屿数量</a>”为例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 洪水填充的做法</span></span><br><span class="line">        <span class="comment">// board : n * m</span></span><br><span class="line">        <span class="comment">// O(n*m)最优解！</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length;</span><br><span class="line">                <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">                <span class="type">int</span> <span class="variable">islands</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                                        islands++;</span><br><span class="line">                                        dfs(board, n, m, i, j);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> islands;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == n || j &lt; <span class="number">0</span> || j == m || board[i][j] != <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// board[i][j] = &#x27;1&#x27;</span></span><br><span class="line">                board[i][j] = <span class="number">0</span>;</span><br><span class="line">                dfs(board, n, m, i - <span class="number">1</span>, j);</span><br><span class="line">                dfs(board, n, m, i + <span class="number">1</span>, j);</span><br><span class="line">                dfs(board, n, m, i, j - <span class="number">1</span>);</span><br><span class="line">                dfs(board, n, m, i, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="17-三种建图方式"><a href="#17-三种建图方式" class="headerlink" title="17.三种建图方式"></a>17.三种建图方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code01_CreateGraph</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 点的最大数量</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 边的最大数量</span></span><br><span class="line">        <span class="comment">// 只有链式前向星方式建图需要这个数量</span></span><br><span class="line">        <span class="comment">// 注意如果无向图的最大数量是m条边，数量要准备m*2</span></span><br><span class="line">        <span class="comment">// 因为一条无向边要加两条有向边</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 邻接矩阵方式建图</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] graph1 = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 邻接表方式建图</span></span><br><span class="line">        <span class="comment">// public static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph2 = new ArrayList&lt;&gt;();</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;<span class="type">int</span>[]&gt;&gt; graph2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链式前向星方式建图</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果边有权重，那么需要这个数组</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] weight = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">                <span class="comment">// 邻接矩阵清空</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                                graph1[i][j] = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 邻接表清空和准备</span></span><br><span class="line">                graph2.clear();</span><br><span class="line">                <span class="comment">// 下标需要支持1~n，所以加入n+1个列表，0下标准备但不用</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                        graph2.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 链式前向星清空</span></span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">                Arrays.fill(head, <span class="number">1</span>, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链式前向星加边</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">                <span class="comment">// u -&gt; v , 边权重是w</span></span><br><span class="line">                next[cnt] = head[u];</span><br><span class="line">                to[cnt] = v;</span><br><span class="line">                weight[cnt] = w;</span><br><span class="line">                head[u] = cnt++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 三种方式建立有向图带权图</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">directGraph</span><span class="params">(<span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">                <span class="comment">// 邻接矩阵建图</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">                        graph1[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 邻接表建图</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">                        <span class="comment">// graph2.get(edge[0]).add(edge[1]);</span></span><br><span class="line">                        graph2.get(edge[<span class="number">0</span>]).add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; edge[<span class="number">1</span>], edge[<span class="number">2</span>] &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 链式前向星建图</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">                        addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>], edge[<span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 三种方式建立无向图带权图</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">undirectGraph</span><span class="params">(<span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">                <span class="comment">// 邻接矩阵建图</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">                        graph1[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">                        graph1[edge[<span class="number">1</span>]][edge[<span class="number">0</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 邻接表建图</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">                        <span class="comment">// graph2.get(edge[0]).add(edge[1]);</span></span><br><span class="line">                        <span class="comment">// graph2.get(edge[1]).add(edge[0]);</span></span><br><span class="line">                        graph2.get(edge[<span class="number">0</span>]).add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; edge[<span class="number">1</span>], edge[<span class="number">2</span>] &#125;);</span><br><span class="line">                        graph2.get(edge[<span class="number">1</span>]).add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; edge[<span class="number">0</span>], edge[<span class="number">2</span>] &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 链式前向星建图</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">                        addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>], edge[<span class="number">2</span>]);</span><br><span class="line">                        addEdge(edge[<span class="number">1</span>], edge[<span class="number">0</span>], edge[<span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;邻接矩阵遍历 :&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                                System.out.print(graph1[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;邻接表遍历 :&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                        System.out.print(i + <span class="string">&quot;(邻居、边权) : &quot;</span>);</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span>[] edge : graph2.get(i)) &#123;</span><br><span class="line">                                System.out.print(<span class="string">&quot;(&quot;</span> + edge[<span class="number">0</span>] + <span class="string">&quot;,&quot;</span> + edge[<span class="number">1</span>] + <span class="string">&quot;) &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;链式前向星 :&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                        System.out.print(i + <span class="string">&quot;(邻居、边权) : &quot;</span>);</span><br><span class="line">                        <span class="comment">// 注意这个for循环，链式前向星的方式遍历</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">ei</span> <span class="operator">=</span> head[i]; ei &gt; <span class="number">0</span>; ei = next[ei]) &#123;</span><br><span class="line">                                System.out.print(<span class="string">&quot;(&quot;</span> + to[ei] + <span class="string">&quot;,&quot;</span> + weight[ei] + <span class="string">&quot;) &quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="18-拓扑排序模板"><a href="#18-拓扑排序模板" class="headerlink" title="18.拓扑排序模板"></a>18.拓扑排序模板</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code02_TopoSortDynamicNowcoder</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">200001</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓扑排序，用到队列</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> l, r;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拓扑排序，入度表</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] indegree = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收集拓扑排序的结果</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">                <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">                <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">                        n = (<span class="type">int</span>) in.nval;</span><br><span class="line">                        in.nextToken();</span><br><span class="line">                        m = (<span class="type">int</span>) in.nval;</span><br><span class="line">                        <span class="comment">// 动态建图，比赛肯定不行，但是一般大厂笔试、面试允许</span></span><br><span class="line">                        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                                graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">                        &#125;</span><br><span class="line">                        Arrays.fill(indegree, <span class="number">0</span>, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, from, to; i &lt; m; i++) &#123;</span><br><span class="line">                                in.nextToken();</span><br><span class="line">                                from = (<span class="type">int</span>) in.nval;</span><br><span class="line">                                in.nextToken();</span><br><span class="line">                                to = (<span class="type">int</span>) in.nval;</span><br><span class="line">                                graph.get(from).add(to);</span><br><span class="line">                                indegree[to]++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (!topoSort(graph)) &#123;</span><br><span class="line">                                out.println(-<span class="number">1</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                                        out.print(ans[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                out.println(ans[n - <span class="number">1</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                out.flush();</span><br><span class="line">                out.close();</span><br><span class="line">                br.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有拓扑排序返回true</span></span><br><span class="line">        <span class="comment">// 没有拓扑排序返回false</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">topoSort</span><span class="params">(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph)</span> &#123;</span><br><span class="line">                l = r = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                                queue[r++] = i;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">fill</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">                        ans[fill++] = cur;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> next : graph.get(cur)) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (--indegree[next] == <span class="number">0</span>) &#123;</span><br><span class="line">                                        queue[r++] = next;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fill == n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-Prim算法模版"><a href="#19-Prim算法模版" class="headerlink" title="19.Prim算法模版"></a>19.Prim算法模版</h3><p>Prim与Kruskal都是用来求最小生成树的，但更推荐使用Prim，所以就只给出Prim的模板</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度O(n + m) + O(m * log m)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code02_PrimDynamic</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">                <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">                <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">                <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">                        ArrayList&lt;ArrayList&lt;<span class="type">int</span>[]&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) in.nval;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                                graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">                        &#125;</span><br><span class="line">                        in.nextToken();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (<span class="type">int</span>) in.nval;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, u, v, w; i &lt; m; i++) &#123;</span><br><span class="line">                                in.nextToken();</span><br><span class="line">                                u = (<span class="type">int</span>) in.nval;</span><br><span class="line">                                in.nextToken();</span><br><span class="line">                                v = (<span class="type">int</span>) in.nval;</span><br><span class="line">                                in.nextToken();</span><br><span class="line">                                w = (<span class="type">int</span>) in.nval;</span><br><span class="line">                                graph.get(u).add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; v, w &#125;);</span><br><span class="line">                                graph.get(v).add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; u, w &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// int[] record</span></span><br><span class="line">                        <span class="comment">// record[0] : 到达的节点</span></span><br><span class="line">                        <span class="comment">// record[1] : 到达的花费</span></span><br><span class="line">                        PriorityQueue&lt;<span class="type">int</span>[]&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span>[] edge : graph.get(<span class="number">1</span>)) &#123;</span><br><span class="line">                                heap.add(edge);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 哪些节点已经发现过了</span></span><br><span class="line">                        <span class="type">boolean</span>[] set = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">                        <span class="type">int</span> <span class="variable">nodeCnt</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                        set[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">                                <span class="type">int</span>[] edge = heap.poll();</span><br><span class="line">                                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">                                <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">                                <span class="keyword">if</span> (!set[next]) &#123;</span><br><span class="line">                                        nodeCnt++;</span><br><span class="line">                                        set[next] = <span class="literal">true</span>;</span><br><span class="line">                                        ans += cost;</span><br><span class="line">                                        <span class="keyword">for</span> (<span class="type">int</span>[] e : graph.get(next)) &#123;</span><br><span class="line">                                                heap.add(e);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        out.println(nodeCnt == n ? ans : <span class="string">&quot;orz&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                out.flush();</span><br><span class="line">                out.close();</span><br><span class="line">                br.close();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="20-BFS"><a href="#20-BFS" class="headerlink" title="20.BFS"></a>20.BFS</h3><p>以“<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/as-far-from-land-as-possible/">地图分析</a>”为例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] queue = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN * MAXM][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> l, r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[MAXN][MAXM];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0:上，1:右，2:下，3:左</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] move = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span> &#125;;</span><br><span class="line">        <span class="comment">//                                      0  1  2  3   4</span></span><br><span class="line">        <span class="comment">//                                               i</span></span><br><span class="line">        <span class="comment">// (x,y)  i来到0位置 : x + move[i], y + move[i+1] -&gt; x - 1, y</span></span><br><span class="line">        <span class="comment">// (x,y)  i来到1位置 : x + move[i], y + move[i+1] -&gt; x, y + 1</span></span><br><span class="line">        <span class="comment">// (x,y)  i来到2位置 : x + move[i], y + move[i+1] -&gt; x + 1, y</span></span><br><span class="line">        <span class="comment">// (x,y)  i来到3位置 : x + move[i], y + move[i+1] -&gt; x, y - 1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxDistance</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">                l = r = <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">                <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">                <span class="type">int</span> <span class="variable">seas</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                                        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">                                        queue[r][<span class="number">0</span>] = i;</span><br><span class="line">                                        queue[r++][<span class="number">1</span>] = j;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">                                        seas++;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (seas == <span class="number">0</span> || seas == n * m) &#123;</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                        level++;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r - l;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>, x, y, nx, ny; k &lt; size; k++) &#123;</span><br><span class="line">                                x = queue[l][<span class="number">0</span>];</span><br><span class="line">                                y = queue[l++][<span class="number">1</span>];</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                                        <span class="comment">// 上、右、下、左</span></span><br><span class="line">                                        nx = x + move[i];</span><br><span class="line">                                        ny = y + move[i + <span class="number">1</span>];</span><br><span class="line">                                        <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; m &amp;&amp; !visited[nx][ny]) &#123;</span><br><span class="line">                                                visited[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">                                                queue[r][<span class="number">0</span>] = nx;</span><br><span class="line">                                                queue[r++][<span class="number">1</span>] = ny;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> level - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="21-dijkstra"><a href="#21-dijkstra" class="headerlink" title="21.dijkstra"></a>21.dijkstra</h3><p>以“<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-with-minimum-effort/">最小体力消耗路径</a>”为模板</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0:上，1:右，2:下，3:左</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] move = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumEffortPath</span><span class="params">(<span class="type">int</span>[][] heights)</span> &#123;</span><br><span class="line">        <span class="comment">// (0,0)源点</span></span><br><span class="line">        <span class="comment">// -&gt; (x,y)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> heights[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] distance = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                        distance[i][j] = Integer.MAX_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        distance[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][m];</span><br><span class="line">        <span class="comment">// 0 : 格子的行</span></span><br><span class="line">        <span class="comment">// 1 : 格子的列</span></span><br><span class="line">        <span class="comment">// 2 : 源点到当前格子的代价</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;<span class="type">int</span>[]&gt;((a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line">        heap.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line">        <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">                <span class="type">int</span>[] record = heap.poll();</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> record[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> record[<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> record[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span> (visited[x][y]) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (x == n - <span class="number">1</span> &amp;&amp; y == m - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 常见剪枝</span></span><br><span class="line">                        <span class="comment">// 发现终点直接返回</span></span><br><span class="line">                        <span class="comment">// 不用等都结束</span></span><br><span class="line">                        <span class="keyword">return</span> c;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> x + move[i];</span><br><span class="line">                        <span class="type">int</span> <span class="variable">ny</span> <span class="operator">=</span> y + move[i + <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; m &amp;&amp; !visited[nx][ny]) &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">nc</span> <span class="operator">=</span> Math.max(c, Math.abs(heights[x][y] - heights[nx][ny]));</span><br><span class="line">                                <span class="keyword">if</span> (nc &lt; distance[nx][ny]) &#123;</span><br><span class="line">                                        distance[nx][ny] = nc;</span><br><span class="line">                                        heap.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; nx, ny, nc &#125;);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22-Floyd算法"><a href="#22-Floyd算法" class="headerlink" title="22.Floyd算法"></a>22.Floyd算法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] path = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] distance = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, m, ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始时设置任意两点之间的最短距离为无穷大，表示任何路不存在</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                        distance[i][j] = Integer.MAX_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">                n = (<span class="type">int</span>) in.nval;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                m = (<span class="type">int</span>) in.nval;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                        in.nextToken();</span><br><span class="line">                        path[i] = (<span class="type">int</span>) in.nval - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这道题给的图是邻接矩阵的形式</span></span><br><span class="line">                <span class="comment">// 任意两点之间的边权都会给定</span></span><br><span class="line">                <span class="comment">// 所以显得distance初始化不太必要</span></span><br><span class="line">                <span class="comment">// 但是一般情况下，distance初始化一定要做</span></span><br><span class="line">                build();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                                in.nextToken();</span><br><span class="line">                                distance[i][j] = (<span class="type">int</span>) in.nval;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                floyd();</span><br><span class="line">                ans = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">                        ans += distance[path[i - <span class="number">1</span>]][path[i]];</span><br><span class="line">                &#125;</span><br><span class="line">                out.println(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        br.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">floyd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// O(N^3)的过程</span></span><br><span class="line">        <span class="comment">// 枚举每个跳板</span></span><br><span class="line">        <span class="comment">// 注意，跳板要最先枚举！跳板要最先枚举！跳板要最先枚举！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">bridge</span> <span class="operator">=</span> <span class="number">0</span>; bridge &lt; n; bridge++) &#123; <span class="comment">// 跳板</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                                <span class="comment">// i -&gt; .....bridge .... -&gt; j</span></span><br><span class="line">                                <span class="comment">// distance[i][j]能不能缩短</span></span><br><span class="line">                                <span class="comment">// distance[i][j] = min ( distance[i][j] , distance[i][bridge] + distance[bridge][j])</span></span><br><span class="line">                                <span class="keyword">if</span> (distance[i][bridge] != Integer.MAX_VALUE </span><br><span class="line">                                                &amp;&amp; distance[bridge][j] != Integer.MAX_VALUE</span><br><span class="line">                                                &amp;&amp; distance[i][j] &gt; distance[i][bridge] + distance[bridge][j]) &#123;</span><br><span class="line">                                        distance[i][j] = distance[i][bridge] + distance[bridge][j];</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-子数组最大累加和"><a href="#23-子数组最大累加和" class="headerlink" title="23.子数组最大累加和"></a>23.子数组最大累加和</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubArray1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">                <span class="comment">// dp[i] : 子数组必须以i位置的数做结尾，往左能延伸出来的最大累加和</span></span><br><span class="line">                <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">                dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                        dp[i] = Math.max(nums[i], dp[i - <span class="number">1</span>] + nums[i]);</span><br><span class="line">                        ans = Math.max(ans, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="24-最长递增子序列"><a href="#24-最长递增子序列" class="headerlink" title="24.最长递增子序列"></a>24.最长递增子序列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">                <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">                <span class="comment">// len表示ends数组目前的有效区长度</span></span><br><span class="line">                <span class="comment">// ends[0...len-1]是有效区，有效区内的数字一定严格升序</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, find; i &lt; n; i++) &#123;</span><br><span class="line">                        find = bs(ends, len, nums[i]);</span><br><span class="line">                        <span class="keyword">if</span> (find == -<span class="number">1</span>) &#123;</span><br><span class="line">                                ends[len++] = nums[i];</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                ends[find] = nums[i];</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// &quot;最长递增子序列&quot;使用如下二分搜索 :</span></span><br><span class="line">        <span class="comment">// ends[0...len-1]是严格升序的，找到&gt;=num的最左位置</span></span><br><span class="line">        <span class="comment">// 如果不存在返回-1</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bs</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> len, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = len - <span class="number">1</span>, m, ans = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                        m = l+(r-l) / <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> (ends[m] &gt;= num) &#123;</span><br><span class="line">                                ans = m;</span><br><span class="line">                                r = m - <span class="number">1</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                l = m + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="25-01背包"><a href="#25-01背包" class="headerlink" title="25. 01背包"></a>25. 01背包</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 严格位置依赖的动态规划</span></span><br><span class="line"><span class="comment">// n个物品编号1~n，第i号物品的花费cost[i]、价值val[i]</span></span><br><span class="line"><span class="comment">// cost、val数组是全局变量，已经把数据读入了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][t + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= t; j++) &#123;</span><br><span class="line">                        <span class="comment">// 不要i号物品</span></span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                        <span class="keyword">if</span> (j - cost[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">// 要i号物品</span></span><br><span class="line">                                dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - cost[i]] + val[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="26-有依赖的背包"><a href="#26-有依赖的背包" class="headerlink" title="26.有依赖的背包"></a>26.有依赖的背包</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">33001</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">61</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] cost = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] val = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span>[] king = <span class="keyword">new</span> <span class="title class_">boolean</span>[MAXM];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] fans = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] follows = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">                        fans[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 严格位置依赖的动态规划</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute1</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// dp[0][....] = 0 : 无商品的时候</span></span><br><span class="line">                <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// p : 上次展开的主商品编号</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, fan1, fan2; i &lt;= m; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (king[i]) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                                        <span class="comment">// dp[i][j] : 0...i范围上，只关心主商品，并且进行展开</span></span><br><span class="line">                                        <span class="comment">//            花费不超过j的情况下，获得的最大收益</span></span><br><span class="line">                                        <span class="comment">// 可能性1 : 不考虑当前主商品</span></span><br><span class="line">                                        dp[i][j] = dp[p][j];</span><br><span class="line">                                        <span class="keyword">if</span> (j - cost[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                                <span class="comment">// 可能性2 : 考虑当前主商品，只要主</span></span><br><span class="line">                                                dp[i][j] = Math.max(dp[i][j], dp[p][j - cost[i]] + val[i]);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="comment">// fan1 : 如果有附1商品，编号给fan1，如果没有，fan1 == -1</span></span><br><span class="line">                                        <span class="comment">// fan2 : 如果有附2商品，编号给fan2，如果没有，fan2 == -1</span></span><br><span class="line">                                        fan1 = fans[i] &gt;= <span class="number">1</span> ? follows[i][<span class="number">0</span>] : -<span class="number">1</span>;</span><br><span class="line">                                        fan2 = fans[i] &gt;= <span class="number">2</span> ? follows[i][<span class="number">1</span>] : -<span class="number">1</span>;</span><br><span class="line">                                        <span class="keyword">if</span> (fan1 != -<span class="number">1</span> &amp;&amp; j - cost[i] - cost[fan1] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                                <span class="comment">// 可能性3 : 主 + 附1</span></span><br><span class="line">                                                dp[i][j] = Math.max(dp[i][j], dp[p][j - cost[i] - cost[fan1]] + val[i] + val[fan1]);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">if</span> (fan2 != -<span class="number">1</span> &amp;&amp; j - cost[i] - cost[fan2] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                                <span class="comment">// 可能性4 : 主 + 附2</span></span><br><span class="line">                                                dp[i][j] = Math.max(dp[i][j], dp[p][j - cost[i] - cost[fan2]] + val[i] + val[fan2]);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">if</span> (fan1 != -<span class="number">1</span> &amp;&amp; fan2 != -<span class="number">1</span> &amp;&amp; j - cost[i] - cost[fan1] - cost[fan2] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                                <span class="comment">// 可能性5 : 主 + 附1 + 附2</span></span><br><span class="line">                                                dp[i][j] = Math.max(dp[i][j],</span><br><span class="line">                                                                dp[p][j - cost[i] - cost[fan1] - cost[fan2]] + val[i] + val[fan1] + val[fan2]);</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                p = i;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> dp[p][n];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="27-分组背包"><a href="#27-分组背包" class="headerlink" title="27.分组背包"></a>27.分组背包</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[i][0] i号物品的体积</span></span><br><span class="line"><span class="comment">// arr[i][1] i号物品的价值</span></span><br><span class="line"><span class="comment">// arr[i][2] i号物品的组号</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> m, n;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">                m = (<span class="type">int</span>) in.nval;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                n = (<span class="type">int</span>) in.nval;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                        in.nextToken();</span><br><span class="line">                        arr[i][<span class="number">0</span>] = (<span class="type">int</span>) in.nval;</span><br><span class="line">                        in.nextToken();</span><br><span class="line">                        arr[i][<span class="number">1</span>] = (<span class="type">int</span>) in.nval;</span><br><span class="line">                        in.nextToken();</span><br><span class="line">                        arr[i][<span class="number">2</span>] = (<span class="type">int</span>) in.nval;</span><br><span class="line">                &#125;</span><br><span class="line">                Arrays.sort(arr, <span class="number">1</span>, n + <span class="number">1</span>, (a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line">                out.println(compute1());</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        br.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">teams</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i - <span class="number">1</span>][<span class="number">2</span>] != arr[i][<span class="number">2</span>]) &#123;</span><br><span class="line">                        teams++;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 组的编号1~teams</span></span><br><span class="line">        <span class="comment">// dp[i][j] : 1~i是组的范围，每个组的物品挑一件，容量不超过j的情况下，最大收益</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[teams + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// dp[0][....] = 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">1</span>, end = <span class="number">2</span>, i = <span class="number">1</span>; start &lt;= n; i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (end &lt;= n &amp;&amp; arr[end][<span class="number">2</span>] == arr[start][<span class="number">2</span>]) &#123;</span><br><span class="line">                        end++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// start ... end-1 -&gt; i组</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                        <span class="comment">// arr[start...end-1]是当前组，组号一样</span></span><br><span class="line">                        <span class="comment">// 其中的每一件商品枚举一遍</span></span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> start; k &lt; end; k++) &#123;</span><br><span class="line">                                <span class="comment">// k是组内的一个商品编号</span></span><br><span class="line">                                <span class="keyword">if</span> (j - arr[k][<span class="number">0</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                        dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - arr[k][<span class="number">0</span>]] + arr[k][<span class="number">1</span>]);</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// start去往下一组的第一个物品</span></span><br><span class="line">                <span class="comment">// 继续处理剩下的组</span></span><br><span class="line">                start = end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[teams][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="28-完全背包"><a href="#28-完全背包" class="headerlink" title="28.完全背包"></a>28.完全背包</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXT</span> <span class="operator">=</span> <span class="number">10000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] cost = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] val = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[MAXT];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> t, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">                t = (<span class="type">int</span>) in.nval;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                m = (<span class="type">int</span>) in.nval;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">                        in.nextToken();</span><br><span class="line">                        cost[i] = (<span class="type">int</span>) in.nval;</span><br><span class="line">                        in.nextToken();</span><br><span class="line">                        val[i] = (<span class="type">int</span>) in.nval;</span><br><span class="line">                &#125;</span><br><span class="line">                out.println(compute2());</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        br.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格位置依赖的动态规划</span></span><br><span class="line"><span class="comment">// 会空间不够，导致无法通过全部测试用例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">compute1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// dp[0][.....] = 0</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][t + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= t; j++) &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                        <span class="keyword">if</span> (j - cost[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                                dp[i][j] = Math.max(dp[i][j], dp[i][j - cost[i]] + val[i]);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="29-多重背包"><a href="#29-多重背包" class="headerlink" title="29.多重背包"></a>29.多重背包</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXW</span> <span class="operator">=</span> <span class="number">40001</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把每一种货物根据个数做二进制分组，去生成衍生商品</span></span><br><span class="line"><span class="comment">// 衍生出来的每一种商品，价值放入v、重量放入w</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] v = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] w = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAXW];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, t, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度O(t * (log(第1种商品的个数) + log(第2种商品的个数) + ... + log(第n种商品的个数)))</span></span><br><span class="line"><span class="comment">// 对每一种商品的个数取log，所以时间复杂度虽然大于O(n * t)，但也不会大多少</span></span><br><span class="line"><span class="comment">// 多重背包最常用的方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">                n = (<span class="type">int</span>) in.nval;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                t = (<span class="type">int</span>) in.nval;</span><br><span class="line">                m = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, value, weight, cnt; i &lt;= n; i++) &#123;</span><br><span class="line">                        in.nextToken(); value = (<span class="type">int</span>) in.nval;</span><br><span class="line">                        in.nextToken(); weight = (<span class="type">int</span>) in.nval;</span><br><span class="line">                        in.nextToken(); cnt = (<span class="type">int</span>) in.nval;</span><br><span class="line">                        <span class="comment">// 整个文件最重要的逻辑 : 二进制分组</span></span><br><span class="line">                        <span class="comment">// 一般都使用这种技巧，这段代码非常重要</span></span><br><span class="line">                        <span class="comment">// 虽然时间复杂度不如单调队列优化的版本</span></span><br><span class="line">                        <span class="comment">// 但是好写，而且即便是比赛，时间复杂度也达标</span></span><br><span class="line">                        <span class="comment">// 二进制分组的时间复杂度为O(log cnt)</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= cnt; k &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                                v[++m] = k * value;</span><br><span class="line">                                w[m] = k * weight;</span><br><span class="line">                                cnt -= k;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                v[++m] = cnt * value;</span><br><span class="line">                                w[m] = cnt * weight;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                out.println(compute());</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        br.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 01背包的空间压缩代码(模版)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        Arrays.fill(dp, <span class="number">0</span>, t + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> t; j &gt;= w[i]; j--) &#123;</span><br><span class="line">                        dp[j] = Math.max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[t];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="我将记录手撕题目"><a href="#我将记录手撕题目" class="headerlink" title="我将记录手撕题目:"></a>我将记录手撕题目:</h2><h3 id="写一个快速排序"><a href="#写一个快速排序" class="headerlink" title="写一个快速排序"></a>写一个快速排序</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 随机快速排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 随机这一下，常数时间比较大</span></span><br><span class="line">        <span class="comment">// 但只有这一下随机，才能在概率上把快速排序的时间复杂度收敛到O(n * logn)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> arr[l + (<span class="type">int</span>) (Math.random() * (r - l + <span class="number">1</span>))];</span><br><span class="line">        partition(arr, l, r, x);</span><br><span class="line">        <span class="comment">// 为了防止底层的递归过程覆盖全局变量</span></span><br><span class="line">        <span class="comment">// 这里用临时变量记录first、last</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> last;</span><br><span class="line">        quickSort(arr, l, left - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, right + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 荷兰国旗问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> first, last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 已知arr[l....r]范围上一定有x这个值</span></span><br><span class="line"><span class="comment">// 划分数组 &lt;x放左边，==x放中间，&gt;x放右边</span></span><br><span class="line"><span class="comment">// 把全局变量first, last，更新成==x区域的左右边界</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        first = l;</span><br><span class="line">        last = r;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= last) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] == x) &#123;</span><br><span class="line">                        i++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; x) &#123;</span><br><span class="line">                        swap(arr, first++, i++);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        swap(arr, i, last--);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求最长递增子序列"><a href="#求最长递增子序列" class="headerlink" title="求最长递增子序列"></a>求最长递增子序列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">                <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">                <span class="comment">// len表示ends数组目前的有效区长度</span></span><br><span class="line">                <span class="comment">// ends[0...len-1]是有效区，有效区内的数字一定严格升序</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, find; i &lt; n; i++) &#123;</span><br><span class="line">                        find = bs1(ends, len, nums[i]);</span><br><span class="line">                        <span class="keyword">if</span> (find == -<span class="number">1</span>) &#123;</span><br><span class="line">                                ends[len++] = nums[i];</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                ends[find] = nums[i];</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// &quot;最长递增子序列&quot;使用如下二分搜索 :</span></span><br><span class="line">        <span class="comment">// ends[0...len-1]是严格升序的，找到&gt;=num的最左位置</span></span><br><span class="line">        <span class="comment">// 如果不存在返回-1</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bs1</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> len, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = len - <span class="number">1</span>, m, ans = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                        m = (l + r) / <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> (ends[m] &gt;= num) &#123;</span><br><span class="line">                                ans = m;</span><br><span class="line">                                r = m - <span class="number">1</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                l = m + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果求最长不下降子序列，那么使用如下的二分搜索 :</span></span><br><span class="line">        <span class="comment">// ends[0...len-1]是不降序的</span></span><br><span class="line">        <span class="comment">// 在其中找到&gt;num的最左位置，如果不存在返回-1</span></span><br><span class="line">        <span class="comment">// 如果求最长不下降子序列，就在lengthOfLIS中把bs1方法换成bs2方法</span></span><br><span class="line">        <span class="comment">// 已经用对数器验证了，是正确的</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bs2</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> len, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = len - <span class="number">1</span>, m, ans = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                        m = (l + r) / <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> (ends[m] &gt; num) &#123;</span><br><span class="line">                                ans = m;</span><br><span class="line">                                r = m - <span class="number">1</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                l = m + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br></pre></td></tr></table></figure><h3 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">class</span> <span class="title class_">DoubleNode</span> &#123;</span><br><span class="line">                        <span class="keyword">public</span> <span class="type">int</span> key;</span><br><span class="line">                        <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">                        <span class="keyword">public</span> DoubleNode last;</span><br><span class="line">                        <span class="keyword">public</span> DoubleNode next;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">public</span> <span class="title function_">DoubleNode</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">                                key = k;</span><br><span class="line">                                val = v;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">class</span> <span class="title class_">DoubleList</span> &#123;</span><br><span class="line">                        <span class="keyword">private</span> DoubleNode head;</span><br><span class="line">                        <span class="keyword">private</span> DoubleNode tail;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">public</span> <span class="title function_">DoubleList</span><span class="params">()</span> &#123;</span><br><span class="line">                                head = <span class="literal">null</span>;</span><br><span class="line">                                tail = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(DoubleNode newNode)</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (newNode == <span class="literal">null</span>) &#123;</span><br><span class="line">                                        <span class="keyword">return</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">                                        head = newNode;</span><br><span class="line">                                        tail = newNode;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        tail.next = newNode;</span><br><span class="line">                                        newNode.last = tail;</span><br><span class="line">                                        tail = newNode;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveNodeToTail</span><span class="params">(DoubleNode node)</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (tail == node) &#123;</span><br><span class="line">                                        <span class="keyword">return</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (head == node) &#123;</span><br><span class="line">                                        head = node.next;</span><br><span class="line">                                        head.last = <span class="literal">null</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        node.last.next = node.next;</span><br><span class="line">                                        node.next.last = node.last;</span><br><span class="line">                                &#125;</span><br><span class="line">                                node.last = tail;</span><br><span class="line">                                node.next = <span class="literal">null</span>;</span><br><span class="line">                                tail.next = node;</span><br><span class="line">                                tail = node;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">public</span> DoubleNode <span class="title function_">removeHead</span><span class="params">()</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">                                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="type">DoubleNode</span> <span class="variable">ans</span> <span class="operator">=</span> head;</span><br><span class="line">                                <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">                                        head = <span class="literal">null</span>;</span><br><span class="line">                                        tail = <span class="literal">null</span>;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        head = ans.next;</span><br><span class="line">                                        ans.next = <span class="literal">null</span>;</span><br><span class="line">                                        head.last = <span class="literal">null</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">return</span> ans;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">private</span> HashMap&lt;Integer, DoubleNode&gt; keyNodeMap;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">private</span> DoubleList nodeList;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">                        keyNodeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                        nodeList = <span class="keyword">new</span> <span class="title class_">DoubleList</span>();</span><br><span class="line">                        capacity = cap;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (keyNodeMap.containsKey(key)) &#123;</span><br><span class="line">                                <span class="type">DoubleNode</span> <span class="variable">ans</span> <span class="operator">=</span> keyNodeMap.get(key);</span><br><span class="line">                                nodeList.moveNodeToTail(ans);</span><br><span class="line">                                <span class="keyword">return</span> ans.val;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (keyNodeMap.containsKey(key)) &#123;</span><br><span class="line">                                <span class="type">DoubleNode</span> <span class="variable">node</span> <span class="operator">=</span> keyNodeMap.get(key);</span><br><span class="line">                                node.val = value;</span><br><span class="line">                                nodeList.moveNodeToTail(node);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (keyNodeMap.size() == capacity) &#123;</span><br><span class="line">                                        keyNodeMap.remove(nodeList.removeHead().key);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="type">DoubleNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleNode</span>(key, value);</span><br><span class="line">                                keyNodeMap.put(key, newNode);</span><br><span class="line">                                nodeList.addNode(newNode);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>一般要求递归和迭代都要写出来</p><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/description/">链接</a></p><p>迭代：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">     ListNode next=<span class="literal">null</span>;</span><br><span class="line">     ListNode pre=<span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;</span><br><span class="line">         next=head.next;</span><br><span class="line">         head.next=pre;</span><br><span class="line">         pre=head;</span><br><span class="line">         head=next;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> pre;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>递归：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> recur(head, <span class="literal">null</span>);    <span class="comment">// 调用递归并返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">recur</span><span class="params">(ListNode cur, ListNode pre)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> pre; <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> recur(cur.next, cur);  <span class="comment">// 递归后继节点</span></span><br><span class="line">    cur.next = pre;              <span class="comment">// 修改节点引用指向</span></span><br><span class="line">    <span class="keyword">return</span> res;                  <span class="comment">// 返回反转链表的头节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h3><p>经典滑动窗口</p><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> n=s.length;</span><br><span class="line">        <span class="type">int</span>[] last=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">        Arrays.fill(last,-<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>,r=<span class="number">0</span>; r&lt;n; r++) &#123;</span><br><span class="line">            l=Math.max(l,last[s[r]]+<span class="number">1</span>);<span class="comment">//如果s[r]之前没出现过，那么l就还是l，如果出现过，则l就变成新的位置</span></span><br><span class="line">            ans=Math.max(ans,r-l+<span class="number">1</span>);</span><br><span class="line">            last[s[r]]=r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        ListNode start=head;</span><br><span class="line">        ListNode end=teamEnd(start,k);</span><br><span class="line">        <span class="keyword">if</span>(end==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head=end;</span><br><span class="line">        reverse(start,end);</span><br><span class="line">        ListNode lastTeamEnd=start;</span><br><span class="line">        <span class="keyword">while</span>(lastTeamEnd.next!=<span class="literal">null</span>) &#123;</span><br><span class="line">            start=lastTeamEnd.next;</span><br><span class="line">            end=teamEnd(start,k);</span><br><span class="line">            <span class="keyword">if</span>(end==<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            reverse(start,end);</span><br><span class="line">            lastTeamEnd.next=end;</span><br><span class="line">            lastTeamEnd=start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(ListNode s, ListNode e)</span> &#123;</span><br><span class="line">           <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">           e=e.next;</span><br><span class="line">           ListNode pre=<span class="literal">null</span>,cur=s,next=<span class="literal">null</span>;</span><br><span class="line">           <span class="keyword">while</span> (cur != e) &#123;</span><br><span class="line">               next = cur.next;</span><br><span class="line">               cur.next = pre;</span><br><span class="line">               pre = cur;</span><br><span class="line">               cur = next;</span><br><span class="line">           &#125;</span><br><span class="line">           s.next = e;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> ListNode <span class="title function_">teamEnd</span><span class="params">(ListNode s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">           <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">           <span class="keyword">while</span> (--k!=<span class="number">0</span>&amp;&amp;s!=<span class="literal">null</span>) &#123;</span><br><span class="line">               s=s.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> s;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="数组中的第K个最大元素"><a href="#数组中的第K个最大元素" class="headerlink" title="数组中的第K个最大元素"></a>数组中的第K个最大元素</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">链接</a></p><p>要实现O(n)的算法，实际上就是写一个快排。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 随机这一下，常数时间比较大</span></span><br><span class="line">               <span class="comment">// 但只有这一下随机，才能在概率上把快速排序的时间复杂度收敛到O(n * logn)</span></span><br><span class="line">               <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> arr[l + (<span class="type">int</span>) (Math.random() * (r - l + <span class="number">1</span>))];</span><br><span class="line">               partition(arr, l, r, x);</span><br><span class="line">               <span class="comment">// 为了防止底层的递归过程覆盖全局变量</span></span><br><span class="line">               <span class="comment">// 这里用临时变量记录first、last</span></span><br><span class="line">               <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> first;</span><br><span class="line">               <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> last;</span><br><span class="line">               quickSort(arr, l, left - <span class="number">1</span>);</span><br><span class="line">               quickSort(arr, right + <span class="number">1</span>, r);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 荷兰国旗问题</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> first, last;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 已知arr[l....r]范围上一定有x这个值</span></span><br><span class="line">       <span class="comment">// 划分数组 &lt;x放左边，==x放中间，&gt;x放右边</span></span><br><span class="line">       <span class="comment">// 把全局变量first, last，更新成==x区域的左右边界</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">               first = l;</span><br><span class="line">               last = r;</span><br><span class="line">               <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l;</span><br><span class="line">               <span class="keyword">while</span> (i &lt;= last) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (arr[i] == x) &#123;</span><br><span class="line">                               i++;</span><br><span class="line">                       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; x) &#123;</span><br><span class="line">                               swap(arr, first++, i++);</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               swap(arr, i, last--);</span><br><span class="line">                       &#125;</span><br><span class="line">               &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">               arr[i] = arr[j];</span><br><span class="line">               arr[j] = tmp;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">       quickSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> nums[nums.length-k];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n=nums.length;</span><br><span class="line">    Arrays.sort(nums);  <span class="comment">//一定得排序那么一下</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> first=<span class="number">0</span>;first&lt;n;first++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(first&gt;<span class="number">0</span>&amp;&amp;nums[first]==nums[first-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> third=n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> target=-nums[first];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> second=first+<span class="number">1</span>;second&lt;n;second++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(second&gt;first+<span class="number">1</span>&amp;&amp;nums[second]==nums[second-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(second&lt;third&amp;&amp;nums[second]+nums[third]&gt;target)&#123;</span><br><span class="line">                --third;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(second==third)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[second]+nums[third]==target)&#123;</span><br><span class="line">                List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                list.add(nums[first]);</span><br><span class="line">                list.add(nums[second]);</span><br><span class="line">                list.add(nums[third]);</span><br><span class="line">                ans.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode head1, ListNode head2)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (head1 == <span class="literal">null</span> || head2 == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> head1 == <span class="literal">null</span> ? head2 : head1;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> head1.val &lt;= head2.val ? head1 : head2;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">h1</span> <span class="operator">=</span> head.next;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">h2</span> <span class="operator">=</span> head == head1 ? head2 : head1;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="keyword">while</span> (h1 != <span class="literal">null</span> &amp;&amp; h2 != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (h1.val &lt;= h2.val) &#123;</span><br><span class="line">               pre.next = h1;</span><br><span class="line">               h1 = h1.next;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               pre.next = h2;</span><br><span class="line">               h2 = h2.next;</span><br><span class="line">           &#125;</span><br><span class="line">           pre = pre.next;</span><br><span class="line">       &#125;</span><br><span class="line">       pre.next = h1 != <span class="literal">null</span> ? h1 : h2;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="排序数组"><a href="#排序数组" class="headerlink" title="排序数组"></a>排序数组</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array/description/">链表</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> first, last;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">       <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">           quickSort(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> nums;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> nums[l + (<span class="type">int</span>) (Math.random() * (r - l + <span class="number">1</span>))];</span><br><span class="line">       partition(nums, l, r,x);</span><br><span class="line">       <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> first;</span><br><span class="line">       <span class="type">int</span> right=last;</span><br><span class="line">       quickSort(nums,l,left-<span class="number">1</span>);</span><br><span class="line">       quickSort(nums,right+<span class="number">1</span>,r);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">       first=l;</span><br><span class="line">       last=r;</span><br><span class="line">       <span class="type">int</span> i=l;</span><br><span class="line">       <span class="keyword">while</span>(i&lt;=last)&#123;</span><br><span class="line">           <span class="keyword">if</span>(nums[i]==x)&#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]&lt;x)&#123;</span><br><span class="line">               swap(nums,first++,i++);</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               swap(nums,i,last--);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">       <span class="type">int</span> temp=nums[i];</span><br><span class="line">       nums[i]=nums[j];</span><br><span class="line">       nums[j]=temp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> start + (end -start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//后半部分有序</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[end])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[end])&#123;</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span>(nums[mid] &gt; target &amp;&amp; target &gt;= nums[start])&#123;</span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="合并K个排序数组"><a href="#合并K个排序数组" class="headerlink" title="合并K个排序数组"></a>合并K个排序数组</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a.val - b.val);</span><br><span class="line">            <span class="keyword">for</span> (ListNode head : lists)</span><br><span class="line">                <span class="keyword">if</span> (head != <span class="literal">null</span>)</span><br><span class="line">                    pq.offer(head);</span><br><span class="line"></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(); <span class="comment">// 哨兵节点，作为合并后链表头节点的前一个节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">            <span class="keyword">while</span> (!pq.isEmpty()) &#123; <span class="comment">// 循环直到堆为空</span></span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll(); <span class="comment">// 剩余节点中的最小节点</span></span><br><span class="line">                <span class="keyword">if</span> (node.next != <span class="literal">null</span>) <span class="comment">// 下一个节点不为空</span></span><br><span class="line">                    pq.offer(node.next); <span class="comment">// 下一个节点有可能是最小节点，入堆</span></span><br><span class="line">                cur.next = node; <span class="comment">// 合并到新链表中</span></span><br><span class="line">                cur = cur.next; <span class="comment">// 准备合并下一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dummy.next; <span class="comment">// 哨兵节点的下一个节点就是新链表的头节点</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="反转链表-1"><a href="#反转链表-1" class="headerlink" title="反转链表||"></a>反转链表||</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">      <span class="comment">// 设置 dummyNode 是这一类问题的一般做法</span></span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">      dummyNode.next = head;</span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">          pre = pre.next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">      ListNode next;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">          next = cur.next;</span><br><span class="line">          cur.next = next.next;</span><br><span class="line">          next.next = pre.next;</span><br><span class="line">          pre.next = next;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">2001</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode[] queue = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[MAXN];</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> l, r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        l = r = <span class="number">0</span>;</span><br><span class="line">        queue[r++] = root;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r - l;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue[r++] = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue[r++] = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(list);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">   <span class="type">int</span> len=s.length();</span><br><span class="line">   <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">   <span class="type">boolean</span>[][] dp=<span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=len-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;len;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==s.charAt(j)&amp;&amp;(j-i&lt;=<span class="number">1</span>||dp[i+<span class="number">1</span>][j-<span class="number">1</span>]))&#123;</span><br><span class="line">            dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(j-i&gt;res)&#123;</span><br><span class="line">                res=j-i;</span><br><span class="line">                left=i;</span><br><span class="line">                right=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(left,right+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相似题目–<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/">最长回文子序列</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq2</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">return</span> f(s, <span class="number">0</span>, n - <span class="number">1</span>, dp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">char</span>[] s, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>[][] dp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">                <span class="keyword">return</span> s[l] == s[r] ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[l][r] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> dp[l][r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans;</span><br><span class="line">        <span class="keyword">if</span> (s[l] == s[r]) &#123;</span><br><span class="line">                ans = <span class="number">2</span> + f(s, l + <span class="number">1</span>, r - <span class="number">1</span>, dp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = Math.max(f(s, l + <span class="number">1</span>, r, dp), f(s, l, r - <span class="number">1</span>, dp));</span><br><span class="line">        &#125;</span><br><span class="line">        dp[l][r] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的锯齿形层序遍历"><a href="#二叉树的锯齿形层序遍历" class="headerlink" title="二叉树的锯齿形层序遍历"></a>二叉树的锯齿形层序遍历</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> MAXN=<span class="number">2001</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode[] queue=<span class="keyword">new</span> <span class="title class_">TreeNode</span>[MAXN];</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> l,r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root!=<span class="literal">null</span>) &#123;</span><br><span class="line">        l=r=<span class="number">0</span>;</span><br><span class="line">        queue[r++]=root;</span><br><span class="line">        <span class="type">boolean</span> reverse=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">            <span class="type">int</span> size=r-l;</span><br><span class="line">            ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> reverse?r-<span class="number">1</span>:l,k=<span class="number">0</span>;k &lt; size; i += reverse?-<span class="number">1</span>:<span class="number">1</span>, k++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue[i];</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue[r++] = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue[r++] = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(list);</span><br><span class="line">            reverse = !reverse;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(root==<span class="literal">null</span>||p==root||q==root)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">      &#125;</span><br><span class="line">      TreeNode left= lowestCommonAncestor(root.left,p,q);</span><br><span class="line">      TreeNode right=  lowestCommonAncestor(root.right,p,q);</span><br><span class="line">      <span class="keyword">if</span>(left!=<span class="literal">null</span>&amp;&amp;right!=<span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">      <span class="keyword">if</span>(left==<span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">      <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> ans=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            dp[i]=Math.max(dp[i-<span class="number">1</span>]+nums[i],nums[i]);</span><br><span class="line">            ans=Math.max(dp[i],ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reorder-list/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reorderList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">      <span class="comment">// 快慢指针找到链表中点</span></span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">      <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">          slow = slow.next;</span><br><span class="line">          fast = fast.next.next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// cur 指向右半部分链表</span></span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> slow.next;</span><br><span class="line">      slow.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 反转右半部分链表</span></span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> cur.next;</span><br><span class="line">          cur.next = pre;</span><br><span class="line">          pre = cur;</span><br><span class="line">          cur = t;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = head;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 此时 cur, pre 分别指向链表左右两半的第一个节点</span></span><br><span class="line">      <span class="comment">// 合并</span></span><br><span class="line">      <span class="keyword">while</span> (pre != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> pre.next;</span><br><span class="line">          pre.next = cur.next;</span><br><span class="line">          cur.next = pre;</span><br><span class="line">          cur = pre.next;</span><br><span class="line">          pre = t;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode h1, ListNode h2)</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(h1==<span class="literal">null</span>||h2==<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> diff=<span class="number">0</span>;</span><br><span class="line">   ListNode a=h1;</span><br><span class="line">   ListNode b=h2;</span><br><span class="line">   <span class="keyword">while</span>(a.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">    a=a.next;</span><br><span class="line">    diff++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(b.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">    b=b.next;</span><br><span class="line">    diff--;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(diff&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">    a=h1;</span><br><span class="line">    b=h2;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    a=h2;</span><br><span class="line">    b=h1;</span><br><span class="line">   &#125;</span><br><span class="line">   diff=Math.abs(diff);</span><br><span class="line">   <span class="keyword">while</span>(diff--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    a=a.next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(a!=b)&#123;</span><br><span class="line">    a=a.next;</span><br><span class="line">    b=b.next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">spiralOrder</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计矩阵从外向内的层数，如果矩阵非空，那么它的层数至少为1层</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> (Math.min(m, n)+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//从外部向内部遍历，逐层打印数据</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; count) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n-i; j++) &#123;</span><br><span class="line">            list.add(matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; m-i; j++) &#123;</span><br><span class="line">            list.add(matrix[j][(n-<span class="number">1</span>)-i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (n-<span class="number">1</span>)-(i+<span class="number">1</span>); j &gt;= i &amp;&amp; (m-<span class="number">1</span>-i） != i; j--) &#123;</span><br><span class="line">            list.add(matrix[(m-<span class="number">1</span>)-i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (m-<span class="number">1</span>)-(i+<span class="number">1</span>); j &gt;= i+<span class="number">1</span> &amp;&amp; (n-<span class="number">1</span>-i) != i; j--) &#123;</span><br><span class="line">            list.add(matrix[j][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>,r=nums.length-<span class="number">2</span>,lmax=nums[<span class="number">0</span>],rmax=nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lmax&lt;=rmax)&#123;</span><br><span class="line">                ans+=Math.max(<span class="number">0</span>,lmax-nums[l]);</span><br><span class="line">                lmax=Math.max(lmax,nums[l++]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ans+=Math.max(<span class="number">0</span>,rmax-nums[r]);</span><br><span class="line">                rmax=Math.max(rmax,nums[r--]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">       <span class="type">int</span> n=grid.length;</span><br><span class="line">       <span class="type">int</span> m=grid[<span class="number">0</span>].length;</span><br><span class="line">       <span class="type">int</span> island=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">               island++;</span><br><span class="line">               dfs(grid,i,j,n,m);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> island;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid,<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> n,<span class="type">int</span> m)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=n||j&lt;<span class="number">0</span>||j&gt;=m||grid[i][j]!=<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       grid[i][j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">       dfs(grid,i+<span class="number">1</span>,j,n,m);</span><br><span class="line">       dfs(grid,i-<span class="number">1</span>,j,n,m);</span><br><span class="line">       dfs(grid,i,j+<span class="number">1</span>,n,m);</span><br><span class="line">       dfs(grid,i,j-<span class="number">1</span>,n,m);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">      ListNode slow=head;</span><br><span class="line">      ListNode fast=head;</span><br><span class="line">      <span class="keyword">while</span>(fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">       slow=slow.next;</span><br><span class="line">       fast=fast.next.next;</span><br><span class="line">       <span class="keyword">if</span>(slow==fast)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, min = prices[<span class="number">0</span>]; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="comment">// min : 0...i范围上的最小值</span></span><br><span class="line">        min = Math.min(min, prices[i]);</span><br><span class="line">        ans = Math.max(ans, prices[i] - min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       f(nums,<span class="number">0</span>,ans);</span><br><span class="line">       <span class="keyword">return</span> ans; </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,List&lt;List&lt;Integer&gt;&gt; ans)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(i==nums.length)&#123;</span><br><span class="line">           List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">               list.add(nums[j]);</span><br><span class="line">           &#125;</span><br><span class="line">           ans.add(list);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123;</span><br><span class="line">               swap(nums,i,j);</span><br><span class="line">               f(nums, i+<span class="number">1</span>, ans);</span><br><span class="line">               swap(nums,i,j);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">       <span class="type">int</span> temp=nums[i];</span><br><span class="line">       nums[i]=nums[j];</span><br><span class="line">       nums[j]=temp;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">                <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">                <span class="comment">// len表示ends数组目前的有效区长度</span></span><br><span class="line">                <span class="comment">// ends[0...len-1]是有效区，有效区内的数字一定严格升序</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, find; i &lt; n; i++) &#123;</span><br><span class="line">                        find = bs(ends, len, nums[i]);</span><br><span class="line">                        <span class="keyword">if</span> (find == -<span class="number">1</span>) &#123;</span><br><span class="line">                                ends[len++] = nums[i];</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                ends[find] = nums[i];</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// &quot;最长递增子序列&quot;使用如下二分搜索 :</span></span><br><span class="line">        <span class="comment">// ends[0...len-1]是严格升序的，找到&gt;=num的最左位置</span></span><br><span class="line">        <span class="comment">// 如果不存在返回-1</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bs</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> len, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = len - <span class="number">1</span>, m, ans = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                        m = l+(r-l) / <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> (ends[m] &gt;= num) &#123;</span><br><span class="line">                                ans = m;</span><br><span class="line">                                r = m - <span class="number">1</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                l = m + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target-nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-sorted-array/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m + n - <span class="number">1</span>;</span><br><span class="line">       m--;</span><br><span class="line">       n--;</span><br><span class="line">       <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (m &lt; <span class="number">0</span> || nums2[n] &gt; nums1[m]) &#123;</span><br><span class="line">               nums1[i--] = nums2[n--];</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               nums1[i--] = nums1[m--];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="删除排序链表中的重复元素II"><a href="#删除排序链表中的重复元素II" class="headerlink" title="删除排序链表中的重复元素II"></a>删除排序链表中的重复元素II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> head;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">     <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">     <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (cur.next.val == cur.next.next.val) &#123;</span><br><span class="line">             <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">             <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == x) &#123;</span><br><span class="line">                 cur.next = cur.next.next;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             cur = cur.next;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> dummy.next;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">       Deque&lt;Character&gt; stack=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">           <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">           <span class="keyword">if</span> (c==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">               stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">               stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">               stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (!stack.isEmpty()&amp;&amp;c==stack.peek())&#123;</span><br><span class="line">                   stack.pop();</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a>字符串相加</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-strings/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>, add = <span class="number">0</span>;</span><br><span class="line">       <span class="type">StringBuffer</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">       <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || add != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> i &gt;= <span class="number">0</span> ? num1.charAt(i) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> j &gt;= <span class="number">0</span> ? num2.charAt(j) - <span class="string">&#x27;0&#x27;</span> : <span class="number">0</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> x + y + add;</span><br><span class="line">           ans.append(result % <span class="number">10</span>);</span><br><span class="line">           add = result / <span class="number">10</span>;</span><br><span class="line">           i--;</span><br><span class="line">           j--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 计算完以后的答案需要翻转过来</span></span><br><span class="line">       ans.reverse();</span><br><span class="line">       <span class="keyword">return</span> ans.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">           <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">           <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">               fast = fast.next.next;</span><br><span class="line">               slow = slow.next;</span><br><span class="line">               <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           fast = head;</span><br><span class="line">           <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">               slow = slow.next;</span><br><span class="line">               fast = fast.next;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> fast;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals)&#123;</span><br><span class="line">        Arrays.sort(intervals,(a,b)-&gt;a[<span class="number">0</span>]-b[<span class="number">0</span>]);</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] interval:intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span>(res.size()==<span class="number">0</span>||interval[<span class="number">0</span>]&gt;res.get(res.size()-<span class="number">1</span>)[<span class="number">1</span>]) &#123;</span><br><span class="line">                res.add(interval);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res.get(res.size()-<span class="number">1</span>)[<span class="number">1</span>]=Math.max(res.get(res.size()-<span class="number">1</span>)[<span class="number">1</span>],interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"> <span class="type">int</span> val;</span><br><span class="line"> TreeNode left;</span><br><span class="line"> TreeNode right;</span><br><span class="line"> TreeNode() &#123;&#125;</span><br><span class="line"> TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line"> TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> <span class="built_in">this</span>.val = val;</span><br><span class="line"> <span class="built_in">this</span>.left = left;</span><br><span class="line"> <span class="built_in">this</span>.right = right;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        maxGain(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxGain</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归计算左右子节点的最大贡献值</span></span><br><span class="line">        <span class="comment">// 只有在最大贡献值大于 0 时，才会选取对应子节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftGain</span> <span class="operator">=</span> Math.max(maxGain(node.left), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightGain</span> <span class="operator">=</span> Math.max(maxGain(node.right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">priceNewpath</span> <span class="operator">=</span> node.val + leftGain + rightGain;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新答案</span></span><br><span class="line">        maxSum = Math.max(maxSum, priceNewpath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">return</span> node.val + Math.max(leftGain, rightGain);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> editDistance(word1,word2,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">editDistance</span><span class="params">(String word1, String word2, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">       <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">       <span class="type">char</span>[] s1 = word1.toCharArray();</span><br><span class="line">       <span class="type">char</span>[] s2 = word2.toCharArray();</span><br><span class="line">       <span class="type">int</span> n=s1.length;</span><br><span class="line">       <span class="type">int</span> m=s2.length;</span><br><span class="line">       <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">1</span>; i &lt;=n; i++) &#123;</span><br><span class="line">           dp[i][<span class="number">0</span>]=i*b;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;=m; j++) &#123;</span><br><span class="line">           dp[<span class="number">0</span>][j]=j*a;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=n; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;=m; j++) &#123;</span><br><span class="line">               <span class="type">int</span> p1=Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">if</span> (s1[i-<span class="number">1</span>]==s2[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                   p1=dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="type">int</span> p2=Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">if</span> (s1[i-<span class="number">1</span>]!=s2[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                   p2=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+c;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="type">int</span> p3=dp[i][j-<span class="number">1</span>]+a;</span><br><span class="line">               <span class="type">int</span> p4=dp[i-<span class="number">1</span>][j]+b;</span><br><span class="line">               dp[i][j]=Math.min(Math.min(p1, p2),Math.min(p3, p4));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[n][m];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; ans=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="type">char</span>[] s1;</span><br><span class="line">   <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        s1 = s.toCharArray();</span><br><span class="line">        dfs(<span class="number">0</span>,s1.length, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> ids,<span class="type">int</span> n,List&lt;Integer&gt; cur)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(cur.size()&gt;<span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">if</span>(ids==n)&#123;</span><br><span class="line">           <span class="keyword">if</span>(cur.size()==<span class="number">4</span>)&#123;</span><br><span class="line">               StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) sb.append(cur.get(i)).append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">               ans.add(sb.substring(<span class="number">0</span>,sb.length()-<span class="number">1</span>));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=ids;i&lt;n;i++)&#123;</span><br><span class="line">               <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> j=ids;j&lt;=i;j++) t=t*<span class="number">10</span>+(s1[j]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">if</span> (s1[ids] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; i != ids) <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">if</span> (t &gt; <span class="number">255</span>) <span class="keyword">break</span>;</span><br><span class="line">               cur.add(t);</span><br><span class="line">               dfs(i + <span class="number">1</span>, n, cur);</span><br><span class="line">               cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s1 = text1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] s2 = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span> n=s1.length;</span><br><span class="line">        <span class="type">int</span> m=s2.length;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> <span class="number">1</span>; len1 &lt;=n; len1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> <span class="number">1</span>; len2 &lt;=m; len2++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1[len1-<span class="number">1</span>]==s2[len2-<span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[len1][len2]=dp[len1-<span class="number">1</span>][len2-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[len1][len2]=Math.max(dp[len1-<span class="number">1</span>][len2],dp[len1][len2-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      <span class="comment">// List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line">      <span class="comment">// inorder(root, res);</span></span><br><span class="line">      <span class="comment">// return res;</span></span><br><span class="line">      List&lt;Integer&gt; res=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">      Deque&lt;TreeNode&gt; stack=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">      <span class="keyword">while</span>(root!=<span class="literal">null</span>||!stack.isEmpty())&#123;</span><br><span class="line">          <span class="keyword">while</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">              stack.push(root);</span><br><span class="line">              root=root.left;</span><br><span class="line">          &#125;</span><br><span class="line">          root=stack.pop();</span><br><span class="line">          res.add(root.val);</span><br><span class="line">          root=root.right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// public void inorder(TreeNode root, List&lt;Integer&gt; res) &#123;</span></span><br><span class="line">  <span class="comment">//     if(root==null)&#123;</span></span><br><span class="line">  <span class="comment">//         return;</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//     inorder(root.left,res);</span></span><br><span class="line">  <span class="comment">//     res.add(root.val);</span></span><br><span class="line">  <span class="comment">//     inorder(root.right,res);</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">       <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> j=nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (i&lt;=j)&#123;</span><br><span class="line">           <span class="type">int</span> m=(i+j)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span> (nums[m]&lt;target)&#123;</span><br><span class="line">               i=m+<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[m]&gt;target)&#123;</span><br><span class="line">               j=m-<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> m;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的右视图"><a href="#二叉树的右视图" class="headerlink" title="二叉树的右视图"></a>二叉树的右视图</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">for</span>(;!queue.isEmpty();)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">lastOne</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">                lastOne = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(lastOne.left != <span class="literal">null</span>) queue.offer(lastOne.left);</span><br><span class="line">                <span class="keyword">if</span>(lastOne.right != <span class="literal">null</span>) queue.offer(lastOne.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(lastOne.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="寻找两个正序数组中的中位数"><a href="#寻找两个正序数组中的中位数" class="headerlink" title="寻找两个正序数组中的中位数"></a>寻找两个正序数组中的中位数</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums1.length &gt; nums2.length) &#123;</span><br><span class="line">               <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">           <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">           <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = m;</span><br><span class="line">           <span class="comment">// median1：前一部分的最大值</span></span><br><span class="line">           <span class="comment">// median2：后一部分的最小值</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">median1</span> <span class="operator">=</span> <span class="number">0</span>, median2 = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">               <span class="comment">// 前一部分包含 nums1[0 .. i-1] 和 nums2[0 .. j-1]</span></span><br><span class="line">               <span class="comment">// 后一部分包含 nums1[i .. m-1] 和 nums2[j .. n-1]</span></span><br><span class="line">               <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">               <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (m + n + <span class="number">1</span>) / <span class="number">2</span> - i;</span><br><span class="line">               <span class="comment">// nums_im1, nums_i, nums_jm1, nums_j 分别表示 nums1[i-1], nums1[i], nums2[j-1], nums2[j]</span></span><br><span class="line">               <span class="type">int</span> <span class="variable">nums_im1</span> <span class="operator">=</span> (i == <span class="number">0</span> ? Integer.MIN_VALUE : nums1[i - <span class="number">1</span>]);</span><br><span class="line">               <span class="type">int</span> <span class="variable">nums_i</span> <span class="operator">=</span> (i == m ? Integer.MAX_VALUE : nums1[i]);</span><br><span class="line">               <span class="type">int</span> <span class="variable">nums_jm1</span> <span class="operator">=</span> (j == <span class="number">0</span> ? Integer.MIN_VALUE : nums2[j - <span class="number">1</span>]);</span><br><span class="line">               <span class="type">int</span> <span class="variable">nums_j</span> <span class="operator">=</span> (j == n ? Integer.MAX_VALUE : nums2[j]);</span><br><span class="line">               <span class="keyword">if</span> (nums_im1 &lt;= nums_j) &#123;</span><br><span class="line">                   median1 = Math.max(nums_im1, nums_jm1);</span><br><span class="line">                   median2 = Math.min(nums_i, nums_j);</span><br><span class="line">                   left = i + <span class="number">1</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   right = i - <span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> (m + n) % <span class="number">2</span> == <span class="number">0</span> ? (median1 + median2) / <span class="number">2.0</span> : median1;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-permutation/description/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, k = n - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">while</span> (k - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[k - <span class="number">1</span>] &gt;= nums[k]) k--;</span><br><span class="line">           <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">               reverse(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> k;</span><br><span class="line">               <span class="keyword">while</span> (u + <span class="number">1</span> &lt; n &amp;&amp; nums[u + <span class="number">1</span>] &gt; nums[k - <span class="number">1</span>]) u++;</span><br><span class="line">               swap(nums, k - <span class="number">1</span>, u);</span><br><span class="line">               reverse(nums, k, n - <span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> a, r = b;</span><br><span class="line">           <span class="keyword">while</span> (l &lt; r) swap(nums, l++, r--);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> nums[a];</span><br><span class="line">           nums[a] = nums[b];</span><br><span class="line">           nums[b] = c;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/">链接</a></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; inStack;</span><br><span class="line">    Deque&lt;Integer&gt; outStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        inStack=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">        outStack=<span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(outStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!inStack.isEmpty())&#123;</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(outStack.isEmpty())&#123;</span><br><span class="line">             <span class="keyword">while</span>(!inStack.isEmpty())&#123;</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.peek();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> inStack.isEmpty()&amp;&amp;outStack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要我还在刷题，持续更新</p></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="/img/img02.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/01/%E6%B5%85%E8%B0%88%E5%88%A9%E7%94%A8AOP%E5%AE%9E%E7%8E%B0%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD/" title="浅谈利用AOP实现记录日志功能"><img class="cover" src="/img/img05.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">浅谈利用AOP实现记录日志功能</div></div></a></div><div class="next-post pull-right"><a href="/2024/07/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" title="计算机网络学习总结"><img class="cover" src="/img/img12.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络学习总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/07/01/%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%9B%9E%E9%A1%BE%E7%9F%A5%E8%AF%86/" title="在面试中回顾知识"><img class="cover" src="/img/img04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-03</div><div class="title">在面试中回顾知识</div></div></a></div><div><a href="/2024/07/14/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" title="LeetCode每日一题"><img class="cover" src="/img/img04.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-17</div><div class="title">LeetCode每日一题</div></div></a></div><div><a href="/2024/07/01/minio%E7%9A%84%E4%BD%BF%E7%94%A8/" title="minio的使用"><img class="cover" src="/img/img13.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-03</div><div class="title">minio的使用</div></div></a></div><div><a href="/2024/07/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%8B%E8%AE%A2%E5%8D%95%E4%B8%9A%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="分布式系统下订单业务解决方案"><img class="cover" src="/img/img14.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-21</div><div class="title">分布式系统下订单业务解决方案</div></div></a></div><div><a href="/2024/07/20/%E5%AE%9E%E7%8E%B0%E7%99%BE%E4%B8%87%E7%BA%A7%E6%95%B0%E6%8D%AE%E4%BB%8EExcel%E5%AF%BC%E5%85%A5%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93/" title="实现百万级数据从Excel导入到数据库"><img class="cover" src="/img/img01.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-20</div><div class="title">实现百万级数据从Excel导入到数据库</div></div></a></div><div><a href="/2024/07/19/%E6%A0%87%E7%AD%BE%E6%90%9C%E7%B4%A2%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0/" title="标签搜索架构实现"><img class="cover" src="/img/img06.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-07-21</div><div class="title">标签搜索架构实现</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">李从浦</div><div class="author-info__description">志不强者智不达，言不信者行不果</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/licongpu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/licongpu" target="_blank" title="Github"><i class="fab fa-github" style="color:#24292e"></i></a><a class="social-icon" href="mailto:2816863923@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color:#4a7dbe"></i></a><a class="social-icon" href="https://miu7shl031o.feishu.cn/drive/folder/WJiBfqX9klvKNEdpTHccfrEQn3e" target="_blank" title="飞书"><i class="fa-sharp fa-solid fa-bookmark" style="color:#4a7dbe"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">一起学习,共同进步</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%BC%8F%E4%B8%8EACM%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">核心代码模式与ACM模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">面试手撕代码的几种形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%A4%84%E7%90%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">3.</span> <span class="toc-text">java处理输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%86%B51-%E5%85%A8%E9%83%BD%E6%98%AF%E6%95%B0%E5%AD%97%E7%9A%84%E8%BE%93%E5%85%A5%EF%BC%8C%E6%AF%8F%E8%A1%8C%E6%95%B0%E5%AD%97%E4%B8%AA%E6%95%B0%E4%B8%8D%E5%AE%9A"><span class="toc-number">3.1.</span> <span class="toc-text">情况1: 全都是数字的输入，每行数字个数不定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%86%B52-%E6%AF%8F%E8%A1%8C%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E4%B8%BA%E7%A1%AE%E5%AE%9A%E7%9A%84%E6%95%B0%E5%AD%97n%EF%BC%8C%E5%90%8E%E9%9D%A2%E8%B7%9F%E7%9D%80n%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="toc-number">3.2.</span> <span class="toc-text">情况2:每行第一个数字为确定的数字n，后面跟着n个数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%86%B53-%E6%AF%8F%E8%A1%8C%E7%A1%AE%E5%AE%9A%E6%9C%89n%E4%B8%AA%E6%95%B0%E5%AD%97%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">3.3.</span> <span class="toc-text">情况3: 每行确定有n个数字的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%85%E5%86%B54-%E7%AC%AC%E4%B8%80%E8%A1%8C%E6%98%AF%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97n-%E7%AC%AC%E4%BA%8C%E8%A1%8C%E6%98%AFn%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.4.</span> <span class="toc-text">情况4: 第一行是一个数字n, 第二行是n个字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%9D%91%E7%82%B9"><span class="toc-number">3.5.</span> <span class="toc-text">避坑点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E7%B1%BB%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF-%E5%8F%AA%E6%8F%90%E4%BE%9BJAVA"><span class="toc-number">5.</span> <span class="toc-text">各类算法模板(只提供JAVA):</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">5.1.</span> <span class="toc-text">1.选择排序、插入排序、冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E4%B8%89%E7%A7%8D%E5%BA%8F"><span class="toc-number">5.2.</span> <span class="toc-text">2.二叉树及其三种序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">5.3.</span> <span class="toc-text">3.归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">5.4.</span> <span class="toc-text">4.快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%90%AB%E6%9C%89%E5%B5%8C%E5%A5%97%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">5.5.</span> <span class="toc-text">5.含有嵌套的表达式求值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0"><span class="toc-number">5.6.</span> <span class="toc-text">6.最大公约数和最小公倍数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%BF%94%E5%9B%9E%E6%97%A0%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%B4%AF%E5%8A%A0%E5%92%8C%E4%B8%BA%E7%BB%99%E5%AE%9A%E5%80%BC%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%EF%BC%88%E4%B8%80%E7%BB%B4%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E4%BF%A1%E6%81%AF%EF%BC%89"><span class="toc-number">5.7.</span> <span class="toc-text">7.返回无序数组中累加和为给定值的最长子数组长（一维构建前缀信息）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86"><span class="toc-number">5.8.</span> <span class="toc-text">8.一维差分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BA%8C%E7%BB%B4%E6%9E%84%E5%BB%BA%E5%89%8D%E7%BC%80%E4%BF%A1%E6%81%AF"><span class="toc-number">5.9.</span> <span class="toc-text">9.二维构建前缀信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86"><span class="toc-number">5.10.</span> <span class="toc-text">10.二维差分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">5.11.</span> <span class="toc-text">11.滑动窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%E6%B3%95"><span class="toc-number">5.12.</span> <span class="toc-text">12.二分答案法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">5.13.</span> <span class="toc-text">13.单调栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">5.14.</span> <span class="toc-text">14.单调队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%A8%A1%E6%9D%BF"><span class="toc-number">5.15.</span> <span class="toc-text">15.并查集模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E6%B4%AA%E6%B0%B4%E5%A1%AB%E5%85%85%E9%97%AE%E9%A2%98"><span class="toc-number">5.16.</span> <span class="toc-text">16.洪水填充问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E4%B8%89%E7%A7%8D%E5%BB%BA%E5%9B%BE%E6%96%B9%E5%BC%8F"><span class="toc-number">5.17.</span> <span class="toc-text">17.三种建图方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF"><span class="toc-number">5.18.</span> <span class="toc-text">18.拓扑排序模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-Prim%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88"><span class="toc-number">5.19.</span> <span class="toc-text">19.Prim算法模版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-BFS"><span class="toc-number">5.20.</span> <span class="toc-text">20.BFS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-dijkstra"><span class="toc-number">5.21.</span> <span class="toc-text">21.dijkstra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-Floyd%E7%AE%97%E6%B3%95"><span class="toc-number">5.22.</span> <span class="toc-text">22.Floyd算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E5%8A%A0%E5%92%8C"><span class="toc-number">5.23.</span> <span class="toc-text">23.子数组最大累加和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">5.24.</span> <span class="toc-text">24.最长递增子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-01%E8%83%8C%E5%8C%85"><span class="toc-number">5.25.</span> <span class="toc-text">25. 01背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E6%9C%89%E4%BE%9D%E8%B5%96%E7%9A%84%E8%83%8C%E5%8C%85"><span class="toc-number">5.26.</span> <span class="toc-text">26.有依赖的背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85"><span class="toc-number">5.27.</span> <span class="toc-text">27.分组背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-number">5.28.</span> <span class="toc-text">28.完全背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="toc-number">5.29.</span> <span class="toc-text">29.多重背包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%91%E5%B0%86%E8%AE%B0%E5%BD%95%E6%89%8B%E6%92%95%E9%A2%98%E7%9B%AE"><span class="toc-number">6.</span> <span class="toc-text">我将记录手撕题目:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">6.1.</span> <span class="toc-text">写一个快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">6.2.</span> <span class="toc-text">求最长递增子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LRU%E7%BC%93%E5%AD%98"><span class="toc-number">6.3.</span> <span class="toc-text">LRU缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">6.4.</span> <span class="toc-text">反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">6.5.</span> <span class="toc-text">无重复字符的最长子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">6.6.</span> <span class="toc-text">K个一组翻转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0"><span class="toc-number">6.7.</span> <span class="toc-text">数组中的第K个最大元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">6.8.</span> <span class="toc-text">三数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-number">6.9.</span> <span class="toc-text">合并两个有序链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">6.10.</span> <span class="toc-text">排序数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">6.11.</span> <span class="toc-text">搜索旋转排序数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">6.12.</span> <span class="toc-text">合并K个排序数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-1"><span class="toc-number">6.13.</span> <span class="toc-text">反转链表||</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">6.14.</span> <span class="toc-text">二叉树的层序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">6.15.</span> <span class="toc-text">最长回文子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">6.16.</span> <span class="toc-text">二叉树的锯齿形层序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">6.17.</span> <span class="toc-text">二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">6.18.</span> <span class="toc-text">最大子数组和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="toc-number">6.19.</span> <span class="toc-text">重排链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="toc-number">6.20.</span> <span class="toc-text">相交链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5"><span class="toc-number">6.21.</span> <span class="toc-text">螺旋矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-number">6.22.</span> <span class="toc-text">接雨水</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-number">6.23.</span> <span class="toc-text">岛屿数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="toc-number">6.24.</span> <span class="toc-text">环形链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-number">6.25.</span> <span class="toc-text">买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">6.26.</span> <span class="toc-text">全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">6.27.</span> <span class="toc-text">最长递增子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">6.28.</span> <span class="toc-text">两数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">6.29.</span> <span class="toc-text">合并两个有序数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II"><span class="toc-number">6.30.</span> <span class="toc-text">删除排序链表中的重复元素II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">6.31.</span> <span class="toc-text">有效的括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0"><span class="toc-number">6.32.</span> <span class="toc-text">字符串相加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II"><span class="toc-number">6.33.</span> <span class="toc-text">环形链表II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-number">6.34.</span> <span class="toc-text">合并区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">6.35.</span> <span class="toc-text">二叉树中的最大路径和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">6.36.</span> <span class="toc-text">编辑距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80"><span class="toc-number">6.37.</span> <span class="toc-text">复原IP地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">6.38.</span> <span class="toc-text">最长公共子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">6.39.</span> <span class="toc-text">二叉树的中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">6.40.</span> <span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="toc-number">6.41.</span> <span class="toc-text">二叉树的右视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">6.42.</span> <span class="toc-text">寻找两个正序数组中的中位数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="toc-number">6.43.</span> <span class="toc-text">下一个排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">6.44.</span> <span class="toc-text">用栈实现队列</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/07/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%8B%E8%AE%A2%E5%8D%95%E4%B8%9A%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="分布式系统下订单业务解决方案"><img src="/img/img14.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="分布式系统下订单业务解决方案"></a><div class="content"><a class="title" href="/2024/07/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%8B%E8%AE%A2%E5%8D%95%E4%B8%9A%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="分布式系统下订单业务解决方案">分布式系统下订单业务解决方案</a><time datetime="2024-07-21T00:32:03.203Z" title="发表于 2024-07-21 08:32:03">2024-07-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/20/%E5%AE%9E%E7%8E%B0%E7%99%BE%E4%B8%87%E7%BA%A7%E6%95%B0%E6%8D%AE%E4%BB%8EExcel%E5%AF%BC%E5%85%A5%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93/" title="实现百万级数据从Excel导入到数据库"><img src="/img/img01.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="实现百万级数据从Excel导入到数据库"></a><div class="content"><a class="title" href="/2024/07/20/%E5%AE%9E%E7%8E%B0%E7%99%BE%E4%B8%87%E7%BA%A7%E6%95%B0%E6%8D%AE%E4%BB%8EExcel%E5%AF%BC%E5%85%A5%E5%88%B0%E6%95%B0%E6%8D%AE%E5%BA%93/" title="实现百万级数据从Excel导入到数据库">实现百万级数据从Excel导入到数据库</a><time datetime="2024-07-20T00:56:49.539Z" title="发表于 2024-07-20 08:56:49">2024-07-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/19/%E6%A0%87%E7%AD%BE%E6%90%9C%E7%B4%A2%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0/" title="标签搜索架构实现"><img src="/img/img06.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="标签搜索架构实现"></a><div class="content"><a class="title" href="/2024/07/19/%E6%A0%87%E7%AD%BE%E6%90%9C%E7%B4%A2%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0/" title="标签搜索架构实现">标签搜索架构实现</a><time datetime="2024-07-19T03:54:34.223Z" title="发表于 2024-07-19 11:54:34">2024-07-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/14/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" title="LeetCode每日一题"><img src="/img/img04.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="LeetCode每日一题"></a><div class="content"><a class="title" href="/2024/07/14/LeetCode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/" title="LeetCode每日一题">LeetCode每日一题</a><time datetime="2024-07-14T02:34:12.532Z" title="发表于 2024-07-14 10:34:12">2024-07-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/01/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1/" title="网络规划与设计"><img src="/img/img08.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="网络规划与设计"></a><div class="content"><a class="title" href="/2024/07/01/%E7%BD%91%E7%BB%9C%E8%A7%84%E5%88%92%E4%B8%8E%E8%AE%BE%E8%AE%A1/" title="网络规划与设计">网络规划与设计</a><time datetime="2024-07-01T07:57:05.362Z" title="发表于 2024-07-01 15:57:05">2024-07-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 李从浦</div><div class="footer_custom_text">欢迎使用我的博客,期待一同进步</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js").then((()=>{pangu.autoSpacingPage()}))}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="true" data-text="懒,羊,羊,大,王,的,博,客" data-fontsize="15px" data-random="false" async></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors=["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"];var pjax=new Pjax({elements:'a:not([target="_blank"])',selectors:pjaxSelectors,cacheBust:!1,analytics:!1,scrollRestoration:!1});document.addEventListener("pjax:send",(function(){if(btf.removeGlobalFnEvent("pjax"),btf.removeGlobalFnEvent("themeChange"),document.getElementById("rightside").classList.remove("rightside-show"),window.aplayers)for(let e=0;e<window.aplayers.length;e++)window.aplayers[e].options.fixed||window.aplayers[e].destroy();"object"==typeof typed&&typed.destroy();const e=document.body.classList;e.contains("read-mode")&&e.remove("read-mode"),"object"==typeof disqusjs&&disqusjs.destroy()})),document.addEventListener("pjax:complete",(function(){window.refreshFn(),document.querySelectorAll("script[data-pjax]").forEach((e=>{const t=document.createElement("script"),o=e.text||e.textContent||e.innerHTML||"";Array.from(e.attributes).forEach((e=>t.setAttribute(e.name,e.value))),t.appendChild(document.createTextNode(o)),e.parentNode.replaceChild(t,e)})),GLOBAL_CONFIG.islazyload&&window.lazyLoadInstance.update(),"function"==typeof panguInit&&panguInit(),"function"==typeof gtag&&gtag("config","",{page_path:window.location.pathname}),"object"==typeof _hmt&&_hmt.push(["_trackPageview",window.location.pathname]),"function"==typeof loadMeting&&document.getElementsByClassName("aplayer").length&&loadMeting(),"object"==typeof Prism&&Prism.highlightAll()})),document.addEventListener("pjax:error",(e=>{404===e.request.status&&pjax.loadUrl("/404.html")}))</script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>